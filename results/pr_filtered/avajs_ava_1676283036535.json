[
  {
    "url": "https://api.github.com/repos/avajs/ava/issues/2785",
    "repository_url": "https://api.github.com/repos/avajs/ava",
    "labels_url": "https://api.github.com/repos/avajs/ava/issues/2785/labels{/name}",
    "comments_url": "https://api.github.com/repos/avajs/ava/issues/2785/comments",
    "events_url": "https://api.github.com/repos/avajs/ava/issues/2785/events",
    "html_url": "https://github.com/avajs/ava/pull/2785",
    "id": 937175612,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NjgzNzc0Mjg2",
    "number": 2785,
    "title": "Breaking changes to the test() interface",
    "user": {
      "login": "novemberborn",
      "id": 33538,
      "node_id": "MDQ6VXNlcjMzNTM4",
      "avatar_url": "https://avatars.githubusercontent.com/u/33538?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/novemberborn",
      "html_url": "https://github.com/novemberborn",
      "followers_url": "https://api.github.com/users/novemberborn/followers",
      "following_url": "https://api.github.com/users/novemberborn/following{/other_user}",
      "gists_url": "https://api.github.com/users/novemberborn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/novemberborn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/novemberborn/subscriptions",
      "organizations_url": "https://api.github.com/users/novemberborn/orgs",
      "repos_url": "https://api.github.com/users/novemberborn/repos",
      "events_url": "https://api.github.com/users/novemberborn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/novemberborn/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-07-05T15:03:11Z",
    "updated_at": "2021-08-12T12:00:18Z",
    "closed_at": "2021-07-10T13:41:20Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "draft": false,
    "pull_request": {
      "url": "https://api.github.com/repos/avajs/ava/pulls/2785",
      "html_url": "https://github.com/avajs/ava/pull/2785",
      "diff_url": "https://github.com/avajs/ava/pull/2785.diff",
      "patch_url": "https://github.com/avajs/ava/pull/2785.patch",
      "merged_at": "2021-07-10T13:41:20Z"
    },
    "body": "Fixes #2716.\r\n\r\nRemove support for passing multiple test implementations. This affects test() and t.try().\r\n\r\nSupporting multiple implementations made both the implementation and the type definitions needlessly complex. Using for/of syntax it's easy enough to declare tests (or t.try() attempts) with the same arguments.\r\n\r\nChange constructor type for `instanceOf` expectation. It should result in an `Error` subclass.\r\n\r\nAdd `test.macro()`, change how macros are typed. Fixes #2189. `test.macro()` returns an object that can be used with\r\n`test()` and hooks. The `t.context` type is inherited from `test`.\r\n\r\nLike with AVA 3, regular functions that also have a `title` property that is a string-returning function are supported. However this is no longer in the type definition.\r\n\r\nInstead the recommended approach is to use `test.macro()` to declare macros. At a TypeScript level these are easier to discriminate from regular implementations.\r\n\r\nChange implementation argument type constraint to unknown. This mostly impacts macros, for which we'd want to encourage explicit types.\r\n\r\nAdd test for context covariance. Fixes #2253 which no longer seems reproducible.\r\n\r\nAdd test for implementation result types.\r\n\r\nRefactor type definition. Split across multiple files. Rename types, most noticeably `TestInterface` is now `TestFn`, but really anything that had the Interface suffix has been changed. Update some documentation.\r\n\r\nReturn null when throws() and throwsAsync() assertions fail.\r\n\r\nUpdate type definitions to disallow null throws expectations.",
    "reactions": {
      "url": "https://api.github.com/repos/avajs/ava/issues/2785/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/avajs/ava/issues/2785/timeline",
    "performed_via_github_app": null,
    "state_reason": null,
    "score": 1,
    "files": [
      {
        "sha": "1a7cd8568b5b9d4f117378b47928d0afa20ae014",
        "filename": ".xo-config.json",
        "status": "modified",
        "additions": 11,
        "deletions": 6,
        "changes": 17,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/.xo-config.json",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/.xo-config.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/.xo-config.json?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -23,13 +23,12 @@\n \t},\n \t\"overrides\": [\n \t\t{\n-\t\t\t\"files\": \"index.d.ts\",\n+\t\t\t\"files\": [\n+\t\t\t\t\"index.d.ts\",\n+\t\t\t\t\"types/*.d.ts\"\n+\t\t\t],\n \t\t\t\"rules\": {\n-\t\t\t\t\"@typescript-eslint/member-ordering\": \"off\",\n-\t\t\t\t\"@typescript-eslint/method-signature-style\": \"off\",\n-\t\t\t\t\"@typescript-eslint/prefer-readonly-parameter-types\": \"off\",\n-\t\t\t\t\"@typescript-eslint/prefer-function-type\": \"off\",\n-\t\t\t\t\"@typescript-eslint/unified-signatures\": \"off\"\n+\t\t\t\t\"import/extensions\": \"off\"\n \t\t\t}\n \t\t},\n \t\t{\n@@ -71,6 +70,12 @@\n \t\t\t\t\"import/no-extraneous-dependencies\": \"off\",\n \t\t\t\t\"import/no-unresolved\": \"off\"\n \t\t\t}\n+\t\t},\n+\t\t{\n+\t\t\t\"files\": \"test/macros/fixtures/macros.js\",\n+\t\t\t\"rules\": {\n+\t\t\t\t\"ava/no-identical-title\": \"off\"\n+\t\t\t}\n \t\t}\n \t]\n }"
      },
      {
        "sha": "fdbad81454dc7c537712b5538da3adcf6b0030cb",
        "filename": "docs/01-writing-tests.md",
        "status": "modified",
        "additions": 26,
        "deletions": 10,
        "changes": 36,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/docs%2F01-writing-tests.md",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/docs%2F01-writing-tests.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/docs%2F01-writing-tests.md?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -294,6 +294,8 @@ console.log('Test file currently being run:', test.meta.file);\n \n Additional arguments passed to the test declaration will be passed to the test implementation. This is useful for creating reusable test macros.\n \n+You can use plain functions:\n+\n ```js\n function macro(t, input, expected) {\n \tt.is(eval(input), expected);\n@@ -303,7 +305,7 @@ test('2 + 2 = 4', macro, '2 + 2', 4);\n test('2 * 3 = 6', macro, '2 * 3', 6);\n ```\n \n-You can build the test title programmatically by attaching a `title` function to the macro:\n+With AVA 3 you can build the test title programmatically by attaching a `title` function to the macro:\n \n ```js\n function macro(t, input, expected) {\n@@ -319,21 +321,35 @@ test('providedTitle', macro, '3 * 3', 9);\n \n The `providedTitle` argument defaults to `undefined` if the user does not supply a string title. This means you can use a parameter assignment to set the default value. The example above uses the empty string as the default.\n \n-You can also pass arrays of macro functions:\n+However with AVA 4 the preferred approach is to use the `test.macro()` helper:\n \n ```js\n-const safeEval = require('safe-eval');\n+import test from 'ava';\n \n-function evalMacro(t, input, expected) {\n+const macro = test.macro((t, input, expected) => {\n \tt.is(eval(input), expected);\n-}\n+});\n \n-function safeEvalMacro(t, input, expected) {\n-\tt.is(safeEval(input), expected);\n-}\n+test('title', macro, '3 * 3', 9);\n+```\n+\n+Or with a title function:\n \n-test([evalMacro, safeEvalMacro], '2 + 2', 4);\n-test([evalMacro, safeEvalMacro], '2 * 3', 6);\n+```js\n+import test from 'ava';\n+\n+const macro = test.macro({\n+\texec(t, input, expected) {\n+\t\tt.is(eval(input), expected);\n+\t},\n+\ttitle(providedTitle = '', input, expected) {\n+\t\treturn `${providedTitle} ${input} = ${expected}`.trim();\n+\t}\n+});\n+\n+test(macro, '2 + 2', 4);\n+test(macro, '2 * 3', 6);\n+test('providedTitle', macro, '3 * 3', 9);\n ```\n \n We encourage you to use macros instead of building your own test generators ([here is an example](https://github.com/avajs/ava-codemods/blob/47073b5b58aa6f3fb24f98757be5d3f56218d160/test/ok-to-truthy.js#L7-L9) of code that should be replaced with a macro). Macros are designed to perform static analysis of your code, which can lead to better performance, IDE integration, and linter rules."
      },
      {
        "sha": "2e719ec85cadaf7877bc06c7f6906dd63816856c",
        "filename": "docs/03-assertions.md",
        "status": "modified",
        "additions": 3,
        "deletions": 7,
        "changes": 10,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/docs%2F03-assertions.md",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/docs%2F03-assertions.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/docs%2F03-assertions.md?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -229,7 +229,7 @@ Finally, this returns a boolean indicating whether the assertion passed.\n \n ### `.throws(fn, expectation?, message?)`\n \n-Assert that an error is thrown. `fn` must be a function which should throw. The thrown value *must* be an error. It is returned so you can run more assertions against it.\n+Assert that an error is thrown. `fn` must be a function which should throw. The thrown value *must* be an error. It is returned so you can run more assertions against it. If the assertion fails then `null` is returned.\n \n `expectation` can be an object with one or more of the following properties:\n \n@@ -257,13 +257,11 @@ test('throws', t => {\n });\n ```\n \n-Does not return anything.\n-\n ### `.throwsAsync(thrower, expectation?, message?)`\n \n Assert that an error is thrown. `thrower` can be an async function which should throw, or a promise that should reject. This assertion must be awaited.\n \n-The thrown value *must* be an error. It is returned so you can run more assertions against it.\n+The thrown value *must* be an error. It is returned so you can run more assertions against it. If the assertion fails then `null` is returned.\n \n `expectation` can be an object with one or more of the following properties:\n \n@@ -294,8 +292,6 @@ test('rejects', async t => {\n });\n ```\n \n-Does not return anything.\n-\n ### `.notThrows(fn, message?)`\n \n Assert that no error is thrown. `fn` must be a function which shouldn't throw. Does not return anything.\n@@ -330,7 +326,7 @@ AVA 3 supports an  `options` object that lets you select a specific snapshot, fo\n \n In AVA 3, you cannot update snapshots while using `t.snapshot.skip()`.\n \n-### `.try(title?, implementation | macro | macro[], ...args?)`\n+### `.try(title?, implementation | macro, ...args?)`\n \n `.try()` allows you to *try* assertions without causing the test to fail.\n "
      },
      {
        "sha": "84cc1db501ff320e3cc39cce047ec6a6c6436fff",
        "filename": "docs/recipes/typescript.md",
        "status": "modified",
        "additions": 40,
        "deletions": 4,
        "changes": 44,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/docs%2Frecipes%2Ftypescript.md",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/docs%2Frecipes%2Ftypescript.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/docs%2Frecipes%2Ftypescript.md?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -121,7 +121,9 @@ const hasLength = (t: ExecutionContext, input: string, expected: number) => {\n test('bar has length 3', hasLength, 'bar', 3);\n ```\n \n-In order to be able to assign the `title` property to a macro you need to type the function:\n+### AVA 3\n+\n+With AVA 3, in order to be able to assign the `title` property to a macro you need to type the function:\n \n ```ts\n import test, {Macro} from 'ava';\n@@ -149,12 +151,46 @@ const macro: CbMacro<[]> = t => {\n test.cb(macro);\n ```\n \n+### AVA 4\n+\n+With AVA 4 you can use the `test.macro()` helper to create macros:\n+\n+```ts\n+import test from 'ava';\n+\n+const macro = test.macro((t, input: string, expected: number) => {\n+\tt.is(eval(input), expected);\n+});\n+\n+test('title', macro, '3 * 3', 9);\n+```\n+\n+Or with a title function:\n+\n+```ts\n+import test from 'ava';\n+\n+const macro = test.macro({\n+\texec(t, input: string, expected: number) {\n+\t\tt.is(eval(input), expected);\n+\t},\n+\ttitle(providedTitle = '', input, expected) {\n+\t\treturn `${providedTitle} ${input} = ${expected}`.trim();\n+\t}\n+});\n+\n+test(macro, '2 + 2', 4);\n+test(macro, '2 * 3', 6);\n+test('providedTitle', macro, '3 * 3', 9);\n+```\n+\n ## Typing [`t.context`](../01-writing-tests.md#test-context)\n \n-By default, the type of `t.context` will be the empty object (`{}`). AVA exposes an interface `TestInterface<Context>` which you can use to apply your own type to `t.context`. This can help you catch errors at compile-time:\n+By default, the type of `t.context` will be the empty object (`{}`). AVA exposes an interface `TestInterface<Context>` (in AVA 4 this is `TestFn<Context>`) which you can use to apply your own type to `t.context`. This can help you catch errors at compile-time:\n \n ```ts\n-import anyTest, {TestInterface} from 'ava';\n+import anyTest, {TestInterface} from 'ava'; // AVA 3\n+// import anyTest, {TestFn as TestInterface} from 'ava'; // AVA 4, usage is the same\n \n const test = anyTest as TestInterface<{foo: string}>;\n \n@@ -178,7 +214,7 @@ test('an actual test', t => {\n You can also type the context when creating macros:\n \n ```ts\n-import anyTest, {Macro, TestInterface} from 'ava';\n+import anyTest, {Macro, TestInterface} from 'ava'; // AVA 3\n \n interface Context {\n \tfoo: string"
      },
      {
        "sha": "24b722040a1f3385c31d67b82486ded871e59b59",
        "filename": "index.d.ts",
        "status": "modified",
        "additions": 6,
        "deletions": 679,
        "changes": 685,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/index.d.ts",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/index.d.ts",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/index.d.ts?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -1,685 +1,12 @@\n-export interface Subscribable {\n-\tsubscribe(observer: {\n-\t\terror(error: any): void;\n-\t\tcomplete(): void;\n-\t}): void;\n-}\n+import type {TestFn} from './types/test-fn';\n \n-export type Constructor = (new (...args: any[]) => any);\n-\n-/** Specify one or more expectations the thrown error must satisfy. */\n-export type ThrowsExpectation = {\n-\t/** The thrown error must have a code that equals the given string or number. */\n-\tcode?: string | number;\n-\n-\t/** The thrown error must be an instance of this constructor. */\n-\tinstanceOf?: Constructor;\n-\n-\t/** The thrown error must be strictly equal to this value. */\n-\tis?: Error;\n-\n-\t/** The thrown error must have a message that equals the given string, or matches the regular expression. */\n-\tmessage?: string | RegExp;\n-\n-\t/** The thrown error must have a name that equals the given string. */\n-\tname?: string;\n-};\n-\n-export type CommitDiscardOptions = {\n-\t/**\n-\t * Whether the logs should be included in those of the parent test.\n-\t */\n-\tretainLogs?: boolean;\n-};\n-\n-export interface Assertions {\n-\t/**\n-\t * Assert that `actual` is [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy), returning a boolean\n-\t * indicating whether the assertion passed. Comes with power-assert.\n-\t */\n-\tassert: AssertAssertion;\n-\n-\t/**\n-\t * Assert that `actual` is [deeply equal](https://github.com/concordancejs/concordance#comparison-details) to\n-\t * `expected`, returning a boolean indicating whether the assertion passed.\n-\t */\n-\tdeepEqual: DeepEqualAssertion;\n-\n-\t/**\n-\t * Assert that `value` is like `selector`, returning a boolean indicating whether the assertion passed.\n-\t */\n-\tlike: LikeAssertion;\n-\n-\t/** Fail the test, always returning `false`. */\n-\tfail: FailAssertion;\n-\n-\t/**\n-\t * Assert that `actual` is strictly false, returning a boolean indicating whether the assertion passed.\n-\t */\n-\tfalse: FalseAssertion;\n-\n-\t/**\n-\t * Assert that `actual` is [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy), returning a boolean\n-\t * indicating whether the assertion passed.\n-\t */\n-\tfalsy: FalsyAssertion;\n-\n-\t/**\n-\t * Assert that `actual` is [the same\n-\t * value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) as `expected`,\n-\t * returning a boolean indicating whether the assertion passed.\n-\t */\n-\tis: IsAssertion;\n-\n-\t/**\n-\t * Assert that `actual` is not [the same\n-\t * value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) as `expected`,\n-\t * returning a boolean indicating whether the assertion passed.\n-\t */\n-\tnot: NotAssertion;\n-\n-\t/**\n-\t * Assert that `actual` is not [deeply equal](https://github.com/concordancejs/concordance#comparison-details) to\n-\t * `expected`, returning a boolean indicating whether the assertion passed.\n-\t */\n-\tnotDeepEqual: NotDeepEqualAssertion;\n-\n-\t/**\n-\t * Assert that `string` does not match the regular expression, returning a boolean indicating whether the assertion\n-\t * passed.\n-\t */\n-\tnotRegex: NotRegexAssertion;\n-\n-\t/** Assert that the function does not throw. */\n-\tnotThrows: NotThrowsAssertion;\n-\n-\t/** Assert that the async function does not throw, or that the promise does not reject. Must be awaited. */\n-\tnotThrowsAsync: NotThrowsAsyncAssertion;\n-\n-\t/** Count a passing assertion, always returning `true`. */\n-\tpass: PassAssertion;\n-\n-\t/**\n-\t * Assert that `string` matches the regular expression, returning a boolean indicating whether the assertion passed.\n-\t */\n-\tregex: RegexAssertion;\n-\n-\t/**\n-\t * Assert that `expected` is [deeply equal](https://github.com/concordancejs/concordance#comparison-details) to a\n-\t * previously recorded [snapshot](https://github.com/concordancejs/concordance#serialization-details), or if\n-\t * necessary record a new snapshot.\n-\t */\n-\tsnapshot: SnapshotAssertion;\n-\n-\t/**\n-\t * Assert that the function throws [an error](https://www.npmjs.com/package/is-error). If so, returns the error value.\n-\t */\n-\tthrows: ThrowsAssertion;\n-\n-\t/**\n-\t * Assert that the async function throws [an error](https://www.npmjs.com/package/is-error), or the promise rejects\n-\t * with one. If so, returns a promise for the error value, which must be awaited.\n-\t */\n-\tthrowsAsync: ThrowsAsyncAssertion;\n-\n-\t/**\n-\t * Assert that `actual` is strictly true, returning a boolean indicating whether the assertion passed.\n-\t */\n-\ttrue: TrueAssertion;\n-\n-\t/**\n-\t * Assert that `actual` is [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy), returning a boolean\n-\t * indicating whether the assertion passed.\n-\t */\n-\ttruthy: TruthyAssertion;\n-}\n-\n-export interface AssertAssertion {\n-\t/**\n-\t * Assert that `actual` is [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy), returning a boolean\n-\t * indicating whether the assertion passed. Comes with power-assert.\n-\t */\n-\t(actual: any, message?: string): boolean;\n-\n-\t/** Skip this assertion. */\n-\tskip(actual: any, message?: string): void;\n-}\n-\n-export interface DeepEqualAssertion {\n-\t/**\n-\t * Assert that `actual` is [deeply equal](https://github.com/concordancejs/concordance#comparison-details) to\n-\t * `expected`, returning a boolean indicating whether the assertion passed.\n-\t */\n-\t<Actual, Expected extends Actual>(actual: Actual, expected: Expected, message?: string): actual is Expected;\n-\n-\t/** Skip this assertion. */\n-\tskip(actual: any, expected: any, message?: string): void;\n-}\n-\n-export interface LikeAssertion {\n-\t/**\n-\t * Assert that `value` is like `selector`, returning a boolean indicating whether the assertion passed.\n-\t */\n-\t<Expected extends Record<string, any>>(value: any, selector: Expected, message?: string): value is Expected;\n-\n-\t/** Skip this assertion. */\n-\tskip(value: any, selector: any, message?: string): void;\n-}\n-\n-export interface FailAssertion {\n-\t/** Fail the test, always returning `false`. */\n-\t(message?: string): boolean;\n-\n-\t/** Skip this assertion. */\n-\tskip(message?: string): void;\n-}\n-\n-export interface FalseAssertion {\n-\t/**\n-\t * Assert that `actual` is strictly false, returning a boolean indicating whether the assertion passed.\n-\t */\n-\t(actual: any, message?: string): actual is false;\n-\n-\t/** Skip this assertion. */\n-\tskip(actual: any, message?: string): void;\n-}\n-\n-export interface FalsyAssertion {\n-\t/**\n-\t * Assert that `actual` is [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy), returning a boolean\n-\t * indicating whether the assertion passed.\n-\t */\n-\t(actual: any, message?: string): boolean;\n-\n-\t/** Skip this assertion. */\n-\tskip(actual: any, message?: string): void;\n-}\n-\n-export interface IsAssertion {\n-\t/**\n-\t * Assert that `actual` is [the same\n-\t * value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) as `expected`,\n-\t * returning a boolean indicating whether the assertion passed.\n-\t */\n-\t<Actual, Expected extends Actual>(actual: Actual, expected: Expected, message?: string): actual is Expected;\n-\n-\t/** Skip this assertion. */\n-\tskip(actual: any, expected: any, message?: string): void;\n-}\n-\n-export interface NotAssertion {\n-\t/**\n-\t * Assert that `actual` is not [the same\n-\t * value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) as `expected`,\n-\t * returning a boolean indicating whether the assertion passed.\n-\t */\n-\t<Actual, Expected>(actual: Actual, expected: Expected, message?: string): boolean;\n-\n-\t/** Skip this assertion. */\n-\tskip(actual: any, expected: any, message?: string): void;\n-}\n-\n-export interface NotDeepEqualAssertion {\n-\t/**\n-\t * Assert that `actual` is not [deeply equal](https://github.com/concordancejs/concordance#comparison-details) to\n-\t * `expected`, returning a boolean indicating whether the assertion passed.\n-\t */\n-\t<Actual, Expected>(actual: Actual, expected: Expected, message?: string): boolean;\n-\n-\t/** Skip this assertion. */\n-\tskip(actual: any, expected: any, message?: string): void;\n-}\n-\n-export interface NotRegexAssertion {\n-\t/**\n-\t * Assert that `string` does not match the regular expression, returning a boolean indicating whether the assertion\n-\t * passed.\n-\t */\n-\t(string: string, regex: RegExp, message?: string): boolean;\n-\n-\t/** Skip this assertion. */\n-\tskip(string: string, regex: RegExp, message?: string): void;\n-}\n-\n-export interface NotThrowsAssertion {\n-\t/** Assert that the function does not throw. */\n-\t(fn: () => any, message?: string): void;\n-\n-\t/** Skip this assertion. */\n-\tskip(fn: () => any, message?: string): void;\n-}\n-\n-export interface NotThrowsAsyncAssertion {\n-\t/** Assert that the async function does not throw. You must await the result. */\n-\t(fn: () => PromiseLike<any>, message?: string): Promise<void>;\n-\n-\t/** Assert that the promise does not reject. You must await the result. */\n-\t(promise: PromiseLike<any>, message?: string): Promise<void>;\n-\n-\t/** Skip this assertion. */\n-\tskip(nonThrower: any, message?: string): void;\n-}\n-\n-export interface PassAssertion {\n-\t/** Count a passing assertion, always returning `true`. */\n-\t(message?: string): boolean;\n-\n-\t/** Skip this assertion. */\n-\tskip(message?: string): void;\n-}\n-\n-export interface RegexAssertion {\n-\t/**\n-\t * Assert that `string` matches the regular expression, returning a boolean indicating whether the assertion passed.\n-\t */\n-\t(string: string, regex: RegExp, message?: string): boolean;\n-\n-\t/** Skip this assertion. */\n-\tskip(string: string, regex: RegExp, message?: string): void;\n-}\n-\n-export interface SnapshotAssertion {\n-\t/**\n-\t * Assert that `expected` is [deeply equal](https://github.com/concordancejs/concordance#comparison-details) to a\n-\t * previously recorded [snapshot](https://github.com/concordancejs/concordance#serialization-details), or if\n-\t * necessary record a new snapshot.\n-\t */\n-\t(expected: any, message?: string): void;\n-\n-\t/** Skip this assertion. */\n-\tskip(expected: any, message?: string): void;\n-}\n-\n-export interface ThrowsAssertion {\n-\t/**\n-\t * Assert that the function throws [an error](https://www.npmjs.com/package/is-error). If so, returns the error value.\n-\t * The error must satisfy all expectations.\n-\t */\n-\t<ThrownError extends Error>(fn: () => any, expectations?: ThrowsExpectation | null, message?: string): ThrownError;\n-\n-\t/** Skip this assertion. */\n-\tskip(fn: () => any, expectations?: any, message?: string): void;\n-}\n-\n-export interface ThrowsAsyncAssertion {\n-\t/**\n-\t * Assert that the async function throws [an error](https://www.npmjs.com/package/is-error). If so, returns the error\n-\t * value. You must await the result.\n-\t */\n-\t<ThrownError extends Error>(fn: () => PromiseLike<any>, expectations?: null, message?: string): Promise<ThrownError>;\n-\n-\t/**\n-\t * Assert that the async function throws [an error](https://www.npmjs.com/package/is-error). If so, returns the error\n-\t * value. You must await the result. The error must satisfy all expectations.\n-\t */\n-\t<ThrownError extends Error>(fn: () => PromiseLike<any>, expectations: ThrowsExpectation, message?: string): Promise<ThrownError>;\n-\n-\t/**\n-\t * Assert that the promise rejects with [an error](https://www.npmjs.com/package/is-error). If so, returns the\n-\t * rejection reason. You must await the result.\n-\t */\n-\t<ThrownError extends Error>(promise: PromiseLike<any>, expectations?: null, message?: string): Promise<ThrownError>;\n-\n-\t/**\n-\t * Assert that the promise rejects with [an error](https://www.npmjs.com/package/is-error). If so, returns the\n-\t * rejection reason. You must await the result. The error must satisfy all expectations.\n-\t */\n-\t<ThrownError extends Error>(promise: PromiseLike<any>, expectations: ThrowsExpectation, message?: string): Promise<ThrownError>;\n-\n-\t/** Skip this assertion. */\n-\tskip(thrower: any, expectations?: any, message?: string): void;\n-}\n-\n-export interface TrueAssertion {\n-\t/**\n-\t * Assert that `actual` is strictly true, returning a boolean indicating whether the assertion passed.\n-\t */\n-\t(actual: any, message?: string): actual is true;\n-\n-\t/** Skip this assertion. */\n-\tskip(actual: any, message?: string): void;\n-}\n-\n-export interface TruthyAssertion {\n-\t/**\n-\t * Assert that `actual` is [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy), returning a boolean\n-\t * indicating whether the assertion passed.\n-\t */\n-\t(actual: any, message?: string): boolean;\n-\n-\t/** Skip this assertion. */\n-\tskip(actual: any, message?: string): void;\n-}\n-\n-/** The `t` value passed to test & hook implementations. */\n-export interface ExecutionContext<Context = unknown> extends Assertions {\n-\t/** Test context, shared with hooks. */\n-\tcontext: Context;\n-\n-\t/** Title of the test or hook. */\n-\treadonly title: string;\n-\n-\t/** Whether the test has passed. Only accurate in afterEach hooks. */\n-\treadonly passed: boolean;\n-\n-\tlog: LogFn;\n-\tplan: PlanFn;\n-\tteardown: TeardownFn;\n-\ttimeout: TimeoutFn;\n-\ttry: TryFn<Context>;\n-}\n-\n-export interface LogFn {\n-\t/** Log one or more values. */\n-\t(...values: any[]): void;\n-\n-\t/** Skip logging. */\n-\tskip(...values: any[]): void;\n-}\n-\n-export interface PlanFn {\n-\t/**\n-\t * Plan how many assertion there are in the test. The test will fail if the actual assertion count doesn't match the\n-\t * number of planned assertions. See [assertion planning](https://github.com/avajs/ava#assertion-planning).\n-\t */\n-\t(count: number): void;\n-\n-\t/** Don't plan assertions. */\n-\tskip(count: number): void;\n-}\n-\n-export interface TimeoutFn {\n-\t/**\n-\t * Set a timeout for the test, in milliseconds. The test will fail if the timeout is exceeded.\n-\t * The timeout is reset each time an assertion is made.\n-\t */\n-\t(ms: number, message?: string): void;\n-}\n-\n-export interface TeardownFn {\n-\t/** Declare a function to be run after the test has ended. */\n-\t(fn: () => void): void;\n-}\n-\n-export interface TryFn<Context = unknown> {\n-\t/**\n-\t * Attempt to run some assertions. The result must be explicitly committed or discarded or else\n-\t * the test will fail. A macro may be provided. The title may help distinguish attempts from\n-\t * one another.\n-\t */\n-\t<Args extends any[]>(title: string, fn: EitherMacro<Args, Context>, ...args: Args): Promise<TryResult>;\n-\n-\t/**\n-\t * Attempt to run some assertions. The result must be explicitly committed or discarded or else\n-\t * the test will fail. A macro may be provided. The title may help distinguish attempts from\n-\t * one another.\n-\t */\n-\t<Args extends any[]>(title: string, fn: [EitherMacro<Args, Context>, ...Array<EitherMacro<Args, Context>>], ...args: Args): Promise<TryResult[]>;\n-\n-\t/**\n-\t * Attempt to run some assertions. The result must be explicitly committed or discarded or else\n-\t * the test will fail. A macro may be provided.\n-\t */\n-\t<Args extends any[]>(fn: EitherMacro<Args, Context>, ...args: Args): Promise<TryResult>;\n-\n-\t/**\n-\t * Attempt to run some assertions. The result must be explicitly committed or discarded or else\n-\t * the test will fail. A macro may be provided.\n-\t */\n-\t<Args extends any[]>(fn: [EitherMacro<Args, Context>, ...Array<EitherMacro<Args, Context>>], ...args: Args): Promise<TryResult[]>;\n-}\n-\n-export interface AssertionError extends Error {}\n-\n-export interface TryResult {\n-\t/**\n-\t* Title of the attempt, helping you tell attempts aparts.\n-\t*/\n-\ttitle: string;\n-\n-\t/**\n-\t* Indicates whether all assertions passed, or at least one failed.\n-\t*/\n-\tpassed: boolean;\n-\n-\t/**\n-\t* Errors raised for each failed assertion.\n-\t*/\n-\terrors: AssertionError[];\n-\n-\t/**\n-\t * Logs created during the attempt using `t.log()`. Contains formatted values.\n-\t */\n-\tlogs: string[];\n-\n-\t/**\n-\t * Commit the attempt. Counts as one assertion for the plan count. If the\n-\t * attempt failed, calling this will also cause your test to fail.\n-\t */\n-\tcommit(options?: CommitDiscardOptions): void;\n-\n-\t/**\n-\t * Discard the attempt.\n-\t */\n-\tdiscard(options?: CommitDiscardOptions): void;\n-}\n-\n-// FIXME(novemberborn) Refactor implementations to be different types returning a promise,, subscribable, or void, not a\n-// single type returning a union. A union with void as a return type doesn't make sense.\n-export type ImplementationResult = PromiseLike<void> | Subscribable | boolean | void;\n-export type Implementation<Context = unknown> = (t: ExecutionContext<Context>) => ImplementationResult;\n-\n-/** A reusable test or hook implementation. */\n-export type UntitledMacro<Args extends any[], Context = unknown> = (t: ExecutionContext<Context>, ...args: Args) => ImplementationResult;\n-\n-/** A reusable test or hook implementation. */\n-export type Macro<Args extends any[], Context = unknown> = UntitledMacro<Args, Context> & {\n-\t/**\n-\t * Implement this function to generate a test (or hook) title whenever this macro is used. `providedTitle` contains\n-\t * the title provided when the test or hook was declared. Also receives the remaining test arguments.\n-\t */\n-\ttitle?: (providedTitle: string | undefined, ...args: Args) => string;\n-};\n-\n-export type EitherMacro<Args extends any[], Context> = Macro<Args, Context> | UntitledMacro<Args, Context>;\n-\n-/** Alias for a single macro, or an array of macros. */\n-export type OneOrMoreMacros<Args extends any[], Context> = EitherMacro<Args, Context> | [EitherMacro<Args, Context>, ...Array<EitherMacro<Args, Context>>];\n-\n-export interface TestInterface<Context = unknown> {\n-\t/** Declare a concurrent test. */\n-\t(title: string, implementation: Implementation<Context>): void;\n-\n-\t/** Declare a concurrent test that uses one or more macros. Additional arguments are passed to the macro. */\n-\t<T extends any[]>(title: string, macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n-\n-\t/** Declare a concurrent test that uses one or more macros. The macro is responsible for generating a unique test title. */\n-\t<T extends any[]>(macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n-\n-\t/** Declare a hook that is run once, after all tests have passed. */\n-\tafter: AfterInterface<Context>;\n-\n-\t/** Declare a hook that is run after each passing test. */\n-\tafterEach: AfterInterface<Context>;\n-\n-\t/** Declare a hook that is run once, before all tests. */\n-\tbefore: BeforeInterface<Context>;\n-\n-\t/** Declare a hook that is run before each test. */\n-\tbeforeEach: BeforeInterface<Context>;\n-\n-\t/** Declare a test that is expected to fail. */\n-\tfailing: FailingInterface<Context>;\n-\n-\t/** Declare tests and hooks that are run serially. */\n-\tserial: SerialInterface<Context>;\n-\n-\tonly: OnlyInterface<Context>;\n-\tskip: SkipInterface<Context>;\n-\ttodo: TodoDeclaration;\n-\tmeta: MetaInterface;\n-}\n-\n-export interface AfterInterface<Context = unknown> {\n-\t/** Declare a hook that is run once, after all tests have passed. */\n-\t(implementation: Implementation<Context>): void;\n-\n-\t/** Declare a hook that is run once, after all tests have passed. */\n-\t(title: string, implementation: Implementation<Context>): void;\n-\n-\t/** Declare a hook that is run once, after all tests have passed. Additional arguments are passed to the macro. */\n-\t<T extends any[]>(title: string, macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n-\n-\t/** Declare a hook that is run once, after all tests have passed. */\n-\t<T extends any[]>(macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n-\n-\t/** Declare a hook that is run once, after all tests are done. */\n-\talways: AlwaysInterface<Context>;\n-\n-\tskip: HookSkipInterface<Context>;\n-}\n-\n-export interface AlwaysInterface<Context = unknown> {\n-\t/** Declare a hook that is run once, after all tests are done. */\n-\t(implementation: Implementation<Context>): void;\n-\n-\t/** Declare a hook that is run once, after all tests are done. */\n-\t(title: string, implementation: Implementation<Context>): void;\n-\n-\t/** Declare a hook that is run once, after all tests are done. Additional arguments are passed to the macro. */\n-\t<T extends any[]>(title: string, macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n-\n-\t/** Declare a hook that is run once, after all tests are done. */\n-\t<T extends any[]>(macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n-\n-\tskip: HookSkipInterface<Context>;\n-}\n-\n-export interface BeforeInterface<Context = unknown> {\n-\t/** Declare a hook that is run once, before all tests. */\n-\t(implementation: Implementation<Context>): void;\n-\n-\t/** Declare a hook that is run once, before all tests. */\n-\t(title: string, implementation: Implementation<Context>): void;\n-\n-\t/** Declare a hook that is run once, before all tests. Additional arguments are passed to the macro. */\n-\t<T extends any[]>(title: string, macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n-\n-\t/** Declare a hook that is run once, before all tests. */\n-\t<T extends any[]>(macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n-\n-\tskip: HookSkipInterface<Context>;\n-}\n-\n-export interface FailingInterface<Context = unknown> {\n-\t/** Declare a concurrent test. The test is expected to fail. */\n-\t(title: string, implementation: Implementation<Context>): void;\n-\n-\t/**\n-\t * Declare a concurrent test that uses one or more macros. Additional arguments are passed to the macro.\n-\t * The test is expected to fail.\n-\t */\n-\t<T extends any[]>(title: string, macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n-\n-\t/**\n-\t * Declare a concurrent test that uses one or more macros. The macro is responsible for generating a unique test title.\n-\t * The test is expected to fail.\n-\t */\n-\t<T extends any[]>(macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n-\n-\tonly: OnlyInterface<Context>;\n-\tskip: SkipInterface<Context>;\n-}\n-\n-export interface HookSkipInterface<Context = unknown> {\n-\t/** Skip this hook. */\n-\t(implementation: Implementation<Context>): void;\n-\n-\t/** Skip this hook. */\n-\t(title: string, implementation: Implementation<Context>): void;\n-\n-\t/** Skip this hook. */\n-\t<T extends any[]>(title: string, macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n-\n-\t/** Skip this hook. */\n-\t<T extends any[]>(macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n-}\n-\n-export interface OnlyInterface<Context = unknown> {\n-\t/** Declare a test. Only this test and others declared with `.only()` are run. */\n-\t(title: string, implementation: Implementation<Context>): void;\n-\n-\t/**\n-\t * Declare a test that uses one or more macros. Additional arguments are passed to the macro.\n-\t * Only this test and others declared with `.only()` are run.\n-\t */\n-\t<T extends any[]>(title: string, macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n-\n-\t/**\n-\t * Declare a test that uses one or more macros. The macro is responsible for generating a unique test title.\n-\t * Only this test and others declared with `.only()` are run.\n-\t */\n-\t<T extends any[]>(macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n-}\n-\n-export interface SerialInterface<Context = unknown> {\n-\t/** Declare a serial test. */\n-\t(title: string, implementation: Implementation<Context>): void;\n-\n-\t/** Declare a serial test that uses one or more macros. Additional arguments are passed to the macro. */\n-\t<T extends any[]>(title: string, macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n-\n-\t/**\n-\t * Declare a serial test that uses one or more macros. The macro is responsible for generating a unique test title.\n-\t */\n-\t<T extends any[]>(macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n-\n-\t/** Declare a serial hook that is run once, after all tests have passed. */\n-\tafter: AfterInterface<Context>;\n-\n-\t/** Declare a serial hook that is run after each passing test. */\n-\tafterEach: AfterInterface<Context>;\n-\n-\t/** Declare a serial hook that is run once, before all tests. */\n-\tbefore: BeforeInterface<Context>;\n-\n-\t/** Declare a serial hook that is run before each test. */\n-\tbeforeEach: BeforeInterface<Context>;\n-\n-\t/** Declare a serial test that is expected to fail. */\n-\tfailing: FailingInterface<Context>;\n-\n-\tonly: OnlyInterface<Context>;\n-\tskip: SkipInterface<Context>;\n-\ttodo: TodoDeclaration;\n-}\n-\n-export interface SkipInterface<Context = unknown> {\n-\t/** Skip this test. */\n-\t(title: string, implementation: Implementation<Context>): void;\n-\n-\t/** Skip this test. */\n-\t<T extends any[]>(title: string, macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n-\n-\t/** Skip this test. */\n-\t<T extends any[]>(macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n-}\n-\n-export interface TodoDeclaration {\n-\t/** Declare a test that should be implemented later. */\n-\t(title: string): void;\n-}\n-\n-export interface MetaInterface {\n-\t/** Path to the test file being executed. */\n-\tfile: string;\n-\n-\t/** Directory where snapshots are stored. */\n-\tsnapshotDirectory: string;\n-}\n+export * from './types/assertions';\n+export * from './types/try-fn';\n+export * from './types/test-fn';\n+export * from './types/subscribable';\n \n /** Call to declare a test, or chain to declare hooks or test modifiers */\n-declare const test: TestInterface;\n+declare const test: TestFn;\n \n /** Call to declare a test, or chain to declare hooks or test modifiers */\n export default test;"
      },
      {
        "sha": "ff69b46b9f9e7e7d50afc8caed6ff8146c476132",
        "filename": "lib/assert.js",
        "status": "modified",
        "additions": 12,
        "deletions": 11,
        "changes": 23,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/lib%2Fassert.js",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/lib%2Fassert.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fassert.js?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -469,7 +469,7 @@ export class Assertions {\n \t\t\tlet [fn, expectations, message] = args;\n \n \t\t\tif (!checkMessage('throws', message)) {\n-\t\t\t\treturn;\n+\t\t\t\treturn null;\n \t\t\t}\n \n \t\t\tif (typeof fn !== 'function') {\n@@ -479,14 +479,14 @@ export class Assertions {\n \t\t\t\t\tmessage: '`t.throws()` must be called with a function',\n \t\t\t\t\tvalues: [formatWithLabel('Called with:', fn)]\n \t\t\t\t}));\n-\t\t\t\treturn;\n+\t\t\t\treturn null;\n \t\t\t}\n \n \t\t\ttry {\n \t\t\t\texpectations = validateExpectations('throws', expectations, args.length, experiments);\n \t\t\t} catch (error) {\n \t\t\t\tfail(error);\n-\t\t\t\treturn;\n+\t\t\t\treturn null;\n \t\t\t}\n \n \t\t\tlet retval;\n@@ -501,7 +501,7 @@ export class Assertions {\n \t\t\t\t\t\tmessage,\n \t\t\t\t\t\tvalues: [formatWithLabel('Function returned a promise. Use `t.throwsAsync()` instead:', retval)]\n \t\t\t\t\t}));\n-\t\t\t\t\treturn;\n+\t\t\t\t\treturn null;\n \t\t\t\t}\n \t\t\t} catch (error) {\n \t\t\t\tactual = error;\n@@ -513,7 +513,7 @@ export class Assertions {\n \t\t\t\t\tmessage,\n \t\t\t\t\tvalues: [formatWithLabel('Function returned:', retval)]\n \t\t\t\t}));\n-\t\t\t\treturn;\n+\t\t\t\treturn null;\n \t\t\t}\n \n \t\t\ttry {\n@@ -531,11 +531,11 @@ export class Assertions {\n \t\t\t}\n \t\t});\n \n-\t\tthis.throwsAsync = withSkip((...args) => {\n+\t\tthis.throwsAsync = withSkip(async (...args) => {\n \t\t\tlet [thrower, expectations, message] = args;\n \n \t\t\tif (!checkMessage('throwsAsync', message)) {\n-\t\t\t\treturn Promise.resolve();\n+\t\t\t\treturn null;\n \t\t\t}\n \n \t\t\tif (typeof thrower !== 'function' && !isPromise(thrower)) {\n@@ -545,14 +545,14 @@ export class Assertions {\n \t\t\t\t\tmessage: '`t.throwsAsync()` must be called with a function or promise',\n \t\t\t\t\tvalues: [formatWithLabel('Called with:', thrower)]\n \t\t\t\t}));\n-\t\t\t\treturn Promise.resolve();\n+\t\t\t\treturn null;\n \t\t\t}\n \n \t\t\ttry {\n \t\t\t\texpectations = validateExpectations('throwsAsync', expectations, args.length, experiments);\n \t\t\t} catch (error) {\n \t\t\t\tfail(error);\n-\t\t\t\treturn Promise.resolve();\n+\t\t\t\treturn null;\n \t\t\t}\n \n \t\t\tconst handlePromise = async (promise, wasReturned) => {\n@@ -583,6 +583,7 @@ export class Assertions {\n \t\t\t\t\treturn await intermediate;\n \t\t\t\t} catch {\n \t\t\t\t\t// Don't reject the returned promise, even if the assertion fails.\n+\t\t\t\t\treturn null;\n \t\t\t\t}\n \t\t\t};\n \n@@ -605,7 +606,7 @@ export class Assertions {\n \t\t\t\t\tactualStack: actual.stack,\n \t\t\t\t\tvalues: [formatWithLabel('Function threw synchronously. Use `t.throws()` instead:', actual)]\n \t\t\t\t}));\n-\t\t\t\treturn Promise.resolve();\n+\t\t\t\treturn null;\n \t\t\t}\n \n \t\t\tif (isPromise(retval)) {\n@@ -617,7 +618,7 @@ export class Assertions {\n \t\t\t\tmessage,\n \t\t\t\tvalues: [formatWithLabel('Function returned:', retval)]\n \t\t\t}));\n-\t\t\treturn Promise.resolve();\n+\t\t\treturn null;\n \t\t});\n \n \t\tthis.notThrows = withSkip((fn, message) => {"
      },
      {
        "sha": "7f283ad454348032356c2cffaec3a415397cd1d7",
        "filename": "lib/create-chain.js",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/lib%2Fcreate-chain.js",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/lib%2Fcreate-chain.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fcreate-chain.js?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -91,6 +91,14 @@ export default function createChain(fn, defaults, meta) {\n \troot.todo = startChain('test.todo', fn, {...defaults, type: 'test', todo: true});\n \troot.serial.todo = startChain('test.serial.todo', fn, {...defaults, serial: true, type: 'test', todo: true});\n \n+\troot.macro = options => {\n+\t\tif (typeof options === 'function') {\n+\t\t\treturn Object.freeze({exec: options});\n+\t\t}\n+\n+\t\treturn Object.freeze({exec: options.exec, title: options.title});\n+\t};\n+\n \troot.meta = meta;\n \n \treturn root;"
      },
      {
        "sha": "de2f5548135d0d11091d8533fb385697c5c36b9d",
        "filename": "lib/parse-test-args.js",
        "status": "modified",
        "additions": 20,
        "deletions": 8,
        "changes": 28,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/lib%2Fparse-test-args.js",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/lib%2Fparse-test-args.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fparse-test-args.js?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -1,14 +1,26 @@\n-const normalize = title => typeof title === 'string' ? title.trim().replace(/\\s+/g, ' ') : title;\n+const buildTitle = (raw, implementation, args) => {\n+\tlet value = implementation && implementation.title ? implementation.title(raw, ...args) : raw;\n+\tconst isValid = typeof value === 'string';\n+\tif (isValid) {\n+\t\tvalue = value.trim().replace(/\\s+/g, ' ');\n+\t}\n+\n+\treturn {\n+\t\traw,\n+\t\tvalue,\n+\t\tisSet: value !== undefined,\n+\t\tisValid,\n+\t\tisEmpty: !isValid || value === ''\n+\t};\n+};\n \n export default function parseTestArgs(args) {\n \tconst rawTitle = typeof args[0] === 'string' ? args.shift() : undefined;\n-\tconst receivedImplementationArray = Array.isArray(args[0]);\n-\tconst implementations = receivedImplementationArray ? args.shift() : args.splice(0, 1);\n+\tconst implementation = args.shift();\n \n-\tconst buildTitle = implementation => {\n-\t\tconst title = normalize(implementation.title ? implementation.title(rawTitle, ...args) : rawTitle);\n-\t\treturn {title, isSet: typeof title !== 'undefined', isValid: typeof title === 'string', isEmpty: !title};\n+\treturn {\n+\t\targs,\n+\t\timplementation: implementation && implementation.exec ? implementation.exec : implementation,\n+\t\ttitle: buildTitle(rawTitle, implementation, args)\n \t};\n-\n-\treturn {args, buildTitle, implementations, rawTitle, receivedImplementationArray};\n }"
      },
      {
        "sha": "a0aca6ce10c3d5417a96f7506056fbbee8a0e9f8",
        "filename": "lib/runner.js",
        "status": "modified",
        "additions": 53,
        "deletions": 52,
        "changes": 105,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/lib%2Frunner.js",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/lib%2Frunner.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Frunner.js?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -100,94 +100,95 @@ export default class Runner extends Emittery {\n \n \t\t\tmetadata.taskIndex = this.nextTaskIndex++;\n \n-\t\t\tconst {args, buildTitle, implementations, rawTitle} = parseTestArgs(testArgs);\n+\t\t\tconst {args, implementation, title} = parseTestArgs(testArgs);\n \n \t\t\tif (this.checkSelectedByLineNumbers) {\n \t\t\t\tmetadata.selected = this.checkSelectedByLineNumbers();\n \t\t\t}\n \n \t\t\tif (metadata.todo) {\n-\t\t\t\tif (implementations.length > 0) {\n+\t\t\t\tif (implementation) {\n \t\t\t\t\tthrow new TypeError('`todo` tests are not allowed to have an implementation. Use `test.skip()` for tests with an implementation.');\n \t\t\t\t}\n \n-\t\t\t\tif (!rawTitle) { // Either undefined or a string.\n+\t\t\t\tif (!title.raw) { // Either undefined or a string.\n \t\t\t\t\tthrow new TypeError('`todo` tests require a title');\n \t\t\t\t}\n \n-\t\t\t\tif (!this.registerUniqueTitle(rawTitle)) {\n-\t\t\t\t\tthrow new Error(`Duplicate test title: ${rawTitle}`);\n+\t\t\t\tif (!this.registerUniqueTitle(title.value)) {\n+\t\t\t\t\tthrow new Error(`Duplicate test title: ${title.value}`);\n \t\t\t\t}\n \n \t\t\t\t// --match selects TODO tests.\n-\t\t\t\tif (this.match.length > 0 && matcher([rawTitle], this.match).length === 1) {\n+\t\t\t\tif (this.match.length > 0 && matcher([title.value], this.match).length === 1) {\n \t\t\t\t\tmetadata.exclusive = true;\n \t\t\t\t\tthis.runOnlyExclusive = true;\n \t\t\t\t}\n \n-\t\t\t\tthis.tasks.todo.push({title: rawTitle, metadata});\n+\t\t\t\tthis.tasks.todo.push({title: title.value, metadata});\n \t\t\t\tthis.emit('stateChange', {\n \t\t\t\t\ttype: 'declared-test',\n-\t\t\t\t\ttitle: rawTitle,\n+\t\t\t\t\ttitle: title.value,\n \t\t\t\t\tknownFailing: false,\n \t\t\t\t\ttodo: true\n \t\t\t\t});\n \t\t\t} else {\n-\t\t\t\tif (implementations.length === 0) {\n+\t\t\t\tif (!implementation) {\n \t\t\t\t\tthrow new TypeError('Expected an implementation. Use `test.todo()` for tests without an implementation.');\n \t\t\t\t}\n \n-\t\t\t\tfor (const implementation of implementations) {\n-\t\t\t\t\tlet {title, isSet, isValid, isEmpty} = buildTitle(implementation);\n+\t\t\t\tif (Array.isArray(implementation)) {\n+\t\t\t\t\tthrow new TypeError('AVA 4 no longer supports multiple implementations.');\n+\t\t\t\t}\n+\n+\t\t\t\tif (title.isSet && !title.isValid) {\n+\t\t\t\t\tthrow new TypeError('Test & hook titles must be strings');\n+\t\t\t\t}\n \n-\t\t\t\t\tif (isSet && !isValid) {\n-\t\t\t\t\t\tthrow new TypeError('Test & hook titles must be strings');\n+\t\t\t\tlet fallbackTitle = title.value;\n+\t\t\t\tif (title.isEmpty) {\n+\t\t\t\t\tif (metadata.type === 'test') {\n+\t\t\t\t\t\tthrow new TypeError('Tests must have a title');\n+\t\t\t\t\t} else if (metadata.always) {\n+\t\t\t\t\t\tfallbackTitle = `${metadata.type}.always hook`;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tfallbackTitle = `${metadata.type} hook`;\n \t\t\t\t\t}\n+\t\t\t\t}\n \n-\t\t\t\t\tif (isEmpty) {\n-\t\t\t\t\t\tif (metadata.type === 'test') {\n-\t\t\t\t\t\t\tthrow new TypeError('Tests must have a title');\n-\t\t\t\t\t\t} else if (metadata.always) {\n-\t\t\t\t\t\t\ttitle = `${metadata.type}.always hook`;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\ttitle = `${metadata.type} hook`;\n-\t\t\t\t\t\t}\n+\t\t\t\tif (metadata.type === 'test' && !this.registerUniqueTitle(title.value)) {\n+\t\t\t\t\tthrow new Error(`Duplicate test title: ${title.value}`);\n+\t\t\t\t}\n+\n+\t\t\t\tconst task = {\n+\t\t\t\t\ttitle: title.value || fallbackTitle,\n+\t\t\t\t\timplementation,\n+\t\t\t\t\targs,\n+\t\t\t\t\tmetadata: {...metadata}\n+\t\t\t\t};\n+\n+\t\t\t\tif (metadata.type === 'test') {\n+\t\t\t\t\tif (this.match.length > 0) {\n+\t\t\t\t\t\t// --match overrides .only()\n+\t\t\t\t\t\ttask.metadata.exclusive = matcher([title.value], this.match).length === 1;\n \t\t\t\t\t}\n \n-\t\t\t\t\tif (metadata.type === 'test' && !this.registerUniqueTitle(title)) {\n-\t\t\t\t\t\tthrow new Error(`Duplicate test title: ${title}`);\n+\t\t\t\t\tif (task.metadata.exclusive) {\n+\t\t\t\t\t\tthis.runOnlyExclusive = true;\n \t\t\t\t\t}\n \n-\t\t\t\t\tconst task = {\n-\t\t\t\t\t\ttitle,\n-\t\t\t\t\t\timplementation,\n-\t\t\t\t\t\targs,\n-\t\t\t\t\t\tmetadata: {...metadata}\n-\t\t\t\t\t};\n+\t\t\t\t\tthis.tasks[metadata.serial ? 'serial' : 'concurrent'].push(task);\n \n-\t\t\t\t\tif (metadata.type === 'test') {\n-\t\t\t\t\t\tif (this.match.length > 0) {\n-\t\t\t\t\t\t\t// --match overrides .only()\n-\t\t\t\t\t\t\ttask.metadata.exclusive = matcher([title], this.match).length === 1;\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tif (task.metadata.exclusive) {\n-\t\t\t\t\t\t\tthis.runOnlyExclusive = true;\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tthis.tasks[metadata.serial ? 'serial' : 'concurrent'].push(task);\n-\n-\t\t\t\t\t\tthis.snapshots.touch(title, metadata.taskIndex);\n-\n-\t\t\t\t\t\tthis.emit('stateChange', {\n-\t\t\t\t\t\t\ttype: 'declared-test',\n-\t\t\t\t\t\t\ttitle,\n-\t\t\t\t\t\t\tknownFailing: metadata.failing,\n-\t\t\t\t\t\t\ttodo: false\n-\t\t\t\t\t\t});\n-\t\t\t\t\t} else if (!metadata.skipped) {\n-\t\t\t\t\t\tthis.tasks[metadata.type + (metadata.always ? 'Always' : '')].push(task);\n-\t\t\t\t\t}\n+\t\t\t\t\tthis.snapshots.touch(title.value, metadata.taskIndex);\n+\n+\t\t\t\t\tthis.emit('stateChange', {\n+\t\t\t\t\t\ttype: 'declared-test',\n+\t\t\t\t\t\ttitle: title.value,\n+\t\t\t\t\t\tknownFailing: metadata.failing,\n+\t\t\t\t\t\ttodo: false\n+\t\t\t\t\t});\n+\t\t\t\t} else if (!metadata.skipped) {\n+\t\t\t\t\tthis.tasks[metadata.type + (metadata.always ? 'Always' : '')].push(task);\n \t\t\t\t}\n \t\t\t}\n \t\t}, {"
      },
      {
        "sha": "313f3115a6f46889fcc46ca465eee5279093841b",
        "filename": "lib/test.js",
        "status": "modified",
        "additions": 67,
        "deletions": 71,
        "changes": 138,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/lib%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/lib%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Ftest.js?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -81,90 +81,86 @@ class ExecutionContext extends Assertions {\n \t\t\t\tthrow error;\n \t\t\t}\n \n-\t\t\tconst {args, buildTitle, implementations, receivedImplementationArray} = parseTestArgs(attemptArgs);\n+\t\t\tconst {args, implementation, title} = parseTestArgs(attemptArgs);\n \n-\t\t\tif (implementations.length === 0) {\n+\t\t\tif (!implementation) {\n \t\t\t\tthrow new TypeError('Expected an implementation.');\n \t\t\t}\n \n-\t\t\tconst attemptPromises = implementations.map((implementation, index) => {\n-\t\t\t\tlet {title, isSet, isValid, isEmpty} = buildTitle(implementation);\n+\t\t\tif (Array.isArray(implementation)) {\n+\t\t\t\tthrow new TypeError('AVA 4 no longer supports t.try() with multiple implementations.');\n+\t\t\t}\n \n-\t\t\t\tif (!isSet || isEmpty) {\n-\t\t\t\t\ttitle = `${test.title} ─ attempt ${test.attemptCount + 1 + index}`;\n-\t\t\t\t} else if (isValid) {\n-\t\t\t\t\ttitle = `${test.title} ─ ${title}`;\n-\t\t\t\t} else {\n-\t\t\t\t\tthrow new TypeError('`t.try()` titles must be strings'); // Throw synchronously!\n-\t\t\t\t}\n+\t\t\tlet attemptTitle;\n+\t\t\tif (!title.isSet || title.isEmpty) {\n+\t\t\t\tattemptTitle = `${test.title} ─ attempt ${test.attemptCount + 1}`;\n+\t\t\t} else if (title.isValid) {\n+\t\t\t\tattemptTitle = `${test.title} ─ ${title.value}`;\n+\t\t\t} else {\n+\t\t\t\tthrow new TypeError('`t.try()` titles must be strings');\n+\t\t\t}\n \n-\t\t\t\tif (!test.registerUniqueTitle(title)) {\n-\t\t\t\t\tthrow new Error(`Duplicate test title: ${title}`);\n-\t\t\t\t}\n+\t\t\tif (!test.registerUniqueTitle(attemptTitle)) {\n+\t\t\t\tthrow new Error(`Duplicate test title: ${attemptTitle}`);\n+\t\t\t}\n \n-\t\t\t\treturn {implementation, title};\n-\t\t\t}).map(async ({implementation, title}) => {\n-\t\t\t\tlet committed = false;\n-\t\t\t\tlet discarded = false;\n-\n-\t\t\t\tconst {assertCount, deferredSnapshotRecordings, errors, logs, passed, snapshotCount, startingSnapshotCount} = await test.runAttempt(title, t => implementation(t, ...args));\n-\n-\t\t\t\treturn {\n-\t\t\t\t\terrors,\n-\t\t\t\t\tlogs: [...logs], // Don't allow modification of logs.\n-\t\t\t\t\tpassed,\n-\t\t\t\t\ttitle,\n-\t\t\t\t\tcommit: ({retainLogs = true} = {}) => {\n-\t\t\t\t\t\tif (committed) {\n-\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t}\n+\t\t\tlet committed = false;\n+\t\t\tlet discarded = false;\n \n-\t\t\t\t\t\tif (discarded) {\n-\t\t\t\t\t\t\ttest.saveFirstError(new Error('Can’t commit a result that was previously discarded'));\n-\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t}\n+\t\t\tconst {assertCount, deferredSnapshotRecordings, errors, logs, passed, snapshotCount, startingSnapshotCount} = await test.runAttempt(attemptTitle, t => implementation(t, ...args));\n \n-\t\t\t\t\t\tcommitted = true;\n-\t\t\t\t\t\ttest.finishAttempt({\n-\t\t\t\t\t\t\tassertCount,\n-\t\t\t\t\t\t\tcommit: true,\n-\t\t\t\t\t\t\tdeferredSnapshotRecordings,\n-\t\t\t\t\t\t\terrors,\n-\t\t\t\t\t\t\tlogs,\n-\t\t\t\t\t\t\tpassed,\n-\t\t\t\t\t\t\tretainLogs,\n-\t\t\t\t\t\t\tsnapshotCount,\n-\t\t\t\t\t\t\tstartingSnapshotCount\n-\t\t\t\t\t\t});\n-\t\t\t\t\t},\n-\t\t\t\t\tdiscard: ({retainLogs = false} = {}) => {\n-\t\t\t\t\t\tif (committed) {\n-\t\t\t\t\t\t\ttest.saveFirstError(new Error('Can’t discard a result that was previously committed'));\n-\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t}\n+\t\t\treturn {\n+\t\t\t\terrors,\n+\t\t\t\tlogs: [...logs], // Don't allow modification of logs.\n+\t\t\t\tpassed,\n+\t\t\t\ttitle: attemptTitle,\n+\t\t\t\tcommit: ({retainLogs = true} = {}) => {\n+\t\t\t\t\tif (committed) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n \n-\t\t\t\t\t\tif (discarded) {\n-\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t}\n+\t\t\t\t\tif (discarded) {\n+\t\t\t\t\t\ttest.saveFirstError(new Error('Can’t commit a result that was previously discarded'));\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n \n-\t\t\t\t\t\tdiscarded = true;\n-\t\t\t\t\t\ttest.finishAttempt({\n-\t\t\t\t\t\t\tassertCount: 0,\n-\t\t\t\t\t\t\tcommit: false,\n-\t\t\t\t\t\t\tdeferredSnapshotRecordings,\n-\t\t\t\t\t\t\terrors,\n-\t\t\t\t\t\t\tlogs,\n-\t\t\t\t\t\t\tpassed,\n-\t\t\t\t\t\t\tretainLogs,\n-\t\t\t\t\t\t\tsnapshotCount,\n-\t\t\t\t\t\t\tstartingSnapshotCount\n-\t\t\t\t\t\t});\n+\t\t\t\t\tcommitted = true;\n+\t\t\t\t\ttest.finishAttempt({\n+\t\t\t\t\t\tassertCount,\n+\t\t\t\t\t\tcommit: true,\n+\t\t\t\t\t\tdeferredSnapshotRecordings,\n+\t\t\t\t\t\terrors,\n+\t\t\t\t\t\tlogs,\n+\t\t\t\t\t\tpassed,\n+\t\t\t\t\t\tretainLogs,\n+\t\t\t\t\t\tsnapshotCount,\n+\t\t\t\t\t\tstartingSnapshotCount\n+\t\t\t\t\t});\n+\t\t\t\t},\n+\t\t\t\tdiscard: ({retainLogs = false} = {}) => {\n+\t\t\t\t\tif (committed) {\n+\t\t\t\t\t\ttest.saveFirstError(new Error('Can’t discard a result that was previously committed'));\n+\t\t\t\t\t\treturn;\n \t\t\t\t\t}\n-\t\t\t\t};\n-\t\t\t});\n \n-\t\t\tconst results = await Promise.all(attemptPromises);\n-\t\t\treturn receivedImplementationArray ? results : results[0];\n+\t\t\t\t\tif (discarded) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tdiscarded = true;\n+\t\t\t\t\ttest.finishAttempt({\n+\t\t\t\t\t\tassertCount: 0,\n+\t\t\t\t\t\tcommit: false,\n+\t\t\t\t\t\tdeferredSnapshotRecordings,\n+\t\t\t\t\t\terrors,\n+\t\t\t\t\t\tlogs,\n+\t\t\t\t\t\tpassed,\n+\t\t\t\t\t\tretainLogs,\n+\t\t\t\t\t\tsnapshotCount,\n+\t\t\t\t\t\tstartingSnapshotCount\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\t\t\t};\n \t\t};\n \t}\n "
      },
      {
        "sha": "446735df79fef49c2b5040d2578a1573d27acd10",
        "filename": "package.json",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/package.json",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/package.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/package.json?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -30,7 +30,9 @@\n \t\"files\": [\n \t\t\"entrypoints\",\n \t\t\"lib\",\n-\t\t\"*.d.ts\"\n+\t\t\"types\",\n+\t\t\"index.d.ts\",\n+\t\t\"plugin.d.ts\"\n \t],\n \t\"keywords\": [\n \t\t\"🦄\","
      },
      {
        "sha": "1e132743323c5077f74983c1085a717e78b47ef7",
        "filename": "test-d/context.ts",
        "status": "modified",
        "additions": 13,
        "deletions": 5,
        "changes": 18,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test-d%2Fcontext.ts",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test-d%2Fcontext.ts",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test-d%2Fcontext.ts?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -1,17 +1,16 @@\n import {expectError, expectType} from 'tsd';\n \n-import anyTest, {Macro, TestInterface} from '..';\n+import anyTest, {ExecutionContext, TestFn} from '..';\n \n interface Context {\n \tfoo: string;\n }\n \n-const test = anyTest as TestInterface<Context>; // eslint-disable-line @typescript-eslint/no-unnecessary-type-assertion\n+const test = anyTest as TestFn<Context>; // eslint-disable-line @typescript-eslint/no-unnecessary-type-assertion\n \n-const macro: Macro<[number], Context> = (t, expected) => {\n+const macro = test.macro((t, expected: number) => {\n \texpectType<string>(t.context.foo);\n-\texpectType<number>(expected);\n-};\n+});\n \n test.beforeEach(t => {\n \texpectType<Context>(t.context);\n@@ -22,3 +21,12 @@ expectError(test('foo is bar', macro, 'bar'));\n anyTest('default context is unknown', t => {\n \texpectType<unknown>(t.context);\n });\n+\n+// See https://github.com/avajs/ava/issues/2253\n+interface Covariant extends Context {\n+\tbar: number;\n+}\n+\n+const test2 = anyTest as TestFn<Covariant>; // eslint-disable-line @typescript-eslint/no-unnecessary-type-assertion\n+const hook = (t: ExecutionContext<Context>) => {};\n+test2.beforeEach(hook);"
      },
      {
        "sha": "b3117613e0aad007a3c534a71d452cf26ab8a873",
        "filename": "test-d/implementation-result.ts",
        "status": "added",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test-d%2Fimplementation-result.ts",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test-d%2Fimplementation-result.ts",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test-d%2Fimplementation-result.ts?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -0,0 +1,25 @@\n+import test from '..';\n+\n+test('return a promise-like', t => {\n+\treturn {\n+\t\tthen(resolve) {\n+\t\t\tresolve?.();\n+\t\t}\n+\t};\n+});\n+\n+test('return a subscribable', t => {\n+\treturn {\n+\t\tsubscribe({complete}) {\n+\t\t\tcomplete();\n+\t\t}\n+\t};\n+});\n+\n+test.after('return anything else', t => {\n+\treturn {\n+\t\tfoo: 'bar',\n+\t\tsubscribe() {},\n+\t\tthen() {}\n+\t};\n+});"
      },
      {
        "sha": "95d14d668190f8c7a22b86b50fea88468f851758",
        "filename": "test-d/macros.ts",
        "status": "modified",
        "additions": 56,
        "deletions": 35,
        "changes": 91,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test-d%2Fmacros.ts",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test-d%2Fmacros.ts",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test-d%2Fmacros.ts?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -1,75 +1,96 @@\n import {expectType} from 'tsd';\n \n-import test, {ExecutionContext, Macro} from '..';\n+import test, {ExecutionContext} from '..';\n \n-// Explicitly type as a macro.\n+// Typed arguments through generics.\n {\n-\tconst hasLength: Macro<[string, number]> = (t, input, expected) => {\n+\tconst hasLength = test.macro<[string, number]>((t, input, expected) => {\n \t\texpectType<string>(input);\n \t\texpectType<number>(expected);\n-\t};\n+\t});\n \n \ttest('bar has length 3', hasLength, 'bar', 3);\n-\ttest('bar has length 3', [hasLength], 'bar', 3);\n }\n \n-// Infer macro\n {\n-\tconst hasLength = (t: ExecutionContext, input: string, expected: number) => {};\n+\tconst hasLength = test.macro<[string, number]>({\n+\t\texec(t, input, expected) {\n+\t\t\texpectType<string>(input);\n+\t\t\texpectType<number>(expected);\n+\t\t},\n+\t\ttitle(providedTitle, input, expected) {\n+\t\t\texpectType<string>(input);\n+\t\t\texpectType<number>(expected);\n+\t\t\treturn 'title';\n+\t\t}\n+\t});\n \n \ttest('bar has length 3', hasLength, 'bar', 3);\n-\ttest('bar has length 3', [hasLength], 'bar', 3);\n }\n \n-// Multiple macros\n+// Typed arguments in execution function.\n {\n-\tconst hasLength = (t: ExecutionContext, input: string, expected: number) => {};\n-\tconst hasCodePoints = (t: ExecutionContext, input: string, expected: number) => {};\n+\tconst hasLength = test.macro((t, input: string, expected: number) => {});\n \n-\ttest('bar has length 3', [hasLength, hasCodePoints], 'bar', 3);\n+\ttest('bar has length 3', hasLength, 'bar', 3);\n }\n \n-// No title\n {\n-\tconst hasLength: Macro<[string, number]> = (t, input, expected) => {};\n-\tconst hasCodePoints: Macro<[string, number]> = (t, input, expected) => {};\n+\tconst hasLength = test.macro({\n+\t\texec(t, input: string, expected: number) {},\n+\t\ttitle(providedTitle, input, expected) {\n+\t\t\texpectType<string>(input);\n+\t\t\texpectType<number>(expected);\n+\t\t\treturn 'title';\n+\t\t}\n+\t});\n+\n+\ttest('bar has length 3', hasLength, 'bar', 3);\n+}\n+\n+// Untyped arguments\n+{\n+\tconst hasLength = test.macro((t, input, expected) => {\n+\t\texpectType<unknown>(input);\n+\t\texpectType<unknown>(expected);\n+\t});\n+\n+\ttest('bar has length 3', hasLength, 'bar', 3);\n+}\n+\n+// Usable without title, even if the macro lacks a title function.\n+{\n+\tconst hasLength = test.macro<[string, number]>((t, input, expected) => {});\n \n \ttest(hasLength, 'bar', 3);\n-\ttest([hasLength, hasCodePoints], 'bar', 3);\n }\n \n // No arguments\n {\n-\tconst pass: Macro<[]> = (t, ...args) => { // eslint-disable-line @typescript-eslint/ban-types\n-\t\texpectType<[]>(args); // eslint-disable-line @typescript-eslint/ban-types\n-\t};\n-\n-\tpass.title = (providedTitle, ...args) => {\n-\t\texpectType<string | undefined>(providedTitle);\n-\t\texpectType<[]>(args); // eslint-disable-line @typescript-eslint/ban-types\n-\t\treturn '';\n-\t};\n+\tconst pass = test.macro<[]>({ // eslint-disable-line @typescript-eslint/ban-types\n+\t\texec(t, ...args) {\n+\t\t\texpectType<[]>(args); // eslint-disable-line @typescript-eslint/ban-types\n+\t\t},\n+\t\ttitle(providedTitle, ...args) {\n+\t\t\texpectType<string | undefined>(providedTitle);\n+\t\t\texpectType<[]>(args); // eslint-disable-line @typescript-eslint/ban-types\n+\t\t\treturn '';\n+\t\t}\n+\t});\n \n \ttest(pass);\n }\n \n-// Inline\n+// Inline function with explicit argument types.\n test('has length 3', (t: ExecutionContext, input: string, expected: number) => {}, 'bar', 3);\n \n-test((t: ExecutionContext, input: string, expected: number) => {}, 'bar', 3);\n-\n-// Completely infer parameters\n+// Completely inferred arguments for inline functions.\n test('has length 3', (t, input, expected) => {\n \texpectType<string>(input);\n \texpectType<number>(expected);\n }, 'foo', 3);\n \n-test((t, input, expected) => {\n-\texpectType<string>(input);\n-\texpectType<number>(expected);\n-}, 'foo', 3);\n-\n-test.skip((t, input, expected) => {\n+test.skip('skip', (t, input, expected) => {\n \texpectType<string>(input);\n \texpectType<number>(expected);\n }, 'foo', 3);"
      },
      {
        "sha": "ea25e1305e0d33f2ef201f2c9350b6f4be0e03ac",
        "filename": "test-d/throws.ts",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test-d%2Fthrows.ts",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test-d%2Fthrows.ts",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test-d%2Fthrows.ts?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -12,13 +12,15 @@ class CustomError extends Error {\n }\n \n test('throws', t => {\n-\texpectType<Error>(t.throws(() => {}));\n-\tconst error2: CustomError = t.throws(() => {});\n-\texpectType<CustomError>(error2);\n-\texpectType<CustomError>(t.throws<CustomError>(() => {}));\n+\texpectType<Error | null>(t.throws(() => {}));\n+\tconst error2: CustomError | null = t.throws(() => {});\n+\texpectType<CustomError | null>(error2);\n+\texpectType<CustomError | null>(t.throws<CustomError>(() => {}));\n });\n \n test('throwsAsync', async t => {\n-\texpectType<Error>(await t.throwsAsync(Promise.reject()));\n-\texpectType<CustomError>(await t.throwsAsync<CustomError>(Promise.reject()));\n+\texpectType<Error | null>(await t.throwsAsync(async () => {}));\n+\texpectType<CustomError | null>(await t.throwsAsync<CustomError>(async () => {}));\n+\texpectType<Error | null>(await t.throwsAsync(Promise.reject()));\n+\texpectType<CustomError | null>(await t.throwsAsync<CustomError>(Promise.reject()));\n });"
      },
      {
        "sha": "a773dc8679a1f4a4d66d3f4597a83b6829cc2945",
        "filename": "test-d/try-commit.ts",
        "status": "modified",
        "additions": 9,
        "deletions": 27,
        "changes": 36,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test-d%2Ftry-commit.ts",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test-d%2Ftry-commit.ts",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test-d%2Ftry-commit.ts?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -29,16 +29,6 @@ test('attempt with title', async t => {\n \tattempt.commit();\n });\n \n-test('multiple attempts', async t => {\n-\tconst attempts = [\n-\t\t...await t.try([tt => tt.pass(), tt => tt.pass()]),\n-\t\t...await t.try('title', [tt => tt.pass(), tt => tt.pass()])\n-\t];\n-\tfor (const attempt of attempts) {\n-\t\tattempt.commit();\n-\t}\n-});\n-\n {\n \tconst lengthCheck = (t: ExecutionContext, a: string, b: number): void => {\n \t\tt.is(a.length, b);\n@@ -58,31 +48,23 @@ test('multiple attempts', async t => {\n test('all possible variants to pass to t.try', async t => {\n \t// No params\n \tt.try(tt => tt.pass());\n-\t/* Fails as expected */ // t.try([]);\n-\tt.try([tt => tt.pass()]);\n-\tt.try([tt => tt.pass(), tt => tt.fail()]);\n \n \tt.try('test', tt => tt.pass());\n-\t/* Fails as expected */ // t.try('test', []);\n-\tt.try('test', [tt => tt.pass()]);\n-\tt.try('test', [tt => tt.pass(), tt => tt.fail()]);\n \n \t// Some params\n \tt.try((tt, a, b) => tt.is(a.length, b), 'hello', 5);\n-\t/* Fails as expected */ // t.try([], 'hello', 5);\n-\tt.try([(tt, a, b) => tt.is(a.length, b)], 'hello', 5);\n-\tt.try([(tt, a, b) => tt.is(a.length, b), (tt, a, b) => tt.is(a.slice(b), '')], 'hello', 5);\n \n \tt.try('test', (tt, a, b) => tt.is(a.length, b), 'hello', 5);\n-\t/* Fails as expected */ // t.try('test', [], 'hello', 5);\n-\tt.try('test', [(tt, a, b) => tt.is(a.length, b)], 'hello', 5);\n-\tt.try('test', [(tt, a, b) => tt.is(a.length, b), (tt, a, b) => tt.is(a.slice(b), '')], 'hello', 5);\n \n \t// Macro with title\n-\tconst macro1: Macro<[string, number]> = (tt, a, b) => tt.is(a.length, b);\n-\tmacro1.title = (title, a, b) => `${title ? `${String(title)} ` : ''}str: \"${String(a)}\" with len: \"${String(b)}\"`;\n-\tconst macro2: Macro<[string, number]> = (tt, a, b) => tt.is(a.slice(b), '');\n+\tconst macro1 = test.macro<[string, number]>({\n+\t\texec: (tt, a, b) => tt.is(a.length, b),\n+\t\ttitle: (title, a, b) => `${title ? `${String(title)} ` : ''}str: \"${String(a)}\" with len: \"${String(b)}\"`\n+\t});\n+\tconst macro2 = test.macro<[string, number]>((tt, a, b) => tt.is(a.slice(b), ''));\n \n-\tt.try([macro1, macro2], 'hello', 5);\n-\tt.try('title', [macro1, macro2], 'hello', 5);\n+\tt.try(macro1, 'hello', 5);\n+\tt.try(macro2, 'hello', 5);\n+\tt.try('title', macro1, 'hello', 5);\n+\tt.try('title', macro2, 'hello', 5);\n });"
      },
      {
        "sha": "4891b52ce38efdd1cee1f7f1eda6ee6b93457a6a",
        "filename": "test-tap/assert.js",
        "status": "modified",
        "additions": 20,
        "deletions": 8,
        "changes": 28,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test-tap%2Fassert.js",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test-tap%2Fassert.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test-tap%2Fassert.js?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -112,6 +112,16 @@ function failsWith(t, fn, subset, {expectBoolean = true} = {}) {\n }\n \n function throwsAsyncFails(t, fn, subset) {\n+\treturn add(() => {\n+\t\tlastFailure = null;\n+\t\treturn fn().then(retval => {\n+\t\t\tt.equal(retval, null);\n+\t\t\tassertFailure(t, subset);\n+\t\t});\n+\t});\n+}\n+\n+function notThrowsAsyncFails(t, fn, subset) {\n \treturn add(() => {\n \t\tlastFailure = null;\n \t\treturn fn().then(retval => {\n@@ -160,6 +170,8 @@ function throwsAsyncPasses(t, fn) {\n \t});\n }\n \n+const notThrowsAsyncPasses = throwsAsyncPasses;\n+\n test('.pass()', t => {\n \tpasses(t, () => {\n \t\treturn assertions.pass();\n@@ -1521,31 +1533,31 @@ test('.notThrows()', gather(t => {\n \n test('.notThrowsAsync()', gather(t => {\n \t// Passes because the promise is resolved\n-\tthrowsAsyncPasses(t, () => assertions.notThrowsAsync(Promise.resolve()));\n+\tnotThrowsAsyncPasses(t, () => assertions.notThrowsAsync(Promise.resolve()));\n \n-\tthrowsAsyncPasses(t, () => {\n+\tnotThrowsAsyncPasses(t, () => {\n \t\treturn assertions.notThrowsAsync(Promise.resolve());\n \t});\n \n \t// Fails because the promise is rejected\n-\tthrowsAsyncFails(t, () => assertions.notThrowsAsync(Promise.reject(new Error())), {\n+\tnotThrowsAsyncFails(t, () => assertions.notThrowsAsync(Promise.reject(new Error())), {\n \t\tassertion: 'notThrowsAsync',\n \t\tmessage: '',\n \t\tvalues: [{label: 'Promise rejected with:', formatted: /Error/}]\n \t});\n \n \t// Passes because the function returned a resolved promise\n-\tthrowsAsyncPasses(t, () => assertions.notThrowsAsync(() => Promise.resolve()));\n+\tnotThrowsAsyncPasses(t, () => assertions.notThrowsAsync(() => Promise.resolve()));\n \n \t// Fails because the function returned a rejected promise\n-\tthrowsAsyncFails(t, () => assertions.notThrowsAsync(() => Promise.reject(new Error())), {\n+\tnotThrowsAsyncFails(t, () => assertions.notThrowsAsync(() => Promise.reject(new Error())), {\n \t\tassertion: 'notThrowsAsync',\n \t\tmessage: '',\n \t\tvalues: [{label: 'Returned promise rejected with:', formatted: /Error/}]\n \t});\n \n \t// Fails because the function throws synchronously\n-\tthrowsAsyncFails(t, () => assertions.notThrowsAsync(() => {\n+\tnotThrowsAsyncFails(t, () => assertions.notThrowsAsync(() => {\n \t\tthrow new Error('sync');\n \t}, 'message'), {\n \t\tassertion: 'notThrowsAsync',\n@@ -1556,15 +1568,15 @@ test('.notThrowsAsync()', gather(t => {\n \t});\n \n \t// Fails because the function did not return a promise\n-\tthrowsAsyncFails(t, () => assertions.notThrowsAsync(() => {}, 'message'), {\n+\tnotThrowsAsyncFails(t, () => assertions.notThrowsAsync(() => {}, 'message'), {\n \t\tassertion: 'notThrowsAsync',\n \t\tmessage: 'message',\n \t\tvalues: [\n \t\t\t{label: 'Function did not return a promise. Use `t.notThrows()` instead:', formatted: /undefined/}\n \t\t]\n \t});\n \n-\tthrowsAsyncFails(t, () => assertions.notThrowsAsync(Promise.resolve(), null), {\n+\tnotThrowsAsyncFails(t, () => assertions.notThrowsAsync(Promise.resolve(), null), {\n \t\tassertion: 'notThrowsAsync',\n \t\timproperUsage: true,\n \t\tmessage: 'The assertion message must be a string',"
      },
      {
        "sha": "90cae952c505b38a0eefb67f14805a1a4c9d63cb",
        "filename": "test-tap/runner.js",
        "status": "modified",
        "additions": 0,
        "deletions": 80,
        "changes": 80,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test-tap%2Frunner.js",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test-tap%2Frunner.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test-tap%2Frunner.js?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -684,86 +684,6 @@ test('match applies to macros', t => {\n \t});\n });\n \n-test('arrays of macros', t => {\n-\tconst expectedArgsA = [\n-\t\t['A'],\n-\t\t['B'],\n-\t\t['C']\n-\t];\n-\n-\tconst expectedArgsB = [\n-\t\t['A'],\n-\t\t['B'],\n-\t\t['D']\n-\t];\n-\n-\tfunction macroFnA(a, ...rest) {\n-\t\tt.same(rest, expectedArgsA.shift());\n-\t\ta.pass();\n-\t}\n-\n-\tmacroFnA.title = prefix => `${prefix}.A`;\n-\n-\tfunction macroFnB(a, ...rest) {\n-\t\tt.same(rest, expectedArgsB.shift());\n-\t\ta.pass();\n-\t}\n-\n-\tmacroFnB.title = prefix => `${prefix}.B`;\n-\n-\treturn promiseEnd(new Runner({file: import.meta.url}), runner => {\n-\t\trunner.on('stateChange', evt => {\n-\t\t\tif (evt.type === 'test-passed') {\n-\t\t\t\tt.pass();\n-\t\t\t}\n-\t\t});\n-\n-\t\trunner.chain('A', [macroFnA, macroFnB], 'A');\n-\t\trunner.chain('B', [macroFnA, macroFnB], 'B');\n-\t\trunner.chain('C', macroFnA, 'C');\n-\t\trunner.chain('D', macroFnB, 'D');\n-\t}).then(() => {\n-\t\tt.equal(expectedArgsA.length, 0);\n-\t\tt.equal(expectedArgsB.length, 0);\n-\t});\n-});\n-\n-test('match applies to arrays of macros', t => {\n-\tt.plan(1);\n-\n-\t// Foo\n-\tfunction fooMacro(a) {\n-\t\tt.fail();\n-\t\ta.pass();\n-\t}\n-\n-\tfooMacro.title = (title, firstArg) => `${firstArg}foo`;\n-\n-\tfunction barMacro(avaT) {\n-\t\tavaT.pass();\n-\t}\n-\n-\tbarMacro.title = (title, firstArg) => `${firstArg}bar`;\n-\n-\tfunction bazMacro(a) {\n-\t\tt.fail();\n-\t\ta.pass();\n-\t}\n-\n-\tbazMacro.title = (title, firstArg) => `${firstArg}baz`;\n-\n-\treturn promiseEnd(new Runner({file: import.meta.url, match: ['foobar']}), runner => {\n-\t\trunner.on('stateChange', evt => {\n-\t\t\tif (evt.type === 'test-passed') {\n-\t\t\t\tt.equal(evt.title, 'foobar');\n-\t\t\t}\n-\t\t});\n-\n-\t\trunner.chain([fooMacro, barMacro, bazMacro], 'foo');\n-\t\trunner.chain([fooMacro, barMacro, bazMacro], 'bar');\n-\t});\n-});\n-\n test('silently skips other tests when .only is used', t => {\n \tt.plan(1);\n \treturn promiseEnd(new Runner({file: import.meta.url}), runner => {"
      },
      {
        "sha": "36324e5a81eb3e3b494e0e00f433edf82c7d12f9",
        "filename": "test-tap/test-try-commit.js",
        "status": "modified",
        "additions": 0,
        "deletions": 62,
        "changes": 62,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test-tap%2Ftest-try-commit.js",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test-tap%2Ftest-try-commit.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test-tap%2Ftest-try-commit.js?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -369,68 +369,6 @@ test('try-commit accepts macros', async t => {\n \tt.ok(result.passed);\n });\n \n-test('try-commit accepts multiple macros', async t => {\n-\tconst ava = newAva();\n-\tconst result = await ava(async a => {\n-\t\tconst [result1, result2] = await a.try([\n-\t\t\tb => {\n-\t\t\t\tt.equal(b.title, 'test ─ attempt 1');\n-\t\t\t\tb.pass();\n-\t\t\t},\n-\t\t\tb => {\n-\t\t\t\tt.equal(b.title, 'test ─ attempt 2');\n-\t\t\t\tb.fail();\n-\t\t\t}\n-\t\t]);\n-\t\tt.ok(result1.passed);\n-\t\tresult1.commit();\n-\t\tt.notOk(result2.passed);\n-\t\tresult2.discard();\n-\n-\t\tconst [result3, result4] = await a.try([\n-\t\t\tb => {\n-\t\t\t\tt.equal(b.title, 'test ─ attempt 3');\n-\t\t\t\tb.pass();\n-\t\t\t},\n-\t\t\tb => {\n-\t\t\t\tt.equal(b.title, 'test ─ attempt 4');\n-\t\t\t\tb.fail();\n-\t\t\t}\n-\t\t]);\n-\t\tt.ok(result3.passed);\n-\t\tresult3.commit();\n-\t\tt.notOk(result4.passed);\n-\t\tresult4.discard();\n-\t}).run();\n-\n-\tt.ok(result.passed);\n-});\n-\n-test('try-commit returns results in the same shape as when implementations are passed', async t => {\n-\tconst ava = newAva();\n-\tconst result = await ava(async a => {\n-\t\tconst [result1, result2, result3] = await Promise.all([\n-\t\t\ta.try(b => b.pass()),\n-\t\t\ta.try([b => b.pass()]),\n-\t\t\ta.try([b => b.pass(), b => b.fail()])\n-\t\t]);\n-\n-\t\tt.match(result1, {passed: true});\n-\t\tresult1.commit();\n-\n-\t\tt.equal(result2.length, 1);\n-\t\tt.match(result2, [{passed: true}]);\n-\t\tresult2[0].commit();\n-\n-\t\tt.equal(result3.length, 2);\n-\t\tt.match(result3, [{passed: true}, {passed: false}]);\n-\t\tresult3[0].commit();\n-\t\tresult3[1].discard();\n-\t}).run();\n-\n-\tt.ok(result.passed);\n-});\n-\n test('try-commit abides timeout', async t => {\n \tconst ava = newAva();\n \tconst result1 = await ava(async a => {"
      },
      {
        "sha": "e51c2839e30ef650dca74a925cde3b7ffce37d42",
        "filename": "test/macros/fixtures/macros.js",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test%2Fmacros%2Ffixtures%2Fmacros.js",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test%2Fmacros%2Ffixtures%2Fmacros.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fmacros%2Ffixtures%2Fmacros.js?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -0,0 +1,18 @@\n+/* eslint-disable ava/test-title, ava/no-unknown-modifiers, ava/use-t */\n+import test from 'ava';\n+\n+const withoutTitle = test.macro((t, arg) => {\n+\tt.is(arg, 'arg');\n+});\n+const withTitle = test.macro({\n+\texec(t, arg) {\n+\t\tt.is(arg, 'arg');\n+\t},\n+\ttitle(provided, arg) {\n+\t\treturn `${provided || ''} ${arg}`;\n+\t}\n+});\n+\n+test('without title', withoutTitle, 'arg');\n+test('with title', withTitle, 'arg');\n+test(withTitle, 'arg');"
      },
      {
        "sha": "82d1f849494c7f9ef2951da1f717629e67b67052",
        "filename": "test/macros/fixtures/package.json",
        "status": "added",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test%2Fmacros%2Ffixtures%2Fpackage.json",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test%2Fmacros%2Ffixtures%2Fpackage.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fmacros%2Ffixtures%2Fpackage.json?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -0,0 +1,8 @@\n+{\n+\t\"type\": \"module\",\n+\t\"ava\": {\n+\t\t\"files\": [\n+\t\t\t\"*\"\n+\t\t]\n+\t}\n+}"
      },
      {
        "sha": "9f48e5190bde2cec92764b921e731d611f3e8533",
        "filename": "test/macros/test.js",
        "status": "added",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test%2Fmacros%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test%2Fmacros%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fmacros%2Ftest.js?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -0,0 +1,8 @@\n+import test from '@ava/test';\n+\n+import {fixture} from '../helpers/exec.js';\n+\n+test('a-okay', async t => {\n+\tconst result = await fixture([]);\n+\tt.is(result.stats.passed.length, 3);\n+});"
      },
      {
        "sha": "82d1f849494c7f9ef2951da1f717629e67b67052",
        "filename": "test/multiple-implementations/fixtures/package.json",
        "status": "added",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test%2Fmultiple-implementations%2Ffixtures%2Fpackage.json",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test%2Fmultiple-implementations%2Ffixtures%2Fpackage.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fmultiple-implementations%2Ffixtures%2Fpackage.json?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -0,0 +1,8 @@\n+{\n+\t\"type\": \"module\",\n+\t\"ava\": {\n+\t\t\"files\": [\n+\t\t\t\"*\"\n+\t\t]\n+\t}\n+}"
      },
      {
        "sha": "204b902dc6cb08df648b03e7596ed7ceebfea28d",
        "filename": "test/multiple-implementations/fixtures/test.js",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test%2Fmultiple-implementations%2Ffixtures%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test%2Fmultiple-implementations%2Ffixtures%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fmultiple-implementations%2Ffixtures%2Ftest.js?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -0,0 +1,3 @@\n+import test from 'ava';\n+\n+test('title', []);"
      },
      {
        "sha": "4b5a1af8950dbe9254022543e938cc24caa4cbad",
        "filename": "test/multiple-implementations/fixtures/try.js",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test%2Fmultiple-implementations%2Ffixtures%2Ftry.js",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test%2Fmultiple-implementations%2Ffixtures%2Ftry.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fmultiple-implementations%2Ffixtures%2Ftry.js?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -0,0 +1,5 @@\n+import test from 'ava';\n+\n+test('try', async t => {\n+\tawait t.try([]);\n+});"
      },
      {
        "sha": "4cefc477b12ad7baa66b2a00b97f32e4d2074edd",
        "filename": "test/multiple-implementations/test.js",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test%2Fmultiple-implementations%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/test%2Fmultiple-implementations%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fmultiple-implementations%2Ftest.js?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -0,0 +1,13 @@\n+import test from '@ava/test';\n+\n+import {fixture} from '../helpers/exec.js';\n+\n+test('test()', async t => {\n+\tconst result = await t.throwsAsync(fixture(['test.js']));\n+\tt.regex(result.stdout, /AVA 4 no longer supports multiple implementations/);\n+});\n+\n+test('t.try()', async t => {\n+\tconst result = await t.throwsAsync(fixture(['try.js']));\n+\tt.regex(result.stdout, /AVA 4 no longer supports t\\.try\\(\\) with multiple implementations/);\n+});"
      },
      {
        "sha": "005c0197c5c811adbd0cdd29b34b1fcaa806010b",
        "filename": "types/assertions.d.ts",
        "status": "added",
        "additions": 327,
        "deletions": 0,
        "changes": 327,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/types%2Fassertions.d.ts",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/types%2Fassertions.d.ts",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/types%2Fassertions.d.ts?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -0,0 +1,327 @@\n+export type ErrorConstructor = new (...args: any[]) => Error;\n+\n+/** Specify one or more expectations the thrown error must satisfy. */\n+export type ThrowsExpectation = {\n+\t/** The thrown error must have a code that equals the given string or number. */\n+\tcode?: string | number;\n+\n+\t/** The thrown error must be an instance of this constructor. */\n+\tinstanceOf?: ErrorConstructor;\n+\n+\t/** The thrown error must be strictly equal to this value. */\n+\tis?: Error;\n+\n+\t/** The thrown error must have a message that equals the given string, or matches the regular expression. */\n+\tmessage?: string | RegExp;\n+\n+\t/** The thrown error must have a name that equals the given string. */\n+\tname?: string;\n+};\n+\n+export interface Assertions {\n+\t/**\n+\t * Assert that `actual` is [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy), returning a boolean\n+\t * indicating whether the assertion passed. Comes with power-assert.\n+\t */\n+\tassert: AssertAssertion;\n+\n+\t/**\n+\t * Assert that `actual` is [deeply equal](https://github.com/concordancejs/concordance#comparison-details) to\n+\t * `expected`, returning a boolean indicating whether the assertion passed.\n+\t */\n+\tdeepEqual: DeepEqualAssertion;\n+\n+\t/**\n+\t * Assert that `value` is like `selector`, returning a boolean indicating whether the assertion passed.\n+\t */\n+\tlike: LikeAssertion;\n+\n+\t/** Fail the test, always returning `false`. */\n+\tfail: FailAssertion;\n+\n+\t/**\n+\t * Assert that `actual` is strictly false, returning a boolean indicating whether the assertion passed.\n+\t */\n+\tfalse: FalseAssertion;\n+\n+\t/**\n+\t * Assert that `actual` is [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy), returning a boolean\n+\t * indicating whether the assertion passed.\n+\t */\n+\tfalsy: FalsyAssertion;\n+\n+\t/**\n+\t * Assert that `actual` is [the same\n+\t * value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) as `expected`,\n+\t * returning a boolean indicating whether the assertion passed.\n+\t */\n+\tis: IsAssertion;\n+\n+\t/**\n+\t * Assert that `actual` is not [the same\n+\t * value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) as `expected`,\n+\t * returning a boolean indicating whether the assertion passed.\n+\t */\n+\tnot: NotAssertion;\n+\n+\t/**\n+\t * Assert that `actual` is not [deeply equal](https://github.com/concordancejs/concordance#comparison-details) to\n+\t * `expected`, returning a boolean indicating whether the assertion passed.\n+\t */\n+\tnotDeepEqual: NotDeepEqualAssertion;\n+\n+\t/**\n+\t * Assert that `string` does not match the regular expression, returning a boolean indicating whether the assertion\n+\t * passed.\n+\t */\n+\tnotRegex: NotRegexAssertion;\n+\n+\t/** Assert that the function does not throw. */\n+\tnotThrows: NotThrowsAssertion;\n+\n+\t/** Assert that the async function does not throw, or that the promise does not reject. Must be awaited. */\n+\tnotThrowsAsync: NotThrowsAsyncAssertion;\n+\n+\t/** Count a passing assertion, always returning `true`. */\n+\tpass: PassAssertion;\n+\n+\t/**\n+\t * Assert that `string` matches the regular expression, returning a boolean indicating whether the assertion passed.\n+\t */\n+\tregex: RegexAssertion;\n+\n+\t/**\n+\t * Assert that `expected` is [deeply equal](https://github.com/concordancejs/concordance#comparison-details) to a\n+\t * previously recorded [snapshot](https://github.com/concordancejs/concordance#serialization-details), or if\n+\t * necessary record a new snapshot.\n+\t */\n+\tsnapshot: SnapshotAssertion;\n+\n+\t/**\n+\t * Assert that the function throws [an error](https://www.npmjs.com/package/is-error). If so, returns the error value.\n+\t */\n+\tthrows: ThrowsAssertion;\n+\n+\t/**\n+\t * Assert that the async function throws [an error](https://www.npmjs.com/package/is-error), or the promise rejects\n+\t * with one. If so, returns a promise for the error value, which must be awaited.\n+\t */\n+\tthrowsAsync: ThrowsAsyncAssertion;\n+\n+\t/**\n+\t * Assert that `actual` is strictly true, returning a boolean indicating whether the assertion passed.\n+\t */\n+\ttrue: TrueAssertion;\n+\n+\t/**\n+\t * Assert that `actual` is [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy), returning a boolean\n+\t * indicating whether the assertion passed.\n+\t */\n+\ttruthy: TruthyAssertion;\n+}\n+\n+export interface AssertAssertion {\n+\t/**\n+\t * Assert that `actual` is [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy), returning a boolean\n+\t * indicating whether the assertion passed. Comes with power-assert.\n+\t */\n+\t(actual: any, message?: string): boolean;\n+\n+\t/** Skip this assertion. */\n+\tskip(actual: any, message?: string): void;\n+}\n+\n+export interface DeepEqualAssertion {\n+\t/**\n+\t * Assert that `actual` is [deeply equal](https://github.com/concordancejs/concordance#comparison-details) to\n+\t * `expected`, returning a boolean indicating whether the assertion passed.\n+\t */\n+\t<Actual, Expected extends Actual>(actual: Actual, expected: Expected, message?: string): actual is Expected;\n+\n+\t/** Skip this assertion. */\n+\tskip(actual: any, expected: any, message?: string): void;\n+}\n+\n+export interface LikeAssertion {\n+\t/**\n+\t * Assert that `value` is like `selector`, returning a boolean indicating whether the assertion passed.\n+\t */\n+\t<Expected extends Record<string, any>>(value: any, selector: Expected, message?: string): value is Expected;\n+\n+\t/** Skip this assertion. */\n+\tskip(value: any, selector: any, message?: string): void;\n+}\n+\n+export interface FailAssertion {\n+\t/** Fail the test, always returning `false`. */\n+\t(message?: string): boolean;\n+\n+\t/** Skip this assertion. */\n+\tskip(message?: string): void;\n+}\n+\n+export interface FalseAssertion {\n+\t/**\n+\t * Assert that `actual` is strictly false, returning a boolean indicating whether the assertion passed.\n+\t */\n+\t(actual: any, message?: string): actual is false;\n+\n+\t/** Skip this assertion. */\n+\tskip(actual: any, message?: string): void;\n+}\n+\n+export interface FalsyAssertion {\n+\t/**\n+\t * Assert that `actual` is [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy), returning a boolean\n+\t * indicating whether the assertion passed.\n+\t */\n+\t(actual: any, message?: string): boolean;\n+\n+\t/** Skip this assertion. */\n+\tskip(actual: any, message?: string): void;\n+}\n+\n+export interface IsAssertion {\n+\t/**\n+\t * Assert that `actual` is [the same\n+\t * value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) as `expected`,\n+\t * returning a boolean indicating whether the assertion passed.\n+\t */\n+\t<Actual, Expected extends Actual>(actual: Actual, expected: Expected, message?: string): actual is Expected;\n+\n+\t/** Skip this assertion. */\n+\tskip(actual: any, expected: any, message?: string): void;\n+}\n+\n+export interface NotAssertion {\n+\t/**\n+\t * Assert that `actual` is not [the same\n+\t * value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) as `expected`,\n+\t * returning a boolean indicating whether the assertion passed.\n+\t */\n+\t<Actual, Expected>(actual: Actual, expected: Expected, message?: string): boolean;\n+\n+\t/** Skip this assertion. */\n+\tskip(actual: any, expected: any, message?: string): void;\n+}\n+\n+export interface NotDeepEqualAssertion {\n+\t/**\n+\t * Assert that `actual` is not [deeply equal](https://github.com/concordancejs/concordance#comparison-details) to\n+\t * `expected`, returning a boolean indicating whether the assertion passed.\n+\t */\n+\t<Actual, Expected>(actual: Actual, expected: Expected, message?: string): boolean;\n+\n+\t/** Skip this assertion. */\n+\tskip(actual: any, expected: any, message?: string): void;\n+}\n+\n+export interface NotRegexAssertion {\n+\t/**\n+\t * Assert that `string` does not match the regular expression, returning a boolean indicating whether the assertion\n+\t * passed.\n+\t */\n+\t(string: string, regex: RegExp, message?: string): boolean;\n+\n+\t/** Skip this assertion. */\n+\tskip(string: string, regex: RegExp, message?: string): void;\n+}\n+\n+export interface NotThrowsAssertion {\n+\t/** Assert that the function does not throw. */\n+\t(fn: () => any, message?: string): void;\n+\n+\t/** Skip this assertion. */\n+\tskip(fn: () => any, message?: string): void;\n+}\n+\n+export interface NotThrowsAsyncAssertion {\n+\t/** Assert that the async function does not throw. You must await the result. */\n+\t(fn: () => PromiseLike<any>, message?: string): Promise<void>;\n+\n+\t/** Assert that the promise does not reject. You must await the result. */\n+\t(promise: PromiseLike<any>, message?: string): Promise<void>; // eslint-disable-line @typescript-eslint/unified-signatures\n+\n+\t/** Skip this assertion. */\n+\tskip(nonThrower: any, message?: string): void;\n+}\n+\n+export interface PassAssertion {\n+\t/** Count a passing assertion, always returning `true`. */\n+\t(message?: string): boolean;\n+\n+\t/** Skip this assertion. */\n+\tskip(message?: string): void;\n+}\n+\n+export interface RegexAssertion {\n+\t/**\n+\t * Assert that `string` matches the regular expression, returning a boolean indicating whether the assertion passed.\n+\t */\n+\t(string: string, regex: RegExp, message?: string): boolean;\n+\n+\t/** Skip this assertion. */\n+\tskip(string: string, regex: RegExp, message?: string): void;\n+}\n+\n+export interface SnapshotAssertion {\n+\t/**\n+\t * Assert that `expected` is [deeply equal](https://github.com/concordancejs/concordance#comparison-details) to a\n+\t * previously recorded [snapshot](https://github.com/concordancejs/concordance#serialization-details), or if\n+\t * necessary record a new snapshot.\n+\t */\n+\t(expected: any, message?: string): void;\n+\n+\t/** Skip this assertion. */\n+\tskip(expected: any, message?: string): void;\n+}\n+\n+export interface ThrowsAssertion {\n+\t/**\n+\t * Assert that the function throws [an error](https://www.npmjs.com/package/is-error). If so, returns the error value.\n+\t * The error must satisfy all expectations. Returns null when the assertion fails.\n+\t */\n+\t<ThrownError extends Error>(fn: () => any, expectations?: ThrowsExpectation, message?: string): ThrownError | null;\n+\n+\t/** Skip this assertion. */\n+\tskip(fn: () => any, expectations?: any, message?: string): void;\n+}\n+\n+export interface ThrowsAsyncAssertion {\n+\t/**\n+\t * Assert that the async function throws [an error](https://www.npmjs.com/package/is-error). If so, returns the error\n+\t * value. Returns null when the assertion fails. You must await the result. The error must satisfy all expectations.\n+\t */\n+\t<ThrownError extends Error>(fn: () => PromiseLike<any>, expectations?: ThrowsExpectation, message?: string): Promise<ThrownError | null>;\n+\n+\t/**\n+\t * Assert that the promise rejects with [an error](https://www.npmjs.com/package/is-error). If so, returns the\n+\t * rejection reason. Returns null when the assertion fails. You must await the result. The error must satisfy all\n+\t * expectations.\n+\t */\n+\t<ThrownError extends Error>(promise: PromiseLike<any>, expectations?: ThrowsExpectation, message?: string): Promise<ThrownError | null>; // eslint-disable-line @typescript-eslint/unified-signatures\n+\n+\t/** Skip this assertion. */\n+\tskip(thrower: any, expectations?: any, message?: string): void;\n+}\n+\n+export interface TrueAssertion {\n+\t/**\n+\t * Assert that `actual` is strictly true, returning a boolean indicating whether the assertion passed.\n+\t */\n+\t(actual: any, message?: string): actual is true;\n+\n+\t/** Skip this assertion. */\n+\tskip(actual: any, message?: string): void;\n+}\n+\n+export interface TruthyAssertion {\n+\t/**\n+\t * Assert that `actual` is [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy), returning a boolean\n+\t * indicating whether the assertion passed.\n+\t */\n+\t(actual: any, message?: string): boolean;\n+\n+\t/** Skip this assertion. */\n+\tskip(actual: any, message?: string): void;\n+}"
      },
      {
        "sha": "3a3399bca155b263318c3beece3b2bad6908f263",
        "filename": "types/subscribable.ts",
        "status": "added",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/types%2Fsubscribable.ts",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/types%2Fsubscribable.ts",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/types%2Fsubscribable.ts?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -0,0 +1,6 @@\n+export interface Subscribable {\n+\tsubscribe(observer: {\n+\t\terror(error: any): void;\n+\t\tcomplete(): void;\n+\t}): void;\n+}"
      },
      {
        "sha": "a876666df151ee1a884e88f9f3f804802acd212c",
        "filename": "types/test-fn.d.ts",
        "status": "added",
        "additions": 232,
        "deletions": 0,
        "changes": 232,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/types%2Ftest-fn.d.ts",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/types%2Ftest-fn.d.ts",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/types%2Ftest-fn.d.ts?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -0,0 +1,232 @@\n+import type {Assertions} from './assertions';\n+import type {Subscribable} from './subscribable';\n+import type {TryFn} from './try-fn';\n+\n+/** The `t` value passed to test & hook implementations. */\n+export interface ExecutionContext<Context = unknown> extends Assertions {\n+\t/** Test context, shared with hooks. */\n+\tcontext: Context;\n+\n+\t/** Title of the test or hook. */\n+\treadonly title: string;\n+\n+\t/** Whether the test has passed. Only accurate in afterEach hooks. */\n+\treadonly passed: boolean;\n+\n+\treadonly log: LogFn;\n+\treadonly plan: PlanFn;\n+\treadonly teardown: TeardownFn;\n+\treadonly timeout: TimeoutFn;\n+\treadonly try: TryFn<Context>;\n+}\n+\n+export interface LogFn {\n+\t/** Log one or more values. */\n+\t(...values: any[]): void;\n+\n+\t/** Skip logging. */\n+\tskip(...values: any[]): void;\n+}\n+\n+export interface PlanFn {\n+\t/**\n+\t * Plan how many assertion there are in the test. The test will fail if the actual assertion count doesn't match the\n+\t * number of planned assertions. See [assertion planning](https://github.com/avajs/ava#assertion-planning).\n+\t */\n+\t(count: number): void;\n+\n+\t/** Don't plan assertions. */\n+\tskip(count: number): void;\n+}\n+\n+/**\n+ * Set a timeout for the test, in milliseconds. The test will fail if the timeout is exceeded.\n+ * The timeout is reset each time an assertion is made.\n+ */\n+export type TimeoutFn = (ms: number, message?: string) => void;\n+\n+/** Declare a function to be run after the test has ended. */\n+export type TeardownFn = (fn: () => void) => void;\n+\n+export type ImplementationFn<Args extends unknown[], Context = unknown> =\n+\t((t: ExecutionContext<Context>, ...args: Args) => PromiseLike<void>) |\n+\t((t: ExecutionContext<Context>, ...args: Args) => Subscribable) |\n+\t((t: ExecutionContext<Context>, ...args: Args) => void);\n+\n+export type TitleFn<Args extends unknown[]> = (providedTitle: string | undefined, ...args: Args) => string;\n+\n+/** A reusable test or hook implementation. */\n+export type Macro<Args extends unknown[], Context = unknown> = {\n+\t/** The function that is executed when the macro is used. */\n+\treadonly exec: ImplementationFn<Args, Context>;\n+\n+\t/** Generates a test title when this macro is used. */\n+\treadonly title?: TitleFn<Args>;\n+};\n+\n+/** A test or hook implementation. */\n+export type Implementation<Args extends unknown[], Context = unknown> = ImplementationFn<Args, Context> | Macro<Args, Context>;\n+\n+export interface TestFn<Context = unknown> {\n+\tafter: AfterFn<Context>;\n+\tafterEach: AfterFn<Context>;\n+\tbefore: BeforeFn<Context>;\n+\tbeforeEach: BeforeFn<Context>;\n+\tfailing: FailingFn<Context>;\n+\tmacro: MacroFn<Context>;\n+\tmeta: Meta;\n+\tonly: OnlyFn<Context>;\n+\tserial: SerialFn<Context>;\n+\tskip: SkipFn<Context>;\n+\ttodo: TodoFn;\n+\n+\t/** Declare a concurrent test. Additional arguments are passed to the implementation or macro. */\n+\t<Args extends unknown[]>(title: string, implementation: Implementation<Args, Context>, ...args: Args): void;\n+\n+\t/**\n+\t * Declare a concurrent test that uses a macro. Additional arguments are passed to the macro.\n+\t * The macro is responsible for generating a unique test title.\n+\t */\n+\t<Args extends unknown[]>(macro: Macro<Args, Context>, ...args: Args): void;\n+}\n+\n+export interface AfterFn<Context = unknown> {\n+\talways: AlwaysInterface<Context>;\n+\tskip: HookSkipFn<Context>;\n+\n+\t/**\n+\t * Declare a hook that is run once, after all tests have passed.\n+\t * Additional arguments are passed to the implementation or macro.\n+\t */\n+\t<Args extends unknown[]>(title: string, implementation: Implementation<Args, Context>, ...args: Args): void;\n+\n+\t/**\n+\t * Declare a hook that is run once, after all tests have passed.\n+\t * Additional arguments are passed to the implementation or macro.\n+\t */\n+\t<Args extends unknown[]>(implementation: Implementation<Args, Context>, ...args: Args): void;\n+\n+}\n+\n+export interface AlwaysInterface<Context = unknown> {\n+\tskip: HookSkipFn<Context>;\n+\n+\t/**\n+\t * Declare a hook that is run once, after all tests are done.\n+\t * Additional arguments are passed to the implementation or macro.\n+\t */\n+\t<Args extends unknown[]>(title: string, implementation: Implementation<Args, Context>, ...args: Args): void;\n+\n+\t/**\n+\t * Declare a hook that is run once, after all tests are done.\n+\t * Additional arguments are passed to the implementation or macro.\n+\t */\n+\t<Args extends unknown[]>(implementation: Implementation<Args, Context>, ...args: Args): void;\n+}\n+\n+export interface BeforeFn<Context = unknown> {\n+\tskip: HookSkipFn<Context>;\n+\n+\t/**\n+\t * Declare a hook that is run once, before all tests.\n+\t * Additional arguments are passed to the implementation or macro.\n+\t */\n+\t<Args extends unknown[]>(title: string, implementation: Implementation<Args, Context>, ...args: Args): void;\n+\n+\t/**\n+\t * Declare a hook that is run once, before all tests.\n+\t * Additional arguments are passed to the implementation or macro.\n+\t */\n+\t<Args extends unknown[]>(implementation: Implementation<Args, Context>, ...args: Args): void;\n+}\n+\n+export interface FailingFn<Context = unknown> {\n+\tonly: OnlyFn<Context>;\n+\tskip: SkipFn<Context>;\n+\n+\t/**\n+\t * Declare a concurrent test that is expected to fail.\n+\t * Additional arguments are passed to the implementation or macro.\n+\t */\n+\t<Args extends unknown[]>(title: string, implementation: Implementation<Args, Context>, ...args: Args): void;\n+\n+\t/**\n+\t * Declare a concurrent test, using a macro, that is expected to fail.\n+\t * Additional arguments are passed to the macro. The macro is responsible for generating a unique test title.\n+\t */\n+\t<Args extends unknown[]>(macro: Macro<Args, Context>, ...args: Args): void;\n+}\n+\n+export interface HookSkipFn<Context = unknown> {\n+\t/** Skip this hook. */\n+\t<Args extends unknown[]>(title: string, implementation: Implementation<Args, Context>, ...args: Args): void;\n+\n+\t/** Skip this hook. */\n+\t<Args extends unknown[]>(implementation: Implementation<Args, Context>, ...args: Args): void;\n+}\n+\n+export interface OnlyFn<Context = unknown> {\n+\t/**\n+\t * Declare a test. Only this test and others declared with `.only()` are run.\n+\t * Additional arguments are passed to the implementation or macro.\n+\t */\n+\t<Args extends unknown[]>(title: string, implementation: Implementation<Args, Context>, ...args: Args): void;\n+\n+\t/**\n+\t * Declare a test that uses a macro. Only this test and others declared with `.only()` are run.\n+\t * Additional arguments are passed to the macro. The macro is responsible for generating a unique test title.\n+\t */\n+\t<Args extends unknown[]>(macro: Macro<Args, Context>, ...args: Args): void;\n+}\n+\n+export interface SerialFn<Context = unknown> {\n+\tafter: AfterFn<Context>;\n+\tafterEach: AfterFn<Context>;\n+\tbefore: BeforeFn<Context>;\n+\tbeforeEach: BeforeFn<Context>;\n+\tfailing: FailingFn<Context>;\n+\tonly: OnlyFn<Context>;\n+\tskip: SkipFn<Context>;\n+\ttodo: TodoFn;\n+\n+\t/** Declare a serial test. Additional arguments are passed to the implementation or macro. */\n+\t<Args extends unknown[]>(title: string, implementation: Implementation<Args, Context>, ...args: Args): void;\n+\n+\t/**\n+\t * Declare a serial test that uses a macro. The macro is responsible for generating a unique test title.\n+\t */\n+\t<Args extends unknown[]>(macro: Macro<Args, Context>, ...args: Args): void;\n+}\n+\n+export interface SkipFn<Context = unknown> {\n+\t/** Skip this test. */\n+\t<Args extends unknown[]>(title: string, implementation: Implementation<Args, Context>, ...args: Args): void;\n+\n+\t/** Skip this test. */\n+\t<Args extends unknown[]>(macro: Macro<Args, Context>, ...args: Args): void;\n+}\n+\n+/** Declare a test that should be implemented later. */\n+export type TodoFn = (title: string) => void;\n+\n+export type MacroDeclarationOptions<Args extends unknown[], Context = unknown> = {\n+\t/** The function that is executed when the macro is used. */\n+\texec: ImplementationFn<Args, Context>;\n+\n+\t/** The function responsible for generating a unique title when the macro is used. */\n+\ttitle: TitleFn<Args>;\n+};\n+\n+export interface MacroFn<Context = unknown> {\n+\t/** Declare a reusable test implementation. */\n+\t<Args extends unknown[]>(/** The function that is executed when the macro is used. */ exec: ImplementationFn<Args, Context>): Macro<Args, Context>;\n+\t<Args extends unknown[]>(declaration: MacroDeclarationOptions<Args, Context>): Macro<Args, Context>; // eslint-disable-line @typescript-eslint/unified-signatures\n+}\n+\n+export interface Meta {\n+\t/** Path to the test file being executed. */\n+\tfile: string;\n+\n+\t/** Directory where snapshots are stored. */\n+\tsnapshotDirectory: string;\n+}"
      },
      {
        "sha": "41a1664d5166bdf4e19cc52e4c03c520149bd277",
        "filename": "types/try-fn.d.ts",
        "status": "added",
        "additions": 58,
        "deletions": 0,
        "changes": 58,
        "blob_url": "https://github.com/avajs/ava/blob/1dd7a8f32dd201aef8fc51008df601e25ce6b890/types%2Ftry-fn.d.ts",
        "raw_url": "https://github.com/avajs/ava/raw/1dd7a8f32dd201aef8fc51008df601e25ce6b890/types%2Ftry-fn.d.ts",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/types%2Ftry-fn.d.ts?ref=1dd7a8f32dd201aef8fc51008df601e25ce6b890",
        "patch": "@@ -0,0 +1,58 @@\n+import type {Implementation} from './test-fn';\n+\n+export type CommitDiscardOptions = {\n+\t/**\n+\t * Whether the logs should be included in those of the parent test.\n+\t */\n+\tretainLogs?: boolean;\n+};\n+\n+export interface AssertionError extends Error {}\n+\n+export interface TryResult {\n+\t/**\n+\t* Title of the attempt, helping you tell attempts aparts.\n+\t*/\n+\ttitle: string;\n+\n+\t/**\n+\t* Indicates whether all assertions passed, or at least one failed.\n+\t*/\n+\tpassed: boolean;\n+\n+\t/**\n+\t* Errors raised for each failed assertion.\n+\t*/\n+\terrors: AssertionError[];\n+\n+\t/**\n+\t * Logs created during the attempt using `t.log()`. Contains formatted values.\n+\t */\n+\tlogs: string[];\n+\n+\t/**\n+\t * Commit the attempt. Counts as one assertion for the plan count. If the\n+\t * attempt failed, calling this will also cause your test to fail.\n+\t */\n+\tcommit(options?: CommitDiscardOptions): void;\n+\n+\t/**\n+\t * Discard the attempt.\n+\t */\n+\tdiscard(options?: CommitDiscardOptions): void;\n+}\n+\n+export interface TryFn<Context = unknown> {\n+\t/**\n+\t * Attempt to run some assertions. The result must be explicitly committed or discarded or else\n+\t * the test will fail. The title may help distinguish attempts from one another.\n+\t */\n+\t<Args extends unknown[]>(title: string, fn: Implementation<Args, Context>, ...args: Args): Promise<TryResult>;\n+\n+\t/**\n+\t * Attempt to run some assertions. The result must be explicitly committed or discarded or else\n+\t * the test will fail.\n+\t */\n+\t<Args extends unknown[]>(fn: Implementation<Args, Context>, ...args: Args): Promise<TryResult>;\n+}\n+"
      }
    ]
  },
  {
    "url": "https://api.github.com/repos/avajs/ava/issues/2685",
    "repository_url": "https://api.github.com/repos/avajs/ava",
    "labels_url": "https://api.github.com/repos/avajs/ava/issues/2685/labels{/name}",
    "comments_url": "https://api.github.com/repos/avajs/ava/issues/2685/comments",
    "events_url": "https://api.github.com/repos/avajs/ava/issues/2685/events",
    "html_url": "https://github.com/avajs/ava/pull/2685",
    "id": 807933970,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NTczMDcxMjM2",
    "number": 2685,
    "title": "Introducing AVA snapshots v3",
    "user": {
      "login": "ninevra",
      "id": 7622339,
      "node_id": "MDQ6VXNlcjc2MjIzMzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7622339?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ninevra",
      "html_url": "https://github.com/ninevra",
      "followers_url": "https://api.github.com/users/ninevra/followers",
      "following_url": "https://api.github.com/users/ninevra/following{/other_user}",
      "gists_url": "https://api.github.com/users/ninevra/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ninevra/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ninevra/subscriptions",
      "organizations_url": "https://api.github.com/users/ninevra/orgs",
      "repos_url": "https://api.github.com/users/ninevra/repos",
      "events_url": "https://api.github.com/users/ninevra/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ninevra/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 25,
    "created_at": "2021-02-14T10:40:47Z",
    "updated_at": "2021-03-13T16:22:02Z",
    "closed_at": "2021-03-13T16:21:54Z",
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "draft": false,
    "pull_request": {
      "url": "https://api.github.com/repos/avajs/ava/pulls/2685",
      "html_url": "https://github.com/avajs/ava/pull/2685",
      "diff_url": "https://github.com/avajs/ava/pull/2685.diff",
      "patch_url": "https://github.com/avajs/ava/pull/2685.patch",
      "merged_at": "2021-03-13T16:21:53Z"
    },
    "body": "Implements a new snapshot file format containing all information necessary to generate the snapshot report file.\r\n\r\nAllows the use of `test.skip()`, `test.only()`, `--match`, line number selection, and `t.snapshot.skip()` during `--update-snapshots` runs.\r\n\r\nCloses #2634 by removing the \"Could not update snapshots\" case entirely.\r\nCloses #2635 by allowing existing test & assertion selection mechanisms to be used with `--update-snapshots`.\r\nHopefully will assist with #1768 and #2099.\r\n\r\n## Current proposed snapshot file format:\r\n\r\n- Readable prefix: `AVA Snapshot v3\\n`\r\n- Snapshot version (UInt16LE): 3\r\n- sha256 checksum of the following\r\n- gzip compressed data:\r\n    - CBOR encoded data:\r\n        ```\r\n        {\r\n          blocks: [\r\n            {\r\n              title: \"A test title\",\r\n              snapshots: [\r\n                {\r\n                  label: \"A snapshot label\",\r\n                  buffer: /* Serialized concordance descriptor */\r\n                },\r\n                ...\r\n              ]\r\n            },\r\n            ...\r\n          ]\r\n        }\r\n        ```\r\n\r\nNotes:\r\n- The `label` field is absent unless the user supplied a label. This allows changing the default snapshot label if desired in the future.\r\n- The `buffer` field may be absent, if the snapshot has only ever been skipped. Such snapshots are currently rendered as `<No Data>`.\r\n- Currently, some data still exists only in the report file, namely the filenames of the test file and the snapshot file. This information can be derived from the name of the snapshot file, but theoretically that could change in the future.\r\n\r\n### Pros of the proposed format:\r\n- The snapshot report can now be regenerated from the snapshot file.\r\n    - Enables the use of test selection mechanisms during `--update-snapshots`\r\n    - Allows snapshot reports to be kept always in order, rather than the previous approach of appending changes at the end.\r\n    - Prerequisite for any feature that edits snapshots without overwriting them entirely.\r\n- AVA now maintains less byte-manipulation code\r\n- The snapshot format is easier (though not trivial, because of the gzipping and the header) for third-parties to read\r\n- Adding new properties either to snapshots, to blocks, or to the file overall should be easy and remain readable by older AVAs (though older AVAs may or may not preserve such unrecognized data when updating the .snap file)\r\n\r\n### Cons of the proposed format:\r\n- AVA can't totally guarantee that the snapshot file format is deterministic; some leeway is given to the CBOR encoder. .snap files might show spurious changes e.g. between minor versions of the CBOR encoder.\r\n- AVA's attack surface is changed. Attackers remain able to submit a malicious .snap file in a pull request, in hope of exploting potential bugs in AVA to exfiltrate repository secrets from CI runs or gain control of developers' machines. The total amount of code exposed to such an attack is significantly increased, and unless we carefully filter the result of CBOR decoding (not currently done), such an attacker can produce unexpected javascript types and values. On the other hand, the binary-parsing code now has rather more eyes on it.\r\n\r\n## Other changes:\r\n\r\n### Frontend:\r\n- Rather than append new tests to the old report, adding new tests without `--update-snaphots` now maintains declaration-order.\r\n- When the snapshot report is changed, tests not touched in that run (e.g. removed tests, tests which no longer use snapshots) are moved to the end of the report, maintaining their previous order among themselves.\r\n\r\n### Edge cases:\r\n- If `--update-snapshots` is passed and the only use of snapshots is in discarded `t.try()` attempts, then the snapshot file is removed. There's no snapshot data to record in this case, so I don't see any reason to keep the file.\r\n- If `t.snapshot.skip(); t.snapshot();` is added at the end of a test, `RangeError` is no longer thrown; instead a \"blank space\" is recorded for the skipped snapshot. This is currently rendered in the snapshot report as `<No Data>`.\r\n- `snapshot-manager` now assumes `Array.prototype.sort` is stable. This is the true in all supported Node versions afaik, and is required by the standard as of ecmascript 2019, but notably is false in node v10. If `Array.prototype.sort` is not stable, the snapshot report order may not be deterministic.\r\n\r\n### Backend:\r\n- The snapshot file is eagerly loaded in the `Runner` constructor, rather than lazily loaded.\r\n     - `Runner` always emits a dependency on its `.snap` file, even in `--update-snapshots` mode and even if no snapshot assertions are performed.\r\n     - In some very narrow edge cases where the snapshot file has a valid version and checksum but unreadable data, this could result in throwing an unhelpful error. AVA@3 only threw such errors if snapshots were actually used.\r\n- Introduces a dependency on `cbor`.\r\n- Removes a dependency on `md5-hex`.\r\n\r\n## TODO:\r\n- [x] Implement a placeholder snapshot format containing the necessary information\r\n- [x] Test that snapshot reports can be regenerated from `.snap` files \r\n- [x] Allow running `--update-snapshots` with `test.skip()`, `t.snapshot.skip()`, `test.only()`, `--match`, line number selection\r\n    - [x] Finish testing this\r\n    - [x] Document this\r\n- [x] Refactor & clean up code\r\n    - [x] Ordering data should be collected as-it-happens, like `skipBlock()` and `skipSnapshot()`, not once at load time \r\n    - [x] Now that the snapshot manager has all the information on skipping tests and snapshots, `cleanSnapshots()` fits more naturally as part of `Manager#save()`. But,\r\n    - [x] The above requires that the snapshot manager exist when not used, which conflicts with `Runner`'s lazy-loading behavior, which in turn is relied on by existing `Runner` unit-test suites.\r\n    - [x] Remove code for handling `cannotSave` events\r\n- [x] Debug the performance issues somehow. Are they caused by this PR or preexisting? Are they specific to CI, specific to temp dirs, or neither?\r\n    - Tests were just spawning too many processes in CI. Fixed.\r\n- [x] Finalize the snapshot file format",
    "reactions": {
      "url": "https://api.github.com/repos/avajs/ava/issues/2685/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/avajs/ava/issues/2685/timeline",
    "performed_via_github_app": null,
    "state_reason": null,
    "score": 1,
    "files": [
      {
        "sha": "5dbb7a730a4985b483b5c82af06e9bbc26b37d62",
        "filename": "docs/01-writing-tests.md",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/docs%2F01-writing-tests.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/docs%2F01-writing-tests.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/docs%2F01-writing-tests.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -120,7 +120,7 @@ You can use the `.only` modifier with all tests. It cannot be used with hooks or\n \n *Note:* The `.only` modifier applies to the test file it's defined in, so if you run multiple test files, tests in other files will still run. If you want to only run the `test.only` test, provide just that test file to AVA.\n \n-You cannot update snapshots when using `.only()`.\n+In AVA 3, you cannot update snapshots when using `.only()`.\n \n ## Skipping tests\n \n@@ -134,7 +134,9 @@ test.skip('will not be run', t => {\n \n You must specify the implementation function. You can use the `.skip` modifier with all tests and hooks, but not with `.todo()`. You can not apply further modifiers to `.skip`.\n \n-You cannot update snapshots when using `.skip()`. If the test is likely to be failing for a while, use `.failing()` instead.\n+If the test is likely to be failing for a while, use `.failing()` instead.\n+\n+In AVA 3, you cannot update snapshots when using `.skip()`.\n \n ## Test placeholders (\"todo\")\n "
      },
      {
        "sha": "0246647b48bf148ecee0d31dc20760d9504631e7",
        "filename": "docs/03-assertions.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/docs%2F03-assertions.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/docs%2F03-assertions.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/docs%2F03-assertions.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -337,7 +337,7 @@ Compares the `expected` value with a previously recorded snapshot. Snapshots are\n \n AVA 3 supports an  `options` object that lets you select a specific snapshot, for instance `{id: 'my snapshot'}`. This is buggy and will be removed in AVA 4.\n \n-Snapshot assertions cannot be skipped when snapshots are being updated.\n+In AVA 3, you cannot update snapshots while using `t.snapshot.skip()`.\n \n ### `.try(title?, implementation | macro | macro[], ...args?)`\n "
      },
      {
        "sha": "ca6fc979bdee389044bf3a37073ab97d8336dbcc",
        "filename": "docs/04-snapshot-testing.md",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/docs%2F04-snapshot-testing.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/docs%2F04-snapshot-testing.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/docs%2F04-snapshot-testing.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -44,6 +44,8 @@ You can then check your code. If the change was intentional you can use the `--u\n $ ava --update-snapshots\n ```\n \n+In AVA 4, if you need to update snapshots for only a particular test, you can use `--update-snapshots` together with e.g. `--match` or `.only()` to select the test.\n+\n You can specify a fixed location for storing the snapshot files in AVA's [`package.json` configuration](./06-configuration.md):\n \n **`package.json`:**"
      },
      {
        "sha": "7c3a9cd70a739ceba67b47302c5470437f190c19",
        "filename": "lib/cli.js",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/lib%2Fcli.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/lib%2Fcli.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fcli.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -210,10 +210,6 @@ exports.run = async () => { // eslint-disable-line complexity\n \tconst chalkOptions = {level: combined.color === false ? 0 : require('chalk').level};\n \tconst chalk = require('./chalk').set(chalkOptions);\n \n-\tif (combined.updateSnapshots && combined.match) {\n-\t\texit('Snapshots cannot be updated when matching specific tests.');\n-\t}\n-\n \tif (confError) {\n \t\tif (confError.parent) {\n \t\t\texit(`${confError.message}\\n\\n${chalk.gray((confError.parent && confError.parent.stack) || confError.parent)}`);\n@@ -390,9 +386,6 @@ exports.run = async () => { // eslint-disable-line complexity\n \t\t\tpattern: normalizePattern(path.relative(projectDir, path.resolve(process.cwd(), pattern))),\n \t\t\t...rest\n \t\t}));\n-\tif (combined.updateSnapshots && filter.some(condition => condition.lineNumbers !== null)) {\n-\t\texit('Snapshots cannot be updated when selecting specific tests by their line number.');\n-\t}\n \n \tconst api = new Api({\n \t\tcacheEnabled: combined.cache !== false,"
      },
      {
        "sha": "3caf0d1a575c8a4da2957d3cde37b5f97ee89232",
        "filename": "lib/reporters/default.js",
        "status": "modified",
        "additions": 0,
        "deletions": 15,
        "changes": 15,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/lib%2Freporters%2Fdefault.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/lib%2Freporters%2Fdefault.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Fdefault.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -198,7 +198,6 @@ class Reporter {\n \t\tthis.sharedWorkerErrors = [];\n \t\tthis.uncaughtExceptions = [];\n \t\tthis.unhandledRejections = [];\n-\t\tthis.unsavedSnapshots = [];\n \n \t\tthis.previousFailures = 0;\n \n@@ -354,10 +353,6 @@ class Reporter {\n \t\t\t\tbreak;\n \t\t\t}\n \n-\t\t\tcase 'snapshot-error':\n-\t\t\t\tthis.unsavedSnapshots.push(event);\n-\t\t\t\tbreak;\n-\n \t\t\tcase 'uncaught-exception': {\n \t\t\t\tthis.uncaughtExceptions.push(event);\n \n@@ -825,16 +820,6 @@ class Reporter {\n \t\t\t}\n \t\t}\n \n-\t\tif (this.unsavedSnapshots.length > 0) {\n-\t\t\tthis.lineWriter.writeLine(colors.title('Could not update snapshots for the following test files:'));\n-\t\t\tthis.lineWriter.writeLine();\n-\t\t\tfor (const event of this.unsavedSnapshots) {\n-\t\t\t\tthis.lineWriter.writeLine(`${figures.warning} ${this.relativeFile(event.testFile)}`);\n-\t\t\t}\n-\n-\t\t\tthis.lineWriter.writeLine();\n-\t\t}\n-\n \t\tif (this.failFastEnabled && (this.stats.remainingTests > 0 || this.stats.files > this.stats.finishedWorkers)) {\n \t\t\tlet remaining = '';\n \t\t\tif (this.stats.remainingTests > 0) {"
      },
      {
        "sha": "8520412dd1769349fe8d7bfecd67a022617355c3",
        "filename": "lib/reporters/tap.js",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/lib%2Freporters%2Ftap.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/lib%2Freporters%2Ftap.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Ftap.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -165,9 +165,6 @@ class TapReporter {\n \t\t\t\t\tthis.writeTest(evt, {passed: false, todo: true, skip: false});\n \t\t\t\t}\n \n-\t\t\t\tbreak;\n-\t\t\tcase 'snapshot-error':\n-\t\t\t\tthis.writeComment(evt, {title: 'Could not update snapshots'});\n \t\t\t\tbreak;\n \t\t\tcase 'stats':\n \t\t\t\tthis.stats = evt.stats;"
      },
      {
        "sha": "d685ebf8c1bf9382481822d0f6c0fb8006499f17",
        "filename": "lib/runner.js",
        "status": "modified",
        "additions": 35,
        "deletions": 59,
        "changes": 94,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/lib%2Frunner.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/lib%2Frunner.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Frunner.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -23,16 +23,24 @@ class Runner extends Emittery {\n \t\tthis.recordNewSnapshots = options.recordNewSnapshots === true;\n \t\tthis.runOnlyExclusive = options.runOnlyExclusive === true;\n \t\tthis.serial = options.serial === true;\n-\t\tthis.skippingTests = false;\n \t\tthis.snapshotDir = options.snapshotDir;\n \t\tthis.updateSnapshots = options.updateSnapshots;\n \n \t\tthis.activeRunnables = new Set();\n \t\tthis.boundCompareTestSnapshot = this.compareTestSnapshot.bind(this);\n-\t\tthis.skippedSnapshots = false;\n \t\tthis.boundSkipSnapshot = this.skipSnapshot.bind(this);\n \t\tthis.interrupted = false;\n-\t\tthis.snapshots = null;\n+\t\tthis.snapshots = snapshotManager.load({\n+\t\t\tfile: this.file,\n+\t\t\tfixedLocation: this.snapshotDir,\n+\t\t\tprojectDir: this.projectDir,\n+\t\t\trecordNewSnapshots: this.recordNewSnapshots,\n+\t\t\tupdating: this.updateSnapshots\n+\t\t});\n+\t\tif (this.snapshots.snapPath !== undefined) {\n+\t\t\tthis.emit('dependency', this.snapshots.snapPath);\n+\t\t}\n+\n \t\tthis.nextTaskIndex = 0;\n \t\tthis.tasks = {\n \t\t\tafter: [],\n@@ -152,15 +160,14 @@ class Runner extends Emittery {\n \t\t\t\t\t\t\ttask.metadata.exclusive = matcher([title], this.match).length === 1;\n \t\t\t\t\t\t}\n \n-\t\t\t\t\t\tif (task.metadata.skipped) {\n-\t\t\t\t\t\t\tthis.skippingTests = true;\n-\t\t\t\t\t\t}\n-\n \t\t\t\t\t\tif (task.metadata.exclusive) {\n \t\t\t\t\t\t\tthis.runOnlyExclusive = true;\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tthis.tasks[metadata.serial ? 'serial' : 'concurrent'].push(task);\n+\n+\t\t\t\t\t\tthis.snapshots.touch(title, metadata.taskIndex);\n+\n \t\t\t\t\t\tthis.emit('stateChange', {\n \t\t\t\t\t\t\ttype: 'declared-test',\n \t\t\t\t\t\t\ttitle,\n@@ -185,49 +192,15 @@ class Runner extends Emittery {\n \t}\n \n \tcompareTestSnapshot(options) {\n-\t\tif (!this.snapshots) {\n-\t\t\tthis.snapshots = snapshotManager.load({\n-\t\t\t\tfile: this.file,\n-\t\t\t\tfixedLocation: this.snapshotDir,\n-\t\t\t\tprojectDir: this.projectDir,\n-\t\t\t\trecordNewSnapshots: this.recordNewSnapshots,\n-\t\t\t\tupdating: this.updateSnapshots && !this.runOnlyExclusive && !this.skippingTests\n-\t\t\t});\n-\t\t\tthis.emit('dependency', this.snapshots.snapPath);\n-\t\t}\n-\n \t\treturn this.snapshots.compare(options);\n \t}\n \n-\tskipSnapshot() {\n-\t\tthis.skippedSnapshots = true;\n+\tskipSnapshot(options) {\n+\t\treturn this.snapshots.skipSnapshot(options);\n \t}\n \n \tsaveSnapshotState() {\n-\t\tif (\n-\t\t\tthis.updateSnapshots &&\n-\t\t\t(\n-\t\t\t\tthis.runOnlyExclusive ||\n-\t\t\t\tthis.skippingTests ||\n-\t\t\t\tthis.skippedSnapshots\n-\t\t\t)\n-\t\t) {\n-\t\t\treturn {cannotSave: true};\n-\t\t}\n-\n-\t\tif (this.snapshots) {\n-\t\t\treturn {touchedFiles: this.snapshots.save()};\n-\t\t}\n-\n-\t\tif (this.updateSnapshots) {\n-\t\t\treturn {touchedFiles: snapshotManager.cleanSnapshots({\n-\t\t\t\tfile: this.file,\n-\t\t\t\tfixedLocation: this.snapshotDir,\n-\t\t\t\tprojectDir: this.projectDir\n-\t\t\t})};\n-\t\t}\n-\n-\t\treturn {};\n+\t\treturn {touchedFiles: this.snapshots.save()};\n \t}\n \n \tonRun(runnable) {\n@@ -301,7 +274,7 @@ class Runner extends Emittery {\n \t\treturn result;\n \t}\n \n-\tasync runHooks(tasks, contextRef, {titleSuffix, testPassed, associatedTaskIndex} = {}) {\n+\tasync runHooks(tasks, contextRef, {titleSuffix, testPassed} = {}) {\n \t\tconst hooks = tasks.map(task => new Runnable({\n \t\t\tcontextRef,\n \t\t\texperiments: this.experiments,\n@@ -312,7 +285,7 @@ class Runner extends Emittery {\n \t\t\tcompareTestSnapshot: this.boundCompareTestSnapshot,\n \t\t\tskipSnapshot: this.boundSkipSnapshot,\n \t\t\tupdateSnapshots: this.updateSnapshots,\n-\t\t\tmetadata: {...task.metadata, associatedTaskIndex},\n+\t\t\tmetadata: task.metadata,\n \t\t\tpowerAssert: this.powerAssert,\n \t\t\ttitle: `${task.title}${titleSuffix || ''}`,\n \t\t\tisHook: true,\n@@ -347,8 +320,7 @@ class Runner extends Emittery {\n \t\t\tthis.tasks.beforeEach,\n \t\t\tcontextRef,\n \t\t\t{\n-\t\t\t\ttitleSuffix: hookSuffix,\n-\t\t\t\tassociatedTaskIndex: task.metadata.taskIndex\n+\t\t\t\ttitleSuffix: hookSuffix\n \t\t\t}\n \t\t);\n \n@@ -388,8 +360,7 @@ class Runner extends Emittery {\n \t\t\t\t\tcontextRef,\n \t\t\t\t\t{\n \t\t\t\t\t\ttitleSuffix: hookSuffix,\n-\t\t\t\t\t\ttestPassed: testOk,\n-\t\t\t\t\t\tassociatedTaskIndex: task.metadata.taskIndex\n+\t\t\t\t\t\ttestPassed: testOk\n \t\t\t\t\t});\n \t\t\t} else {\n \t\t\t\tthis.emit('stateChange', {\n@@ -409,8 +380,7 @@ class Runner extends Emittery {\n \t\t\tcontextRef,\n \t\t\t{\n \t\t\t\ttitleSuffix: hookSuffix,\n-\t\t\t\ttestPassed: testOk,\n-\t\t\t\tassociatedTaskIndex: task.metadata.taskIndex\n+\t\t\t\ttestPassed: testOk\n \t\t\t});\n \t\treturn alwaysOk && hooksOk && testOk;\n \t}\n@@ -420,10 +390,12 @@ class Runner extends Emittery {\n \t\tconst serialTests = [];\n \t\tfor (const task of this.tasks.serial) {\n \t\t\tif (this.runOnlyExclusive && !task.metadata.exclusive) {\n+\t\t\t\tthis.snapshots.skipBlock(task.title, task.metadata.taskIndex);\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tif (this.checkSelectedByLineNumbers && !task.metadata.selected) {\n+\t\t\t\tthis.snapshots.skipBlock(task.title, task.metadata.taskIndex);\n \t\t\t\tcontinue;\n \t\t\t}\n \n@@ -435,17 +407,21 @@ class Runner extends Emittery {\n \t\t\t\ttodo: false\n \t\t\t});\n \n-\t\t\tif (!task.metadata.skipped) {\n+\t\t\tif (task.metadata.skipped) {\n+\t\t\t\tthis.snapshots.skipBlock(task.title, task.metadata.taskIndex);\n+\t\t\t} else {\n \t\t\t\tserialTests.push(task);\n \t\t\t}\n \t\t}\n \n \t\tfor (const task of this.tasks.concurrent) {\n \t\t\tif (this.runOnlyExclusive && !task.metadata.exclusive) {\n+\t\t\t\tthis.snapshots.skipBlock(task.title, task.metadata.taskIndex);\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tif (this.checkSelectedByLineNumbers && !task.metadata.selected) {\n+\t\t\t\tthis.snapshots.skipBlock(task.title, task.metadata.taskIndex);\n \t\t\t\tcontinue;\n \t\t\t}\n \n@@ -457,12 +433,12 @@ class Runner extends Emittery {\n \t\t\t\ttodo: false\n \t\t\t});\n \n-\t\t\tif (!task.metadata.skipped) {\n-\t\t\t\tif (this.serial) {\n-\t\t\t\t\tserialTests.push(task);\n-\t\t\t\t} else {\n-\t\t\t\t\tconcurrentTests.push(task);\n-\t\t\t\t}\n+\t\t\tif (task.metadata.skipped) {\n+\t\t\t\tthis.snapshots.skipBlock(task.title, task.metadata.taskIndex);\n+\t\t\t} else if (this.serial) {\n+\t\t\t\tserialTests.push(task);\n+\t\t\t} else {\n+\t\t\t\tconcurrentTests.push(task);\n \t\t\t}\n \t\t}\n "
      },
      {
        "sha": "a64d387d6d63ffd7c5bffdc67352a097dd756a4e",
        "filename": "lib/snapshot-manager.js",
        "status": "modified",
        "additions": 223,
        "deletions": 246,
        "changes": 469,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/lib%2Fsnapshot-manager.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/lib%2Fsnapshot-manager.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fsnapshot-manager.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -7,18 +7,18 @@ const zlib = require('zlib');\n \n const concordance = require('concordance');\n const indentString = require('indent-string');\n-const md5Hex = require('md5-hex');\n const convertSourceMap = require('convert-source-map');\n const slash = require('slash');\n const writeFileAtomic = require('write-file-atomic');\n const mem = require('mem');\n+const cbor = require('cbor');\n \n const concordanceOptions = require('./concordance-options').snapshotManager;\n \n // Increment if encoding layout or Concordance serialization versions change. Previous AVA versions will not be able to\n // decode buffers generated by a newer version, so changing this value will require a major version bump of AVA itself.\n // The version is encoded as an unsigned 16 bit integer.\n-const VERSION = 2;\n+const VERSION = 3;\n \n const VERSION_HEADER = Buffer.alloc(2);\n VERSION_HEADER.writeUInt16LE(VERSION);\n@@ -28,7 +28,7 @@ const READABLE_PREFIX = Buffer.from(`AVA Snapshot v${VERSION}\\n`, 'ascii');\n const REPORT_SEPARATOR = Buffer.from('\\n\\n', 'ascii');\n const REPORT_TRAILING_NEWLINE = Buffer.from('\\n', 'ascii');\n \n-const MD5_HASH_LENGTH = 16;\n+const SHA_256_HASH_LENGTH = 32;\n \n class SnapshotError extends Error {\n \tconstructor(message, snapPath) {\n@@ -82,168 +82,115 @@ function tryRead(file) {\n \t}\n }\n \n-function withoutLineEndings(buffer) {\n-\tlet checkPosition = buffer.byteLength - 1;\n-\twhile (buffer[checkPosition] === 0x0A || buffer[checkPosition] === 0x0D) {\n-\t\tcheckPosition--;\n-\t}\n-\n-\treturn buffer.slice(0, checkPosition + 1);\n-}\n+function formatEntry(snapshot, index) {\n+\tconst {\n+\t\tdata,\n+\t\tlabel = `Snapshot ${index + 1}` // Human-readable labels start counting at 1.\n+\t} = snapshot;\n \n-function formatEntry(label, descriptor) {\n-\tif (label) {\n-\t\tlabel = `> ${label}\\n\\n`;\n-\t}\n+\tconst description = data ?\n+\t\tconcordance.formatDescriptor(concordance.deserialize(data), concordanceOptions) :\n+\t\t'<No Data>';\n \n-\tconst codeBlock = indentString(concordance.formatDescriptor(descriptor, concordanceOptions), 4);\n-\treturn Buffer.from(label + codeBlock, 'utf8');\n+\treturn `> ${label}\\n\\n${indentString(description, 4)}`;\n }\n \n-function combineEntries(entries) {\n-\tconst buffers = [];\n-\tlet byteLength = 0;\n-\n-\tconst sortedKeys = [...entries.keys()].sort((keyA, keyB) => {\n-\t\tconst [a, b] = [entries.get(keyA), entries.get(keyB)];\n-\t\tconst taskDifference = a.taskIndex - b.taskIndex;\n+function combineEntries({blocks}) {\n+\tconst combined = new BufferBuilder();\n \n-\t\tif (taskDifference !== 0) {\n-\t\t\treturn taskDifference;\n-\t\t}\n+\tfor (const {title, snapshots} of blocks) {\n+\t\tconst last = snapshots[snapshots.length - 1];\n+\t\tcombined.write(`\\n\\n## ${title}\\n\\n`);\n \n-\t\tconst [assocA, assocB] = [a.associatedTaskIndex, b.associatedTaskIndex];\n-\t\tif (assocA !== undefined && assocB !== undefined) {\n-\t\t\tconst assocDifference = assocA - assocB;\n+\t\tfor (const [index, snapshot] of snapshots.entries()) {\n+\t\t\tcombined.write(formatEntry(snapshot, index));\n \n-\t\t\tif (assocDifference !== 0) {\n-\t\t\t\treturn assocDifference;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn a.snapIndex - b.snapIndex;\n-\t});\n-\n-\tfor (const key of sortedKeys) {\n-\t\tconst keyBuffer = Buffer.from(`\\n\\n## ${key}\\n\\n`, 'utf8');\n-\t\tbuffers.push(keyBuffer);\n-\t\tbyteLength += keyBuffer.byteLength;\n-\n-\t\tconst formattedEntries = entries.get(key).buffers;\n-\t\tconst last = formattedEntries[formattedEntries.length - 1];\n-\t\tfor (const entry of formattedEntries) {\n-\t\t\tbuffers.push(entry);\n-\t\t\tbyteLength += entry.byteLength;\n-\n-\t\t\tif (entry !== last) {\n-\t\t\t\tbuffers.push(REPORT_SEPARATOR);\n-\t\t\t\tbyteLength += REPORT_SEPARATOR.byteLength;\n+\t\t\tif (snapshot !== last) {\n+\t\t\t\tcombined.write(REPORT_SEPARATOR);\n \t\t\t}\n \t\t}\n \t}\n \n-\treturn {buffers, byteLength};\n+\treturn combined;\n }\n \n-function generateReport(relFile, snapFile, entries) {\n-\tconst combined = combineEntries(entries);\n-\tconst {buffers} = combined;\n-\tlet {byteLength} = combined;\n-\n-\tconst header = Buffer.from(`# Snapshot report for \\`${slash(relFile)}\\`\n+function generateReport(relFile, snapFile, snapshots) {\n+\treturn new BufferBuilder()\n+\t\t.write(`# Snapshot report for \\`${slash(relFile)}\\`\n \n The actual snapshot is saved in \\`${snapFile}\\`.\n \n-Generated by [AVA](https://avajs.dev).`, 'utf8');\n-\tbuffers.unshift(header);\n-\tbyteLength += header.byteLength;\n-\n-\tbuffers.push(REPORT_TRAILING_NEWLINE);\n-\tbyteLength += REPORT_TRAILING_NEWLINE.byteLength;\n-\treturn Buffer.concat(buffers, byteLength);\n+Generated by [AVA](https://avajs.dev).`)\n+\t\t.append(combineEntries(snapshots))\n+\t\t.write(REPORT_TRAILING_NEWLINE)\n+\t\t.toBuffer();\n }\n \n-function appendReportEntries(existingReport, entries) {\n-\tconst combined = combineEntries(entries);\n-\tconst {buffers} = combined;\n-\tlet {byteLength} = combined;\n-\n-\tconst prepend = withoutLineEndings(existingReport);\n-\tbuffers.unshift(prepend);\n-\tbyteLength += prepend.byteLength;\n+class BufferBuilder {\n+\tconstructor() {\n+\t\tthis.buffers = [];\n+\t\tthis.byteOffset = 0;\n+\t}\n \n-\tbuffers.push(REPORT_TRAILING_NEWLINE);\n-\tbyteLength += REPORT_TRAILING_NEWLINE.byteLength;\n-\treturn Buffer.concat(buffers, byteLength);\n-}\n+\tappend(builder) {\n+\t\tthis.buffers.push(...builder.buffers);\n+\t\tthis.byteOffset += builder.byteOffset;\n+\t\treturn this;\n+\t}\n \n-function encodeSnapshots(buffersByHash) {\n-\tconst buffers = [];\n-\tlet byteOffset = 0;\n-\n-\t// Entry start and end pointers are relative to the header length. This means\n-\t// it's possible to append new entries to an existing snapshot file, without\n-\t// having to rewrite pointers for existing entries.\n-\tconst headerLength = Buffer.alloc(4);\n-\tbuffers.push(headerLength);\n-\tbyteOffset += 4;\n-\n-\t// Allows 65535 hashes (tests or identified snapshots) per file.\n-\tconst numberHashes = Buffer.alloc(2);\n-\tnumberHashes.writeUInt16LE(buffersByHash.size);\n-\tbuffers.push(numberHashes);\n-\tbyteOffset += 2;\n-\n-\tconst entries = [];\n-\t// Maps can't have duplicate keys, so all items in [...buffersByHash.keys()]\n-\t// are unique, so sortedHashes should be deterministic.\n-\tconst sortedHashes = [...buffersByHash.keys()].sort();\n-\tconst sortedBuffersByHash = [...sortedHashes.map(hash => [hash, buffersByHash.get(hash)])];\n-\tfor (const [hash, snapshotBuffers] of sortedBuffersByHash) {\n-\t\tbuffers.push(Buffer.from(hash, 'hex'));\n-\t\tbyteOffset += MD5_HASH_LENGTH;\n-\n-\t\t// Allows 65535 snapshots per hash.\n-\t\tconst numberSnapshots = Buffer.alloc(2);\n-\t\tnumberSnapshots.writeUInt16LE(snapshotBuffers.length, 0);\n-\t\tbuffers.push(numberSnapshots);\n-\t\tbyteOffset += 2;\n-\n-\t\tfor (const value of snapshotBuffers) {\n-\t\t\t// Each pointer is 32 bits, restricting the total, uncompressed buffer to\n-\t\t\t// 4 GiB.\n-\t\t\tconst start = Buffer.alloc(4);\n-\t\t\tconst end = Buffer.alloc(4);\n-\t\t\tentries.push({start, end, value});\n-\n-\t\t\tbuffers.push(start, end);\n-\t\t\tbyteOffset += 8;\n+\twrite(data) {\n+\t\tif (typeof data === 'string') {\n+\t\t\tthis.write(Buffer.from(data, 'utf8'));\n+\t\t} else {\n+\t\t\tthis.buffers.push(data);\n+\t\t\tthis.byteOffset += data.byteLength;\n \t\t}\n-\t}\n \n-\theaderLength.writeUInt32LE(byteOffset, 0);\n+\t\treturn this;\n+\t}\n \n-\tlet bodyOffset = 0;\n-\tfor (const entry of entries) {\n-\t\tconst start = bodyOffset;\n-\t\tconst end = bodyOffset + entry.value.byteLength;\n-\t\tentry.start.writeUInt32LE(start, 0);\n-\t\tentry.end.writeUInt32LE(end, 0);\n-\t\tbuffers.push(entry.value);\n-\t\tbodyOffset = end;\n+\ttoBuffer() {\n+\t\treturn Buffer.concat(this.buffers, this.byteOffset);\n \t}\n+}\n \n-\tbyteOffset += bodyOffset;\n+function sortBlocks(blocksByTitle, blockIndices) {\n+\treturn [...blocksByTitle].sort(\n+\t\t([aTitle], [bTitle]) => {\n+\t\t\tconst a = blockIndices.get(aTitle);\n+\t\t\tconst b = blockIndices.get(bTitle);\n \n-\tconst compressed = zlib.gzipSync(Buffer.concat(buffers, byteOffset));\n+\t\t\tif (a === undefined) {\n+\t\t\t\tif (b === undefined) {\n+\t\t\t\t\treturn 0;\n+\t\t\t\t}\n+\n+\t\t\t\treturn 1;\n+\t\t\t}\n+\n+\t\t\tif (b === undefined) {\n+\t\t\t\treturn -1;\n+\t\t\t}\n+\n+\t\t\treturn a - b;\n+\t\t}\n+\t);\n+}\n+\n+function encodeSnapshots(snapshotData) {\n+\tconst encoded = cbor.encodeOne(snapshotData, {\n+\t\tomitUndefinedProperties: true,\n+\t\tcanonical: true\n+\t});\n+\tconst compressed = zlib.gzipSync(encoded);\n \tcompressed[9] = 0x03; // Override the GZip header containing the OS to always be Linux\n-\tconst md5sum = crypto.createHash('md5').update(compressed).digest();\n+\tconst sha256sum = crypto.createHash('sha256').update(compressed).digest();\n \treturn Buffer.concat([\n \t\tREADABLE_PREFIX,\n \t\tVERSION_HEADER,\n-\t\tmd5sum,\n+\t\tsha256sum,\n \t\tcompressed\n-\t], READABLE_PREFIX.byteLength + VERSION_HEADER.byteLength + MD5_HASH_LENGTH + compressed.byteLength);\n+\t], READABLE_PREFIX.byteLength + VERSION_HEADER.byteLength + SHA_256_HASH_LENGTH + compressed.byteLength);\n }\n \n function decodeSnapshots(buffer, snapPath) {\n@@ -259,148 +206,165 @@ function decodeSnapshots(buffer, snapPath) {\n \t\tthrow new VersionMismatchError(snapPath, version);\n \t}\n \n-\tconst md5sumOffset = versionOffset + 2;\n-\tconst compressedOffset = md5sumOffset + MD5_HASH_LENGTH;\n+\tconst sha256sumOffset = versionOffset + 2;\n+\tconst compressedOffset = sha256sumOffset + SHA_256_HASH_LENGTH;\n \tconst compressed = buffer.slice(compressedOffset);\n \n-\tconst md5sum = crypto.createHash('md5').update(compressed).digest();\n-\tconst expectedSum = buffer.slice(md5sumOffset, compressedOffset);\n-\tif (!md5sum.equals(expectedSum)) {\n+\tconst sha256sum = crypto.createHash('sha256').update(compressed).digest();\n+\tconst expectedSum = buffer.slice(sha256sumOffset, compressedOffset);\n+\tif (!sha256sum.equals(expectedSum)) {\n \t\tthrow new ChecksumError(snapPath);\n \t}\n \n \tconst decompressed = zlib.gunzipSync(compressed);\n-\tlet byteOffset = 0;\n-\n-\tconst headerLength = decompressed.readUInt32LE(byteOffset);\n-\tbyteOffset += 4;\n-\n-\tconst snapshotsByHash = new Map();\n-\tconst numberHashes = decompressed.readUInt16LE(byteOffset);\n-\tbyteOffset += 2;\n-\n-\tfor (let count = 0; count < numberHashes; count++) {\n-\t\tconst hash = decompressed.toString('hex', byteOffset, byteOffset + MD5_HASH_LENGTH);\n-\t\tbyteOffset += MD5_HASH_LENGTH;\n-\n-\t\tconst numberSnapshots = decompressed.readUInt16LE(byteOffset);\n-\t\tbyteOffset += 2;\n-\n-\t\tconst snapshotsBuffers = new Array(numberSnapshots);\n-\t\tfor (let index = 0; index < numberSnapshots; index++) {\n-\t\t\tconst start = decompressed.readUInt32LE(byteOffset) + headerLength;\n-\t\t\tbyteOffset += 4;\n-\t\t\tconst end = decompressed.readUInt32LE(byteOffset) + headerLength;\n-\t\t\tbyteOffset += 4;\n-\t\t\tsnapshotsBuffers[index] = decompressed.slice(start, end);\n-\t\t}\n-\n-\t\t// Allow for new entries to be appended to an existing header, which could\n-\t\t// lead to the same hash being present multiple times.\n-\t\tif (snapshotsByHash.has(hash)) {\n-\t\t\tsnapshotsByHash.set(hash, snapshotsByHash.get(hash).concat(snapshotsBuffers));\n-\t\t} else {\n-\t\t\tsnapshotsByHash.set(hash, snapshotsBuffers);\n-\t\t}\n-\t}\n-\n-\treturn snapshotsByHash;\n+\treturn cbor.decode(decompressed);\n }\n \n class Manager {\n \tconstructor(options) {\n-\t\tthis.appendOnly = options.appendOnly;\n \t\tthis.dir = options.dir;\n \t\tthis.recordNewSnapshots = options.recordNewSnapshots;\n+\t\tthis.updating = options.updating;\n \t\tthis.relFile = options.relFile;\n \t\tthis.reportFile = options.reportFile;\n+\t\tthis.reportPath = options.reportPath;\n \t\tthis.snapFile = options.snapFile;\n \t\tthis.snapPath = options.snapPath;\n-\t\tthis.snapshotsByHash = options.snapshotsByHash;\n+\t\tthis.oldBlocksByTitle = options.oldBlocksByTitle;\n+\t\tthis.newBlocksByTitle = options.newBlocksByTitle;\n+\t\tthis.blockIndices = new Map();\n+\t\tthis.error = options.error;\n \n \t\tthis.hasChanges = false;\n-\t\tthis.reportEntries = new Map();\n+\t}\n+\n+\ttouch(title, taskIndex) {\n+\t\tthis.blockIndices.set(title, taskIndex);\n \t}\n \n \tcompare(options) {\n-\t\tconst hash = md5Hex(options.belongsTo);\n-\t\tconst entries = this.snapshotsByHash.get(hash) || [];\n-\t\tconst snapshotBuffer = entries[options.index];\n+\t\tif (this.error) {\n+\t\t\tthrow this.error;\n+\t\t}\n \n-\t\tif (!snapshotBuffer) {\n+\t\tconst block = this.newBlocksByTitle.get(options.belongsTo);\n+\n+\t\tconst snapshot = block && block.snapshots[options.index];\n+\t\tconst data = snapshot && snapshot.data;\n+\n+\t\tif (!data) {\n \t\t\tif (!this.recordNewSnapshots) {\n \t\t\t\treturn {pass: false};\n \t\t\t}\n \n \t\t\tif (options.deferRecording) {\n-\t\t\t\tconst record = this.deferRecord(hash, options);\n+\t\t\t\tconst record = this.deferRecord(options);\n \t\t\t\treturn {pass: true, record};\n \t\t\t}\n \n-\t\t\tthis.record(hash, options);\n+\t\t\tthis.record(options);\n \t\t\treturn {pass: true};\n \t\t}\n \n-\t\tconst actual = concordance.deserialize(snapshotBuffer, concordanceOptions);\n+\t\tconst actual = concordance.deserialize(data, concordanceOptions);\n \t\tconst expected = concordance.describe(options.expected, concordanceOptions);\n \t\tconst pass = concordance.compareDescriptors(actual, expected);\n \n \t\treturn {actual, expected, pass};\n \t}\n \n-\tdeferRecord(hash, options) {\n-\t\tconst descriptor = concordance.describe(options.expected, concordanceOptions);\n-\t\tconst snapshot = concordance.serialize(descriptor);\n-\t\tconst entry = formatEntry(options.label, descriptor);\n-\t\tconst {taskIndex, snapIndex, associatedTaskIndex} = options;\n+\trecordSerialized({data, label, belongsTo, index}) {\n+\t\tlet block = this.newBlocksByTitle.get(belongsTo);\n+\t\tif (!block) {\n+\t\t\tblock = {snapshots: []};\n+\t\t}\n \n-\t\treturn () => { // Must be called in order!\n-\t\t\tthis.hasChanges = true;\n+\t\tconst {snapshots} = block;\n \n-\t\t\tlet snapshots = this.snapshotsByHash.get(hash);\n-\t\t\tif (!snapshots) {\n-\t\t\t\tsnapshots = [];\n-\t\t\t\tthis.snapshotsByHash.set(hash, snapshots);\n+\t\tif (index > snapshots.length) {\n+\t\t\tthrow new RangeError(`Cannot record snapshot ${index} for ${JSON.stringify(belongsTo)}, exceeds expected index of ${snapshots.length}`);\n+\t\t} else if (index < snapshots.length) {\n+\t\t\tif (snapshots[index].data) {\n+\t\t\t\tthrow new RangeError(`Cannot record snapshot ${index} for ${JSON.stringify(belongsTo)}, already exists`);\n \t\t\t}\n \n-\t\t\tif (options.index > snapshots.length) {\n-\t\t\t\tthrow new RangeError(`Cannot record snapshot ${options.index} for ${JSON.stringify(options.belongsTo)}, exceeds expected index of ${snapshots.length}`);\n-\t\t\t}\n+\t\t\tsnapshots[index] = {data, label};\n+\t\t} else {\n+\t\t\tsnapshots.push({data, label});\n+\t\t}\n \n-\t\t\tif (options.index < snapshots.length) {\n-\t\t\t\tthrow new RangeError(`Cannot record snapshot ${options.index} for ${JSON.stringify(options.belongsTo)}, already exists`);\n-\t\t\t}\n+\t\tthis.newBlocksByTitle.set(belongsTo, block);\n+\t}\n \n-\t\t\tsnapshots.push(snapshot);\n+\tdeferRecord(options) {\n+\t\tconst {expected, belongsTo, label, index} = options;\n+\t\tconst descriptor = concordance.describe(expected, concordanceOptions);\n+\t\tconst data = concordance.serialize(descriptor);\n \n-\t\t\tif (this.reportEntries.has(options.belongsTo)) {\n-\t\t\t\tthis.reportEntries.get(options.belongsTo).buffers.push(entry);\n-\t\t\t} else {\n-\t\t\t\tthis.reportEntries.set(options.belongsTo, {buffers: [entry], taskIndex, snapIndex, associatedTaskIndex});\n-\t\t\t}\n+\t\treturn () => { // Must be called in order!\n+\t\t\tthis.hasChanges = true;\n+\t\t\tthis.recordSerialized({data, label, belongsTo, index});\n \t\t};\n \t}\n \n-\trecord(hash, options) {\n-\t\tconst record = this.deferRecord(hash, options);\n+\trecord(options) {\n+\t\tconst record = this.deferRecord(options);\n \t\trecord();\n \t}\n \n+\tskipBlock(title) {\n+\t\tconst block = this.oldBlocksByTitle.get(title);\n+\n+\t\tif (block) {\n+\t\t\tthis.newBlocksByTitle.set(title, block);\n+\t\t}\n+\t}\n+\n+\tskipSnapshot({belongsTo, index, deferRecording}) {\n+\t\tconst oldBlock = this.oldBlocksByTitle.get(belongsTo);\n+\t\tlet snapshot = oldBlock && oldBlock.snapshots[index];\n+\n+\t\tif (!snapshot) {\n+\t\t\tsnapshot = {};\n+\t\t}\n+\n+\t\t// Retain the label from the old snapshot, so as not to assume that the\n+\t\t// snapshot.skip() arguments are well-formed.\n+\n+\t\t// Defer recording if called in a try().\n+\t\tif (deferRecording) {\n+\t\t\treturn () => { // Must be called in order!\n+\t\t\t\tthis.recordSerialized({belongsTo, index, ...snapshot});\n+\t\t\t};\n+\t\t}\n+\n+\t\tthis.recordSerialized({belongsTo, index, ...snapshot});\n+\t}\n+\n \tsave() {\n+\t\tconst {dir, relFile, snapFile, snapPath, reportPath} = this;\n+\n+\t\tif (this.updating && this.newBlocksByTitle.size === 0) {\n+\t\t\treturn [\n+\t\t\t\t...cleanFile(snapPath),\n+\t\t\t\t...cleanFile(reportPath)\n+\t\t\t];\n+\t\t}\n+\n \t\tif (!this.hasChanges) {\n \t\t\treturn null;\n \t\t}\n \n-\t\tconst {snapPath} = this;\n-\t\tconst buffer = encodeSnapshots(this.snapshotsByHash);\n+\t\tconst snapshots = {\n+\t\t\tblocks: sortBlocks(this.newBlocksByTitle, this.blockIndices).map(\n+\t\t\t\t([title, block]) => ({title, ...block})\n+\t\t\t)\n+\t\t};\n \n-\t\tconst reportPath = path.join(this.dir, this.reportFile);\n-\t\tconst existingReport = this.appendOnly ? tryRead(reportPath) : null;\n-\t\tconst reportBuffer = existingReport ?\n-\t\t\tappendReportEntries(existingReport, this.reportEntries) :\n-\t\t\tgenerateReport(this.relFile, this.snapFile, this.reportEntries);\n+\t\tconst buffer = encodeSnapshots(snapshots);\n+\t\tconst reportBuffer = generateReport(relFile, snapFile, snapshots);\n \n-\t\tfs.mkdirSync(this.dir, {recursive: true});\n+\t\tfs.mkdirSync(dir, {recursive: true});\n \n \t\tconst paths = [snapPath, reportPath];\n \t\tconst tmpfileCreated = tmpfile => paths.push(tmpfile);\n@@ -460,7 +424,9 @@ function determineSnapshotPaths({file, fixedLocation, projectDir}) {\n \t\tdir,\n \t\trelFile,\n \t\tsnapFile,\n-\t\treportFile\n+\t\treportFile,\n+\t\tsnapPath: path.join(dir, snapFile),\n+\t\treportPath: path.join(dir, reportFile)\n \t};\n }\n \n@@ -477,44 +443,55 @@ function cleanFile(file) {\n \t}\n }\n \n-// Remove snapshot and report if they exist. Returns an array containing the\n-// paths of the touched files.\n-function cleanSnapshots({file, fixedLocation, projectDir}) {\n-\tconst {dir, snapFile, reportFile} = determineSnapshotPaths({file, fixedLocation, projectDir});\n+function load({file, fixedLocation, projectDir, recordNewSnapshots, updating}) {\n+\t// Keep runner unit tests that use `new Runner()` happy\n+\tif (file === undefined || projectDir === undefined) {\n+\t\treturn new Manager({\n+\t\t\trecordNewSnapshots,\n+\t\t\tupdating,\n+\t\t\toldBlocksByTitle: new Map(),\n+\t\t\tnewBlocksByTitle: new Map()\n+\t\t});\n+\t}\n \n-\treturn [\n-\t\t...cleanFile(path.join(dir, snapFile)),\n-\t\t...cleanFile(path.join(dir, reportFile))\n-\t];\n-}\n+\tconst paths = determineSnapshotPaths({file, fixedLocation, projectDir});\n+\tconst buffer = tryRead(paths.snapPath);\n \n-exports.cleanSnapshots = cleanSnapshots;\n+\tif (!buffer) {\n+\t\treturn new Manager({\n+\t\t\trecordNewSnapshots,\n+\t\t\tupdating,\n+\t\t\t...paths,\n+\t\t\toldBlocksByTitle: new Map(),\n+\t\t\tnewBlocksByTitle: new Map()\n+\t\t});\n+\t}\n \n-function load({file, fixedLocation, projectDir, recordNewSnapshots, updating}) {\n-\tconst {dir, relFile, snapFile, reportFile} = determineSnapshotPaths({file, fixedLocation, projectDir});\n-\tconst snapPath = path.join(dir, snapFile);\n+\tlet blocksByTitle;\n+\tlet snapshotError;\n \n-\tlet appendOnly = !updating;\n-\tlet snapshotsByHash;\n+\ttry {\n+\t\tconst data = decodeSnapshots(buffer, paths.snapPath);\n+\t\tblocksByTitle = new Map(data.blocks.map(({title, ...block}) => [title, block]));\n+\t} catch (error) {\n+\t\tblocksByTitle = new Map();\n \n-\tif (!updating) {\n-\t\tconst buffer = tryRead(snapPath);\n-\t\tif (buffer) {\n-\t\t\tsnapshotsByHash = decodeSnapshots(buffer, snapPath);\n-\t\t} else {\n-\t\t\tappendOnly = false;\n+\t\tif (!updating) { // Discard all decoding errors when updating snapshots\n+\t\t\tif (error instanceof SnapshotError) {\n+\t\t\t\tsnapshotError = error;\n+\t\t\t} else {\n+\t\t\t\tthrow error;\n+\t\t\t}\n \t\t}\n \t}\n \n \treturn new Manager({\n-\t\tappendOnly,\n-\t\tdir,\n \t\trecordNewSnapshots,\n-\t\trelFile,\n-\t\treportFile,\n-\t\tsnapFile,\n-\t\tsnapPath,\n-\t\tsnapshotsByHash: snapshotsByHash || new Map()\n+\t\tupdating,\n+\t\t...paths,\n+\t\toldBlocksByTitle: blocksByTitle,\n+\t\tnewBlocksByTitle: updating ? new Map() : blocksByTitle,\n+\t\terror: snapshotError\n \t});\n }\n "
      },
      {
        "sha": "6fd25a05cb54913836a41b8b55c89bdd94eacd15",
        "filename": "lib/test.js",
        "status": "modified",
        "additions": 14,
        "deletions": 13,
        "changes": 27,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/lib%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/lib%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Ftest.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -227,18 +227,15 @@ class Test {\n \n \t\t\tconst belongsTo = snapshotBelongsTo;\n \t\t\tconst index = this.nextSnapshotIndex++;\n-\t\t\tconst label = message || `Snapshot ${index + 1}`; // Human-readable labels start counting at 1.\n+\t\t\tconst label = message;\n \n-\t\t\tconst {taskIndex, associatedTaskIndex} = this.metadata;\n \t\t\tconst {record, ...result} = options.compareTestSnapshot({\n \t\t\t\tbelongsTo,\n \t\t\t\tdeferRecording,\n \t\t\t\texpected,\n \t\t\t\tindex,\n \t\t\t\tlabel,\n-\t\t\t\ttaskIndex,\n-\t\t\t\tsnapIndex: this.snapshotCount,\n-\t\t\t\tassociatedTaskIndex\n+\t\t\t\ttaskIndex: this.metadata.taskIndex\n \t\t\t});\n \t\t\tif (record) {\n \t\t\t\tthis.deferredSnapshotRecordings.push(record);\n@@ -249,16 +246,20 @@ class Test {\n \n \t\tthis.skipSnapshot = () => {\n \t\t\tif (typeof options.skipSnapshot === 'function') {\n-\t\t\t\toptions.skipSnapshot();\n+\t\t\t\tconst record = options.skipSnapshot({\n+\t\t\t\t\tbelongsTo: snapshotBelongsTo,\n+\t\t\t\t\tindex: this.nextSnapshotIndex,\n+\t\t\t\t\tdeferRecording,\n+\t\t\t\t\ttaskIndex: this.metadata.taskIndex\n+\t\t\t\t});\n+\t\t\t\tif (record) {\n+\t\t\t\t\tthis.deferredSnapshotRecordings.push(record);\n+\t\t\t\t}\n \t\t\t}\n \n-\t\t\tif (options.updateSnapshots) {\n-\t\t\t\tthis.addFailedAssertion(new Error('Snapshot assertions cannot be skipped when updating snapshots'));\n-\t\t\t} else {\n-\t\t\t\tthis.nextSnapshotIndex++;\n-\t\t\t\tthis.snapshotCount++;\n-\t\t\t\tthis.countPassedAssertion();\n-\t\t\t}\n+\t\t\tthis.nextSnapshotIndex++;\n+\t\t\tthis.snapshotCount++;\n+\t\t\tthis.countPassedAssertion();\n \t\t};\n \n \t\tthis.runAttempt = async (title, fn) => {"
      },
      {
        "sha": "6fc3279c79a58fde98ada1e413121692aadb1095",
        "filename": "lib/worker/base.js",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/lib%2Fworker%2Fbase.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/lib%2Fworker%2Fbase.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fworker%2Fbase.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -98,10 +98,8 @@ const run = async options => {\n \n \trunner.on('finish', async () => {\n \t\ttry {\n-\t\t\tconst {cannotSave, touchedFiles} = runner.saveSnapshotState();\n-\t\t\tif (cannotSave) {\n-\t\t\t\tchannel.send({type: 'snapshot-error'});\n-\t\t\t} else if (touchedFiles) {\n+\t\t\tconst {touchedFiles} = runner.saveSnapshotState();\n+\t\t\tif (touchedFiles) {\n \t\t\t\tchannel.send({type: 'touched-files', files: touchedFiles});\n \t\t\t}\n \t\t} catch (error) {"
      },
      {
        "sha": "7ee253009ef1605d57927907fdc5365e7a5227dd",
        "filename": "package-lock.json",
        "status": "modified",
        "additions": 48,
        "deletions": 7,
        "changes": 55,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/package-lock.json",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/package-lock.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/package-lock.json?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -15,6 +15,7 @@\n \t\t\t\t\"arrgv\": \"^1.0.2\",\n \t\t\t\t\"arrify\": \"^2.0.1\",\n \t\t\t\t\"callsites\": \"^3.1.0\",\n+\t\t\t\t\"cbor\": \"^7.0.2\",\n \t\t\t\t\"chalk\": \"^4.1.0\",\n \t\t\t\t\"chokidar\": \"^3.5.1\",\n \t\t\t\t\"chunkd\": \"^2.0.1\",\n@@ -42,7 +43,6 @@\n \t\t\t\t\"is-promise\": \"^4.0.0\",\n \t\t\t\t\"lodash\": \"^4.17.20\",\n \t\t\t\t\"matcher\": \"^3.0.0\",\n-\t\t\t\t\"md5-hex\": \"^3.0.1\",\n \t\t\t\t\"mem\": \"^8.0.0\",\n \t\t\t\t\"ms\": \"^2.1.3\",\n \t\t\t\t\"ora\": \"^5.3.0\",\n@@ -2558,6 +2558,26 @@\n \t\t\t\"integrity\": \"sha1-G2gcIf+EAzyCZUMJBolCDRhxUdw=\",\n \t\t\t\"dev\": true\n \t\t},\n+\t\t\"node_modules/cbor\": {\n+\t\t\t\"version\": \"7.0.2\",\n+\t\t\t\"resolved\": \"https://registry.npmjs.org/cbor/-/cbor-7.0.2.tgz\",\n+\t\t\t\"integrity\": \"sha512-YR6TF7LBhTqdz0vjtoY5lDnOhHXg8/mdHd2qZYQz5q8Pl7i56/ndiIGLkms1RpkFAqrT9IHGO3cjo58SfFsF2A==\",\n+\t\t\t\"hasInstallScript\": true,\n+\t\t\t\"dependencies\": {\n+\t\t\t\t\"nofilter\": \"^2.0.0\"\n+\t\t\t},\n+\t\t\t\"engines\": {\n+\t\t\t\t\"node\": \">=10.18.0\"\n+\t\t\t},\n+\t\t\t\"peerDependencies\": {\n+\t\t\t\t\"bignumber.js\": \"^9.0.1\"\n+\t\t\t},\n+\t\t\t\"peerDependenciesMeta\": {\n+\t\t\t\t\"bignumber.js\": {\n+\t\t\t\t\t\"optional\": true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t},\n \t\t\"node_modules/chalk\": {\n \t\t\t\"version\": \"4.1.0\",\n \t\t\t\"resolved\": \"https://registry.npmjs.org/chalk/-/chalk-4.1.0.tgz\",\n@@ -3019,9 +3039,9 @@\n \t\t\t\"integrity\": \"sha1-2Klr13/Wjfd5OnMDajug1UBdR3s=\"\n \t\t},\n \t\t\"node_modules/concordance\": {\n-\t\t\t\"version\": \"5.0.1\",\n-\t\t\t\"resolved\": \"https://registry.npmjs.org/concordance/-/concordance-5.0.1.tgz\",\n-\t\t\t\"integrity\": \"sha512-TbNtInKVElgEBnJ1v2Xg+MFX2lvFLbmlv3EuSC5wTfCwpB8kC3w3mffF6cKuUhkn475Ym1f1I4qmuXzx2+uXpw==\",\n+\t\t\t\"version\": \"5.0.4\",\n+\t\t\t\"resolved\": \"https://registry.npmjs.org/concordance/-/concordance-5.0.4.tgz\",\n+\t\t\t\"integrity\": \"sha512-OAcsnTEYu1ARJqWVGwf4zh4JDfHZEaSNlNccFmt8YjB2l/n19/PF2viLINHc57vO4FKIAFl2FWASIGZZWZ2Kxw==\",\n \t\t\t\"dependencies\": {\n \t\t\t\t\"date-time\": \"^3.1.0\",\n \t\t\t\t\"esutils\": \"^2.0.3\",\n@@ -7794,6 +7814,14 @@\n \t\t\t\"dev\": true,\n \t\t\t\"peer\": true\n \t\t},\n+\t\t\"node_modules/nofilter\": {\n+\t\t\t\"version\": \"2.0.0\",\n+\t\t\t\"resolved\": \"https://registry.npmjs.org/nofilter/-/nofilter-2.0.0.tgz\",\n+\t\t\t\"integrity\": \"sha512-i3ck2PUWBa+trsGGBvwS3msnTowbFei5G++BgpOpT7y7VTrprXphMQP5svTdsMLdttKDZFo+5RqVWRqhmf+BwQ==\",\n+\t\t\t\"engines\": {\n+\t\t\t\t\"node\": \">=10.18\"\n+\t\t\t}\n+\t\t},\n \t\t\"node_modules/nopt\": {\n \t\t\t\"version\": \"1.0.10\",\n \t\t\t\"resolved\": \"https://registry.npmjs.org/nopt/-/nopt-1.0.10.tgz\",\n@@ -16789,6 +16817,14 @@\n \t\t\t\"integrity\": \"sha1-G2gcIf+EAzyCZUMJBolCDRhxUdw=\",\n \t\t\t\"dev\": true\n \t\t},\n+\t\t\"cbor\": {\n+\t\t\t\"version\": \"7.0.2\",\n+\t\t\t\"resolved\": \"https://registry.npmjs.org/cbor/-/cbor-7.0.2.tgz\",\n+\t\t\t\"integrity\": \"sha512-YR6TF7LBhTqdz0vjtoY5lDnOhHXg8/mdHd2qZYQz5q8Pl7i56/ndiIGLkms1RpkFAqrT9IHGO3cjo58SfFsF2A==\",\n+\t\t\t\"requires\": {\n+\t\t\t\t\"nofilter\": \"^2.0.0\"\n+\t\t\t}\n+\t\t},\n \t\t\"chalk\": {\n \t\t\t\"version\": \"4.1.0\",\n \t\t\t\"resolved\": \"https://registry.npmjs.org/chalk/-/chalk-4.1.0.tgz\",\n@@ -17151,9 +17187,9 @@\n \t\t\t\"integrity\": \"sha1-2Klr13/Wjfd5OnMDajug1UBdR3s=\"\n \t\t},\n \t\t\"concordance\": {\n-\t\t\t\"version\": \"5.0.1\",\n-\t\t\t\"resolved\": \"https://registry.npmjs.org/concordance/-/concordance-5.0.1.tgz\",\n-\t\t\t\"integrity\": \"sha512-TbNtInKVElgEBnJ1v2Xg+MFX2lvFLbmlv3EuSC5wTfCwpB8kC3w3mffF6cKuUhkn475Ym1f1I4qmuXzx2+uXpw==\",\n+\t\t\t\"version\": \"5.0.4\",\n+\t\t\t\"resolved\": \"https://registry.npmjs.org/concordance/-/concordance-5.0.4.tgz\",\n+\t\t\t\"integrity\": \"sha512-OAcsnTEYu1ARJqWVGwf4zh4JDfHZEaSNlNccFmt8YjB2l/n19/PF2viLINHc57vO4FKIAFl2FWASIGZZWZ2Kxw==\",\n \t\t\t\"requires\": {\n \t\t\t\t\"date-time\": \"^3.1.0\",\n \t\t\t\t\"esutils\": \"^2.0.3\",\n@@ -20859,6 +20895,11 @@\n \t\t\t\"dev\": true,\n \t\t\t\"peer\": true\n \t\t},\n+\t\t\"nofilter\": {\n+\t\t\t\"version\": \"2.0.0\",\n+\t\t\t\"resolved\": \"https://registry.npmjs.org/nofilter/-/nofilter-2.0.0.tgz\",\n+\t\t\t\"integrity\": \"sha512-i3ck2PUWBa+trsGGBvwS3msnTowbFei5G++BgpOpT7y7VTrprXphMQP5svTdsMLdttKDZFo+5RqVWRqhmf+BwQ==\"\n+\t\t},\n \t\t\"nopt\": {\n \t\t\t\"version\": \"1.0.10\",\n \t\t\t\"resolved\": \"https://registry.npmjs.org/nopt/-/nopt-1.0.10.tgz\","
      },
      {
        "sha": "23135aeffc20e1bba5fb3e4e6b2086237da82a95",
        "filename": "package.json",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/package.json",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/package.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/package.json?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -64,6 +64,7 @@\n \t\t\"arrgv\": \"^1.0.2\",\n \t\t\"arrify\": \"^2.0.1\",\n \t\t\"callsites\": \"^3.1.0\",\n+\t\t\"cbor\": \"^7.0.2\",\n \t\t\"chalk\": \"^4.1.0\",\n \t\t\"chokidar\": \"^3.5.1\",\n \t\t\"chunkd\": \"^2.0.1\",\n@@ -91,7 +92,6 @@\n \t\t\"is-promise\": \"^4.0.0\",\n \t\t\"lodash\": \"^4.17.20\",\n \t\t\"matcher\": \"^3.0.0\",\n-\t\t\"md5-hex\": \"^3.0.1\",\n \t\t\"mem\": \"^8.0.0\",\n \t\t\"ms\": \"^2.1.3\",\n \t\t\"ora\": \"^5.3.0\","
      },
      {
        "sha": "6fac103bfd8fc2ae83fc107d6d1053b520e31fac",
        "filename": "test-tap/fixture/assert.js.md",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test-tap%2Ffixture%2Fassert.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test-tap%2Ffixture%2Fassert.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test-tap%2Ffixture%2Fassert.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -18,12 +18,6 @@ Generated by [AVA](https://avajs.dev).\n       foo: 'bar',\n     }\n \n-## fixed id\n-\n-    {\n-      foo: 'bar',\n-    }\n-\n ## fails\n \n > Snapshot 1"
      },
      {
        "sha": "9dc6b52db73e830290ca243aad872fa7552e791b",
        "filename": "test-tap/fixture/assert.js.snap",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test-tap%2Ffixture%2Fassert.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test-tap%2Ffixture%2Fassert.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test-tap%2Ffixture%2Fassert.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "0dd31160ea61f2aa32f991c1f67c70413d321348",
        "filename": "test-tap/fixture/snapshots/test-content/test.js.snap.expected",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test-tap%2Ffixture%2Fsnapshots%2Ftest-content%2Ftest.js.snap.expected",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test-tap%2Ffixture%2Fsnapshots%2Ftest-content%2Ftest.js.snap.expected",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test-tap%2Ffixture%2Fsnapshots%2Ftest-content%2Ftest.js.snap.expected?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "2ceb2c743a77d8797b4c8dac84abb448f2cc6a9f",
        "filename": "test-tap/fixture/try-snapshot.js.md",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test-tap%2Ffixture%2Ftry-snapshot.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test-tap%2Ffixture%2Ftry-snapshot.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test-tap%2Ffixture%2Ftry-snapshot.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -4,7 +4,7 @@ The actual snapshot is saved in `try-snapshot.js.snap`.\n \n Generated by [AVA](https://avajs.dev).\n \n-## concurrent\n+## serial\n \n > Snapshot 1\n \n@@ -20,7 +20,13 @@ Generated by [AVA](https://avajs.dev).\n       boo: 'far',\n     }\n \n-## serial\n+> Snapshot 4\n+\n+    {\n+      foo: 'bar',\n+    }\n+\n+## concurrent\n \n > Snapshot 1\n \n@@ -35,9 +41,3 @@ Generated by [AVA](https://avajs.dev).\n     {\n       boo: 'far',\n     }\n-\n-> Snapshot 4\n-\n-    {\n-      foo: 'bar',\n-    }"
      },
      {
        "sha": "2505134d775b1c0d0413858b255f4130b1ee2a48",
        "filename": "test-tap/fixture/try-snapshot.js.snap",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test-tap%2Ffixture%2Ftry-snapshot.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test-tap%2Ffixture%2Ftry-snapshot.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test-tap%2Ffixture%2Ftry-snapshot.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "2dbcd7310a63d220470d03ffada51795a6e874b8",
        "filename": "test-tap/integration/snapshots.js",
        "status": "modified",
        "additions": 14,
        "deletions": 3,
        "changes": 17,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test-tap%2Fintegration%2Fsnapshots.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test-tap%2Fintegration%2Fsnapshots.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test-tap%2Fintegration%2Fsnapshots.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -79,21 +79,32 @@ test('outdated snapshot version is reported to the console', t => {\n \n \texecCli(['test.js'], {dirname: 'fixture/snapshots'}, (error, stdout) => {\n \t\tt.ok(error);\n-\t\tt.match(stdout, /The snapshot file is v0, but only v2 is supported\\./);\n+\t\tt.match(stdout, /The snapshot file is v0, but only v3 is supported\\./);\n \t\tt.match(stdout, /File path:/);\n \t\tt.match(stdout, snapPath);\n \t\tt.match(stdout, /Please run AVA again with the .*--update-snapshots.* flag to upgrade\\./);\n \t\tt.end();\n \t});\n });\n \n+test('outdated snapshot version can be updated', t => {\n+\tconst snapPath = path.join(__dirname, '..', 'fixture', 'snapshots', 'test.js.snap');\n+\tfs.writeFileSync(snapPath, Buffer.from([0x0A, 0x00, 0x00]));\n+\n+\texecCli(['test.js', '--update-snapshots'], {dirname: 'fixture/snapshots', env: {AVA_FORCE_CI: 'not-ci'}}, (error, stdout) => {\n+\t\tt.ifError(error);\n+\t\tt.match(stdout, /2 tests passed/);\n+\t\tt.end();\n+\t});\n+});\n+\n test('newer snapshot version is reported to the console', t => {\n \tconst snapPath = path.join(__dirname, '..', 'fixture', 'snapshots', 'test.js.snap');\n \tfs.writeFileSync(snapPath, Buffer.from([0x0A, 0xFF, 0xFF]));\n \n \texecCli(['test.js'], {dirname: 'fixture/snapshots'}, (error, stdout) => {\n \t\tt.ok(error);\n-\t\tt.match(stdout, /The snapshot file is v65535, but only v2 is supported\\./);\n+\t\tt.match(stdout, /The snapshot file is v65535, but only v3 is supported\\./);\n \t\tt.match(stdout, /File path:/);\n \t\tt.match(stdout, snapPath);\n \t\tt.match(stdout, /You should upgrade AVA\\./);\n@@ -103,7 +114,7 @@ test('newer snapshot version is reported to the console', t => {\n \n test('snapshot corruption is reported to the console', t => {\n \tconst snapPath = path.join(__dirname, '..', 'fixture', 'snapshots', 'test.js.snap');\n-\tfs.writeFileSync(snapPath, Buffer.from([0x0A, 0x02, 0x00]));\n+\tfs.writeFileSync(snapPath, Buffer.from([0x0A, 0x03, 0x00]));\n \n \texecCli(['test.js'], {dirname: 'fixture/snapshots'}, (error, stdout) => {\n \t\tt.ok(error);"
      },
      {
        "sha": "5ac030ab9d51396da50415c0c2d605ae54936f4d",
        "filename": "test-tap/test.js",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test-tap%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test-tap%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test-tap%2Ftest.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -723,9 +723,12 @@ test('snapshot assertions call options.skipSnapshot when skipped', async t => {\n \tawait test.run();\n \n \tt.true(skipSnapshot.calledTwice);\n+\tfor (const [index, call] of skipSnapshot.getCalls().entries()) {\n+\t\tt.like(call.firstArg, {belongsTo: 'passes', index});\n+\t}\n });\n \n-test('snapshot assertion cannot be skipped when updating snapshots', t => {\n+test('snapshot assertion can be skipped when updating snapshots', t => {\n \treturn new Test({\n \t\tupdateSnapshots: true,\n \t\tmetadata: {},\n@@ -734,8 +737,7 @@ test('snapshot assertion cannot be skipped when updating snapshots', t => {\n \t\t\tt.snapshot.skip({not: {a: 'match'}});\n \t\t}\n \t}).run().then(result => {\n-\t\tt.false(result.passed);\n-\t\tt.is(result.error.message, 'Snapshot assertions cannot be skipped when updating snapshots');\n+\t\tt.true(result.passed);\n \t});\n });\n "
      },
      {
        "sha": "543a6e90c6c65fc69b2cd08afe202fcfb19e3130",
        "filename": "test-tap/try-snapshot.js",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test-tap%2Ftry-snapshot.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test-tap%2Ftry-snapshot.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test-tap%2Ftry-snapshot.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -23,7 +23,7 @@ function setup(title, manager, fn) {\n \n test(async t => {\n \t// Set to `true` to update the snapshot, then run:\n-\t// \"$(npm bin)\"/tap -R spec test/try-snapshot.js\n+\t// npx tap -R spec test-tap/try-snapshot.js\n \t//\n \t// Ignore errors and make sure not to run tests with the `-b` (bail) option.\n \tconst updating = false;"
      },
      {
        "sha": "f82f8f23f86269cd1c1c04923ccb920c24b0522c",
        "filename": "test/assertions/fixtures/happy-path.js.snap",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fassertions%2Ffixtures%2Fhappy-path.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fassertions%2Ffixtures%2Fhappy-path.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fassertions%2Ffixtures%2Fhappy-path.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "50d04bde0fd289b4773865b020342a874890b01a",
        "filename": "test/helpers/exec.js",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fhelpers%2Fexec.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fhelpers%2Fexec.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fhelpers%2Fexec.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -68,7 +68,6 @@ exports.fixture = async (args, options = {}) => {\n \t\tskipped: [],\n \t\ttodo: [],\n \t\tuncaughtExceptions: [],\n-\t\tunsavedSnapshots: [],\n \t\tgetError(statObject) {\n \t\t\treturn errors.get(statObject);\n \t\t},\n@@ -107,12 +106,6 @@ exports.fixture = async (args, options = {}) => {\n \t\t\t\tbreak;\n \t\t\t}\n \n-\t\t\tcase 'snapshot-error': {\n-\t\t\t\tconst {testFile} = statusEvent;\n-\t\t\t\tstats.unsavedSnapshots.push({file: normalizePath(cwd, testFile)});\n-\t\t\t\tbreak;\n-\t\t\t}\n-\n \t\t\tcase 'test-passed': {\n \t\t\t\tconst {title, testFile} = statusEvent;\n \t\t\t\tconst statObject = {title, file: normalizePath(cwd, testFile)};\n@@ -153,6 +146,5 @@ exports.fixture = async (args, options = {}) => {\n \t\tstats.passed.sort(compareStatObjects);\n \t\tstats.skipped.sort(compareStatObjects);\n \t\tstats.todo.sort(compareStatObjects);\n-\t\tstats.unsavedSnapshots.sort(compareStatObjects);\n \t}\n };"
      },
      {
        "sha": "f872866e69f28f05910330510867ac1148838e95",
        "filename": "test/helpers/with-temporary-fixture.js",
        "status": "added",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fhelpers%2Fwith-temporary-fixture.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fhelpers%2Fwith-temporary-fixture.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fhelpers%2Fwith-temporary-fixture.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,14 @@\n+const tempy = require('tempy');\n+const fse = require('fs-extra');\n+\n+async function withTemporaryFixture(cwd, task) {\n+\tlet result;\n+\tawait tempy.directory.task(async temporary => {\n+\t\tawait fse.copy(cwd, temporary);\n+\t\tresult = await task(temporary);\n+\t});\n+\n+\treturn result;\n+}\n+\n+module.exports.withTemporaryFixture = withTemporaryFixture;"
      },
      {
        "sha": "17aeedced8a515ea99db267b5118e202c087fa5a",
        "filename": "test/snapshot-order/fixtures/randomness/test.js.snap",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-order%2Ffixtures%2Frandomness%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-order%2Ffixtures%2Frandomness%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-order%2Ffixtures%2Frandomness%2Ftest.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "3d401bdf1f73bf727a2fdff303e28d3538a6e5f7",
        "filename": "test/snapshot-order/snapshots/randomness.js.md",
        "status": "modified",
        "additions": 10,
        "deletions": 8,
        "changes": 18,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-order%2Fsnapshots%2Frandomness.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-order%2Fsnapshots%2Frandomness.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-order%2Fsnapshots%2Frandomness.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -9,12 +9,14 @@ Generated by [AVA](https://avajs.dev).\n > resulting snapshot in binary encoding\n \n     Buffer @Uint8Array [\n-      41564120 536e6170 73686f74 2076320a 020089ef 307bf8df 7d1d9bef fcd38d56\n-      76211f8b 08000000 00000003 dbc1c0c0 c0ca101b fa49b4b6 7ccbb3fb 4faf6d6b\n-      2fd34864 64000131 208e5f7b 77a5e07b 763fb9ee 6b9372cf b0fe6306 8bea40b1\n-      13144700 f1f94533 4f1d923e 71cf844d 86f7e85e 934626b0 683e14b7 01f12557\n-      e69bbb0f 6e4d6d9d b8a26a67 6f912e13 58740e14 6f06e22f 02f3d57d 0eceb77f\n-      e6f3587c e703fd0e 66b0e849 28be0fc5 5f819899 811dec46 46560641 468eccbc\n-      94d40a2b 0513aca2 a65845cd b08a9aa3 88724245 0d8db00b 1b6335c3 02bb6203\n-      ac8ab18b 1a621535 02004e86 b593ad01 0000\n+      41564120 536e6170 73686f74 2076330a 03008ba7 6ff7a1a2 251e5fa1 afbf3fa8\n+      fdf7ca69 3e5b2af2 b0734c95 46791417 ae201f8b 08000000 00000003 5b989694\n+      939f9c5d dcba28b5 24b32427 b542ca49 41572125 353927b1 2855a138 3f1748e4\n+      25161467 e4971467 c259cd0b 5352124b 12c39819 d8194080 91954190 9123332f\n+      25b5c24a c160111e 49c3d49c c4a4d49c dc8cc462 854485dc d4e2e2c4 f4547c1a\n+      8c201a8a 12738af3 15507541 5d2cef88 eee2dcfc 22acce6e c4e76c13 9879aace\n+      38434021 330f687f 4951a586 265260e0 73be29c4 f9a9f9a5 25a945f8 149a4115\n+      66e6e5e1 57680e51 980d3651 21313d31 330fee72 5790cb33 8b93138b 52887179\n+      133e7b2c 305d1e8e a2901316 a506385d 54e40274 10aed868 5a88cf50 23bcb2c6\n+      00d6e9f1 35b80200 00\n     ]"
      },
      {
        "sha": "f144e6104bbf6b4cd5ca7408b6ff16780ff86a3c",
        "filename": "test/snapshot-order/snapshots/randomness.js.snap",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-order%2Fsnapshots%2Frandomness.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-order%2Fsnapshots%2Frandomness.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-order%2Fsnapshots%2Frandomness.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
        "filename": "test/snapshot-regenerate-report/fixtures/package.json",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-regenerate-report%2Ffixtures%2Fpackage.json",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-regenerate-report%2Ffixtures%2Fpackage.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-regenerate-report%2Ffixtures%2Fpackage.json?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1 @@\n+{}"
      },
      {
        "sha": "29245bd3f4e6aa52ffef6bb2523f959ee81a1ee1",
        "filename": "test/snapshot-regenerate-report/fixtures/test.js",
        "status": "added",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-regenerate-report%2Ffixtures%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-regenerate-report%2Ffixtures%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-regenerate-report%2Ffixtures%2Ftest.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,31 @@\n+const test = require('ava');\n+\n+function randomDelay(max) {\n+\treturn new Promise(resolve => {\n+\t\tsetTimeout(resolve, Math.random() * max);\n+\t});\n+}\n+\n+test('some snapshots', t => {\n+\tt.snapshot({foo: 42});\n+\tt.snapshot('bar', 'a message');\n+});\n+\n+test('no snapshots', t => {\n+\tt.pass();\n+});\n+\n+test('async with some snapshots', async t => {\n+\tt.snapshot(['baz']);\n+\tawait t.notThrowsAsync(randomDelay(100));\n+\tt.snapshot(['quux']);\n+});\n+\n+test('more snapshots', t => {\n+\tt.snapshot(['hello', 'world'], 'again');\n+});\n+\n+test('async again', async t => {\n+\tawait t.notThrowsAsync(randomDelay(100));\n+\tt.snapshot(null, 'delayed');\n+});"
      },
      {
        "sha": "aa63810d764014a3e92ea0606416f3220c3641c3",
        "filename": "test/snapshot-regenerate-report/test.js",
        "status": "added",
        "additions": 42,
        "deletions": 0,
        "changes": 42,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-regenerate-report%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-regenerate-report%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-regenerate-report%2Ftest.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,42 @@\n+const test = require('@ava/test');\n+const exec = require('../helpers/exec');\n+\n+const fs = require('fs').promises;\n+const path = require('path');\n+\n+require('../../lib/chalk').set({level: 0});\n+require('../../lib/worker/options').set({});\n+const {load} = require('../../lib/snapshot-manager');\n+\n+test('snapshot report can be regenerated from .snap file', async t => {\n+\tconst cwd = exec.cwd();\n+\tconst env = {\n+\t\tAVA_FORCE_CI: 'not-ci'\n+\t};\n+\tconst reportPath = path.join(cwd, 'test.js.md');\n+\n+\tt.teardown(() => fs.unlink(reportPath));\n+\tt.teardown(() => fs.unlink(path.join(cwd, 'test.js.snap')));\n+\n+\t// Run fixture to generate report, snapshot\n+\tawait exec.fixture(['--update-snapshots'], {cwd, env});\n+\n+\t// Read report\n+\tconst report = await fs.readFile(reportPath, 'utf8');\n+\n+\t// Delete report\n+\tawait fs.unlink(reportPath);\n+\n+\t// Load snapshot manager from .snap file\n+\tconst snapshots = load({\n+\t\tfile: path.join(cwd, 'test.js'),\n+\t\tprojectDir: cwd\n+\t});\n+\n+\t// Regenerate report\n+\tsnapshots.hasChanges = true; // TODO this is a hack\n+\tsnapshots.save();\n+\n+\t// Assert that reports match\n+\tt.is(await fs.readFile(reportPath, 'utf8'), report);\n+});"
      },
      {
        "sha": "98c6b8ffda29e1222cd925afecbee93d3d7d0444",
        "filename": "test/snapshot-removal/fixtures/fixed-snapshot-dir/fixedSnapshotDir/test.js.md",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Ffixed-snapshot-dir%2FfixedSnapshotDir%2Ftest.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Ffixed-snapshot-dir%2FfixedSnapshotDir%2Ftest.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Ffixtures%2Ffixed-snapshot-dir%2FfixedSnapshotDir%2Ftest.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,21 @@\n+# Snapshot report for `test.js`\n+\n+The actual snapshot is saved in `test.js.snap`.\n+\n+Generated by [AVA](https://avajs.dev).\n+\n+## some snapshots\n+\n+> Snapshot 1\n+\n+    'foo'\n+\n+> Snapshot 2\n+\n+    'bar'\n+\n+## another snapshot\n+\n+> Snapshot 1\n+\n+    'baz'"
      },
      {
        "sha": "b97b68cab1811caf09660aebc7328909e33861eb",
        "filename": "test/snapshot-removal/fixtures/fixed-snapshot-dir/fixedSnapshotDir/test.js.snap",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Ffixed-snapshot-dir%2FfixedSnapshotDir%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Ffixed-snapshot-dir%2FfixedSnapshotDir%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Ffixtures%2Ffixed-snapshot-dir%2FfixedSnapshotDir%2Ftest.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "8b45ec1f58b20b5307e755d7e7cf6b789d5e9b75",
        "filename": "test/snapshot-removal/fixtures/no-snapshots/test.js",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fno-snapshots%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fno-snapshots%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Ffixtures%2Fno-snapshots%2Ftest.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -1,4 +1,4 @@\n-const test = require('ava');\n+const test = require(process.env.AVA_PATH); // This fixture is copied to a temporary directory, so require AVA through its configured path.\n \n test('without snapshots', t => {\n \tt.pass();"
      },
      {
        "sha": "98c6b8ffda29e1222cd925afecbee93d3d7d0444",
        "filename": "test/snapshot-removal/fixtures/only-test/test.js.md",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fonly-test%2Ftest.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fonly-test%2Ftest.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Ffixtures%2Fonly-test%2Ftest.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,21 @@\n+# Snapshot report for `test.js`\n+\n+The actual snapshot is saved in `test.js.snap`.\n+\n+Generated by [AVA](https://avajs.dev).\n+\n+## some snapshots\n+\n+> Snapshot 1\n+\n+    'foo'\n+\n+> Snapshot 2\n+\n+    'bar'\n+\n+## another snapshot\n+\n+> Snapshot 1\n+\n+    'baz'"
      },
      {
        "sha": "b97b68cab1811caf09660aebc7328909e33861eb",
        "filename": "test/snapshot-removal/fixtures/only-test/test.js.snap",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fonly-test%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fonly-test%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Ffixtures%2Fonly-test%2Ftest.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "98c6b8ffda29e1222cd925afecbee93d3d7d0444",
        "filename": "test/snapshot-removal/fixtures/removal/test.js.md",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fremoval%2Ftest.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fremoval%2Ftest.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Ffixtures%2Fremoval%2Ftest.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,21 @@\n+# Snapshot report for `test.js`\n+\n+The actual snapshot is saved in `test.js.snap`.\n+\n+Generated by [AVA](https://avajs.dev).\n+\n+## some snapshots\n+\n+> Snapshot 1\n+\n+    'foo'\n+\n+> Snapshot 2\n+\n+    'bar'\n+\n+## another snapshot\n+\n+> Snapshot 1\n+\n+    'baz'"
      },
      {
        "sha": "b97b68cab1811caf09660aebc7328909e33861eb",
        "filename": "test/snapshot-removal/fixtures/removal/test.js.snap",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fremoval%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fremoval%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Ffixtures%2Fremoval%2Ftest.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "1b065f6a9f8f0920945e979f4f708c155e8fdc70",
        "filename": "test/snapshot-removal/fixtures/skipped-snapshots-in-try/test.js.md",
        "status": "added",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fskipped-snapshots-in-try%2Ftest.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fskipped-snapshots-in-try%2Ftest.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Ffixtures%2Fskipped-snapshots-in-try%2Ftest.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,11 @@\n+# Snapshot report for `test.js`\n+\n+The actual snapshot is saved in `test.js.snap`.\n+\n+Generated by [AVA](https://avajs.dev).\n+\n+## skipped snapshots in try\n+\n+> Snapshot 1\n+\n+    'in try'"
      },
      {
        "sha": "e4742dc050bdfab788a0f15a17f9fbe26276c426",
        "filename": "test/snapshot-removal/fixtures/skipped-snapshots-in-try/test.js.snap",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fskipped-snapshots-in-try%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fskipped-snapshots-in-try%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Ffixtures%2Fskipped-snapshots-in-try%2Ftest.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "98c6b8ffda29e1222cd925afecbee93d3d7d0444",
        "filename": "test/snapshot-removal/fixtures/skipped-snapshots/test.js.md",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fskipped-snapshots%2Ftest.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fskipped-snapshots%2Ftest.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Ffixtures%2Fskipped-snapshots%2Ftest.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,21 @@\n+# Snapshot report for `test.js`\n+\n+The actual snapshot is saved in `test.js.snap`.\n+\n+Generated by [AVA](https://avajs.dev).\n+\n+## some snapshots\n+\n+> Snapshot 1\n+\n+    'foo'\n+\n+> Snapshot 2\n+\n+    'bar'\n+\n+## another snapshot\n+\n+> Snapshot 1\n+\n+    'baz'"
      },
      {
        "sha": "b97b68cab1811caf09660aebc7328909e33861eb",
        "filename": "test/snapshot-removal/fixtures/skipped-snapshots/test.js.snap",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fskipped-snapshots%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fskipped-snapshots%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Ffixtures%2Fskipped-snapshots%2Ftest.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "98c6b8ffda29e1222cd925afecbee93d3d7d0444",
        "filename": "test/snapshot-removal/fixtures/skipped-tests/test.js.md",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fskipped-tests%2Ftest.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fskipped-tests%2Ftest.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Ffixtures%2Fskipped-tests%2Ftest.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,21 @@\n+# Snapshot report for `test.js`\n+\n+The actual snapshot is saved in `test.js.snap`.\n+\n+Generated by [AVA](https://avajs.dev).\n+\n+## some snapshots\n+\n+> Snapshot 1\n+\n+    'foo'\n+\n+> Snapshot 2\n+\n+    'bar'\n+\n+## another snapshot\n+\n+> Snapshot 1\n+\n+    'baz'"
      },
      {
        "sha": "b97b68cab1811caf09660aebc7328909e33861eb",
        "filename": "test/snapshot-removal/fixtures/skipped-tests/test.js.snap",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fskipped-tests%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fskipped-tests%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Ffixtures%2Fskipped-tests%2Ftest.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "673f0277f9749adc14681d37e4e83e7ee4892357",
        "filename": "test/snapshot-removal/fixtures/snapshot-dir/test/snapshots/test.js.md",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fsnapshot-dir%2Ftest%2Fsnapshots%2Ftest.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fsnapshot-dir%2Ftest%2Fsnapshots%2Ftest.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Ffixtures%2Fsnapshot-dir%2Ftest%2Fsnapshots%2Ftest.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,21 @@\n+# Snapshot report for `test/test.js`\n+\n+The actual snapshot is saved in `test.js.snap`.\n+\n+Generated by [AVA](https://avajs.dev).\n+\n+## some snapshots\n+\n+> Snapshot 1\n+\n+    'foo'\n+\n+> Snapshot 2\n+\n+    'bar'\n+\n+## another snapshot\n+\n+> Snapshot 1\n+\n+    'baz'"
      },
      {
        "sha": "b97b68cab1811caf09660aebc7328909e33861eb",
        "filename": "test/snapshot-removal/fixtures/snapshot-dir/test/snapshots/test.js.snap",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fsnapshot-dir%2Ftest%2Fsnapshots%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Fsnapshot-dir%2Ftest%2Fsnapshots%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Ffixtures%2Fsnapshot-dir%2Ftest%2Fsnapshots%2Ftest.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "09cead48da9d7d02d042ef3a8a1b0903e096287a",
        "filename": "test/snapshot-removal/fixtures/try/test.js.md",
        "status": "added",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Ftry%2Ftest.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Ftry%2Ftest.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Ffixtures%2Ftry%2Ftest.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,11 @@\n+# Snapshot report for `test.js`\n+\n+The actual snapshot is saved in `test.js.snap`.\n+\n+Generated by [AVA](https://avajs.dev).\n+\n+## snapshots in try\n+\n+> Snapshot 1\n+\n+    'in try'"
      },
      {
        "sha": "4ee93b4e01b2b665c828f794e09ddb0337d35299",
        "filename": "test/snapshot-removal/fixtures/try/test.js.snap",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Ftry%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ffixtures%2Ftry%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Ffixtures%2Ftry%2Ftest.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "77644629ee779726bec527131efdedac703579a9",
        "filename": "test/snapshot-removal/helpers/macros.js",
        "status": "modified",
        "additions": 49,
        "deletions": 63,
        "changes": 112,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Fhelpers%2Fmacros.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Fhelpers%2Fmacros.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Fhelpers%2Fmacros.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -1,86 +1,72 @@\n const fs = require('fs').promises;\n const exec = require('../../helpers/exec');\n const path = require('path');\n-const tempy = require('tempy');\n-const fse = require('fs-extra');\n-\n-function withTemporaryFixture(macro) {\n-\tconst avaPath = path.resolve(path.join(__dirname, '..', '..', '..'));\n-\n-\treturn async (t, {cwd, env, ...options}) => {\n-\t\tawait tempy.directory.task(async temporary => {\n-\t\t\tawait fse.copy(cwd, temporary);\n-\t\t\tawait macro(t, {\n-\t\t\t\tcwd: temporary,\n-\t\t\t\tenv: {\n-\t\t\t\t\tAVA_PATH: avaPath,\n-\t\t\t\t\t...env\n-\t\t\t\t},\n-\t\t\t\t...options\n-\t\t\t});\n-\t\t});\n-\t};\n-}\n-\n-module.exports.withTemporaryFixture = withTemporaryFixture;\n+const {withTemporaryFixture} = require('../../helpers/with-temporary-fixture');\n \n async function testSnapshotPruning(t, {\n \tcwd,\n \tenv,\n \tcli,\n \tremove,\n-\tsnapshotPath = 'test.js.snap',\n-\treportPath = 'test.js.md',\n+\tsnapshotFile = 'test.js.snap',\n+\treportFile = 'test.js.md',\n \tcheckRun = async (t, run) => {\n \t\tawait t.notThrowsAsync(run, 'Expected fixture not to throw');\n \t}\n }) {\n-\tsnapshotPath = path.join(cwd, snapshotPath);\n-\treportPath = path.join(cwd, reportPath);\n+\tconst updating = process.argv.includes('--update-fixture-snapshots');\n \n-\tt.teardown(async () => {\n-\t\ttry {\n-\t\t\tawait fs.unlink(snapshotPath);\n-\t\t\tawait fs.unlink(reportPath);\n-\t\t} catch {}\n-\t});\n+\tif (updating) {\n+\t\t// Execute fixture as template to generate snapshots\n+\t\tconst templateResult = exec.fixture(['--update-snapshots'], {\n+\t\t\tcwd,\n+\t\t\tenv: {\n+\t\t\t\tAVA_FORCE_CI: 'not-ci',\n+\t\t\t\tTEMPLATE: 'true'\n+\t\t\t}\n+\t\t});\n \n-\t// Execute fixture as template to generate snapshots\n-\tconst templateResult = exec.fixture(['--update-snapshots'], {\n-\t\tcwd,\n-\t\tenv: {\n-\t\t\t...env,\n-\t\t\tAVA_FORCE_CI: 'not-ci',\n-\t\t\tTEMPLATE: 'true'\n-\t\t}\n-\t});\n+\t\tawait t.notThrowsAsync(templateResult, 'Template crashed - there\\'s a bug in the test');\n \n-\tawait t.notThrowsAsync(templateResult, 'Template crashed - there\\'s a bug in the test');\n+\t\t// Check that the snapshots were created\n+\t\tconst snapshotPath = path.join(cwd, snapshotFile);\n+\t\tconst reportPath = path.join(cwd, reportFile);\n+\t\tawait Promise.all([\n+\t\t\tt.notThrowsAsync(fs.access(snapshotPath), 'Template didn\\'t create a snapshot - there\\'s a bug in the test'),\n+\t\t\tt.notThrowsAsync(fs.access(reportPath), 'Template didn\\'t create a report - there\\'s a bug in the test')\n+\t\t]);\n+\t}\n \n-\t// Check that the snapshots were created\n-\tawait t.notThrowsAsync(fs.access(snapshotPath), 'Template didn\\'t create a snapshot - there\\'s a bug in the test');\n-\tawait t.notThrowsAsync(fs.access(reportPath), 'Template didn\\'t create a report - there\\'s a bug in the test');\n+\t// Make a temporary copy of the fixture\n+\tawait withTemporaryFixture(cwd, async cwd => {\n+\t\t// Execute fixture as run\n+\t\tconst run = exec.fixture(cli, {\n+\t\t\tcwd,\n+\t\t\tenv: {\n+\t\t\t\tAVA_FORCE_CI: 'not-ci',\n+\t\t\t\t...env\n+\t\t\t}\n+\t\t});\n \n-\t// Execute fixture as run\n-\tconst run = exec.fixture(cli, {\n-\t\tcwd,\n-\t\tenv: {\n-\t\t\tAVA_FORCE_CI: 'not-ci',\n-\t\t\t...env\n-\t\t}\n-\t});\n+\t\tawait checkRun(t, run);\n \n-\tawait checkRun(t, run);\n+\t\tconst snapshotPath = path.join(cwd, snapshotFile);\n+\t\tconst reportPath = path.join(cwd, reportFile);\n \n-\tif (remove) {\n-\t\t// Assert files don't exist\n-\t\tawait t.throwsAsync(fs.access(snapshotPath), {code: 'ENOENT'}, 'Expected snapshot to be removed');\n-\t\tawait t.throwsAsync(fs.access(reportPath), {code: 'ENOENT'}, 'Expected report to be remove');\n-\t} else {\n-\t\t// Assert files exist\n-\t\tawait t.notThrowsAsync(fs.access(snapshotPath), 'Expected snapshot not to be removed');\n-\t\tawait t.notThrowsAsync(fs.access(reportPath), 'Expected report not to be removed');\n-\t}\n+\t\tif (remove) { // eslint-disable-line unicorn/prefer-ternary\n+\t\t\t// Assert files don't exist\n+\t\t\tawait Promise.all([\n+\t\t\t\tt.throwsAsync(fs.access(snapshotPath), {code: 'ENOENT'}, 'Expected snapshot to be removed'),\n+\t\t\t\tt.throwsAsync(fs.access(reportPath), {code: 'ENOENT'}, 'Expected report to be remove')\n+\t\t\t]);\n+\t\t} else {\n+\t\t\t// Assert files exist\n+\t\t\tawait Promise.all([\n+\t\t\t\tt.notThrowsAsync(fs.access(snapshotPath), 'Expected snapshot not to be removed'),\n+\t\t\t\tt.notThrowsAsync(fs.access(reportPath), 'Expected report not to be removed')\n+\t\t\t]);\n+\t\t}\n+\t});\n }\n \n module.exports.testSnapshotPruning = testSnapshotPruning;"
      },
      {
        "sha": "87a9cd5e71d68c20ee1d1a0ce9bd326f37d1317c",
        "filename": "test/snapshot-removal/snapshots/test.js.md",
        "status": "modified",
        "additions": 19,
        "deletions": 23,
        "changes": 42,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Fsnapshots%2Ftest.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Fsnapshots%2Ftest.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Fsnapshots%2Ftest.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -19,58 +19,54 @@ Generated by [AVA](https://avajs.dev).\n       },\n     ]\n \n-> files where snapshots could not be updated\n-\n-    []\n-\n ## snapshots remain if tests run with --match\n \n-> stderr\n-\n-    'Snapshots cannot be updated when matching specific tests.'\n-\n-## snapshots remain if tests selected by line numbers\n-\n-> stderr\n-\n-    'Snapshots cannot be updated when selecting specific tests by their line number.'\n-\n-## snapshots remain if using test.only\n-\n-> files where snapshots could not be updated\n+> passed tests\n \n     [\n       {\n         file: 'test.js',\n+        title: 'another snapshot',\n       },\n     ]\n \n-## snapshots remain if tests are skipped\n+## snapshots removed if --match selects all tests\n \n-> files where snapshots could not be updated\n+> passed tests\n \n     [\n       {\n         file: 'test.js',\n+        title: 'another snapshot',\n+      },\n+      {\n+        file: 'test.js',\n+        title: 'some snapshots',\n       },\n     ]\n \n-## snapshots remain if snapshot assertions are skipped\n+## snapshots remain if tests selected by line numbers\n \n-> files where snapshots could not be updated\n+> passed tests\n \n     [\n       {\n         file: 'test.js',\n+        title: 'some snapshots',\n       },\n     ]\n \n-## snapshots remain if skipped in a discarded try()\n+## snapshots removed if line numbers select all tests\n \n-> files where snapshots could not be updated\n+> passed tests\n \n     [\n       {\n         file: 'test.js',\n+        title: 'another snapshot',\n+      },\n+      {\n+        file: 'test.js',\n+        title: 'some snapshots',\n       },\n     ]"
      },
      {
        "sha": "0874c3c39b8aae2734824ab70b7918563d6ef25e",
        "filename": "test/snapshot-removal/snapshots/test.js.snap",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Fsnapshots%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Fsnapshots%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Fsnapshots%2Ftest.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "a2c8e7c5be55f9bfd69c64d6afc6f8eb51b0456c",
        "filename": "test/snapshot-removal/test.js",
        "status": "modified",
        "additions": 98,
        "deletions": 48,
        "changes": 146,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-removal%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-removal%2Ftest.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -1,52 +1,84 @@\n const test = require('@ava/test');\n const exec = require('../helpers/exec');\n-const {testSnapshotPruning, withTemporaryFixture} = require('./helpers/macros');\n+const {testSnapshotPruning} = require('./helpers/macros');\n+const {withTemporaryFixture} = require('../helpers/with-temporary-fixture');\n+const fs = require('fs').promises;\n const path = require('path');\n \n-const macro = withTemporaryFixture(testSnapshotPruning);\n+// To update the test fixture templates, run:\n+// npx test-ava test/snapshot-removal/** -- --update-fixture-snapshots\n \n-test('snapshots are removed when tests stop using them', macro, {\n+// Serial execution is used here solely to reduce the burden on CI machines.\n+\n+test.serial('snapshots are removed when tests stop using them', testSnapshotPruning, {\n \tcwd: exec.cwd('removal'),\n \tcli: ['--update-snapshots'],\n \tremove: true\n });\n \n-test('snapshots are removed from a snapshot directory', macro, {\n+test.serial('snapshots are removed from a snapshot directory', testSnapshotPruning, {\n \tcwd: exec.cwd('snapshot-dir'),\n \tcli: ['--update-snapshots'],\n \tremove: true,\n-\tsnapshotPath: path.join('test', 'snapshots', 'test.js.snap'),\n-\treportPath: path.join('test', 'snapshots', 'test.js.md')\n+\tsnapshotFile: path.join('test', 'snapshots', 'test.js.snap'),\n+\treportFile: path.join('test', 'snapshots', 'test.js.md')\n });\n \n-test('snapshots are removed from a custom snapshotDir', macro, {\n+test.serial('snapshots are removed from a custom snapshotDir', testSnapshotPruning, {\n \tcwd: exec.cwd('fixed-snapshot-dir'),\n \tcli: ['--update-snapshots'],\n \tremove: true,\n-\tsnapshotPath: path.join('fixedSnapshotDir', 'test.js.snap'),\n-\treportPath: path.join('fixedSnapshotDir', 'test.js.md')\n-});\n-\n-test('removing non-existent snapshots doesn\\'t throw', async t => {\n-\t// Execute fixture; this should try to unlink the nonexistent snapshots, and\n-\t// should not throw\n-\tconst run = exec.fixture(['--update-snapshots'], {\n-\t\tcwd: exec.cwd('no-snapshots'),\n-\t\tenv: {\n-\t\t\tAVA_FORCE_CI: 'not-ci'\n-\t\t}\n+\tsnapshotFile: path.join('fixedSnapshotDir', 'test.js.snap'),\n+\treportFile: path.join('fixedSnapshotDir', 'test.js.md')\n+});\n+\n+test.serial('removing non-existent snapshots doesn\\'t throw', async t => {\n+\tawait withTemporaryFixture(exec.cwd('no-snapshots'), async cwd => {\n+\t\t// Execute fixture; this should try to unlink the nonexistent snapshots, and\n+\t\t// should not throw\n+\t\tconst run = exec.fixture(['--update-snapshots'], {\n+\t\t\tcwd,\n+\t\t\tenv: {\n+\t\t\t\tAVA_FORCE_CI: 'not-ci'\n+\t\t\t}\n+\t\t});\n+\n+\t\tawait t.notThrowsAsync(run);\n+\t});\n+});\n+\n+test.serial('without --update-snapshots, invalid .snaps are retained', async t => {\n+\tawait withTemporaryFixture(exec.cwd('no-snapshots'), async cwd => {\n+\t\tconst snapPath = path.join(cwd, 'test.js.snap');\n+\t\tconst invalid = Buffer.of(0x0A, 0x00, 0x00);\n+\t\tawait fs.writeFile(snapPath, invalid);\n+\n+\t\tawait exec.fixture([], {cwd});\n+\n+\t\tawait t.notThrowsAsync(fs.access(snapPath));\n+\t\tt.deepEqual(await fs.readFile(snapPath), invalid);\n \t});\n+});\n+\n+test.serial('with --update-snapshots, invalid .snaps are removed', async t => {\n+\tawait withTemporaryFixture(exec.cwd('no-snapshots'), async cwd => {\n+\t\tconst snapPath = path.join(cwd, 'test.js.snap');\n+\t\tconst invalid = Buffer.of(0x0A, 0x00, 0x00);\n+\t\tawait fs.writeFile(snapPath, invalid);\n+\n+\t\tawait exec.fixture(['--update-snapshots'], {cwd});\n \n-\tawait t.notThrowsAsync(run);\n+\t\tawait t.throwsAsync(fs.access(snapPath), {code: 'ENOENT'}, 'Expected snapshot to be removed');\n+\t});\n });\n \n-test('snapshots remain if not updating', macro, {\n+test.serial('snapshots remain if not updating', testSnapshotPruning, {\n \tcwd: exec.cwd('removal'),\n \tcli: [],\n \tremove: false\n });\n \n-test('snapshots remain if they are still used', macro, {\n+test.serial('snapshots remain if they are still used', testSnapshotPruning, {\n \tcwd: exec.cwd('removal'),\n \tcli: ['--update-snapshots'],\n \tremove: false,\n@@ -57,77 +89,95 @@ test('snapshots remain if they are still used', macro, {\n \t\tawait t.notThrowsAsync(run, 'Expected fixture not to throw');\n \t\tconst result = await run;\n \t\tt.snapshot(result.stats.passed, 'passed tests');\n-\t\tt.snapshot(result.stats.unsavedSnapshots, 'files where snapshots could not be updated');\n \t}\n });\n \n-test('snapshots remain if tests run with --match', macro, {\n+test.serial('snapshots remain if tests run with --match', testSnapshotPruning, {\n \tcwd: exec.cwd('removal'),\n-\tcli: ['--update-snapshots', '--match=\\'*snapshot*\\''],\n+\tcli: ['--update-snapshots', '--match=\\'*another*\\''],\n \tremove: false,\n \tcheckRun: async (t, run) => {\n-\t\tconst result = await t.throwsAsync(run, undefined, 'Expected fixture to throw');\n-\t\tt.snapshot(exec.cleanOutput(result.stderr), 'stderr');\n+\t\tawait t.notThrowsAsync(run, 'Expected fixture not to throw');\n+\t\tconst result = await run;\n+\t\tt.snapshot(result.stats.passed, 'passed tests');\n \t}\n });\n \n-test('snapshots remain if tests selected by line numbers', macro, {\n+test.serial('snapshots removed if --match selects all tests', testSnapshotPruning, {\n \tcwd: exec.cwd('removal'),\n-\tcli: ['test.js:3-12', '--update-snapshots'],\n+\tcli: ['--update-snapshots', '--match=\\'*snapshot*\\''],\n+\tremove: true,\n+\tcheckRun: async (t, run) => {\n+\t\tawait t.notThrowsAsync(run, 'Expected fixture not to throw');\n+\t\tconst result = await run;\n+\t\tt.snapshot(result.stats.passed, 'passed tests');\n+\t}\n+});\n+\n+test.serial('snapshots remain if tests selected by line numbers', testSnapshotPruning, {\n+\tcwd: exec.cwd('removal'),\n+\tcli: ['test.js:10-17', '--update-snapshots'],\n \tremove: false,\n \tcheckRun: async (t, run) => {\n-\t\tconst result = await t.throwsAsync(run, undefined, 'Expected fixture to throw');\n-\t\tt.snapshot(exec.cleanOutput(result.stderr), 'stderr');\n+\t\tawait t.notThrowsAsync(run, 'Expected fixture not to throw');\n+\t\tconst result = await run;\n+\t\tt.snapshot(result.stats.passed, 'passed tests');\n \t}\n });\n \n-test('snapshots remain if using test.only', macro, {\n+test.serial('snapshots removed if line numbers select all tests', testSnapshotPruning, {\n+\tcwd: exec.cwd('removal'),\n+\tcli: ['test.js:0-100', '--update-snapshots'],\n+\tremove: true,\n+\tcheckRun: async (t, run) => {\n+\t\tawait t.notThrowsAsync(run, 'Expected fixture not to throw');\n+\t\tconst result = await run;\n+\t\tt.snapshot(result.stats.passed, 'passed tests');\n+\t}\n+});\n+\n+test.serial('snapshots remain if using test.only', testSnapshotPruning, {\n \tcwd: exec.cwd('only-test'),\n \tcli: ['--update-snapshots'],\n \tremove: false,\n \tcheckRun: async (t, run) => {\n \t\tawait t.notThrowsAsync(run, 'Expected fixture not to throw');\n-\t\tconst result = await run;\n-\t\tt.snapshot(result.stats.unsavedSnapshots, 'files where snapshots could not be updated');\n \t}\n });\n \n-test('snapshots remain if tests are skipped', macro, {\n+test.serial('snapshots remain if tests are skipped', testSnapshotPruning, {\n \tcwd: exec.cwd('skipped-tests'),\n \tcli: ['--update-snapshots'],\n \tremove: false,\n \tcheckRun: async (t, run) => {\n \t\tawait t.notThrowsAsync(run, 'Expected fixture not to throw');\n-\t\tconst result = await run;\n-\t\tt.snapshot(result.stats.unsavedSnapshots, 'files where snapshots could not be updated');\n \t}\n });\n \n-test('snapshots remain if snapshot assertions are skipped', macro, {\n+test.serial('snapshots remain if snapshot assertions are skipped', testSnapshotPruning, {\n \tcwd: exec.cwd('skipped-snapshots'),\n \tcli: ['--update-snapshots'],\n \tremove: false,\n \tcheckRun: async (t, run) => {\n-\t\tconst result = await t.throwsAsync(run, {\n-\t\t\tmessage: /Snapshot assertions cannot be skipped when updating snapshots/\n-\t\t}, 'Expected fixture to throw');\n-\t\tt.snapshot(result.stats.unsavedSnapshots, 'files where snapshots could not be updated');\n+\t\tawait t.notThrowsAsync(run, 'Expected fixture not to throw');\n \t}\n });\n \n-test('snapshots remain if used in a discarded try()', macro, {\n+// This behavior is consistent with the expectation that discarded attempts\n+// should have no effect.\n+test.serial('snapshots removed if used in a discarded try()', testSnapshotPruning, {\n \tcwd: exec.cwd('try'),\n \tcli: ['--update-snapshots'],\n-\tremove: false\n+\tremove: true\n });\n \n-test('snapshots remain if skipped in a discarded try()', macro, {\n+// This behavior is consistent with the expectation that discarded attempts\n+// should have no effect.\n+test.serial('snapshots removed if skipped in a discarded try()', testSnapshotPruning, {\n \tcwd: exec.cwd('skipped-snapshots-in-try'),\n \tcli: ['--update-snapshots'],\n-\tremove: false,\n+\tremove: true,\n \tcheckRun: async (t, run) => {\n \t\tawait t.notThrowsAsync(run, 'Expected fixture not to throw');\n-\t\tconst result = await run;\n-\t\tt.snapshot(result.stats.unsavedSnapshots, 'files where snapshots could not be updated');\n \t}\n });"
      },
      {
        "sha": "ad0db1061cd28aebbbbab56ad3c1410a6dd7f1ae",
        "filename": "test/snapshot-updates/fixtures/contains-only.js",
        "status": "removed",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/avajs/ava/blob/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-only.js",
        "raw_url": "https://github.com/avajs/ava/raw/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-only.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-only.js?ref=61ded90ce3a9217133cbe8409c3b52dd2934070c",
        "patch": "@@ -1,10 +0,0 @@\n-const test = require('ava');\n-\n-test('always failing snapshot', t => {\n-\tt.snapshot(Date.now());\n-});\n-\n-test.only('exclusive test', t => { // eslint-disable-line ava/no-only-test\n-\tt.pass();\n-});\n-"
      },
      {
        "sha": "349903a59f05791694f9db29c100db3fa641e4c0",
        "filename": "test/snapshot-updates/fixtures/contains-only.js.md",
        "status": "removed",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "blob_url": "https://github.com/avajs/ava/blob/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-only.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-only.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-only.js.md?ref=61ded90ce3a9217133cbe8409c3b52dd2934070c",
        "patch": "@@ -1,11 +0,0 @@\n-# Snapshot report for `contains-only.js`\n-\n-The actual snapshot is saved in `contains-only.js.snap`.\n-\n-Generated by [AVA](https://avajs.dev).\n-\n-## always failing snapshot\n-\n-> Snapshot 1\n-\n-    1592749428423"
      },
      {
        "sha": "9861ec0a6ac360ae2bffbf180025b4314ee7e550",
        "filename": "test/snapshot-updates/fixtures/contains-only.js.snap",
        "status": "removed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-only.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-only.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-only.js.snap?ref=61ded90ce3a9217133cbe8409c3b52dd2934070c"
      },
      {
        "sha": "960e344517a616faf7dfc2134f3603080a12aac1",
        "filename": "test/snapshot-updates/fixtures/contains-skip-assertion.js",
        "status": "removed",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/avajs/ava/blob/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-skip-assertion.js",
        "raw_url": "https://github.com/avajs/ava/raw/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-skip-assertion.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-skip-assertion.js?ref=61ded90ce3a9217133cbe8409c3b52dd2934070c",
        "patch": "@@ -1,10 +0,0 @@\n-const test = require('ava');\n-\n-test('always failing snapshot', t => {\n-\tt.snapshot(Date.now());\n-});\n-\n-test('skipped assertion', t => {\n-\tt.snapshot.skip(Date.now()); // eslint-disable-line ava/no-skip-assert\n-\tt.pass();\n-});"
      },
      {
        "sha": "009f68b792aec9956a4973f073ea9b3b09b8259a",
        "filename": "test/snapshot-updates/fixtures/contains-skip-assertion.js.md",
        "status": "removed",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "blob_url": "https://github.com/avajs/ava/blob/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-skip-assertion.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-skip-assertion.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-skip-assertion.js.md?ref=61ded90ce3a9217133cbe8409c3b52dd2934070c",
        "patch": "@@ -1,11 +0,0 @@\n-# Snapshot report for `contains-skip-assertion.js`\n-\n-The actual snapshot is saved in `contains-skip-assertion.js.snap`.\n-\n-Generated by [AVA](https://avajs.dev).\n-\n-## always failing snapshot\n-\n-> Snapshot 1\n-\n-    1607992742963"
      },
      {
        "sha": "4e5b373882185abd58e6697ef5803302b611f554",
        "filename": "test/snapshot-updates/fixtures/contains-skip-assertion.js.snap",
        "status": "removed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-skip-assertion.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-skip-assertion.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-skip-assertion.js.snap?ref=61ded90ce3a9217133cbe8409c3b52dd2934070c"
      },
      {
        "sha": "9c3b7c881771a2843648f6c086a509c8be68ed58",
        "filename": "test/snapshot-updates/fixtures/contains-skip.js",
        "status": "removed",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/avajs/ava/blob/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-skip.js",
        "raw_url": "https://github.com/avajs/ava/raw/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-skip.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-skip.js?ref=61ded90ce3a9217133cbe8409c3b52dd2934070c",
        "patch": "@@ -1,10 +0,0 @@\n-const test = require('ava');\n-\n-test('always failing snapshot', t => {\n-\tt.snapshot(Date.now());\n-});\n-\n-test.skip('skipped test', t => { // eslint-disable-line ava/no-skip-test\n-\tt.pass();\n-});\n-"
      },
      {
        "sha": "ad54a701f2af6ceea5e53564ec9d8b24b378c18b",
        "filename": "test/snapshot-updates/fixtures/contains-skip.js.md",
        "status": "removed",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "blob_url": "https://github.com/avajs/ava/blob/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-skip.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-skip.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-skip.js.md?ref=61ded90ce3a9217133cbe8409c3b52dd2934070c",
        "patch": "@@ -1,11 +0,0 @@\n-# Snapshot report for `contains-skip.js`\n-\n-The actual snapshot is saved in `contains-skip.js.snap`.\n-\n-Generated by [AVA](https://avajs.dev).\n-\n-## always failing snapshot\n-\n-> Snapshot 1\n-\n-    1592749428431"
      },
      {
        "sha": "20d65d330fa5ae7358a20a34f631ea88d5e0d4fa",
        "filename": "test/snapshot-updates/fixtures/contains-skip.js.snap",
        "status": "removed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-skip.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-skip.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-updates%2Ffixtures%2Fcontains-skip.js.snap?ref=61ded90ce3a9217133cbe8409c3b52dd2934070c"
      },
      {
        "sha": "f9b9cb835832615f252b8c1ecc0c3b77d9b0ad10",
        "filename": "test/snapshot-updates/fixtures/package.json",
        "status": "removed",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/avajs/ava/blob/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fpackage.json",
        "raw_url": "https://github.com/avajs/ava/raw/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ffixtures%2Fpackage.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-updates%2Ffixtures%2Fpackage.json?ref=61ded90ce3a9217133cbe8409c3b52dd2934070c",
        "patch": "@@ -1,7 +0,0 @@\n-{\n-  \"ava\": {\n-    \"files\": [\n-      \"*.js\"\n-    ]\n-  }\n-}"
      },
      {
        "sha": "c01fe5fab8b09e3b71c1f712e7d6de51a03b23e0",
        "filename": "test/snapshot-updates/snapshots/test.js.md",
        "status": "removed",
        "additions": 0,
        "deletions": 96,
        "changes": 96,
        "blob_url": "https://github.com/avajs/ava/blob/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Fsnapshots%2Ftest.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Fsnapshots%2Ftest.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-updates%2Fsnapshots%2Ftest.js.md?ref=61ded90ce3a9217133cbe8409c3b52dd2934070c",
        "patch": "@@ -1,96 +0,0 @@\n-# Snapshot report for `test/snapshot-updates/test.js`\n-\n-The actual snapshot is saved in `test.js.snap`.\n-\n-Generated by [AVA](https://avajs.dev).\n-\n-## cannot update snapshots when file contains skipped tests\n-\n-> failed tests\n-\n-    [\n-      {\n-        file: 'contains-skip.js',\n-        title: 'always failing snapshot',\n-      },\n-    ]\n-\n-> skipped tests\n-\n-    [\n-      {\n-        file: 'contains-skip.js',\n-        title: 'skipped test',\n-      },\n-    ]\n-\n-> files where snapshots could not be updated\n-\n-    [\n-      {\n-        file: 'contains-skip.js',\n-      },\n-    ]\n-\n-## cannot update snapshots when file contains exclusive tests\n-\n-> failed tests\n-\n-    []\n-\n-> passed tests\n-\n-    [\n-      {\n-        file: 'contains-only.js',\n-        title: 'exclusive test',\n-      },\n-    ]\n-\n-> files where snapshots could not be updated\n-\n-    [\n-      {\n-        file: 'contains-only.js',\n-      },\n-    ]\n-\n-## cannot update snapshots when matching test titles\n-\n-> Snapshot 1\n-\n-    'Snapshots cannot be updated when matching specific tests.'\n-\n-## cannot update snapshots when selecting tests by line number\n-\n-> Snapshot 1\n-\n-    'Snapshots cannot be updated when selecting specific tests by their line number.'\n-\n-## cannot update snapshots when skipping snapshot assertions\n-\n-> failed tests\n-\n-    [\n-      {\n-        file: 'contains-skip-assertion.js',\n-        title: 'skipped assertion',\n-      },\n-    ]\n-\n-> passed tests\n-\n-    [\n-      {\n-        file: 'contains-skip-assertion.js',\n-        title: 'always failing snapshot',\n-      },\n-    ]\n-\n-> files where snapshots could not be updated\n-\n-    [\n-      {\n-        file: 'contains-skip-assertion.js',\n-      },\n-    ]"
      },
      {
        "sha": "25527388ff8b8af702bf3f2909fe31121448cc81",
        "filename": "test/snapshot-updates/snapshots/test.js.snap",
        "status": "removed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Fsnapshots%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Fsnapshots%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-updates%2Fsnapshots%2Ftest.js.snap?ref=61ded90ce3a9217133cbe8409c3b52dd2934070c"
      },
      {
        "sha": "b93fb7120c1774bd4a52244aed168e1fec6f37c8",
        "filename": "test/snapshot-updates/test.js",
        "status": "removed",
        "additions": 0,
        "deletions": 33,
        "changes": 33,
        "blob_url": "https://github.com/avajs/ava/blob/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/61ded90ce3a9217133cbe8409c3b52dd2934070c/test%2Fsnapshot-updates%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-updates%2Ftest.js?ref=61ded90ce3a9217133cbe8409c3b52dd2934070c",
        "patch": "@@ -1,33 +0,0 @@\n-const test = require('@ava/test');\n-const exec = require('../helpers/exec');\n-\n-test('cannot update snapshots when file contains skipped tests', async t => {\n-\tconst result = await t.throwsAsync(exec.fixture(['contains-skip.js', '-u']));\n-\tt.snapshot(result.stats.failed, 'failed tests');\n-\tt.snapshot(result.stats.skipped, 'skipped tests');\n-\tt.snapshot(result.stats.unsavedSnapshots, 'files where snapshots could not be updated');\n-});\n-\n-test('cannot update snapshots when file contains exclusive tests', async t => {\n-\tconst result = await exec.fixture(['contains-only.js', '-u']);\n-\tt.snapshot(result.stats.failed, 'failed tests');\n-\tt.snapshot(result.stats.passed, 'passed tests');\n-\tt.snapshot(result.stats.unsavedSnapshots, 'files where snapshots could not be updated');\n-});\n-\n-test('cannot update snapshots when matching test titles', async t => {\n-\tconst result = await t.throwsAsync(exec.fixture(['contains-skip.js', '-u', '-m=snapshot']));\n-\tt.snapshot(exec.cleanOutput(result.stderr));\n-});\n-\n-test('cannot update snapshots when selecting tests by line number', async t => {\n-\tconst result = await t.throwsAsync(exec.fixture(['contains-skip.js:4', '-u']));\n-\tt.snapshot(exec.cleanOutput(result.stderr));\n-});\n-\n-test('cannot update snapshots when skipping snapshot assertions', async t => {\n-\tconst result = await t.throwsAsync(exec.fixture(['contains-skip-assertion.js', '-u'], {env: {AVA_FORCE_CI: 'not-ci'}}));\n-\tt.snapshot(result.stats.failed, 'failed tests');\n-\tt.snapshot(result.stats.passed, 'passed tests');\n-\tt.snapshot(result.stats.unsavedSnapshots, 'files where snapshots could not be updated');\n-});"
      },
      {
        "sha": "c8f2cf921e9a9e6f97f0249455ba96f84bb27f04",
        "filename": "test/snapshot-workflow/README.md",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2FREADME.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2FREADME.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2FREADME.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,23 @@\n+# Snapshot workflow tests\n+\n+These tests simulate various situations that may arise in the process of writing and maintaining snapshot-based tests.\n+\n+Most of these tests consist of a fixture containing test files that can be run in two ways (with or without `TEMPLATE=true`) to simulate a user making a change to their tests. Most fixtures also contain some initial snapshot state. The fixture is copied to a temporary directory AVA is invoked. The test then asserts that the snapshots were changed in the expected manner.\n+\n+## Updating test fixture snapshots\n+\n+When changes are made to the snapshot file format or to the fixtures themselves, it may be necessary to update the fixtures' initial states. To do this, pass `--update-fixture-snapshots` to the tests:\n+\n+```\n+npx test-ava test/snapshot-workflow/** -- --update-fixture-snapshots\n+```\n+\n+## Invariants\n+\n+1. All tests that use a fixture must initialize it in the same manner. Otherwise, they would overwrite eachothers' expected initial states.\n+    - Typically, initialization is done by the equivalent of running `TEMPLATE=true npx ava --update-snapshots` in the fixture directory.\n+    - Tests that require different initialization can set up their initial state _after_ copying the fixture to a temporary directory.\n+\n+## Serial execution\n+\n+Many tests in this suite are declared with `test.serial()`. This is typically done to spare CI machines the burden of many parallel `AVA` invocations, rather than because of shared dependencies."
      },
      {
        "sha": "ebbd7c252fdb341e674f785b1aafe7fbd0cdfd74",
        "filename": "test/snapshot-workflow/adding.js",
        "status": "added",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Fadding.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Fadding.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Fadding.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,68 @@\n+const test = require('@ava/test');\n+\n+const exec = require('../helpers/exec');\n+const path = require('path');\n+const fs = require('fs').promises;\n+const {beforeAndAfter} = require('./helpers/macros');\n+const {withTemporaryFixture} = require('../helpers/with-temporary-fixture');\n+\n+test.serial('First run generates a .snap and a .md', async t => {\n+\tawait withTemporaryFixture(exec.cwd('first-run'), async cwd => {\n+\t\tconst env = {\n+\t\t\tAVA_FORCE_CI: 'not-ci'\n+\t\t};\n+\n+\t\tawait exec.fixture([], {cwd, env});\n+\n+\t\tconst [, report] = await Promise.all([\n+\t\t\tt.notThrowsAsync(fs.access(path.join(cwd, 'test.js.snap'))),\n+\t\t\tfs.readFile(path.join(cwd, 'test.js.md'), 'utf8')\n+\t\t]);\n+\t\tt.snapshot(report, 'snapshot report');\n+\t});\n+});\n+\n+test.serial(\n+\t'Adding more snapshots to a test adds them to the .snap and .md',\n+\tbeforeAndAfter,\n+\t{\n+\t\tcwd: exec.cwd('adding-snapshots'),\n+\t\texpectChanged: true\n+\t}\n+);\n+\n+test.serial(\n+\t'Adding a test with snapshots adds them to the .snap and .md',\n+\tbeforeAndAfter,\n+\t{\n+\t\tcwd: exec.cwd('adding-test'),\n+\t\texpectChanged: true\n+\t}\n+);\n+\n+test.serial(\n+\t'Changing a test\\'s title adds a new block, puts the old block at the end',\n+\tbeforeAndAfter,\n+\t{\n+\t\tcwd: exec.cwd('changing-title'),\n+\t\texpectChanged: true\n+\t}\n+);\n+\n+test.serial(\n+\t'Adding skipped snapshots followed by unskipped snapshots records blanks',\n+\tbeforeAndAfter,\n+\t{\n+\t\tcwd: exec.cwd('adding-skipped-snapshots'),\n+\t\texpectChanged: true\n+\t}\n+);\n+\n+test.serial(\n+\t'Filling in blanks doesn\\'t require --update-snapshots',\n+\tbeforeAndAfter,\n+\t{\n+\t\tcwd: exec.cwd('filling-in-blanks'),\n+\t\texpectChanged: true\n+\t}\n+);"
      },
      {
        "sha": "948978bc7de7d09f80ea19933292a6afbad3349e",
        "filename": "test/snapshot-workflow/changing-label.js",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Fchanging-label.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Fchanging-label.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Fchanging-label.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,22 @@\n+const test = require('@ava/test');\n+const exec = require('../helpers/exec');\n+const {beforeAndAfter} = require('./helpers/macros');\n+\n+test.serial(\n+\t'Changing a snapshot\\'s label does not change the .snap or .md',\n+\tbeforeAndAfter,\n+\t{\n+\t\tcwd: exec.cwd('changing-label'),\n+\t\texpectChanged: false\n+\t}\n+);\n+\n+test.serial(\n+\t'With --update-snapshots, changing a snapshot\\'s label updates the .snap and .md',\n+\tbeforeAndAfter,\n+\t{\n+\t\tcwd: exec.cwd('changing-label'),\n+\t\tcli: ['--update-snapshots'],\n+\t\texpectChanged: true\n+\t}\n+);"
      },
      {
        "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
        "filename": "test/snapshot-workflow/fixtures/adding-skipped-snapshots/package.json",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-skipped-snapshots%2Fpackage.json",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-skipped-snapshots%2Fpackage.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-skipped-snapshots%2Fpackage.json?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1 @@\n+{}"
      },
      {
        "sha": "fd49d517dcd896c2820fd3461b45fc205a325684",
        "filename": "test/snapshot-workflow/fixtures/adding-skipped-snapshots/test.js",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-skipped-snapshots%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-skipped-snapshots%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-skipped-snapshots%2Ftest.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,10 @@\n+const test = require(process.env.AVA_PATH); // This fixture is copied to a temporary directory, so require AVA through its configured path.\n+\n+test('foo', t => {\n+\tt.snapshot({foo: 'one'});\n+\n+\tif (!process.env.TEMPLATE) {\n+\t\tt.snapshot.skip({foo: 'two'});\n+\t\tt.snapshot({foo: 'three'});\n+\t}\n+});"
      },
      {
        "sha": "0eb94478eb83495854b9114c8f809c23f7f2d559",
        "filename": "test/snapshot-workflow/fixtures/adding-skipped-snapshots/test.js.md",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-skipped-snapshots%2Ftest.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-skipped-snapshots%2Ftest.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-skipped-snapshots%2Ftest.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,13 @@\n+# Snapshot report for `test.js`\n+\n+The actual snapshot is saved in `test.js.snap`.\n+\n+Generated by [AVA](https://avajs.dev).\n+\n+## foo\n+\n+> Snapshot 1\n+\n+    {\n+      foo: 'one',\n+    }"
      },
      {
        "sha": "5be59ecb312ebab2b0a0448460eb0a9ad097414e",
        "filename": "test/snapshot-workflow/fixtures/adding-skipped-snapshots/test.js.snap",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-skipped-snapshots%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-skipped-snapshots%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-skipped-snapshots%2Ftest.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
        "filename": "test/snapshot-workflow/fixtures/adding-snapshots/package.json",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-snapshots%2Fpackage.json",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-snapshots%2Fpackage.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-snapshots%2Fpackage.json?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1 @@\n+{}"
      },
      {
        "sha": "f5417b28aede2686e44b5b90c17b9907de5ca5ee",
        "filename": "test/snapshot-workflow/fixtures/adding-snapshots/test.js",
        "status": "added",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-snapshots%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-snapshots%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-snapshots%2Ftest.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,9 @@\n+const test = require(process.env.AVA_PATH); // This fixture is copied to a temporary directory, so require AVA through its configured path.\n+\n+test('foo', t => {\n+\tt.snapshot({foo: 'one'});\n+\n+\tif (!process.env.TEMPLATE) {\n+\t\tt.snapshot({foo: 'two'});\n+\t}\n+});"
      },
      {
        "sha": "0eb94478eb83495854b9114c8f809c23f7f2d559",
        "filename": "test/snapshot-workflow/fixtures/adding-snapshots/test.js.md",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-snapshots%2Ftest.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-snapshots%2Ftest.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-snapshots%2Ftest.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,13 @@\n+# Snapshot report for `test.js`\n+\n+The actual snapshot is saved in `test.js.snap`.\n+\n+Generated by [AVA](https://avajs.dev).\n+\n+## foo\n+\n+> Snapshot 1\n+\n+    {\n+      foo: 'one',\n+    }"
      },
      {
        "sha": "5be59ecb312ebab2b0a0448460eb0a9ad097414e",
        "filename": "test/snapshot-workflow/fixtures/adding-snapshots/test.js.snap",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-snapshots%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-snapshots%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-snapshots%2Ftest.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
        "filename": "test/snapshot-workflow/fixtures/adding-test/package.json",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-test%2Fpackage.json",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-test%2Fpackage.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-test%2Fpackage.json?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1 @@\n+{}"
      },
      {
        "sha": "e00daa459a60ccd6d4c7ebb47cf34d3cc0bf71c1",
        "filename": "test/snapshot-workflow/fixtures/adding-test/test.js",
        "status": "added",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-test%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-test%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-test%2Ftest.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,11 @@\n+const test = require(process.env.AVA_PATH); // This fixture is copied to a temporary directory, so require AVA through its configured path.\n+\n+test('foo', t => {\n+\tt.snapshot({foo: 'one'});\n+});\n+\n+if (!process.env.TEMPLATE) {\n+\ttest('bar', t => {\n+\t\tt.snapshot({bar: 'one'});\n+\t});\n+}"
      },
      {
        "sha": "0eb94478eb83495854b9114c8f809c23f7f2d559",
        "filename": "test/snapshot-workflow/fixtures/adding-test/test.js.md",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-test%2Ftest.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-test%2Ftest.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-test%2Ftest.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,13 @@\n+# Snapshot report for `test.js`\n+\n+The actual snapshot is saved in `test.js.snap`.\n+\n+Generated by [AVA](https://avajs.dev).\n+\n+## foo\n+\n+> Snapshot 1\n+\n+    {\n+      foo: 'one',\n+    }"
      },
      {
        "sha": "5be59ecb312ebab2b0a0448460eb0a9ad097414e",
        "filename": "test/snapshot-workflow/fixtures/adding-test/test.js.snap",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-test%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-test%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fadding-test%2Ftest.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
        "filename": "test/snapshot-workflow/fixtures/changing-label/package.json",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-label%2Fpackage.json",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-label%2Fpackage.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-label%2Fpackage.json?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1 @@\n+{}"
      },
      {
        "sha": "671188798ce1035a55417e1031b6ccd60cc20a1d",
        "filename": "test/snapshot-workflow/fixtures/changing-label/test.js",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-label%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-label%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-label%2Ftest.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,5 @@\n+const test = require(process.env.AVA_PATH); // This fixture is copied to a temporary directory, so require AVA through its configured path.\n+\n+test('foo', t => {\n+\tt.snapshot({foo: 'one'}, process.env.TEMPLATE ? undefined : 'a new message');\n+});"
      },
      {
        "sha": "0eb94478eb83495854b9114c8f809c23f7f2d559",
        "filename": "test/snapshot-workflow/fixtures/changing-label/test.js.md",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-label%2Ftest.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-label%2Ftest.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-label%2Ftest.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,13 @@\n+# Snapshot report for `test.js`\n+\n+The actual snapshot is saved in `test.js.snap`.\n+\n+Generated by [AVA](https://avajs.dev).\n+\n+## foo\n+\n+> Snapshot 1\n+\n+    {\n+      foo: 'one',\n+    }"
      },
      {
        "sha": "5be59ecb312ebab2b0a0448460eb0a9ad097414e",
        "filename": "test/snapshot-workflow/fixtures/changing-label/test.js.snap",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-label%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-label%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-label%2Ftest.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
        "filename": "test/snapshot-workflow/fixtures/changing-title/package.json",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-title%2Fpackage.json",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-title%2Fpackage.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-title%2Fpackage.json?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1 @@\n+{}"
      },
      {
        "sha": "8f5821a7b15a7f114a5c330ade2bcfacf48292e0",
        "filename": "test/snapshot-workflow/fixtures/changing-title/test.js",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-title%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-title%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-title%2Ftest.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,5 @@\n+const test = require(process.env.AVA_PATH); // This fixture is copied to a temporary directory, so require AVA through its configured path.\n+\n+test(`a ${process.env.TEMPLATE ? '' : 'new '}title`, t => {\n+\tt.snapshot({foo: 'one'});\n+});"
      },
      {
        "sha": "98c62ae4d8b1c393faddf0294ea8172370cd8583",
        "filename": "test/snapshot-workflow/fixtures/changing-title/test.js.md",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-title%2Ftest.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-title%2Ftest.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-title%2Ftest.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,13 @@\n+# Snapshot report for `test.js`\n+\n+The actual snapshot is saved in `test.js.snap`.\n+\n+Generated by [AVA](https://avajs.dev).\n+\n+## a title\n+\n+> Snapshot 1\n+\n+    {\n+      foo: 'one',\n+    }"
      },
      {
        "sha": "0af5b0513cf910364e2ae1259b915d42ec5ebea1",
        "filename": "test/snapshot-workflow/fixtures/changing-title/test.js.snap",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-title%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-title%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fchanging-title%2Ftest.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
        "filename": "test/snapshot-workflow/fixtures/commit-skip/package.json",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fcommit-skip%2Fpackage.json",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fcommit-skip%2Fpackage.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fcommit-skip%2Fpackage.json?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1 @@\n+{}"
      },
      {
        "sha": "d40f4acfdc2bd6dd1364540b70e781c3f872a456",
        "filename": "test/snapshot-workflow/fixtures/commit-skip/test.js",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fcommit-skip%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fcommit-skip%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fcommit-skip%2Ftest.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,15 @@\n+const test = require(process.env.AVA_PATH); // This fixture is copied to a temporary directory, so require AVA through its configured path.\n+\n+test('commit a skipped snapshot', async t => {\n+\tt.snapshot(1);\n+\n+\tconst firstTry = await t.try(t => {\n+\t\tif (process.env.TEMPLATE) {\n+\t\t\tt.snapshot('before');\n+\t\t} else {\n+\t\t\tt.snapshot.skip('after');\n+\t\t}\n+\t});\n+\n+\tfirstTry.commit();\n+});"
      },
      {
        "sha": "c30917602872233aeea2d0ce81a8aa26da6a152b",
        "filename": "test/snapshot-workflow/fixtures/commit-skip/test.js.md",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fcommit-skip%2Ftest.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fcommit-skip%2Ftest.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fcommit-skip%2Ftest.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,15 @@\n+# Snapshot report for `test.js`\n+\n+The actual snapshot is saved in `test.js.snap`.\n+\n+Generated by [AVA](https://avajs.dev).\n+\n+## commit a skipped snapshot\n+\n+> Snapshot 1\n+\n+    1\n+\n+> Snapshot 2\n+\n+    'before'"
      },
      {
        "sha": "aa38bf8aa1d393b93064bcae96f47a394e569067",
        "filename": "test/snapshot-workflow/fixtures/commit-skip/test.js.snap",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fcommit-skip%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fcommit-skip%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fcommit-skip%2Ftest.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
        "filename": "test/snapshot-workflow/fixtures/discard-skip/package.json",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fdiscard-skip%2Fpackage.json",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fdiscard-skip%2Fpackage.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fdiscard-skip%2Fpackage.json?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1 @@\n+{}"
      },
      {
        "sha": "74b54a0aecf1425e949ffed6253d6ae7fedd3faa",
        "filename": "test/snapshot-workflow/fixtures/discard-skip/test.js",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fdiscard-skip%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fdiscard-skip%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fdiscard-skip%2Ftest.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,21 @@\n+const test = require(process.env.AVA_PATH); // This fixture is copied to a temporary directory, so require AVA through its configured path.\n+\n+test('discard a skipped snapshot', async t => {\n+\tt.snapshot(1);\n+\n+\tconst firstTry = await t.try(t => {\n+\t\tif (process.env.TEMPLATE) {\n+\t\t\tt.snapshot('before (first try)');\n+\t\t} else {\n+\t\t\tt.snapshot.skip('after (first try)');\n+\t\t}\n+\t});\n+\n+\tfirstTry.discard();\n+\n+\tconst secondTry = await t.try(t => {\n+\t\tt.snapshot(process.env.TEMPLATE ? 'before (second try)' : 'after (second try)');\n+\t});\n+\n+\tsecondTry.commit();\n+});"
      },
      {
        "sha": "05ee8adc9c237db51b3061f671d1dd3cb66ab1d7",
        "filename": "test/snapshot-workflow/fixtures/discard-skip/test.js.md",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fdiscard-skip%2Ftest.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fdiscard-skip%2Ftest.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fdiscard-skip%2Ftest.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,15 @@\n+# Snapshot report for `test.js`\n+\n+The actual snapshot is saved in `test.js.snap`.\n+\n+Generated by [AVA](https://avajs.dev).\n+\n+## discard a skipped snapshot\n+\n+> Snapshot 1\n+\n+    1\n+\n+> Snapshot 2\n+\n+    'before (second try)'"
      },
      {
        "sha": "43173e0e9aef110f25cb025418e21b9d52c83030",
        "filename": "test/snapshot-workflow/fixtures/discard-skip/test.js.snap",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fdiscard-skip%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Fdiscard-skip%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Fdiscard-skip%2Ftest.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
        "filename": "test/snapshot-workflow/fixtures/filling-in-blanks/package.json",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Ffilling-in-blanks%2Fpackage.json",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Ffilling-in-blanks%2Fpackage.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Ffilling-in-blanks%2Fpackage.json?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1 @@\n+{}"
      },
      {
        "sha": "143c190a4395e7cafc1937757d880b4adfb9419f",
        "filename": "test/snapshot-workflow/fixtures/filling-in-blanks/test.js",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Ffilling-in-blanks%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Ffilling-in-blanks%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Ffilling-in-blanks%2Ftest.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,13 @@\n+const test = require(process.env.AVA_PATH); // This fixture is copied to a temporary directory, so require AVA through its configured path.\n+\n+test('foo', t => {\n+\tt.snapshot({foo: 'one'});\n+\n+\tif (process.env.TEMPLATE) {\n+\t\tt.snapshot.skip({foo: 'two'});\n+\t} else {\n+\t\tt.snapshot({foo: 'two'});\n+\t}\n+\n+\tt.snapshot({foo: 'three'});\n+});"
      },
      {
        "sha": "639a9ba2b54e80eb5155c069729a621c59fdb118",
        "filename": "test/snapshot-workflow/fixtures/filling-in-blanks/test.js.md",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Ffilling-in-blanks%2Ftest.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Ffilling-in-blanks%2Ftest.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Ffilling-in-blanks%2Ftest.js.md?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,23 @@\n+# Snapshot report for `test.js`\n+\n+The actual snapshot is saved in `test.js.snap`.\n+\n+Generated by [AVA](https://avajs.dev).\n+\n+## foo\n+\n+> Snapshot 1\n+\n+    {\n+      foo: 'one',\n+    }\n+\n+> Snapshot 2\n+\n+    <No Data>\n+\n+> Snapshot 3\n+\n+    {\n+      foo: 'three',\n+    }"
      },
      {
        "sha": "9f96657ac8b2edaf1f3e40b89dfacff00a7f74f4",
        "filename": "test/snapshot-workflow/fixtures/filling-in-blanks/test.js.snap",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Ffilling-in-blanks%2Ftest.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Ffilling-in-blanks%2Ftest.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Ffilling-in-blanks%2Ftest.js.snap?ref=30f9f665e15b9f6b15777bed622d28f9bd594955"
      },
      {
        "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
        "filename": "test/snapshot-workflow/fixtures/first-run/package.json",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Ffirst-run%2Fpackage.json",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Ffirst-run%2Fpackage.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Ffirst-run%2Fpackage.json?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1 @@\n+{}"
      },
      {
        "sha": "ffbc6ff77db3c46581c5c70c2a367717088faaf2",
        "filename": "test/snapshot-workflow/fixtures/first-run/test.js",
        "status": "added",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/avajs/ava/blob/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Ffirst-run%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/30f9f665e15b9f6b15777bed622d28f9bd594955/test%2Fsnapshot-workflow%2Ffixtures%2Ffirst-run%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsnapshot-workflow%2Ffixtures%2Ffirst-run%2Ftest.js?ref=30f9f665e15b9f6b15777bed622d28f9bd594955",
        "patch": "@@ -0,0 +1,14 @@\n+const test = require(process.env.AVA_PATH); // This fixture is copied to a temporary directory, so require AVA through its configured path.\n+\n+test('foo', t => {\n+\tt.snapshot({foo: 'one'});\n+});\n+\n+test('bar', t => {\n+\tt.pass();\n+});\n+\n+test('baz', t => {\n+\tt.snapshot({baz: 'one'}, 'a message');\n+\tt.snapshot({baz: 'two'});\n+});"
      }
    ]
  },
  {
    "url": "https://api.github.com/repos/avajs/ava/issues/1947",
    "repository_url": "https://api.github.com/repos/avajs/ava",
    "labels_url": "https://api.github.com/repos/avajs/ava/issues/1947/labels{/name}",
    "comments_url": "https://api.github.com/repos/avajs/ava/issues/1947/comments",
    "events_url": "https://api.github.com/repos/avajs/ava/issues/1947/events",
    "html_url": "https://github.com/avajs/ava/pull/1947",
    "id": 367502273,
    "node_id": "MDExOlB1bGxSZXF1ZXN0MjIwOTE1NTk1",
    "number": 1947,
    "title": "Add try-commit to test assertions",
    "user": {
      "login": "qlonik",
      "id": 1373271,
      "node_id": "MDQ6VXNlcjEzNzMyNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1373271?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/qlonik",
      "html_url": "https://github.com/qlonik",
      "followers_url": "https://api.github.com/users/qlonik/followers",
      "following_url": "https://api.github.com/users/qlonik/following{/other_user}",
      "gists_url": "https://api.github.com/users/qlonik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/qlonik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/qlonik/subscriptions",
      "organizations_url": "https://api.github.com/users/qlonik/orgs",
      "repos_url": "https://api.github.com/users/qlonik/repos",
      "events_url": "https://api.github.com/users/qlonik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/qlonik/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 41,
    "created_at": "2018-10-06T22:42:28Z",
    "updated_at": "2019-09-15T18:08:02Z",
    "closed_at": "2019-09-08T19:37:34Z",
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "draft": false,
    "pull_request": {
      "url": "https://api.github.com/repos/avajs/ava/pulls/1947",
      "html_url": "https://github.com/avajs/ava/pull/1947",
      "diff_url": "https://github.com/avajs/ava/pull/1947.diff",
      "patch_url": "https://github.com/avajs/ava/pull/1947.patch",
      "merged_at": "2019-09-08T19:37:34Z"
    },
    "body": "Hello. Some time ago there was a discussion in the #1692 issue. I tried to look around the code and see what could be done. I tried doing this but I'm not sure if it is the best solution.\r\n\r\nThis method creates new instance of `Test` class and runs the attempted assertion as part of that and then it updates main test if the attempted test passes or fails.\r\nThere were suggestions in the issue to create some `Host` class, which `Test` class will extend. Such `Host` class will only care about running assertions, while `Test` class will care about counting assertions and taking care of snapshots. I tried with `Host` class at first, however, I found that assertions are getting bound to the `Test`, and I was not sure which parts of `Test` need to be moved to `Host` and which can stay, without breaking assertions.\r\nAlso, creating new `Host` class, would require to re-implement the `run()` function and all of the edge cases, which are already figured out in the current implementation of `Test()`.\r\n\r\nThere were also mentions about taking care of `plan()` assertion and about recursiveness of `try()` assertion. Also, snapshots were excluded from discussion, but I think they should be talked about too.\r\nSince the current implementation of `Test` can handle all of these cases, it means reusing `Test` class as an instance for `try()` function should allow for those three things to work. There was also a comment about supporting the `.discard()` on promise returned from `.try()`, which is also added.\r\n\r\nWith the current implementation, each attempt has to be explicitly either accepted with `.commit()` or declined with `.discard()`. When the result is committed to, it increase assertion counter and copies the log of the attempt into main test. When the result is discarded, the assertion counter is not increased. It seems that it would be possible to remove explicit discard on the attempt result. However, in that case, there will be a requirement that user need to have at least one call to `.commit()` in order to pass the test.\r\n\r\nI'm open to some suggestions about current implementation and to guidance how to make `Host` class work, if this is more desirable way.\r\n\r\nExample usages with current implementation:\r\n```js\r\nconst twoRndInts = () => {\r\n  const rnd = Math.round(Math.random() * 100);\r\n  const x = rnd % 10;\r\n  const y = Math.floor(rnd / 10);\r\n  return [x, y];\r\n};\r\n\r\ntest('test', async t => {\r\n\r\n  const result = await t.try((t, a, b) => {\r\n    t.is(a, b);\r\n  }, ...twoRndInts());\r\n\r\n  if (result.passed) {\r\n    result.commit();\r\n  } else {\r\n    t.log(result.error);\r\n    result.discard();\r\n\r\n    const result1 = await t.try((t, a, b) => {\r\n      t.is(a, b);\r\n    }, ...twoRndInts());\r\n\r\n    result1.commit();\r\n  }\r\n});\r\n\r\n// EDIT: the following usage scenario with discarding incomplete attempt is not supported\r\ntest('test2', t => {\r\n  const result = t.try((t, a, b) => {  // <-- result here is a pending promise\r\n    return new Promise(res => setTimeout(res, 1000))\r\n      .then(() => t.is(a, b));\r\n  }, ...twoRndInts());\r\n\r\n  return new Promise(res => setTimeout(res, 100))\r\n    .then(() => {\r\n      result.discard();\r\n    });\r\n});\r\n```\r\n\r\n## TODO:\r\n\r\n(Updated from https://github.com/avajs/ava/pull/1947#issuecomment-462152014)\r\n\r\n- [x] Test the context (`t.context`)\r\n- [x] Update test assertCount with the number of assertions made within a committed attempt\r\n- [x] Add support of macros passed to try fn\r\n- [x] Type t.try() so it accepts macros\r\n- [x] Investigate refactor so attempts don't need to instantiate a new Test\r\n    - [x] If not possible, add metadata to indicate the test is \"inline\" and adjust handling of test.failing() and t.end() based on that\r\n- [x] Revisit how attempt titles are generated\r\n- [x] Ensure snapshots created in each attempt start at the correct invocation count\r\n- [x] Fail the test if concurrent attempts that created snapshots are committed\r\n- [x] Move try-commit tests into its own file\r\n- [ ] Determine documented properties of AssertionError and add to type definitions\r\n- [x] Update Flow definition\r\n- [ ] Update ESLint plugin to recognize the assertion\r\n- [ ] File issue to discuss suggested argument name (tt?) for inline functions, and update power-assert     \r\n   - [ ] rewrite rules to handle it\r\n- [x] Review test coverage\r\n- [ ] Update documentation\r\n\r\n<!--\r\n\r\nRead the [contributing guidelines](https://github.com/avajs/ava/blob/master/contributing.md). We are excited about pull requests, but please try to limit the scope, provide a general description of the changes, and remember, it's up to you to convince us to land it. If this fixes an open issue, link to it in the following way: `Fixes #321`. New features and bug fixes should come with tests.\r\n\r\n-->\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/avajs/ava/issues/1947/reactions",
      "total_count": 4,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 3,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/avajs/ava/issues/1947/timeline",
    "performed_via_github_app": null,
    "state_reason": null,
    "score": 1,
    "files": [
      {
        "sha": "8b08af3366efd35d78b88a7e5510bf5424a92685",
        "filename": "docs/06-configuration.md",
        "status": "modified",
        "additions": 11,
        "deletions": 2,
        "changes": 13,
        "blob_url": "https://github.com/avajs/ava/blob/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/docs%2F06-configuration.md",
        "raw_url": "https://github.com/avajs/ava/raw/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/docs%2F06-configuration.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/docs%2F06-configuration.md?ref=2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17",
        "patch": "@@ -164,7 +164,7 @@ AVA has a minimum depth of `3`.\n \n ## Experiments\n \n-From time to time, AVA will implement experimental features. These may change or be removed at any time, not just when there's a new major version. You can opt-in to such a feature by enabling it in the `nonSemVerExperiments` configuration.\n+From time to time, AVA will implement experimental features. These may change or be removed at any time, not just when there's a new major version. You can opt in to such a feature by enabling it in the `nonSemVerExperiments` configuration.\n \n `ava.config.js`:\n ```js\n@@ -175,6 +175,15 @@ export default {\n };\n ```\n \n-There are currently no such features available.\n+You can opt in to the new `t.try()` assertion by specifying `tryAssertion`:\n+\n+`ava.config.js`:\n+```js\n+export default {\n+\tnonSemVerExperiments: {\n+\t\ttryAssertion: true\n+\t}\n+};\n+```\n \n [CLI]: ./05-command-line.md"
      },
      {
        "sha": "35b34e983f5fd977a057100ec7d5bd42178e1263",
        "filename": "index.d.ts",
        "status": "modified",
        "additions": 71,
        "deletions": 0,
        "changes": 71,
        "blob_url": "https://github.com/avajs/ava/blob/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/index.d.ts",
        "raw_url": "https://github.com/avajs/ava/raw/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/index.d.ts",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/index.d.ts?ref=2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17",
        "patch": "@@ -25,6 +25,13 @@ export type ThrowsExpectation = {\n \tname?: string;\n };\n \n+export type CommitDiscardOptions = {\n+\t/**\n+\t * Whether the logs should be included in those of the parent test.\n+\t */\n+\tretainLogs?: boolean\n+}\n+\n /** Options that can be passed to the `t.snapshot()` assertion. */\n export type SnapshotOptions = {\n \t/** If provided and not an empty string, used to select the snapshot to compare the `expected` value against. */\n@@ -363,6 +370,7 @@ export interface ExecutionContext<Context = unknown> extends Assertions {\n \tlog: LogFn;\n \tplan: PlanFn;\n \ttimeout: TimeoutFn;\n+\ttry: TryFn<Context>;\n }\n \n export interface LogFn {\n@@ -392,6 +400,69 @@ export interface TimeoutFn {\n \t(ms: number): void;\n }\n \n+export interface TryFn<Context = unknown> {\n+\t/**\n+\t * Requires opt-in. Attempt to run some assertions. The result must be explicitly committed or discarded or else\n+\t * the test will fail. A macro may be provided. The title may help distinguish attempts from\n+\t * one another.\n+\t */\n+\t<Args extends any[]>(title: string, fn: EitherMacro<Args, Context>, ...args: Args): Promise<TryResult>;\n+\n+\t/**\n+\t* Requires opt-in. Attempt to run some assertions. The result must be explicitly committed or discarded or else\n+\t * the test will fail. A macro may be provided. The title may help distinguish attempts from\n+\t * one another.\n+\t */\n+\t<Args extends any[]>(title: string, fn: [EitherMacro<Args, Context>, ...EitherMacro<Args, Context>[]], ...args: Args): Promise<TryResult[]>;\n+\n+\t/**\n+\t* Requires opt-in. Attempt to run some assertions. The result must be explicitly committed or discarded or else\n+\t* the test will fail. A macro may be provided.\n+\t*/\n+\t<Args extends any[]>(fn: EitherMacro<Args, Context>, ...args: Args): Promise<TryResult>;\n+\n+\t/**\n+\t* Requires opt-in. Attempt to run some assertions. The result must be explicitly committed or discarded or else\n+\t* the test will fail. A macro may be provided.\n+\t*/\n+\t<Args extends any[]>(fn: [EitherMacro<Args, Context>, ...EitherMacro<Args, Context>[]], ...args: Args): Promise<TryResult[]>;\n+}\n+\n+export interface AssertionError extends Error {}\n+\n+export interface TryResult {\n+\t/**\n+\t* Title of the attempt, helping you tell attempts aparts.\n+\t*/\n+\ttitle: string;\n+\n+\t/**\n+\t* Indicates whether all assertions passed, or at least one failed.\n+\t*/\n+\tpassed: boolean;\n+\n+\t/**\n+\t* Errors raised for each failed assertion.\n+\t*/\n+\terrors: AssertionError[];\n+\n+\t/**\n+\t * Logs created during the attempt using `t.log()`. Contains formatted values.\n+\t */\n+\tlogs: string[];\n+\n+\t/**\n+\t * Commit the attempt. Counts as one assertion for the plan count. If the\n+\t * attempt failed, calling this will also cause your test to fail.\n+\t */\n+\tcommit(options?: CommitDiscardOptions): void;\n+\n+\t/**\n+\t * Discard the attempt.\n+\t */\n+\tdiscard(options?: CommitDiscardOptions): void;\n+}\n+\n /** The `t` value passed to implementations for tests & hooks declared with the `.cb` modifier. */\n export interface CbExecutionContext<Context = unknown> extends ExecutionContext<Context> {\n \t/**"
      },
      {
        "sha": "17cf53dc0c5416c8a566b4466519b9b7e8d4787c",
        "filename": "lib/load-config.js",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/lib%2Fload-config.js",
        "raw_url": "https://github.com/avajs/ava/raw/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/lib%2Fload-config.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fload-config.js?ref=2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17",
        "patch": "@@ -6,7 +6,7 @@ const pkgConf = require('pkg-conf');\n \n const NO_SUCH_FILE = Symbol('no ava.config.js file');\n const MISSING_DEFAULT_EXPORT = Symbol('missing default export');\n-const EXPERIMENTS = new Set([]);\n+const EXPERIMENTS = new Set(['tryAssertion']);\n \n function loadConfig({configFile, resolveFrom = process.cwd(), defaults = {}} = {}) { // eslint-disable-line complexity\n \tlet packageConf = pkgConf.sync('ava', {cwd: resolveFrom});"
      },
      {
        "sha": "5ea5f0aa47cb1c9034a88d5395a5ff96f2334a66",
        "filename": "lib/parse-test-args.js",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/avajs/ava/blob/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/lib%2Fparse-test-args.js",
        "raw_url": "https://github.com/avajs/ava/raw/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/lib%2Fparse-test-args.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fparse-test-args.js?ref=2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17",
        "patch": "@@ -0,0 +1,15 @@\n+'use strict';\n+function parseTestArgs(args) {\n+\tconst rawTitle = typeof args[0] === 'string' ? args.shift() : undefined;\n+\tconst receivedImplementationArray = Array.isArray(args[0]);\n+\tconst implementations = receivedImplementationArray ? args.shift() : args.splice(0, 1);\n+\n+\tconst buildTitle = implementation => {\n+\t\tconst title = implementation.title ? implementation.title(rawTitle, ...args) : rawTitle;\n+\t\treturn {title, isSet: typeof title !== 'undefined', isValid: typeof title === 'string', isEmpty: !title};\n+\t};\n+\n+\treturn {args, buildTitle, implementations, rawTitle, receivedImplementationArray};\n+}\n+\n+module.exports = parseTestArgs;"
      },
      {
        "sha": "cfb9cdcde9a15d1d1a3fc5765ee503b62e40fddf",
        "filename": "lib/runner.js",
        "status": "modified",
        "additions": 29,
        "deletions": 27,
        "changes": 56,
        "blob_url": "https://github.com/avajs/ava/blob/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/lib%2Frunner.js",
        "raw_url": "https://github.com/avajs/ava/raw/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/lib%2Frunner.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Frunner.js?ref=2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17",
        "patch": "@@ -3,6 +3,7 @@ const Emittery = require('emittery');\n const matcher = require('matcher');\n const ContextRef = require('./context-ref');\n const createChain = require('./create-chain');\n+const parseTestArgs = require('./parse-test-args');\n const snapshotManager = require('./snapshot-manager');\n const serializeError = require('./serialize-error');\n const Runnable = require('./test');\n@@ -11,6 +12,7 @@ class Runner extends Emittery {\n \tconstructor(options = {}) {\n \t\tsuper();\n \n+\t\tthis.experiments = options.experiments || {};\n \t\tthis.failFast = options.failFast === true;\n \t\tthis.failWithoutAssertions = options.failWithoutAssertions !== false;\n \t\tthis.file = options.file;\n@@ -39,12 +41,21 @@ class Runner extends Emittery {\n \t\t};\n \n \t\tconst uniqueTestTitles = new Set();\n+\t\tthis.registerUniqueTitle = title => {\n+\t\t\tif (uniqueTestTitles.has(title)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\tuniqueTestTitles.add(title);\n+\t\t\treturn true;\n+\t\t};\n+\n \t\tlet hasStarted = false;\n \t\tlet scheduledStart = false;\n \t\tconst meta = Object.freeze({\n \t\t\tfile: options.file\n \t\t});\n-\t\tthis.chain = createChain((metadata, args) => { // eslint-disable-line complexity\n+\t\tthis.chain = createChain((metadata, testArgs) => { // eslint-disable-line complexity\n \t\t\tif (hasStarted) {\n \t\t\t\tthrow new Error('All tests and hooks must be declared synchronously in your test file, and cannot be nested within other tests or hooks.');\n \t\t\t}\n@@ -57,40 +68,33 @@ class Runner extends Emittery {\n \t\t\t\t});\n \t\t\t}\n \n-\t\t\tconst specifiedTitle = typeof args[0] === 'string' ?\n-\t\t\t\targs.shift() :\n-\t\t\t\tundefined;\n-\t\t\tconst implementations = Array.isArray(args[0]) ?\n-\t\t\t\targs.shift() :\n-\t\t\t\targs.splice(0, 1);\n+\t\t\tconst {args, buildTitle, implementations, rawTitle} = parseTestArgs(testArgs);\n \n \t\t\tif (metadata.todo) {\n \t\t\t\tif (implementations.length > 0) {\n \t\t\t\t\tthrow new TypeError('`todo` tests are not allowed to have an implementation. Use `test.skip()` for tests with an implementation.');\n \t\t\t\t}\n \n-\t\t\t\tif (specifiedTitle === undefined || specifiedTitle === '') {\n+\t\t\t\tif (!rawTitle) { // Either undefined or a string.\n \t\t\t\t\tthrow new TypeError('`todo` tests require a title');\n \t\t\t\t}\n \n-\t\t\t\tif (uniqueTestTitles.has(specifiedTitle)) {\n-\t\t\t\t\tthrow new Error(`Duplicate test title: ${specifiedTitle}`);\n-\t\t\t\t} else {\n-\t\t\t\t\tuniqueTestTitles.add(specifiedTitle);\n+\t\t\t\tif (!this.registerUniqueTitle(rawTitle)) {\n+\t\t\t\t\tthrow new Error(`Duplicate test title: ${rawTitle}`);\n \t\t\t\t}\n \n \t\t\t\tif (this.match.length > 0) {\n \t\t\t\t\t// --match selects TODO tests.\n-\t\t\t\t\tif (matcher([specifiedTitle], this.match).length === 1) {\n+\t\t\t\t\tif (matcher([rawTitle], this.match).length === 1) {\n \t\t\t\t\t\tmetadata.exclusive = true;\n \t\t\t\t\t\tthis.runOnlyExclusive = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \n-\t\t\t\tthis.tasks.todo.push({title: specifiedTitle, metadata});\n+\t\t\t\tthis.tasks.todo.push({title: rawTitle, metadata});\n \t\t\t\tthis.emit('stateChange', {\n \t\t\t\t\ttype: 'declared-test',\n-\t\t\t\t\ttitle: specifiedTitle,\n+\t\t\t\t\ttitle: rawTitle,\n \t\t\t\t\tknownFailing: false,\n \t\t\t\t\ttodo: true\n \t\t\t\t});\n@@ -100,15 +104,13 @@ class Runner extends Emittery {\n \t\t\t\t}\n \n \t\t\t\tfor (const implementation of implementations) {\n-\t\t\t\t\tlet title = implementation.title ?\n-\t\t\t\t\t\timplementation.title(specifiedTitle, ...args) :\n-\t\t\t\t\t\tspecifiedTitle;\n+\t\t\t\t\tlet {title, isSet, isValid, isEmpty} = buildTitle(implementation);\n \n-\t\t\t\t\tif (title !== undefined && typeof title !== 'string') {\n+\t\t\t\t\tif (isSet && !isValid) {\n \t\t\t\t\t\tthrow new TypeError('Test & hook titles must be strings');\n \t\t\t\t\t}\n \n-\t\t\t\t\tif (title === undefined || title === '') {\n+\t\t\t\t\tif (isEmpty) {\n \t\t\t\t\t\tif (metadata.type === 'test') {\n \t\t\t\t\t\t\tthrow new TypeError('Tests must have a title');\n \t\t\t\t\t\t} else if (metadata.always) {\n@@ -118,12 +120,8 @@ class Runner extends Emittery {\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n-\t\t\t\t\tif (metadata.type === 'test') {\n-\t\t\t\t\t\tif (uniqueTestTitles.has(title)) {\n-\t\t\t\t\t\t\tthrow new Error(`Duplicate test title: ${title}`);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tuniqueTestTitles.add(title);\n-\t\t\t\t\t\t}\n+\t\t\t\t\tif (metadata.type === 'test' && !this.registerUniqueTitle(title)) {\n+\t\t\t\t\t\tthrow new Error(`Duplicate test title: ${title}`);\n \t\t\t\t\t}\n \n \t\t\t\t\tconst task = {\n@@ -162,6 +160,7 @@ class Runner extends Emittery {\n \t\t\ttodo: false,\n \t\t\tfailing: false,\n \t\t\tcallback: false,\n+\t\t\tinline: false, // Set for attempt metadata created by `t.try()`\n \t\t\talways: false\n \t\t}, meta);\n \t}\n@@ -269,6 +268,7 @@ class Runner extends Emittery {\n \tasync runHooks(tasks, contextRef, titleSuffix) {\n \t\tconst hooks = tasks.map(task => new Runnable({\n \t\t\tcontextRef,\n+\t\t\texperiments: this.experiments,\n \t\t\tfailWithoutAssertions: false,\n \t\t\tfn: task.args.length === 0 ?\n \t\t\t\ttask.implementation :\n@@ -309,14 +309,16 @@ class Runner extends Emittery {\n \t\t\t// Only run the test if all `beforeEach` hooks passed.\n \t\t\tconst test = new Runnable({\n \t\t\t\tcontextRef,\n+\t\t\t\texperiments: this.experiments,\n \t\t\t\tfailWithoutAssertions: this.failWithoutAssertions,\n \t\t\t\tfn: task.args.length === 0 ?\n \t\t\t\t\ttask.implementation :\n \t\t\t\t\tt => task.implementation.apply(null, [t].concat(task.args)),\n \t\t\t\tcompareTestSnapshot: this.boundCompareTestSnapshot,\n \t\t\t\tupdateSnapshots: this.updateSnapshots,\n \t\t\t\tmetadata: task.metadata,\n-\t\t\t\ttitle: task.title\n+\t\t\t\ttitle: task.title,\n+\t\t\t\tregisterUniqueTitle: this.registerUniqueTitle\n \t\t\t});\n \n \t\t\tconst result = await this.runSingle(test);"
      },
      {
        "sha": "2fed69aef9bd0b39616bf4e88695744716b88eed",
        "filename": "lib/snapshot-manager.js",
        "status": "modified",
        "additions": 39,
        "deletions": 20,
        "changes": 59,
        "blob_url": "https://github.com/avajs/ava/blob/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/lib%2Fsnapshot-manager.js",
        "raw_url": "https://github.com/avajs/ava/raw/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/lib%2Fsnapshot-manager.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fsnapshot-manager.js?ref=2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17",
        "patch": "@@ -305,45 +305,64 @@ class Manager {\n \tcompare(options) {\n \t\tconst hash = md5Hex(options.belongsTo);\n \t\tconst entries = this.snapshotsByHash.get(hash) || [];\n-\t\tif (options.index > entries.length) {\n-\t\t\tthrow new RangeError(`Cannot record snapshot ${options.index} for ${JSON.stringify(options.belongsTo)}, exceeds expected index of ${entries.length}`);\n-\t\t}\n+\t\tconst snapshotBuffer = entries[options.index];\n \n-\t\tif (options.index === entries.length) {\n+\t\tif (!snapshotBuffer) {\n \t\t\tif (!this.recordNewSnapshots) {\n \t\t\t\treturn {pass: false};\n \t\t\t}\n \n+\t\t\tif (options.deferRecording) {\n+\t\t\t\tconst record = this.deferRecord(hash, options);\n+\t\t\t\treturn {pass: true, record};\n+\t\t\t}\n+\n \t\t\tthis.record(hash, options);\n \t\t\treturn {pass: true};\n \t\t}\n \n-\t\tconst snapshotBuffer = entries[options.index];\n \t\tconst actual = concordance.deserialize(snapshotBuffer, concordanceOptions);\n-\n \t\tconst expected = concordance.describe(options.expected, concordanceOptions);\n \t\tconst pass = concordance.compareDescriptors(actual, expected);\n \n \t\treturn {actual, expected, pass};\n \t}\n \n-\trecord(hash, options) {\n+\tdeferRecord(hash, options) {\n \t\tconst descriptor = concordance.describe(options.expected, concordanceOptions);\n-\n-\t\tthis.hasChanges = true;\n \t\tconst snapshot = concordance.serialize(descriptor);\n-\t\tif (this.snapshotsByHash.has(hash)) {\n-\t\t\tthis.snapshotsByHash.get(hash).push(snapshot);\n-\t\t} else {\n-\t\t\tthis.snapshotsByHash.set(hash, [snapshot]);\n-\t\t}\n-\n \t\tconst entry = formatEntry(options.label, descriptor);\n-\t\tif (this.reportEntries.has(options.belongsTo)) {\n-\t\t\tthis.reportEntries.get(options.belongsTo).push(entry);\n-\t\t} else {\n-\t\t\tthis.reportEntries.set(options.belongsTo, [entry]);\n-\t\t}\n+\n+\t\treturn () => { // Must be called in order!\n+\t\t\tthis.hasChanges = true;\n+\n+\t\t\tlet snapshots = this.snapshotsByHash.get(hash);\n+\t\t\tif (!snapshots) {\n+\t\t\t\tsnapshots = [];\n+\t\t\t\tthis.snapshotsByHash.set(hash, snapshots);\n+\t\t\t}\n+\n+\t\t\tif (options.index > snapshots.length) {\n+\t\t\t\tthrow new RangeError(`Cannot record snapshot ${options.index} for ${JSON.stringify(options.belongsTo)}, exceeds expected index of ${snapshots.length}`);\n+\t\t\t}\n+\n+\t\t\tif (options.index < snapshots.length) {\n+\t\t\t\tthrow new RangeError(`Cannot record snapshot ${options.index} for ${JSON.stringify(options.belongsTo)}, already exists`);\n+\t\t\t}\n+\n+\t\t\tsnapshots.push(snapshot);\n+\n+\t\t\tif (this.reportEntries.has(options.belongsTo)) {\n+\t\t\t\tthis.reportEntries.get(options.belongsTo).push(entry);\n+\t\t\t} else {\n+\t\t\t\tthis.reportEntries.set(options.belongsTo, [entry]);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\trecord(hash, options) {\n+\t\tconst record = this.deferRecord(hash, options);\n+\t\trecord();\n \t}\n \n \tsave() {"
      },
      {
        "sha": "303e0d2e71d0e33b90fe8ebd39c27d40870388bb",
        "filename": "lib/test.js",
        "status": "modified",
        "additions": 221,
        "deletions": 15,
        "changes": 236,
        "blob_url": "https://github.com/avajs/ava/blob/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/lib%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/lib%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Ftest.js?ref=2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17",
        "patch": "@@ -6,6 +6,7 @@ const isObservable = require('is-observable');\n const plur = require('plur');\n const assert = require('./assert');\n const nowAndTimers = require('./now-and-timers');\n+const parseTestArgs = require('./parse-test-args');\n const concordanceOptions = require('./concordance-options').default;\n \n function formatErrorValue(label, error) {\n@@ -67,6 +68,95 @@ class ExecutionContext extends assert.Assertions {\n \t\tthis.timeout = ms => {\n \t\t\ttest.timeout(ms);\n \t\t};\n+\n+\t\tthis.try = async (...attemptArgs) => {\n+\t\t\tif (test.experiments.tryAssertion !== true) {\n+\t\t\t\tthrow new Error('t.try() is currently an experiment. Opt in by setting `nonSemVerExperiments.tryAssertion` to `true`.');\n+\t\t\t}\n+\n+\t\t\tconst {args, buildTitle, implementations, receivedImplementationArray} = parseTestArgs(attemptArgs);\n+\n+\t\t\tif (implementations.length === 0) {\n+\t\t\t\tthrow new TypeError('Expected an implementation.');\n+\t\t\t}\n+\n+\t\t\tconst attemptPromises = implementations.map(implementation => {\n+\t\t\t\tlet {title, isSet, isValid, isEmpty} = buildTitle(implementation);\n+\n+\t\t\t\tif (!isSet || isEmpty) {\n+\t\t\t\t\ttitle = `${test.title} (attempt ${test.attemptCount + 1})`;\n+\t\t\t\t} else if (!isValid) {\n+\t\t\t\t\tthrow new TypeError('`t.try()` titles must be strings'); // Throw synchronously!\n+\t\t\t\t}\n+\n+\t\t\t\tif (!test.registerUniqueTitle(title)) {\n+\t\t\t\t\tthrow new Error(`Duplicate test title: ${title}`);\n+\t\t\t\t}\n+\n+\t\t\t\treturn {implementation, title};\n+\t\t\t}).map(async ({implementation, title}) => {\n+\t\t\t\tlet committed = false;\n+\t\t\t\tlet discarded = false;\n+\n+\t\t\t\tconst {assertCount, deferredSnapshotRecordings, errors, logs, passed, snapshotCount, startingSnapshotCount} = await test.runAttempt(title, t => implementation(t, ...args));\n+\n+\t\t\t\treturn {\n+\t\t\t\t\terrors,\n+\t\t\t\t\tlogs: [...logs], // Don't allow modification of logs.\n+\t\t\t\t\tpassed,\n+\t\t\t\t\ttitle,\n+\t\t\t\t\tcommit: ({retainLogs = true} = {}) => {\n+\t\t\t\t\t\tif (committed) {\n+\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif (discarded) {\n+\t\t\t\t\t\t\ttest.saveFirstError(new Error('Can\\'t commit a result that was previously discarded'));\n+\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tcommitted = true;\n+\t\t\t\t\t\ttest.finishAttempt({\n+\t\t\t\t\t\t\tassertCount,\n+\t\t\t\t\t\t\tcommit: true,\n+\t\t\t\t\t\t\tdeferredSnapshotRecordings,\n+\t\t\t\t\t\t\terrors,\n+\t\t\t\t\t\t\tlogs,\n+\t\t\t\t\t\t\tpassed,\n+\t\t\t\t\t\t\tretainLogs,\n+\t\t\t\t\t\t\tsnapshotCount,\n+\t\t\t\t\t\t\tstartingSnapshotCount\n+\t\t\t\t\t\t});\n+\t\t\t\t\t},\n+\t\t\t\t\tdiscard: ({retainLogs = false} = {}) => {\n+\t\t\t\t\t\tif (committed) {\n+\t\t\t\t\t\t\ttest.saveFirstError(new Error('Can\\'t discard a result that was previously committed'));\n+\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif (discarded) {\n+\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tdiscarded = true;\n+\t\t\t\t\t\ttest.finishAttempt({\n+\t\t\t\t\t\t\tassertCount: 0,\n+\t\t\t\t\t\t\tcommit: false,\n+\t\t\t\t\t\t\tdeferredSnapshotRecordings,\n+\t\t\t\t\t\t\terrors,\n+\t\t\t\t\t\t\tlogs,\n+\t\t\t\t\t\t\tpassed,\n+\t\t\t\t\t\t\tretainLogs,\n+\t\t\t\t\t\t\tsnapshotCount,\n+\t\t\t\t\t\t\tstartingSnapshotCount\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t};\n+\t\t\t});\n+\n+\t\t\tconst results = await Promise.all(attemptPromises);\n+\t\t\treturn receivedImplementationArray ? results : results[0];\n+\t\t};\n \t}\n \n \tget end() {\n@@ -99,32 +189,74 @@ class ExecutionContext extends assert.Assertions {\n class Test {\n \tconstructor(options) {\n \t\tthis.contextRef = options.contextRef;\n+\t\tthis.experiments = options.experiments || {};\n \t\tthis.failWithoutAssertions = options.failWithoutAssertions;\n \t\tthis.fn = options.fn;\n \t\tthis.metadata = options.metadata;\n \t\tthis.title = options.title;\n+\t\tthis.registerUniqueTitle = options.registerUniqueTitle;\n \t\tthis.logs = [];\n \n-\t\tthis.snapshotInvocationCount = 0;\n-\t\tthis.compareWithSnapshot = assertionOptions => {\n-\t\t\tconst belongsTo = assertionOptions.id || this.title;\n-\t\t\tconst {expected} = assertionOptions;\n-\t\t\tconst index = assertionOptions.id ? 0 : this.snapshotInvocationCount++;\n-\t\t\tconst label = assertionOptions.id ? '' : assertionOptions.message || `Snapshot ${this.snapshotInvocationCount}`;\n-\t\t\treturn options.compareTestSnapshot({belongsTo, expected, index, label});\n+\t\tconst {snapshotBelongsTo = this.title, nextSnapshotIndex = 0} = options;\n+\t\tthis.snapshotBelongsTo = snapshotBelongsTo;\n+\t\tthis.nextSnapshotIndex = nextSnapshotIndex;\n+\t\tthis.snapshotCount = 0;\n+\n+\t\tconst deferRecording = this.metadata.inline;\n+\t\tthis.deferredSnapshotRecordings = [];\n+\t\tthis.compareWithSnapshot = ({expected, id, message}) => {\n+\t\t\tthis.snapshotCount++;\n+\n+\t\t\t// TODO: In a breaking change, reject non-undefined, falsy IDs and messages.\n+\t\t\tconst belongsTo = id || snapshotBelongsTo;\n+\t\t\tconst index = id ? 0 : this.nextSnapshotIndex++;\n+\t\t\tconst label = id ? '' : message || `Snapshot ${index + 1}`; // Human-readable labels start counting at 1.\n+\n+\t\t\tconst {record, ...result} = options.compareTestSnapshot({belongsTo, deferRecording, expected, index, label});\n+\t\t\tif (record) {\n+\t\t\t\tthis.deferredSnapshotRecordings.push(record);\n+\t\t\t}\n+\n+\t\t\treturn result;\n \t\t};\n \n \t\tthis.skipSnapshot = () => {\n \t\t\tif (options.updateSnapshots) {\n \t\t\t\tthis.addFailedAssertion(new Error('Snapshot assertions cannot be skipped when updating snapshots'));\n \t\t\t} else {\n-\t\t\t\tthis.snapshotInvocationCount++;\n+\t\t\t\tthis.nextSnapshotIndex++;\n+\t\t\t\tthis.snapshotCount++;\n \t\t\t\tthis.countPassedAssertion();\n \t\t\t}\n \t\t};\n \n+\t\tthis.runAttempt = async (title, fn) => {\n+\t\t\tif (this.finishing) {\n+\t\t\t\tthis.saveFirstError(new Error('Running a `t.try()`, but the test has already finished'));\n+\t\t\t}\n+\n+\t\t\tthis.attemptCount++;\n+\t\t\tthis.pendingAttemptCount++;\n+\n+\t\t\tconst {contextRef, snapshotBelongsTo, nextSnapshotIndex, snapshotCount: startingSnapshotCount} = this;\n+\t\t\tconst attempt = new Test({\n+\t\t\t\t...options,\n+\t\t\t\tfn,\n+\t\t\t\tmetadata: {...options.metadata, callback: false, failing: false, inline: true},\n+\t\t\t\tcontextRef: contextRef.copy(),\n+\t\t\t\tsnapshotBelongsTo,\n+\t\t\t\tnextSnapshotIndex,\n+\t\t\t\ttitle\n+\t\t\t});\n+\n+\t\t\tconst {deferredSnapshotRecordings, error, logs, passed, assertCount, snapshotCount} = await attempt.run();\n+\t\t\tconst errors = error ? [error] : [];\n+\t\t\treturn {assertCount, deferredSnapshotRecordings, errors, logs, passed, snapshotCount, startingSnapshotCount};\n+\t\t};\n+\n \t\tthis.assertCount = 0;\n \t\tthis.assertError = undefined;\n+\t\tthis.attemptCount = 0;\n \t\tthis.calledEnd = false;\n \t\tthis.duration = null;\n \t\tthis.endCallbackFinisher = null;\n@@ -133,11 +265,12 @@ class Test {\n \t\tthis.finishDueToTimeout = null;\n \t\tthis.finishing = false;\n \t\tthis.pendingAssertionCount = 0;\n+\t\tthis.pendingAttemptCount = 0;\n \t\tthis.pendingThrowsAssertion = null;\n \t\tthis.planCount = null;\n \t\tthis.startedAt = 0;\n-\t\tthis.timeoutTimer = null;\n \t\tthis.timeoutMs = 0;\n+\t\tthis.timeoutTimer = null;\n \t}\n \n \tbindEndCallback() {\n@@ -147,7 +280,11 @@ class Test {\n \t\t\t};\n \t\t}\n \n-\t\tthrow new Error('`t.end()`` is not supported in this context. To use `t.end()` as a callback, you must use \"callback mode\" via `test.cb(testName, fn)`');\n+\t\tif (this.metadata.inline) {\n+\t\t\tthrow new Error('`t.end()` is not supported inside `t.try()`');\n+\t\t} else {\n+\t\t\tthrow new Error('`t.end()` is not supported in this context. To use `t.end()` as a callback, you must use \"callback mode\" via `test.cb(testName, fn)`');\n+\t\t}\n \t}\n \n \tendCallback(error, savedError) {\n@@ -181,6 +318,10 @@ class Test {\n \t\t\tthis.saveFirstError(new Error('Assertion passed, but test has already finished'));\n \t\t}\n \n+\t\tif (this.pendingAttemptCount > 0) {\n+\t\t\tthis.saveFirstError(new Error('Assertion passed, but an attempt is pending. Use the attempt’s assertions instead'));\n+\t\t}\n+\n \t\tthis.assertCount++;\n \t\tthis.refreshTimeout();\n \t}\n@@ -191,7 +332,11 @@ class Test {\n \n \taddPendingAssertion(promise) {\n \t\tif (this.finishing) {\n-\t\t\tthis.saveFirstError(new Error('Assertion passed, but test has already finished'));\n+\t\t\tthis.saveFirstError(new Error('Assertion started, but test has already finished'));\n+\t\t}\n+\n+\t\tif (this.pendingAttemptCount > 0) {\n+\t\t\tthis.saveFirstError(new Error('Assertion started, but an attempt is pending. Use the attempt’s assertions instead'));\n \t\t}\n \n \t\tthis.assertCount++;\n@@ -211,11 +356,53 @@ class Test {\n \t\t\tthis.saveFirstError(new Error('Assertion failed, but test has already finished'));\n \t\t}\n \n+\t\tif (this.pendingAttemptCount > 0) {\n+\t\t\tthis.saveFirstError(new Error('Assertion failed, but an attempt is pending. Use the attempt’s assertions instead'));\n+\t\t}\n+\n \t\tthis.assertCount++;\n \t\tthis.refreshTimeout();\n \t\tthis.saveFirstError(error);\n \t}\n \n+\tfinishAttempt({commit, deferredSnapshotRecordings, errors, logs, passed, retainLogs, snapshotCount, startingSnapshotCount}) {\n+\t\tif (this.finishing) {\n+\t\t\tif (commit) {\n+\t\t\t\tthis.saveFirstError(new Error('`t.try()` result was committed, but the test has already finished'));\n+\t\t\t} else {\n+\t\t\t\tthis.saveFirstError(new Error('`t.try()` result was discarded, but the test has already finished'));\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (commit) {\n+\t\t\tthis.assertCount++;\n+\n+\t\t\tif (startingSnapshotCount === this.snapshotCount) {\n+\t\t\t\tthis.snapshotCount += snapshotCount;\n+\t\t\t\tthis.nextSnapshotIndex += snapshotCount;\n+\t\t\t\tfor (const record of deferredSnapshotRecordings) {\n+\t\t\t\t\trecord();\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tthis.saveFirstError(new Error('Cannot commit `t.try()` result. Do not run concurrent snapshot assertions when using `t.try()`'));\n+\t\t\t}\n+\t\t}\n+\n+\t\tthis.pendingAttemptCount--;\n+\n+\t\tif (commit && !passed) {\n+\t\t\tthis.saveFirstError(errors[0]);\n+\t\t}\n+\n+\t\tif (retainLogs) {\n+\t\t\tfor (const log of logs) {\n+\t\t\t\tthis.addLog(log);\n+\t\t\t}\n+\t\t}\n+\n+\t\tthis.refreshTimeout();\n+\t}\n+\n \tsaveFirstError(error) {\n \t\tif (!this.assertError) {\n \t\t\tthis.assertError = error;\n@@ -279,11 +466,27 @@ class Test {\n \t}\n \n \tverifyAssertions() {\n-\t\tif (!this.assertError) {\n-\t\t\tif (this.failWithoutAssertions && !this.calledEnd && this.planCount === null && this.assertCount === 0) {\n+\t\tif (this.assertError) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.pendingAttemptCount > 0) {\n+\t\t\tthis.saveFirstError(new Error('Test finished, but not all attempts were committed or discarded'));\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.pendingAssertionCount > 0) {\n+\t\t\tthis.saveFirstError(new Error('Test finished, but an assertion is still pending'));\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.failWithoutAssertions) {\n+\t\t\tif (this.planCount !== null) {\n+\t\t\t\treturn; // `verifyPlan()` will report an error already.\n+\t\t\t}\n+\n+\t\t\tif (this.assertCount === 0 && !this.calledEnd) {\n \t\t\t\tthis.saveFirstError(new Error('Test finished without running any assertions'));\n-\t\t\t} else if (this.pendingAssertionCount > 0) {\n-\t\t\t\tthis.saveFirstError(new Error('Test finished, but an assertion is still pending'));\n \t\t\t}\n \t\t}\n \t}\n@@ -476,11 +679,14 @@ class Test {\n \t\t}\n \n \t\treturn {\n+\t\t\tdeferredSnapshotRecordings: this.deferredSnapshotRecordings,\n \t\t\tduration: this.duration,\n \t\t\terror,\n \t\t\tlogs: this.logs,\n \t\t\tmetadata: this.metadata,\n \t\t\tpassed,\n+\t\t\tsnapshotCount: this.snapshotCount,\n+\t\t\tassertCount: this.assertCount,\n \t\t\ttitle: this.title\n \t\t};\n \t}"
      },
      {
        "sha": "861f0ecfaaf989a01f4ace1878ecac9e1bd36fdb",
        "filename": "lib/worker/subprocess.js",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/avajs/ava/blob/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/lib%2Fworker%2Fsubprocess.js",
        "raw_url": "https://github.com/avajs/ava/raw/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/lib%2Fworker%2Fsubprocess.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fworker%2Fsubprocess.js?ref=2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17",
        "patch": "@@ -31,6 +31,7 @@ ipc.options.then(options => {\n \t}\n \n \tconst runner = new Runner({\n+\t\texperiments: options.experiments,\n \t\tfailFast: options.failFast,\n \t\tfailWithoutAssertions: options.failWithoutAssertions,\n \t\tfile: options.file,"
      },
      {
        "sha": "5c5987f36296bc2c3bddd23446c07bd6bb9c4299",
        "filename": "test/fixture/try-snapshot.js.md",
        "status": "added",
        "additions": 43,
        "deletions": 0,
        "changes": 43,
        "blob_url": "https://github.com/avajs/ava/blob/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/test%2Ffixture%2Ftry-snapshot.js.md",
        "raw_url": "https://github.com/avajs/ava/raw/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/test%2Ffixture%2Ftry-snapshot.js.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Ftry-snapshot.js.md?ref=2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17",
        "patch": "@@ -0,0 +1,43 @@\n+# Snapshot report for `try-snapshot.js`\n+\n+The actual snapshot is saved in `try-snapshot.js.snap`.\n+\n+Generated by [AVA](https://ava.li).\n+\n+## concurrent\n+\n+> Snapshot 1\n+\n+    'hello'\n+\n+> Snapshot 2\n+\n+    true\n+\n+> Snapshot 3\n+\n+    {\n+      boo: 'far',\n+    }\n+\n+## serial\n+\n+> Snapshot 1\n+\n+    'hello'\n+\n+> Snapshot 2\n+\n+    true\n+\n+> Snapshot 3\n+\n+    {\n+      boo: 'far',\n+    }\n+\n+> Snapshot 4\n+\n+    {\n+      foo: 'bar',\n+    }"
      },
      {
        "sha": "b4919bad0fdf5a27010703b0269a3099161ef178",
        "filename": "test/fixture/try-snapshot.js.snap",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/test%2Ffixture%2Ftry-snapshot.js.snap",
        "raw_url": "https://github.com/avajs/ava/raw/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/test%2Ffixture%2Ftry-snapshot.js.snap",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Ftry-snapshot.js.snap?ref=2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17"
      },
      {
        "sha": "36cbf67f6ad68c9fe99ad4317ebe090870143f88",
        "filename": "test/helper/ava-test.js",
        "status": "added",
        "additions": 57,
        "deletions": 0,
        "changes": 57,
        "blob_url": "https://github.com/avajs/ava/blob/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/test%2Fhelper%2Fava-test.js",
        "raw_url": "https://github.com/avajs/ava/raw/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/test%2Fhelper%2Fava-test.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fhelper%2Fava-test.js?ref=2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17",
        "patch": "@@ -0,0 +1,57 @@\n+const Test = require('../../lib/test');\n+const ContextRef = require('../../lib/context-ref');\n+\n+function withExperiments(experiments = {}) {\n+\tfunction ava(fn, contextRef) {\n+\t\treturn new Test({\n+\t\t\tcontextRef: contextRef || new ContextRef(),\n+\t\t\texperiments,\n+\t\t\tfailWithoutAssertions: true,\n+\t\t\tfn,\n+\t\t\tregisterUniqueTitle: () => true,\n+\t\t\tmetadata: {type: 'test', callback: false},\n+\t\t\ttitle: 'test'\n+\t\t});\n+\t}\n+\n+\tava.failing = (fn, contextRef) => {\n+\t\treturn new Test({\n+\t\t\tcontextRef: contextRef || new ContextRef(),\n+\t\t\texperiments,\n+\t\t\tfailWithoutAssertions: true,\n+\t\t\tfn,\n+\t\t\tregisterUniqueTitle: () => true,\n+\t\t\tmetadata: {type: 'test', callback: false, failing: true},\n+\t\t\ttitle: 'test.failing'\n+\t\t});\n+\t};\n+\n+\tava.cb = (fn, contextRef) => {\n+\t\treturn new Test({\n+\t\t\tcontextRef: contextRef || new ContextRef(),\n+\t\t\texperiments,\n+\t\t\tfailWithoutAssertions: true,\n+\t\t\tfn,\n+\t\t\tregisterUniqueTitle: () => true,\n+\t\t\tmetadata: {type: 'test', callback: true},\n+\t\t\ttitle: 'test.cb'\n+\t\t});\n+\t};\n+\n+\tava.cb.failing = (fn, contextRef) => {\n+\t\treturn new Test({\n+\t\t\tcontextRef: contextRef || new ContextRef(),\n+\t\t\texperiments,\n+\t\t\tfailWithoutAssertions: true,\n+\t\t\tfn,\n+\t\t\tregisterUniqueTitle: () => true,\n+\t\t\tmetadata: {type: 'test', callback: true, failing: true},\n+\t\t\ttitle: 'test.cb.failing'\n+\t\t});\n+\t};\n+\n+\treturn ava;\n+}\n+\n+exports.ava = withExperiments();\n+exports.withExperiments = withExperiments;"
      },
      {
        "sha": "759e74a9ff7eac5f3f00115a1b49c61f85c295f3",
        "filename": "test/test-try-commit.js",
        "status": "added",
        "additions": 589,
        "deletions": 0,
        "changes": 589,
        "blob_url": "https://github.com/avajs/ava/blob/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/test%2Ftest-try-commit.js",
        "raw_url": "https://github.com/avajs/ava/raw/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/test%2Ftest-try-commit.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ftest-try-commit.js?ref=2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17",
        "patch": "@@ -0,0 +1,589 @@\n+'use strict';\n+require('../lib/chalk').set();\n+require('../lib/worker/options').set({color: false});\n+\n+const {test} = require('tap');\n+const delay = require('delay');\n+const ContextRef = require('../lib/context-ref');\n+const {withExperiments} = require('./helper/ava-test');\n+\n+const ava = withExperiments({tryAssertion: true});\n+\n+test('try-commit works', async t => {\n+\tconst instance = ava(async a => {\n+\t\tconst res = await a.try(b => b.pass());\n+\t\tt.true(res.passed);\n+\t\tres.commit();\n+\t});\n+\n+\tconst result = await instance.run();\n+\n+\tt.true(result.passed);\n+\tt.is(instance.assertCount, 1);\n+});\n+\n+test('try-commit is bound', async t => {\n+\tconst result = await ava(async a => {\n+\t\tconst {try: tryFn} = a;\n+\t\tconst res = await tryFn(b => b.pass());\n+\t\tawait res.commit();\n+\t}).run();\n+\n+\tt.true(result.passed);\n+});\n+\n+test('try-commit discards failed attempt', async t => {\n+\tconst result = await ava(async a => {\n+\t\tconst res = await a.try(b => b.fail());\n+\t\tawait res.discard();\n+\t\tawait a.pass();\n+\t}).run();\n+\n+\tt.true(result.passed);\n+});\n+\n+test('try-commit can discard produced result', async t => {\n+\tconst result = await ava(async a => {\n+\t\tconst res = await a.try(b => b.pass());\n+\t\tres.discard();\n+\t}).run();\n+\n+\tt.false(result.passed);\n+\tt.ok(result.error);\n+\tt.match(result.error.message, /without running any assertions/);\n+\tt.is(result.error.name, 'Error');\n+});\n+\n+test('try-commit fails when not all assertions were committed/discarded', async t => {\n+\tconst result = await ava(async a => {\n+\t\ta.pass();\n+\t\tawait a.try(b => b.pass());\n+\t}).run();\n+\n+\tt.false(result.passed);\n+\tt.ok(result.error);\n+\tt.match(result.error.message, /not all attempts were committed/);\n+\tt.is(result.error.name, 'Error');\n+});\n+\n+test('try-commit works with values', async t => {\n+\tconst testValue1 = 123;\n+\tconst testValue2 = 123;\n+\n+\tconst result = await ava(async a => {\n+\t\tconst res = await a.try((b, val1, val2) => {\n+\t\t\tb.is(val1, val2);\n+\t\t}, testValue1, testValue2);\n+\t\tt.true(res.passed);\n+\t\tres.commit();\n+\t}).run();\n+\n+\tt.true(result.passed);\n+});\n+\n+test('try-commit is properly counted', async t => {\n+\tconst instance = ava(async a => {\n+\t\tconst res = await a.try(b => {\n+\t\t\tb.is(1, 1);\n+\t\t\tb.is(2, 2);\n+\t\t\tb.pass();\n+\t\t});\n+\n+\t\tt.true(res.passed);\n+\t\tt.is(instance.pendingAttemptCount, 1);\n+\t\tres.commit();\n+\t\tt.is(instance.pendingAttemptCount, 0);\n+\t});\n+\n+\tconst result = await instance.run();\n+\n+\tt.true(result.passed);\n+\tt.is(instance.assertCount, 1);\n+});\n+\n+test('try-commit is properly counted multiple', async t => {\n+\tconst instance = ava(async a => {\n+\t\tconst [res1, res2, res3] = await Promise.all([\n+\t\t\ta.try(b => b.pass()),\n+\t\t\ta.try(b => b.pass()),\n+\t\t\ta.try(b => b.pass())\n+\t\t]);\n+\n+\t\tt.is(instance.pendingAttemptCount, 3);\n+\t\tres1.commit();\n+\t\tres2.discard();\n+\t\tres3.commit();\n+\t\tt.is(instance.pendingAttemptCount, 0);\n+\t});\n+\n+\tconst result = await instance.run();\n+\n+\tt.true(result.passed);\n+\tt.is(instance.assertCount, 2);\n+});\n+\n+test('try-commit goes as many levels', async t => {\n+\tt.plan(5);\n+\tconst instance = ava(async a => {\n+\t\tt.ok(a.try);\n+\t\tconst res1 = await a.try(async b => {\n+\t\t\tt.ok(b.try);\n+\t\t\tconst res = await b.try(c => {\n+\t\t\t\tt.ok(c.try);\n+\t\t\t\tc.pass();\n+\t\t\t});\n+\t\t\tres.commit();\n+\t\t});\n+\t\tres1.commit();\n+\t});\n+\n+\tconst result = await instance.run();\n+\n+\tt.true(result.passed);\n+\tt.is(instance.assertCount, 1);\n+});\n+\n+test('try-commit fails when not committed', async t => {\n+\tconst result = await ava(async a => {\n+\t\tconst res = await a.try(b => b.pass());\n+\t\tt.true(res.passed);\n+\t}).run();\n+\n+\tt.false(result.passed);\n+\tt.ok(result.error);\n+\tt.match(result.error.message, /not all attempts were committed/);\n+\tt.is(result.error.name, 'Error');\n+});\n+\n+test('try-commit fails when no assertions inside try', async t => {\n+\tconst result = await ava(async a => {\n+\t\tconst res = await a.try(() => {});\n+\t\tt.false(res.passed);\n+\t\tt.ok(res.errors);\n+\t\tt.is(res.errors.length, 1);\n+\t\tconst error = res.errors[0];\n+\t\tt.match(error.message, /Test finished without running any assertions/);\n+\t\tt.is(error.name, 'Error');\n+\t\tres.commit();\n+\t}).run();\n+\n+\tt.false(result.passed);\n+});\n+\n+test('try-commit fails when no assertions inside multiple try', async t => {\n+\tconst result = await ava(async a => {\n+\t\tconst [res1, res2] = await Promise.all([\n+\t\t\ta.try(b => b.pass()),\n+\t\t\ta.try(() => {})\n+\t\t]);\n+\n+\t\tres1.commit();\n+\t\tt.true(res1.passed);\n+\n+\t\tt.false(res2.passed);\n+\t\tt.ok(res2.errors);\n+\t\tt.is(res2.errors.length, 1);\n+\t\tconst error = res2.errors[0];\n+\t\tt.match(error.message, /Test finished without running any assertions/);\n+\t\tt.is(error.name, 'Error');\n+\t\tres2.commit();\n+\t}).run();\n+\n+\tt.false(result.passed);\n+});\n+\n+test('test fails when try-commit committed to failed state', async t => {\n+\tconst result = await ava(async a => {\n+\t\tconst res = await a.try(b => b.fail());\n+\t\tt.false(res.passed);\n+\t\tres.commit();\n+\t}).run();\n+\n+\tt.false(result.passed);\n+});\n+\n+test('try-commit has proper titles, when going in depth and width', async t => {\n+\tt.plan(6);\n+\tawait ava(async a => {\n+\t\tt.is(a.title, 'test');\n+\n+\t\tawait Promise.all([\n+\t\t\ta.try(async b => {\n+\t\t\t\tt.is(b.title, 'test (attempt 1)');\n+\n+\t\t\t\tawait Promise.all([\n+\t\t\t\t\tb.try(c => t.is(c.title, 'test (attempt 1) (attempt 1)')),\n+\t\t\t\t\tb.try(c => t.is(c.title, 'test (attempt 1) (attempt 2)'))\n+\t\t\t\t]);\n+\t\t\t}),\n+\t\t\ta.try(b => t.is(b.title, 'test (attempt 2)')),\n+\t\t\ta.try(b => t.is(b.title, 'test (attempt 3)'))\n+\t\t]);\n+\t}).run();\n+});\n+\n+test('try-commit does not fail when calling commit twice', async t => {\n+\tconst result = await ava(async a => {\n+\t\tconst res = await a.try(b => b.pass());\n+\t\tres.commit();\n+\t\tres.commit();\n+\t}).run();\n+\n+\tt.true(result.passed);\n+\tt.false(result.error);\n+});\n+\n+test('try-commit does not fail when calling discard twice', async t => {\n+\tconst result = await ava(async a => {\n+\t\tconst res = await a.try(b => b.pass());\n+\t\tres.discard();\n+\t\tres.discard();\n+\t}).run();\n+\n+\tt.false(result.passed);\n+\tt.ok(result.error);\n+\tt.match(result.error.message, /Test finished without running any assertions/);\n+\tt.is(result.error.name, 'Error');\n+});\n+\n+test('try-commit allows planning inside the try', async t => {\n+\tconst result = await ava(async a => {\n+\t\tconst res = await a.try(b => {\n+\t\t\tb.plan(3);\n+\n+\t\t\tb.pass();\n+\t\t\tb.pass();\n+\t\t\tb.pass();\n+\t\t});\n+\t\tt.true(res.passed);\n+\t\tres.commit();\n+\t}).run();\n+\n+\tt.true(result.passed);\n+});\n+\n+test('try-commit fails when plan is not reached inside the try', async t => {\n+\tconst result = await ava(async a => {\n+\t\tconst res = await a.try(b => {\n+\t\t\tb.plan(3);\n+\n+\t\t\tb.pass();\n+\t\t\tb.pass();\n+\t\t});\n+\t\tt.false(res.passed);\n+\t\tres.commit();\n+\t}).run();\n+\n+\tt.false(result.passed);\n+});\n+\n+test('plan within try-commit is not affected by assertions outside', async t => {\n+\tconst result = await ava(async a => {\n+\t\ta.is(1, 1);\n+\t\ta.is(2, 2);\n+\n+\t\tconst attempt = a.try(b => {\n+\t\t\tb.plan(3);\n+\t\t});\n+\n+\t\tconst res = await attempt;\n+\t\tt.false(res.passed);\n+\t\tres.commit();\n+\t}).run();\n+\n+\tt.false(result.passed);\n+\tt.ok(result.error);\n+\tt.match(result.error.message, /Planned for 3 assertions, but got 0/);\n+});\n+\n+test('assertions within try-commit do not affect plan in the parent test', async t => {\n+\tconst result = await ava(async a => {\n+\t\ta.plan(2);\n+\n+\t\tconst res = await a.try(b => {\n+\t\t\tb.plan(3);\n+\t\t\tb.pass();\n+\t\t\tb.pass();\n+\t\t\tb.pass();\n+\t\t});\n+\n+\t\tt.true(res.passed);\n+\t\tres.commit();\n+\t}).run();\n+\n+\tt.false(result.passed);\n+\tt.ok(result.error);\n+\tt.match(result.error.message, /Planned for 2 assertions, but got 1/);\n+});\n+\n+test('test expected to fail will pass with failing try-commit within the test', async t => {\n+\tconst result = await ava.failing(async a => {\n+\t\tconst res = await a.try(b => b.fail());\n+\t\tt.false(res.passed);\n+\t\tt.ok(res.errors);\n+\t\tt.is(res.errors.length, 1);\n+\t\tconst error = res.errors[0];\n+\t\tt.match(error.message, /Test failed via `t\\.fail\\(\\)`/);\n+\t\tt.is(error.name, 'AssertionError');\n+\t\tres.commit();\n+\t}).run();\n+\n+\tt.true(result.passed);\n+});\n+\n+test('try-commit works with callback test', async t => {\n+\tconst result = await ava.cb(a => {\n+\t\ta\n+\t\t\t.try(b => b.pass())\n+\t\t\t.then(res => {\n+\t\t\t\tres.commit();\n+\t\t\t\ta.end();\n+\t\t\t});\n+\t}).run();\n+\n+\tt.true(result.passed);\n+});\n+\n+test('try-commit works with failing callback test', async t => {\n+\tconst result = await ava.cb.failing(a => {\n+\t\ta\n+\t\t\t.try(b => b.fail())\n+\t\t\t.then(res => {\n+\t\t\t\tt.false(res.passed);\n+\t\t\t\tt.ok(res.errors);\n+\t\t\t\tt.is(res.errors.length, 1);\n+\t\t\t\tconst error = res.errors[0];\n+\t\t\t\tt.match(error.message, /Test failed via `t\\.fail\\(\\)`/);\n+\t\t\t\tt.is(error.name, 'AssertionError');\n+\t\t\t\tres.commit();\n+\t\t\t})\n+\t\t\t.then(() => {\n+\t\t\t\ta.end();\n+\t\t\t});\n+\t}).run();\n+\n+\tt.true(result.passed);\n+});\n+\n+test('try-commit does not allow to use .end() in attempt when parent is callback test', async t => {\n+\tconst result = await ava.cb(a => {\n+\t\ta\n+\t\t\t.try(b => {\n+\t\t\t\tb.pass();\n+\t\t\t\tb.end();\n+\t\t\t})\n+\t\t\t.then(res => {\n+\t\t\t\tres.commit();\n+\t\t\t\ta.end();\n+\t\t\t});\n+\t}).run();\n+\n+\tt.false(result.passed);\n+\tt.ok(result.error);\n+\tt.match(result.error.message, /Error thrown in test/);\n+\tt.is(result.error.name, 'AssertionError');\n+\tt.match(result.error.values[0].formatted, /t\\.end.*not supported/);\n+});\n+\n+test('try-commit does not allow to use .end() in attempt when parent is regular test', async t => {\n+\tconst result = await ava(async a => {\n+\t\tconst res = await a.try(b => {\n+\t\t\tb.pass();\n+\t\t\tb.end();\n+\t\t});\n+\n+\t\tres.commit();\n+\t}).run();\n+\n+\tt.false(result.passed);\n+\tt.ok(result.error);\n+\tt.match(result.error.message, /Error thrown in test/);\n+\tt.is(result.error.name, 'AssertionError');\n+\tt.match(result.error.values[0].formatted, /t\\.end.*not supported/);\n+});\n+\n+test('try-commit accepts macros', async t => {\n+\tconst macro = b => {\n+\t\tt.is(b.title, ' Title');\n+\t\tb.pass();\n+\t};\n+\n+\tmacro.title = providedTitle => `${providedTitle ? providedTitle : ''} Title`;\n+\n+\tconst result = await ava(async a => {\n+\t\tconst res = await a.try(macro);\n+\t\tt.true(res.passed);\n+\t\tres.commit();\n+\t}).run();\n+\n+\tt.true(result.passed);\n+});\n+\n+test('try-commit accepts multiple macros', async t => {\n+\tconst macros = [b => b.pass(), b => b.fail()];\n+\tconst result = await ava(async a => {\n+\t\tconst [res1, res2] = await a.try(macros);\n+\t\tt.true(res1.passed);\n+\t\tres1.commit();\n+\t\tt.false(res2.passed);\n+\t\tres2.discard();\n+\t}).run();\n+\n+\tt.true(result.passed);\n+});\n+\n+test('try-commit returns results in the same shape as when implementations are passed', async t => {\n+\tconst result = await ava(async a => {\n+\t\tconst [res1, res2, res3] = await Promise.all([\n+\t\t\ta.try(b => b.pass()),\n+\t\t\ta.try([b => b.pass()]),\n+\t\t\ta.try([b => b.pass(), b => b.fail()])\n+\t\t]);\n+\n+\t\tt.match(res1, {passed: true});\n+\t\tres1.commit();\n+\n+\t\tt.is(res2.length, 1);\n+\t\tt.match(res2, [{passed: true}]);\n+\t\tres2[0].commit();\n+\n+\t\tt.is(res3.length, 2);\n+\t\tt.match(res3, [{passed: true}, {passed: false}]);\n+\t\tres3[0].commit();\n+\t\tres3[1].discard();\n+\t}).run();\n+\n+\tt.true(result.passed);\n+});\n+\n+test('try-commit abides timeout', async t => {\n+\tconst result1 = await ava(async a => {\n+\t\ta.timeout(10);\n+\t\tconst result = await a.try(async b => {\n+\t\t\tb.pass();\n+\t\t\tawait delay(200);\n+\t\t});\n+\t\tawait result.commit();\n+\t}).run();\n+\n+\tt.is(result1.passed, false);\n+\tt.match(result1.error.message, /timeout/);\n+});\n+\n+test('try-commit fails when it exceeds its own timeout', async t => {\n+\tconst result = await ava(async a => {\n+\t\ta.timeout(200);\n+\t\tconst result = await a.try(async b => {\n+\t\t\tb.timeout(50);\n+\t\t\tb.pass();\n+\t\t\tawait delay(100);\n+\t\t});\n+\n+\t\tt.false(result.passed);\n+\t\tt.ok(result.errors);\n+\t\tt.is(result.errors.length, 1);\n+\t\tconst error = result.errors[0];\n+\t\tt.match(error.message, /Test timeout exceeded/);\n+\t\tt.is(error.name, 'Error');\n+\n+\t\tresult.discard();\n+\t\ta.pass();\n+\t}).run();\n+\n+\tt.true(result.passed);\n+});\n+\n+test('try-commit refreshes the timeout on commit/discard', async t => {\n+\tconst result1 = await ava.cb(a => {\n+\t\ta.timeout(10);\n+\t\ta.plan(3);\n+\t\tsetTimeout(() => a.try(b => b.pass()).then(result => result.commit()), 5);\n+\t\tsetTimeout(() => a.try(b => b.pass()).then(result => result.commit()), 10);\n+\t\tsetTimeout(() => a.try(b => b.pass()).then(result => result.commit()), 15);\n+\t\tsetTimeout(() => a.end(), 20);\n+\t}).run();\n+\n+\tt.is(result1.passed, true);\n+});\n+\n+test('assertions within try-commit do not refresh the timeout', async t => {\n+\tconst result = await ava(async a => {\n+\t\ta.timeout(15);\n+\t\ta.pass();\n+\n+\t\t// Attempt by itself will refresh timeout, so it has to finish after\n+\t\t// timeout of the test in order to make sure that it does not refresh the\n+\t\t// timeout. However, if assert within attempt is called before test timeout\n+\t\t// expires and will refresh the timeout (which is faulty behavior), then\n+\t\t// the entire test will not fail by timeout.\n+\t\tconst res = await a.try(async b => {\n+\t\t\tawait delay(10);\n+\t\t\tb.is(1, 1);\n+\t\t\tawait delay(10);\n+\t\t});\n+\t\tres.commit();\n+\t}).run();\n+\n+\tt.false(result.passed);\n+\tt.ok(result.error);\n+\tt.match(result.error.message, /Test timeout exceeded/);\n+\tt.is(result.error.name, 'Error');\n+});\n+\n+test('try-commit inherits the test context', async t => {\n+\tconst context = new ContextRef();\n+\tconst data = {foo: 'bar'};\n+\tcontext.set(data);\n+\tconst result = await ava(async a => {\n+\t\tconst res = await a.try(b => {\n+\t\t\tb.pass();\n+\t\t\tt.strictDeepEqual(b.context, data);\n+\t\t});\n+\t\tawait res.commit();\n+\t}, context).run();\n+\n+\tt.is(result.passed, true);\n+});\n+\n+test('assigning context in try-commit does not affect parent', async t => {\n+\tconst context = new ContextRef();\n+\tconst data = {foo: 'bar'};\n+\tcontext.set(data);\n+\tconst result = await ava(async a => {\n+\t\tt.strictDeepEqual(a.context, data);\n+\t\tconst res = await a.try(b => {\n+\t\t\tb.pass();\n+\t\t\tb.context = {bar: 'foo'};\n+\t\t});\n+\t\tres.commit();\n+\t\tt.strictDeepEqual(a.context, data);\n+\t}, context).run();\n+\n+\tt.is(result.passed, true);\n+});\n+\n+test('do not run assertions outside of an active attempt', async t => {\n+\tconst passing = await ava(async a => {\n+\t\tawait a.try(() => {});\n+\t\ta.pass();\n+\t}).run();\n+\n+\tt.false(passing.passed);\n+\tt.match(passing.error.message, /Assertion passed, but an attempt is pending. Use the attempt’s assertions instead/);\n+\n+\tconst pending = await ava(async a => {\n+\t\tawait a.try(() => {});\n+\t\tawait a.throwsAsync(Promise.reject(new Error('')));\n+\t}).run();\n+\n+\tt.false(pending.passed);\n+\tt.match(pending.error.message, /Assertion started, but an attempt is pending. Use the attempt’s assertions instead/);\n+\n+\tconst failing = await ava(async a => {\n+\t\tawait a.try(() => {});\n+\t\ta.fail();\n+\t}).run();\n+\n+\tt.false(failing.passed);\n+\tt.match(failing.error.message, /Assertion failed, but an attempt is pending. Use the attempt’s assertions instead/);\n+});"
      },
      {
        "sha": "085105b11d6be62366bed31390db4081290d10e7",
        "filename": "test/test.js",
        "status": "modified",
        "additions": 1,
        "deletions": 54,
        "changes": 55,
        "blob_url": "https://github.com/avajs/ava/blob/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/test%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/test%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ftest.js?ref=2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17",
        "patch": "@@ -9,63 +9,10 @@ const delay = require('delay');\n const snapshotManager = require('../lib/snapshot-manager');\n const Test = require('../lib/test');\n const HelloMessage = require('./fixture/hello-message');\n+const {ava} = require('./helper/ava-test');\n \n const failingTestHint = 'Test was expected to fail, but succeeded, you should stop marking the test as failing';\n \n-class ContextRef {\n-\tconstructor() {\n-\t\tthis.value = {};\n-\t}\n-\n-\tget() {\n-\t\treturn this.value;\n-\t}\n-\n-\tset(newValue) {\n-\t\tthis.value = newValue;\n-\t}\n-}\n-\n-function ava(fn, contextRef) {\n-\treturn new Test({\n-\t\tcontextRef: contextRef || new ContextRef(),\n-\t\tfailWithoutAssertions: true,\n-\t\tfn,\n-\t\tmetadata: {type: 'test', callback: false},\n-\t\ttitle: 'test'\n-\t});\n-}\n-\n-ava.failing = (fn, contextRef) => {\n-\treturn new Test({\n-\t\tcontextRef: contextRef || new ContextRef(),\n-\t\tfailWithoutAssertions: true,\n-\t\tfn,\n-\t\tmetadata: {type: 'test', callback: false, failing: true},\n-\t\ttitle: 'test.failing'\n-\t});\n-};\n-\n-ava.cb = (fn, contextRef) => {\n-\treturn new Test({\n-\t\tcontextRef: contextRef || new ContextRef(),\n-\t\tfailWithoutAssertions: true,\n-\t\tfn,\n-\t\tmetadata: {type: 'test', callback: true},\n-\t\ttitle: 'test.cb'\n-\t});\n-};\n-\n-ava.cb.failing = (fn, contextRef) => {\n-\treturn new Test({\n-\t\tcontextRef: contextRef || new ContextRef(),\n-\t\tfailWithoutAssertions: true,\n-\t\tfn,\n-\t\tmetadata: {type: 'test', callback: true, failing: true},\n-\t\ttitle: 'test.cb.failing'\n-\t});\n-};\n-\n test('run test', t => {\n \treturn ava(a => {\n \t\ta.fail();"
      },
      {
        "sha": "864533af1a0b61d1d8bf286ee5c2fb4552cd7328",
        "filename": "test/try-snapshot.js",
        "status": "added",
        "additions": 85,
        "deletions": 0,
        "changes": 85,
        "blob_url": "https://github.com/avajs/ava/blob/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/test%2Ftry-snapshot.js",
        "raw_url": "https://github.com/avajs/ava/raw/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/test%2Ftry-snapshot.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ftry-snapshot.js?ref=2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17",
        "patch": "@@ -0,0 +1,85 @@\n+'use strict';\n+require('../lib/chalk').set();\n+require('../lib/worker/options').set({color: false});\n+\n+const path = require('path');\n+const {test} = require('tap');\n+const snapshotManager = require('../lib/snapshot-manager');\n+const Test = require('../lib/test');\n+const ContextRef = require('../lib/context-ref');\n+\n+function setup(title, manager, fn) {\n+\treturn new Test({\n+\t\texperiments: {tryAssertion: true},\n+\t\tfn,\n+\t\tfailWithoutAssertions: true,\n+\t\tmetadata: {type: 'test', callback: false},\n+\t\tcontextRef: new ContextRef(),\n+\t\tregisterUniqueTitle: () => true,\n+\t\ttitle,\n+\t\tcompareTestSnapshot: options => manager.compare(options)\n+\t});\n+}\n+\n+test(async t => {\n+\t// Set to `true` to update the snapshot, then run:\n+\t// \"$(npm bin)\"/tap --no-cov -R spec test/try-snapshot.js\n+\t//\n+\t// Ignore errors and make sure not to run tests with the `-b` (bail) option.\n+\tconst updating = false;\n+\n+\tconst projectDir = path.join(__dirname, 'fixture');\n+\tconst manager = snapshotManager.load({\n+\t\tfile: path.join(projectDir, 'try-snapshot.js'),\n+\t\tprojectDir,\n+\t\tfixedLocation: null,\n+\t\tupdating,\n+\t\trecordNewSnapshots: updating\n+\t});\n+\n+\tawait t.test('try-commit snapshots serially', async t => {\n+\t\tconst ava = setup('serial', manager, async a => {\n+\t\t\ta.snapshot('hello');\n+\n+\t\t\tconst first = await a.try(t2 => {\n+\t\t\t\tt2.snapshot(true);\n+\t\t\t\tt2.snapshot({boo: 'far'});\n+\t\t\t});\n+\t\t\tfirst.commit();\n+\n+\t\t\tconst second = await a.try(t2 => {\n+\t\t\t\tt2.snapshot({foo: 'bar'});\n+\t\t\t});\n+\t\t\tsecond.commit();\n+\t\t});\n+\n+\t\tconst result = await ava.run();\n+\t\tt.true(result.passed);\n+\t});\n+\n+\tawait t.test('try-commit snapshots concurrently', async t => {\n+\t\tconst ava = setup('concurrent', manager, async a => {\n+\t\t\ta.snapshot('hello');\n+\n+\t\t\tconst [first, second] = await Promise.all([\n+\t\t\t\ta.try(t2 => {\n+\t\t\t\t\tt2.snapshot(true);\n+\t\t\t\t\tt2.snapshot({boo: 'far'});\n+\t\t\t\t}),\n+\t\t\t\ta.try(t2 => {\n+\t\t\t\t\tt2.snapshot({foo: 'bar'});\n+\t\t\t\t})\n+\t\t\t]);\n+\t\t\tfirst.commit();\n+\t\t\tsecond.commit();\n+\t\t});\n+\n+\t\tconst result = await ava.run();\n+\t\tt.false(result.passed);\n+\t\tt.ok(result.error);\n+\t\tt.match(result.error.message, /not run concurrent snapshot assertions when using `t\\.try\\(\\)`/);\n+\t\tt.is(result.error.name, 'Error');\n+\t});\n+\n+\tmanager.save();\n+});"
      },
      {
        "sha": "c7f263cf40708f87a89cd0ba2cb4075f95a9d562",
        "filename": "test/ts-types/context.ts",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/avajs/ava/blob/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/test%2Fts-types%2Fcontext.ts",
        "raw_url": "https://github.com/avajs/ava/raw/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/test%2Fts-types%2Fcontext.ts",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fts-types%2Fcontext.ts?ref=2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17",
        "patch": "@@ -15,3 +15,8 @@ test.beforeEach(t => {\n });\n \n test('foo is bar', macro, 'bar');\n+\n+anyTest('default context is unknown', t => {\n+\t// @ts-ignore\n+\tt.is(t.context.foo, 'bar')\n+})"
      },
      {
        "sha": "8a4b9dd0d86589a6e7b4989799939c3bd492ef46",
        "filename": "test/ts-types/try-commit.ts",
        "status": "added",
        "additions": 86,
        "deletions": 0,
        "changes": 86,
        "blob_url": "https://github.com/avajs/ava/blob/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/test%2Fts-types%2Ftry-commit.ts",
        "raw_url": "https://github.com/avajs/ava/raw/2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17/test%2Fts-types%2Ftry-commit.ts",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fts-types%2Ftry-commit.ts?ref=2b8ba3ac99f7ed9ea6ea5297c915a16bbcf28a17",
        "patch": "@@ -0,0 +1,86 @@\n+import test, {ExecutionContext, Macro} from '../..';\n+\n+{\n+\ttest('attempt', async t => {\n+\t\tconst attempt = await t.try(\n+\t\t\t(u, a, b) => {\n+\t\t\t\tu.is(a.length, b);\n+\t\t\t},\n+\t\t\t'string',\n+\t\t\t6\n+\t\t);\n+\t\tattempt.commit();\n+\t});\n+\n+\ttest('attempt with title', async t => {\n+\t\tconst attempt = await t.try(\n+\t\t\t'attempt title',\n+\t\t\t(u, a, b) => {\n+\t\t\t\tu.is(a.length, b);\n+\t\t\t},\n+\t\t\t'string',\n+\t\t\t6\n+\t\t);\n+\t\tattempt.commit();\n+\t});\n+\n+\ttest('multiple attempts', async t => {\n+\t\tconst attempts = [\n+\t\t\t...await t.try([tt => tt.pass(), tt => tt.pass()]),\n+\t\t\t...await t.try('title', [tt => tt.pass(), tt => tt.pass()]),\n+\t\t];\n+\t\tfor (const attempt of attempts) {\n+\t\t\tattempt.commit();\n+\t\t}\n+\t});\n+}\n+\n+{\n+\tconst lengthCheck = (t: ExecutionContext, a: string, b: number) => {\n+\t\tt.is(a.length, b);\n+\t};\n+\n+\ttest('attempt with helper', async t => {\n+\t\tconst attempt = await t.try(lengthCheck, 'string', 6);\n+\t\tattempt.commit();\n+\t});\n+\n+\ttest('attempt with title', async t => {\n+\t\tconst attempt = await t.try(lengthCheck, 'string', 6);\n+\t\tattempt.commit();\n+\t});\n+}\n+\n+{\n+\ttest('all possible variants to pass to t.try', async t => {\n+\t\t// no params\n+\t\tt.try(tt => tt.pass());\n+\t\t/* fails as expected */ // t.try([]);\n+\t\tt.try([tt => tt.pass()]);\n+\t\tt.try([tt => tt.pass(), tt => tt.fail()]);\n+\n+\t\tt.try('test', tt => tt.pass());\n+\t\t/* fails as expected */ // t.try('test', []);\n+\t\tt.try('test', [tt => tt.pass()]);\n+\t\tt.try('test', [tt => tt.pass(), tt => tt.fail()]);\n+\n+\t\t// some params\n+\t\tt.try((tt, a, b) => tt.is(a.length, b), 'hello', 5);\n+\t\t/* fails as expected */ // t.try([], 'hello', 5);\n+\t\tt.try([(tt, a, b) => tt.is(a.length, b)], 'hello', 5);\n+\t\tt.try([(tt, a, b) => tt.is(a.length, b), (tt, a, b) => tt.is(a.slice(b), '')], 'hello', 5);\n+\n+\t\tt.try('test', (tt, a, b) => tt.is(a.length, b), 'hello', 5);\n+\t\t/* fails as expected */ // t.try('test', [], 'hello', 5);\n+\t\tt.try('test', [(tt, a, b) => tt.is(a.length, b)], 'hello', 5);\n+\t\tt.try('test', [(tt, a, b) => tt.is(a.length, b), (tt, a, b) => tt.is(a.slice(b), '')], 'hello', 5);\n+\n+\t\t// macro with title\n+\t\tconst macro1: Macro<[string, number]> = (tt, a, b) => tt.is(a.length, b);\n+\t\tmacro1.title = (title, a, b) => `${title ? `${title} `: ''}str: \"${a}\" with len: \"${b}\"`;\n+\t\tconst macro2: Macro<[string, number]> = (tt, a, b) => tt.is(a.slice(b), '');\n+\n+\t\tt.try([macro1, macro2], 'hello', 5);\n+\t\tt.try('title', [macro1, macro2], 'hello', 5);\n+\t});\n+}"
      }
    ]
  },
  {
    "url": "https://api.github.com/repos/avajs/ava/issues/1722",
    "repository_url": "https://api.github.com/repos/avajs/ava",
    "labels_url": "https://api.github.com/repos/avajs/ava/issues/1722/labels{/name}",
    "comments_url": "https://api.github.com/repos/avajs/ava/issues/1722/comments",
    "events_url": "https://api.github.com/repos/avajs/ava/issues/1722/events",
    "html_url": "https://github.com/avajs/ava/pull/1722",
    "id": 298334635,
    "node_id": "MDExOlB1bGxSZXF1ZXN0MTcwMDA0MTcy",
    "number": 1722,
    "title": "Refactor IPC, status and reporters",
    "user": {
      "login": "novemberborn",
      "id": 33538,
      "node_id": "MDQ6VXNlcjMzNTM4",
      "avatar_url": "https://avatars.githubusercontent.com/u/33538?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/novemberborn",
      "html_url": "https://github.com/novemberborn",
      "followers_url": "https://api.github.com/users/novemberborn/followers",
      "following_url": "https://api.github.com/users/novemberborn/following{/other_user}",
      "gists_url": "https://api.github.com/users/novemberborn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/novemberborn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/novemberborn/subscriptions",
      "organizations_url": "https://api.github.com/users/novemberborn/orgs",
      "repos_url": "https://api.github.com/users/novemberborn/repos",
      "events_url": "https://api.github.com/users/novemberborn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/novemberborn/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 672695353,
        "node_id": "MDU6TGFiZWw2NzI2OTUzNTM=",
        "url": "https://api.github.com/repos/avajs/ava/labels/scope:reporters",
        "name": "scope:reporters",
        "color": "d93f0b",
        "default": false,
        "description": null
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/avajs/ava/milestones/2",
      "html_url": "https://github.com/avajs/ava/milestone/2",
      "labels_url": "https://api.github.com/repos/avajs/ava/milestones/2/labels",
      "id": 3036701,
      "node_id": "MDk6TWlsZXN0b25lMzAzNjcwMQ==",
      "number": 2,
      "title": "1.0",
      "description": "",
      "creator": {
        "login": "novemberborn",
        "id": 33538,
        "node_id": "MDQ6VXNlcjMzNTM4",
        "avatar_url": "https://avatars.githubusercontent.com/u/33538?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/novemberborn",
        "html_url": "https://github.com/novemberborn",
        "followers_url": "https://api.github.com/users/novemberborn/followers",
        "following_url": "https://api.github.com/users/novemberborn/following{/other_user}",
        "gists_url": "https://api.github.com/users/novemberborn/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/novemberborn/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/novemberborn/subscriptions",
        "organizations_url": "https://api.github.com/users/novemberborn/orgs",
        "repos_url": "https://api.github.com/users/novemberborn/repos",
        "events_url": "https://api.github.com/users/novemberborn/events{/privacy}",
        "received_events_url": "https://api.github.com/users/novemberborn/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 0,
      "closed_issues": 40,
      "state": "closed",
      "created_at": "2018-01-15T16:32:53Z",
      "updated_at": "2019-01-27T17:16:24Z",
      "due_on": null,
      "closed_at": "2019-01-27T17:16:24Z"
    },
    "comments": 8,
    "created_at": "2018-02-19T16:25:40Z",
    "updated_at": "2018-04-22T16:54:50Z",
    "closed_at": "2018-04-22T16:54:46Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "draft": false,
    "pull_request": {
      "url": "https://api.github.com/repos/avajs/ava/pulls/1722",
      "html_url": "https://github.com/avajs/ava/pull/1722",
      "diff_url": "https://github.com/avajs/ava/pull/1722.diff",
      "patch_url": "https://github.com/avajs/ava/pull/1722.patch",
      "merged_at": "2018-04-22T16:54:46Z"
    },
    "body": "Simplify how test results flow from the worker processes to the API instance to the reporters by emitting \"state changes\" rather than specific events.\r\n\r\nWorkers report (most) state changes as they happen, they're collated for each run, and reporters receive each state change and can write to the console in turn. Stats are computed centrally in `lib/run-status.js` and are emitted whenever they change, thus simplifying reporters.\r\n\r\nBecause workers report state changes as they happen we can greatly simplify their coordination with the main process. We just need to make sure the last state change has been received before exiting. If the main process decides to exit a worker it can simplify do so, it'll already have received results from completed tests.\r\n\r\nError conditions are either explicit or can be inferred from the computed stats.\r\n\r\nThe API now emits its plan of the tests it'll run, which can then be sent to the reporters. This leads to better separation of concerns between the reporters, the run status, the API and the watch mode\r\nimplementation.\r\n\r\nUncaught exceptions and unhandled rejections are now shown with a code excerpt if possible. There are other minor variations in the reporter output, but I've tried to keep changes to a minimum.\r\n\r\nAll reporters now write to `process.stdout`. The `stdout` and `stderr` output from workers is written to `process.stderr`. AVA will insert line breaks in `process.stdout` after writing a chunk to `process.stderr` that does not end in a line break.\r\n\r\nIn watch mode, files being rerun are now excluded from the previous failure count.\r\n\r\n`profile.js` is now wired up to use the verbose reporter. It's still a terrible hack though.\r\n\r\nPorting the tests surfaced some integration-type tests that no longer made sense. They've been removed. Hopefully I haven't gone overboard with that. Ideally we'd rewrite the integration tests but that's a lot of work. Code coverage still looks good though.\r\n\r\n---\r\n\r\nAdditional changes:\r\n\r\n* `append-transform`, `nyc` and `require-precompiled` are now removed from error stacks\r\n* Reporters are now verified using integration tests. This replaces the previous reporter tests. Instead we run the reporter for varying test outputs and record the results. The environment is modified to ensure the highest fidelity colors and figures are used. Where necessary output is rewritten so the resulting logs can be compared across Node.js versions and operating systems.\r\n\r\n  `./test/helpers/replay.js` can be used to replay a log file.\r\n* Test implementations are now called so that `this ==== null`. Previously we were exposing the test instance through `this`, and we shouldn't have been\r\n* `time-require` has been removed. It was only used when `DEBUG=ava` but it's not super useful during development. Users can load it themselves if they want to measure how quickly their own code loads\r\n* We now instantiate our own copy of `chalk`. This will make it easier to inherit the color level from the main process (#1701)\r\n* When serializing errors, if the value is not an actual error object we'll format it using Concordance and display that instead\r\n* No more repeated timeouts for the same worker\r\n\r\n---\r\n\r\nTo do:\r\n\r\n* [x] Port mini and TAP reporters\r\n* [x] Ensure tests pass\r\n* [ ] Ensure good coverage for new reporter code\r\n\r\nFollow-up issues:\r\n\r\n* [ ] File issue so color level can be defined in AVA's `package.json` options\r\n* [ ] Unblock existing reporter issues",
    "reactions": {
      "url": "https://api.github.com/repos/avajs/ava/issues/1722/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/avajs/ava/issues/1722/timeline",
    "performed_via_github_app": null,
    "state_reason": null,
    "score": 1,
    "files": [
      {
        "sha": "5342377eb2a36a254f9ad173f958c1d85dab1d04",
        "filename": "api.js",
        "status": "modified",
        "additions": 73,
        "deletions": 84,
        "changes": 157,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/api.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/api.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/api.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,5 +1,4 @@\n 'use strict';\n-const EventEmitter = require('events');\n const path = require('path');\n const fs = require('fs');\n const os = require('os');\n@@ -14,10 +13,11 @@ const arrify = require('arrify');\n const ms = require('ms');\n const babelConfigHelper = require('./lib/babel-config');\n const CachingPrecompiler = require('./lib/caching-precompiler');\n+const Emittery = require('./lib/emittery');\n const RunStatus = require('./lib/run-status');\n-const AvaError = require('./lib/ava-error');\n const AvaFiles = require('./lib/ava-files');\n const fork = require('./lib/fork');\n+const serializeError = require('./lib/serialize-error');\n \n function resolveModules(modules) {\n \treturn arrify(modules).map(name => {\n@@ -31,7 +31,7 @@ function resolveModules(modules) {\n \t});\n }\n \n-class Api extends EventEmitter {\n+class Api extends Emittery {\n \tconstructor(options) {\n \t\tsuper();\n \n@@ -46,19 +46,13 @@ class Api extends EventEmitter {\n \t\t// Each run will have its own status. It can only be created when test files\n \t\t// have been found.\n \t\tlet runStatus;\n-\n \t\t// Irrespectively, perform some setup now, before finding test files.\n-\t\tconst handleError = exception => {\n-\t\t\trunStatus.handleExceptions({\n-\t\t\t\texception,\n-\t\t\t\tfile: exception.file ? path.relative(process.cwd(), exception.file) : undefined\n-\t\t\t});\n-\t\t};\n \n \t\t// Track active forks and manage timeouts.\n \t\tconst failFast = apiOptions.failFast === true;\n \t\tlet bailed = false;\n-\t\tconst pendingForks = new Set();\n+\t\tconst pendingWorkers = new Set();\n+\t\tconst timedOutWorkerFiles = new Set();\n \t\tlet restartTimer;\n \t\tif (apiOptions.timeout) {\n \t\t\tconst timeout = ms(apiOptions.timeout);\n@@ -70,11 +64,12 @@ class Api extends EventEmitter {\n \t\t\t\t\tbailed = true;\n \t\t\t\t}\n \n-\t\t\t\tfor (const fork of pendingForks) {\n-\t\t\t\t\tfork.exit();\n+\t\t\t\tfor (const worker of pendingWorkers) {\n+\t\t\t\t\ttimedOutWorkerFiles.add(worker.file);\n+\t\t\t\t\tworker.exit();\n \t\t\t\t}\n \n-\t\t\t\thandleError(new AvaError(`Exited because no new tests completed within the last ${timeout}ms of inactivity`));\n+\t\t\t\trunStatus.emitStateChange({type: 'timeout', period: timeout});\n \t\t\t}, timeout);\n \t\t} else {\n \t\t\trestartTimer = Object.assign(() => {}, {cancel() {}});\n@@ -83,39 +78,48 @@ class Api extends EventEmitter {\n \t\t// Find all test files.\n \t\treturn new AvaFiles({cwd: apiOptions.resolveTestsFrom, files}).findTestFiles()\n \t\t\t.then(files => {\n-\t\t\t\trunStatus = new RunStatus({\n-\t\t\t\t\trunOnlyExclusive: runtimeOptions.runOnlyExclusive,\n-\t\t\t\t\tprefixTitles: apiOptions.explicitTitles || files.length > 1,\n-\t\t\t\t\tbase: path.relative(process.cwd(), commonPathPrefix(files)) + path.sep,\n-\t\t\t\t\tfailFast,\n-\t\t\t\t\tfileCount: files.length,\n-\t\t\t\t\tupdateSnapshots: runtimeOptions.updateSnapshots\n+\t\t\t\trunStatus = new RunStatus(files.length);\n+\n+\t\t\t\tconst emittedRun = this.emit('run', {\n+\t\t\t\t\tclearLogOnNextRun: runtimeOptions.clearLogOnNextRun === true,\n+\t\t\t\t\tfailFastEnabled: failFast,\n+\t\t\t\t\tfilePathPrefix: commonPathPrefix(files),\n+\t\t\t\t\tfiles,\n+\t\t\t\t\tmatching: apiOptions.match.length > 0,\n+\t\t\t\t\tpreviousFailures: runtimeOptions.previousFailures || 0,\n+\t\t\t\t\trunOnlyExclusive: runtimeOptions.runOnlyExclusive === true,\n+\t\t\t\t\trunVector: runtimeOptions.runVector || 0,\n+\t\t\t\t\tstatus: runStatus\n \t\t\t\t});\n \n-\t\t\t\trunStatus.on('test', restartTimer);\n-\t\t\t\tif (failFast) {\n-\t\t\t\t\t// Prevent new test files from running once a test has failed.\n-\t\t\t\t\trunStatus.on('test', test => {\n-\t\t\t\t\t\tif (test.error) {\n-\t\t\t\t\t\t\tbailed = true;\n-\n-\t\t\t\t\t\t\tfor (const fork of pendingForks) {\n-\t\t\t\t\t\t\t\tfork.notifyOfPeerFailure();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n+\t\t\t\t// Bail out early if no files were found.\n+\t\t\t\tif (files.length === 0) {\n+\t\t\t\t\treturn emittedRun.then(() => {\n+\t\t\t\t\t\treturn runStatus;\n \t\t\t\t\t});\n \t\t\t\t}\n \n-\t\t\t\tthis.emit('test-run', runStatus, files);\n+\t\t\t\trunStatus.on('stateChange', record => {\n+\t\t\t\t\tif (record.testFile && !timedOutWorkerFiles.has(record.testFile)) {\n+\t\t\t\t\t\t// Restart the timer whenever there is activity from workers that\n+\t\t\t\t\t\t// haven't already timed out.\n+\t\t\t\t\t\trestartTimer();\n+\t\t\t\t\t}\n \n-\t\t\t\t// Bail out early if no files were found.\n-\t\t\t\tif (files.length === 0) {\n-\t\t\t\t\thandleError(new AvaError('Couldn\\'t find any files to test'));\n-\t\t\t\t\treturn runStatus;\n-\t\t\t\t}\n+\t\t\t\t\tif (failFast && (record.type === 'hook-failed' || record.type === 'test-failed' || record.type === 'worker-failed')) {\n+\t\t\t\t\t\t// Prevent new test files from running once a test has failed.\n+\t\t\t\t\t\tbailed = true;\n+\n+\t\t\t\t\t\t// Try to stop currently scheduled tests.\n+\t\t\t\t\t\tfor (const worker of pendingWorkers) {\n+\t\t\t\t\t\t\tworker.notifyOfPeerFailure();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t});\n \n \t\t\t\t// Set up a fresh precompiler for each test run.\n-\t\t\t\treturn this._setupPrecompiler()\n+\t\t\t\treturn emittedRun\n+\t\t\t\t\t.then(() => this._setupPrecompiler())\n \t\t\t\t\t.then(precompilation => {\n \t\t\t\t\t\tif (!precompilation) {\n \t\t\t\t\t\t\treturn null;\n@@ -156,59 +160,44 @@ class Api extends EventEmitter {\n \t\t\t\t\t\t\t// No new files should be run once a test has timed out or failed,\n \t\t\t\t\t\t\t// and failFast is enabled.\n \t\t\t\t\t\t\tif (bailed) {\n-\t\t\t\t\t\t\t\treturn null;\n+\t\t\t\t\t\t\t\treturn;\n \t\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\tlet forked;\n-\t\t\t\t\t\t\treturn Bluebird.resolve(\n-\t\t\t\t\t\t\t\tthis._computeForkExecArgv().then(execArgv => {\n-\t\t\t\t\t\t\t\t\tconst options = Object.assign({}, apiOptions, {\n-\t\t\t\t\t\t\t\t\t\t// If we're looking for matches, run every single test process in exclusive-only mode\n-\t\t\t\t\t\t\t\t\t\trunOnlyExclusive: apiOptions.match.length > 0 || runtimeOptions.runOnlyExclusive === true\n-\t\t\t\t\t\t\t\t\t});\n-\t\t\t\t\t\t\t\t\tif (precompilation) {\n-\t\t\t\t\t\t\t\t\t\toptions.cacheDir = precompilation.cacheDir;\n-\t\t\t\t\t\t\t\t\t\toptions.precompiled = precompilation.map;\n-\t\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\t\toptions.precompiled = {};\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\tif (runtimeOptions.updateSnapshots) {\n-\t\t\t\t\t\t\t\t\t\t// Don't use in Object.assign() since it'll override options.updateSnapshots even when false.\n-\t\t\t\t\t\t\t\t\t\toptions.updateSnapshots = true;\n-\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\tforked = fork(file, options, execArgv);\n-\t\t\t\t\t\t\t\t\tpendingForks.add(forked);\n-\t\t\t\t\t\t\t\t\trunStatus.observeFork(forked);\n-\t\t\t\t\t\t\t\t\trestartTimer();\n-\t\t\t\t\t\t\t\t\treturn forked;\n-\t\t\t\t\t\t\t\t}).catch(err => {\n-\t\t\t\t\t\t\t\t\t// Prevent new test files from running.\n-\t\t\t\t\t\t\t\t\tif (failFast) {\n-\t\t\t\t\t\t\t\t\t\tbailed = true;\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\thandleError(Object.assign(err, {file}));\n-\t\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t\t})\n-\t\t\t\t\t\t\t).finally(() => {\n-\t\t\t\t\t\t\t\tpendingForks.delete(forked);\n+\t\t\t\t\t\t\treturn this._computeForkExecArgv().then(execArgv => {\n+\t\t\t\t\t\t\t\tconst options = Object.assign({}, apiOptions, {\n+\t\t\t\t\t\t\t\t\t// If we're looking for matches, run every single test process in exclusive-only mode\n+\t\t\t\t\t\t\t\t\trunOnlyExclusive: apiOptions.match.length > 0 || runtimeOptions.runOnlyExclusive === true\n+\t\t\t\t\t\t\t\t});\n+\t\t\t\t\t\t\t\tif (precompilation) {\n+\t\t\t\t\t\t\t\t\toptions.cacheDir = precompilation.cacheDir;\n+\t\t\t\t\t\t\t\t\toptions.precompiled = precompilation.map;\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\toptions.precompiled = {};\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tif (runtimeOptions.updateSnapshots) {\n+\t\t\t\t\t\t\t\t\t// Don't use in Object.assign() since it'll override options.updateSnapshots even when false.\n+\t\t\t\t\t\t\t\t\toptions.updateSnapshots = true;\n+\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\tconst worker = fork(file, options, execArgv);\n+\t\t\t\t\t\t\t\trunStatus.observeWorker(worker, file);\n+\n+\t\t\t\t\t\t\t\tpendingWorkers.add(worker);\n+\t\t\t\t\t\t\t\tworker.promise.then(() => { // eslint-disable-line max-nested-callbacks\n+\t\t\t\t\t\t\t\t\tpendingWorkers.delete(worker);\n+\t\t\t\t\t\t\t\t});\n+\n+\t\t\t\t\t\t\t\trestartTimer();\n+\n+\t\t\t\t\t\t\t\treturn worker.promise;\n \t\t\t\t\t\t\t});\n \t\t\t\t\t\t}, {concurrency});\n \t\t\t\t\t})\n \t\t\t\t\t.catch(err => {\n-\t\t\t\t\t\thandleError(err);\n-\t\t\t\t\t\treturn [];\n+\t\t\t\t\t\trunStatus.emitStateChange({type: 'internal-error', err: serializeError('Internal error', false, err)});\n \t\t\t\t\t})\n-\t\t\t\t\t.then(results => {\n+\t\t\t\t\t.then(() => {\n \t\t\t\t\t\trestartTimer.cancel();\n-\n-\t\t\t\t\t\t// Filter out undefined results (e.g. for files that were skipped after a timeout)\n-\t\t\t\t\t\tresults = results.filter(Boolean);\n-\t\t\t\t\t\tif (apiOptions.match.length > 0 && !runStatus.hasExclusive) {\n-\t\t\t\t\t\t\thandleError(new AvaError('Couldn\\'t find any matching tests'));\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\trunStatus.processResults(results);\n \t\t\t\t\t\treturn runStatus;\n \t\t\t\t\t});\n \t\t\t});"
      },
      {
        "sha": "2114a9a14a6839a79e65dc91b590503143867bd8",
        "filename": "cli.js",
        "status": "modified",
        "additions": 1,
        "deletions": 10,
        "changes": 11,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/cli.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/cli.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/cli.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -7,14 +7,5 @@ const importLocal = require('import-local');\n if (importLocal(__filename)) {\n \tdebug('Using local install of AVA');\n } else {\n-\tif (debug.enabled) {\n-\t\trequire('@ladjs/time-require'); // eslint-disable-line import/no-unassigned-import\n-\t}\n-\n-\ttry {\n-\t\trequire('./lib/cli').run();\n-\t} catch (err) {\n-\t\tconsole.error(`\\n  ${err.message}`);\n-\t\tprocess.exit(1);\n-\t}\n+\trequire('./lib/cli').run();\n }"
      },
      {
        "sha": "24f28865b24d7ad12ab25870fb75bae4ecf4e58e",
        "filename": "index.js",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/index.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/index.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/index.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -4,5 +4,5 @@\n if (process.env.AVA_PATH && process.env.AVA_PATH !== __dirname) {\n \tmodule.exports = require(process.env.AVA_PATH);\n } else {\n-\tmodule.exports = require('./lib/main');\n+\tmodule.exports = require('./lib/worker/main');\n }"
      },
      {
        "sha": "05df6b34985f6ec4ea064792108893b02b79cd1e",
        "filename": "lib/ava-error.js",
        "status": "removed",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/lib%2Fava-error.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/lib%2Fava-error.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fava-error.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,10 +0,0 @@\n-'use strict';\n-\n-class AvaError extends Error {\n-\tconstructor(message) {\n-\t\tsuper(message);\n-\t\tthis.name = 'AvaError';\n-\t}\n-}\n-\n-module.exports = AvaError;"
      },
      {
        "sha": "c087d5b413b0cba578db2d0db8f245fd6a233b3b",
        "filename": "lib/babel-config.js",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fbabel-config.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fbabel-config.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fbabel-config.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,12 +1,10 @@\n 'use strict';\n const fs = require('fs');\n const path = require('path');\n-const chalk = require('chalk');\n-const figures = require('figures');\n const configManager = require('hullabaloo-config-manager');\n const md5Hex = require('md5-hex');\n const makeDir = require('make-dir');\n-const colors = require('./colors');\n+const chalk = require('./chalk').get();\n \n const stage4Path = require.resolve('../stage-4');\n const syntaxAsyncGeneratorsPath = require.resolve('@babel/plugin-syntax-async-generators');\n@@ -23,7 +21,7 @@ function validate(conf) {\n \t}\n \n \tif (!conf || typeof conf !== 'object' || !conf.testOptions || typeof conf.testOptions !== 'object' || Array.isArray(conf.testOptions) || Object.keys(conf).length > 1) {\n-\t\tthrow new Error(`${colors.error(figures.cross)} Unexpected Babel configuration for AVA. See ${chalk.underline('https://github.com/avajs/ava/blob/master/docs/recipes/babel.md')} for allowed values.`);\n+\t\tthrow new Error(`Unexpected Babel configuration for AVA. See ${chalk.underline('https://github.com/avajs/ava/blob/master/docs/recipes/babel.md')} for allowed values.`);\n \t}\n \n \treturn conf;"
      },
      {
        "sha": "52959b5934caf870a7f2b9004c817a949e9759f4",
        "filename": "lib/beautify-stack.js",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fbeautify-stack.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fbeautify-stack.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fbeautify-stack.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -6,8 +6,8 @@ const debug = require('debug')('ava');\n // Ignore unimportant stack trace lines\n let ignoreStackLines = [];\n \n-const avaInternals = /\\/ava\\/(?:lib\\/)?[\\w-]+\\.js:\\d+:\\d+\\)?$/;\n-const avaDependencies = /\\/node_modules\\/(?:bluebird|empower-core|(?:ava\\/node_modules\\/)?(?:babel-runtime|core-js))\\//;\n+const avaInternals = /\\/ava\\/(?:lib\\/|lib\\/worker\\/)?[\\w-]+\\.js:\\d+:\\d+\\)?$/;\n+const avaDependencies = /\\/node_modules\\/(?:append-transform|bluebird|empower-core|nyc|require-precompiled|(?:ava\\/node_modules\\/)?(?:babel-runtime|core-js))\\//;\n const stackFrameLine = /^.+( \\(.+:\\d+:\\d+\\)|:\\d+:\\d+)$/;\n \n if (!debug.enabled) {"
      },
      {
        "sha": "ae27dfe9e0ad019b47e9a310279686cdfa856493",
        "filename": "lib/chalk.js",
        "status": "added",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fchalk.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fchalk.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fchalk.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,16 @@\n+'use strict';\n+const Chalk = require('chalk').constructor;\n+\n+let ctx = null;\n+exports.get = () => {\n+\tif (!ctx) {\n+\t\tthrow new Error('Chalk has not yet been configured');\n+\t}\n+\treturn ctx;\n+};\n+exports.set = options => {\n+\tif (ctx) {\n+\t\tthrow new Error('Chalk has already been configured');\n+\t}\n+\tctx = new Chalk(options);\n+};"
      },
      {
        "sha": "bfb5fad74ffb6238450229ca12a233e4e61655ba",
        "filename": "lib/cli.js",
        "status": "modified",
        "additions": 49,
        "deletions": 58,
        "changes": 107,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fcli.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fcli.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fcli.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -7,19 +7,16 @@ const meow = require('meow');\n const Promise = require('bluebird');\n const pkgConf = require('pkg-conf');\n const isCi = require('is-ci');\n-const Api = require('../api');\n-const colors = require('./colors');\n-const VerboseReporter = require('./reporters/verbose');\n-const MiniReporter = require('./reporters/mini');\n-const TapReporter = require('./reporters/tap');\n-const Logger = require('./logger');\n-const Watcher = require('./watcher');\n-const babelConfigHelper = require('./babel-config');\n \n // Bluebird specific\n Promise.longStackTraces();\n \n-exports.run = () => {\n+function exit(message) {\n+\tconsole.error(`\\n  ${require('./chalk').get().red(figures.cross)} ${message}`);\n+\tprocess.exit(1); // eslint-disable-line unicorn/no-process-exit\n+}\n+\n+exports.run = () => { // eslint-disable-line complexity\n \tconst conf = pkgConf.sync('ava');\n \n \tconst filepath = pkgConf.filepath(conf);\n@@ -110,39 +107,54 @@ exports.run = () => {\n \t});\n \n \tupdateNotifier({pkg: cli.pkg}).notify();\n+\trequire('./chalk').set({enabled: cli.flags.color});\n \n \tif (cli.flags.watch && cli.flags.tap && !conf.tap) {\n-\t\tthrow new Error(`${colors.error(figures.cross)} The TAP reporter is not available when using watch mode.`);\n+\t\texit('The TAP reporter is not available when using watch mode.');\n \t}\n \n \tif (cli.flags.watch && isCi) {\n-\t\tthrow new Error(`${colors.error(figures.cross)} Watch mode is not available in CI, as it prevents AVA from terminating.`);\n+\t\texit('Watch mode is not available in CI, as it prevents AVA from terminating.');\n \t}\n \n \tif (\n \t\tcli.flags.concurrency === '' ||\n \t\t(cli.flags.concurrency && (!Number.isInteger(Number.parseFloat(cli.flags.concurrency)) || parseInt(cli.flags.concurrency, 10) < 0))\n \t) {\n-\t\tthrow new Error(`${colors.error(figures.cross)} The --concurrency or -c flag must be provided with a nonnegative integer.`);\n+\t\texit('The --concurrency or -c flag must be provided with a nonnegative integer.');\n \t}\n \n \tif ('source' in conf) {\n-\t\tthrow new Error(`${colors.error(figures.cross)} The 'source' option has been renamed. Use 'sources' instead.`);\n+\t\texit('The \\'source\\' option has been renamed. Use \\'sources\\' instead.');\n+\t}\n+\n+\tconst Api = require('../api');\n+\tconst VerboseReporter = require('./reporters/verbose');\n+\tconst MiniReporter = require('./reporters/mini');\n+\tconst TapReporter = require('./reporters/tap');\n+\tconst Watcher = require('./watcher');\n+\tconst babelConfigHelper = require('./babel-config');\n+\n+\tlet babelConfig = null;\n+\ttry {\n+\t\tbabelConfig = babelConfigHelper.validate(conf.babel);\n+\t} catch (err) {\n+\t\texit(err.message);\n \t}\n \n \t// Copy resultant cli.flags into conf for use with Api and elsewhere\n \tObject.assign(conf, cli.flags);\n \n+\tconst match = arrify(conf.match);\n \tconst api = new Api({\n \t\tfailFast: conf.failFast,\n \t\tfailWithoutAssertions: conf.failWithoutAssertions !== false,\n \t\tserial: conf.serial,\n \t\trequire: arrify(conf.require),\n \t\tcacheEnabled: conf.cache,\n \t\tcompileEnhancements: conf.compileEnhancements !== false,\n-\t\texplicitTitles: conf.watch,\n-\t\tmatch: arrify(conf.match),\n-\t\tbabelConfig: babelConfigHelper.validate(conf.babel),\n+\t\tmatch,\n+\t\tbabelConfig,\n \t\tresolveTestsFrom: cli.input.length === 0 ? projectDir : process.cwd(),\n \t\tprojectDir,\n \t\ttimeout: conf.timeout,\n@@ -154,57 +166,36 @@ exports.run = () => {\n \t});\n \n \tlet reporter;\n-\n \tif (conf.tap && !conf.watch) {\n-\t\treporter = new TapReporter();\n+\t\treporter = new TapReporter({\n+\t\t\treportStream: process.stdout,\n+\t\t\tstdStream: process.stderr\n+\t\t});\n \t} else if (conf.verbose || isCi) {\n-\t\treporter = new VerboseReporter({color: conf.color, watching: conf.watch});\n+\t\treporter = new VerboseReporter({\n+\t\t\treportStream: process.stdout,\n+\t\t\tstdStream: process.stderr,\n+\t\t\twatching: conf.watch\n+\t\t});\n \t} else {\n-\t\treporter = new MiniReporter({color: conf.color, watching: conf.watch});\n+\t\treporter = new MiniReporter({\n+\t\t\treportStream: process.stdout,\n+\t\t\tstdStream: process.stderr,\n+\t\t\twatching: conf.watch\n+\t\t});\n \t}\n \n-\treporter.api = api;\n-\tconst logger = new Logger(reporter);\n-\n-\tlogger.start();\n-\n-\tapi.on('test-run', runStatus => {\n-\t\treporter.api = runStatus;\n-\t\trunStatus.on('test', logger.test);\n-\t\trunStatus.on('error', logger.unhandledError);\n-\n-\t\trunStatus.on('stdout', logger.stdout);\n-\t\trunStatus.on('stderr', logger.stderr);\n-\t});\n+\tapi.on('run', plan => reporter.startRun(plan));\n \n \tconst files = cli.input.length ? cli.input : arrify(conf.files);\n \n \tif (conf.watch) {\n-\t\ttry {\n-\t\t\tconst watcher = new Watcher(logger, api, files, arrify(conf.sources));\n-\t\t\twatcher.observeStdin(process.stdin);\n-\t\t} catch (err) {\n-\t\t\tif (err.name === 'AvaError') {\n-\t\t\t\t// An AvaError may be thrown if `chokidar` is not installed. Log it nicely.\n-\t\t\t\tconsole.error(`  ${colors.error(figures.cross)} ${err.message}`);\n-\t\t\t\tlogger.exit(1);\n-\t\t\t} else {\n-\t\t\t\t// Rethrow so it becomes an uncaught exception\n-\t\t\t\tthrow err;\n-\t\t\t}\n-\t\t}\n+\t\tconst watcher = new Watcher(reporter, api, files, arrify(conf.sources));\n+\t\twatcher.observeStdin(process.stdin);\n \t} else {\n-\t\tapi.run(files)\n-\t\t\t.then(runStatus => {\n-\t\t\t\tlogger.finish(runStatus);\n-\t\t\t\tlogger.exit(runStatus.failCount > 0 || runStatus.rejectionCount > 0 || runStatus.exceptionCount > 0 ? 1 : 0);\n-\t\t\t})\n-\t\t\t.catch(err => {\n-\t\t\t\t// Don't swallow exceptions. Note that any expected error should already\n-\t\t\t\t// have been logged.\n-\t\t\t\tsetImmediate(() => {\n-\t\t\t\t\tthrow err;\n-\t\t\t\t});\n-\t\t\t});\n+\t\tapi.run(files).then(runStatus => {\n+\t\t\tprocess.exitCode = runStatus.suggestExitCode({matching: match.length > 0});\n+\t\t\treporter.endRun();\n+\t\t});\n \t}\n };"
      },
      {
        "sha": "7f2a4623fcff1e5ff35aeb083cfaef326029518c",
        "filename": "lib/code-excerpt.js",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fcode-excerpt.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fcode-excerpt.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fcode-excerpt.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -3,7 +3,7 @@ const fs = require('fs');\n const equalLength = require('equal-length');\n const codeExcerpt = require('code-excerpt');\n const truncate = require('cli-truncate');\n-const chalk = require('chalk');\n+const chalk = require('./chalk').get();\n \n const formatLineNumber = (lineNumber, maxLineNumber) =>\n \t' '.repeat(Math.max(0, String(maxLineNumber).length - String(lineNumber).length)) + lineNumber;"
      },
      {
        "sha": "b934ab58a4007393ea82241eb1b571b2fc02060c",
        "filename": "lib/concordance-options.js",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fconcordance-options.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fconcordance-options.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fconcordance-options.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,10 +1,9 @@\n 'use strict';\n const ansiStyles = require('ansi-styles');\n-const chalk = require('chalk');\n const stripAnsi = require('strip-ansi');\n const cloneDeepWith = require('lodash.clonedeepwith');\n const reactPlugin = require('@concordance/react');\n-const options = require('./worker-options').get();\n+const chalk = require('./chalk').get();\n \n // Wrap Concordance's React plugin. Change the name to avoid collisions if in\n // the future users can register plugins themselves.\n@@ -124,7 +123,7 @@ const plainTheme = cloneDeepWith(colorTheme, value => {\n \t}\n });\n \n-const theme = options.color === false ? plainTheme : colorTheme;\n+const theme = chalk.enabled ? colorTheme : plainTheme;\n exports.default = {maxDepth: 3, plugins, theme};\n exports.diff = {maxDepth: 1, plugins, theme};\n exports.snapshotManager = {plugins, theme: plainTheme};"
      },
      {
        "sha": "57405d21df38c80eeea75f3bda79d71337753a23",
        "filename": "lib/emittery.js",
        "status": "added",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Femittery.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Femittery.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Femittery.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,6 @@\n+'use strict';\n+try {\n+\tmodule.exports = require('emittery');\n+} catch (err) {\n+\tmodule.exports = require('emittery/legacy');\n+}"
      },
      {
        "sha": "eb2399f2b68e88b2f2957b4df57aec7cd05216bd",
        "filename": "lib/fork.js",
        "status": "modified",
        "additions": 63,
        "deletions": 92,
        "changes": 155,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Ffork.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Ffork.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Ffork.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -3,8 +3,7 @@ const childProcess = require('child_process');\n const path = require('path');\n const fs = require('fs');\n const Promise = require('bluebird');\n-const debug = require('debug')('ava');\n-const AvaError = require('./ava-error');\n+const Emittery = require('./emittery');\n \n if (fs.realpathSync(__filename) !== __filename) {\n \tconsole.warn('WARNING: `npm link ava` and the `--preserve-symlink` flag are incompatible. We have detected that AVA is linked via `npm link`, and that you are using either an early version of Node 6, or the `--preserve-symlink` flag. This breaks AVA. You should upgrade to Node 6.2.0+, avoid the `--preserve-symlink` flag, or avoid using `npm link ava`.');\n@@ -24,132 +23,104 @@ if (env.NODE_PATH) {\n // the presence of this variable allows it to require this one instead\n env.AVA_PATH = path.resolve(__dirname, '..');\n \n+const workerPath = require.resolve('./worker/subprocess');\n+\n module.exports = (file, opts, execArgv) => {\n+\tlet finished = false;\n+\n+\tconst emitter = new Emittery();\n+\tconst emitStateChange = evt => {\n+\t\tif (!finished) {\n+\t\t\temitter.emit('stateChange', Object.assign(evt, {testFile: file}));\n+\t\t}\n+\t};\n+\n \topts = Object.assign({\n \t\tfile,\n \t\tbaseDir: process.cwd(),\n \t\ttty: process.stdout.isTTY ? {\n-\t\t\tcolumns: process.stdout.columns,\n+\t\t\tcolumns: process.stdout.columns || 80,\n \t\t\trows: process.stdout.rows\n \t\t} : false\n \t}, opts);\n \n \tconst args = [JSON.stringify(opts), opts.color ? '--color' : '--no-color'].concat(opts.workerArgv);\n \n-\tconst ps = childProcess.fork(path.join(__dirname, 'test-worker.js'), args, {\n+\tconst subprocess = childProcess.fork(workerPath, args, {\n \t\tcwd: opts.projectDir,\n \t\tsilent: true,\n \t\tenv,\n \t\texecArgv: execArgv || process.execArgv\n \t});\n \n-\tconst relFile = path.relative('.', file);\n-\n-\tlet exiting = false;\n-\tconst send = (name, data) => {\n-\t\tif (!exiting) {\n-\t\t\t// This seems to trigger a Node bug which kills the AVA master process, at\n-\t\t\t// least while running AVA's tests. See\n-\t\t\t// <https://github.com/novemberborn/_ava-tap-crash> for more details.\n-\t\t\tps.send({\n-\t\t\t\tname: `ava-${name}`,\n-\t\t\t\tdata,\n-\t\t\t\tava: true\n-\t\t\t});\n+\tsubprocess.stdout.on('data', chunk => {\n+\t\temitStateChange({type: 'worker-stdout', chunk});\n+\t});\n+\n+\tsubprocess.stderr.on('data', chunk => {\n+\t\temitStateChange({type: 'worker-stderr', chunk});\n+\t});\n+\n+\tlet forcedExit = false;\n+\tconst send = evt => {\n+\t\tif (subprocess.connected && !finished && !forcedExit) {\n+\t\t\tsubprocess.send({ava: evt});\n \t\t}\n \t};\n \n-\tlet loadedFile = false;\n-\tconst testResults = [];\n-\tlet results;\n+\tconst promise = new Promise(resolve => {\n+\t\tconst finish = () => {\n+\t\t\tfinished = true;\n+\t\t\tresolve();\n+\t\t};\n \n-\tconst promise = new Promise((resolve, reject) => {\n-\t\tps.on('error', reject);\n-\n-\t\t// Emit `test` and `stats` events\n-\t\tps.on('message', event => {\n-\t\t\tif (!event.ava) {\n+\t\tsubprocess.on('message', message => {\n+\t\t\tif (!message.ava) {\n \t\t\t\treturn;\n \t\t\t}\n \n-\t\t\tevent.name = event.name.replace(/^ava-/, '');\n-\t\t\tevent.data.file = relFile;\n-\n-\t\t\tdebug('ipc %s:\\n%o', event.name, event.data);\n-\n-\t\t\tps.emit(event.name, event.data);\n-\t\t});\n-\n-\t\tps.on('test', props => {\n-\t\t\ttestResults.push(props);\n+\t\t\tif (message.ava.type === 'ping') {\n+\t\t\t\tsend({type: 'pong'});\n+\t\t\t} else {\n+\t\t\t\temitStateChange(message.ava);\n+\t\t\t}\n \t\t});\n \n-\t\tps.on('results', data => {\n-\t\t\tresults = data;\n-\t\t\tdata.tests = testResults;\n-\t\t\tsend('teardown');\n+\t\tsubprocess.on('error', err => {\n+\t\t\temitStateChange({type: 'worker-failed', err});\n+\t\t\tfinish();\n \t\t});\n \n-\t\tps.on('exit', (code, signal) => {\n-\t\t\tif (code > 0) {\n-\t\t\t\treturn reject(new AvaError(`${relFile} exited with a non-zero exit code: ${code}`));\n-\t\t\t}\n-\n-\t\t\tif (code === null && signal) {\n-\t\t\t\treturn reject(new AvaError(`${relFile} exited due to ${signal}`));\n-\t\t\t}\n-\n-\t\t\tif (results) {\n-\t\t\t\tresolve(results);\n-\t\t\t} else if (loadedFile) {\n-\t\t\t\treject(new AvaError(`No tests found in ${relFile}`));\n+\t\tsubprocess.on('exit', (code, signal) => {\n+\t\t\tif (forcedExit) {\n+\t\t\t\temitStateChange({type: 'worker-finished', forcedExit});\n+\t\t\t} else if (code > 0) {\n+\t\t\t\temitStateChange({type: 'worker-failed', nonZeroExitCode: code});\n+\t\t\t} else if (code === null && signal) {\n+\t\t\t\temitStateChange({type: 'worker-failed', signal});\n \t\t\t} else {\n-\t\t\t\treject(new AvaError(`Test results were not received from ${relFile}`));\n+\t\t\t\temitStateChange({type: 'worker-finished', forcedExit});\n \t\t\t}\n-\t\t});\n-\n-\t\tps.on('loaded-file', data => {\n-\t\t\tloadedFile = true;\n \n-\t\t\tif (!data.avaRequired) {\n-\t\t\t\tsend('teardown');\n-\t\t\t\treject(new AvaError(`No tests found in ${relFile}, make sure to import \"ava\" at the top of your test file`));\n-\t\t\t}\n+\t\t\tfinish();\n \t\t});\n \t});\n \n-\t// Teardown finished, now exit\n-\tps.on('teardown', () => {\n-\t\tsend('exit');\n-\t\texiting = true;\n-\t});\n+\treturn {\n+\t\texit() {\n+\t\t\tforcedExit = true;\n+\t\t\tsubprocess.kill();\n+\t\t},\n \n-\t// Uncaught exception in fork, need to exit\n-\tps.on('uncaughtException', () => {\n-\t\tsend('teardown');\n-\t});\n+\t\tnotifyOfPeerFailure() {\n+\t\t\tsend({type: 'peer-failed'});\n+\t\t},\n \n-\tps.stdout.on('data', data => {\n-\t\tps.emit('stdout', data);\n-\t});\n+\t\tonStateChange(listener) {\n+\t\t\treturn emitter.on('stateChange', listener);\n+\t\t},\n \n-\tps.stderr.on('data', data => {\n-\t\tps.emit('stderr', data);\n-\t});\n-\n-\tpromise.on = function () {\n-\t\tps.on.apply(ps, arguments);\n-\t\treturn promise;\n-\t};\n-\n-\tpromise.exit = () => {\n-\t\tsend('init-exit');\n-\t\treturn promise;\n-\t};\n-\n-\tpromise.notifyOfPeerFailure = () => {\n-\t\tsend('peer-failed');\n+\t\tfile,\n+\t\tpromise\n \t};\n-\n-\treturn promise;\n };"
      },
      {
        "sha": "9256f4979fe427389ccb12e7a30beb2cf1302ca4",
        "filename": "lib/logger.js",
        "status": "removed",
        "additions": 0,
        "deletions": 92,
        "changes": 92,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/lib%2Flogger.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/lib%2Flogger.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Flogger.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,92 +0,0 @@\n-'use strict';\n-const autoBind = require('auto-bind');\n-\n-class Logger {\n-\tconstructor(reporter) {\n-\t\tthis.reporter = reporter;\n-\t\tautoBind(this);\n-\t}\n-\n-\tstart(runStatus) {\n-\t\tif (!this.reporter.start) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tthis.write(this.reporter.start(runStatus), runStatus);\n-\t}\n-\n-\treset(runStatus) {\n-\t\tif (!this.reporter.reset) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tthis.write(this.reporter.reset(runStatus), runStatus);\n-\t}\n-\n-\ttest(test, runStatus) {\n-\t\tthis.write(this.reporter.test(test), runStatus);\n-\t}\n-\n-\tunhandledError(err, runStatus) {\n-\t\tif (!this.reporter.unhandledError) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tthis.write(this.reporter.unhandledError(err, runStatus), runStatus);\n-\t}\n-\n-\tfinish(runStatus) {\n-\t\tif (!this.reporter.finish) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tthis.write(this.reporter.finish(runStatus), runStatus);\n-\t}\n-\n-\tsection() {\n-\t\tif (!this.reporter.section) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tthis.write(this.reporter.section());\n-\t}\n-\n-\tclear() {\n-\t\tif (!this.reporter.clear) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tthis.write(this.reporter.clear());\n-\t\treturn true;\n-\t}\n-\n-\twrite(str, runStatus) {\n-\t\tif (typeof str === 'undefined') {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tthis.reporter.write(str, runStatus);\n-\t}\n-\n-\tstdout(data, runStatus) {\n-\t\tif (!this.reporter.stdout) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tthis.reporter.stdout(data, runStatus);\n-\t}\n-\n-\tstderr(data, runStatus) {\n-\t\tif (!this.reporter.stderr) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tthis.reporter.stderr(data, runStatus);\n-\t}\n-\n-\texit(code) {\n-\t\tprocess.exit(code); // eslint-disable-line unicorn/no-process-exit\n-\t}\n-}\n-\n-module.exports = Logger;"
      },
      {
        "sha": "a1c7b4f3bc7d313543adeeb1138c7aa72280535f",
        "filename": "lib/prefix-title.js",
        "status": "removed",
        "additions": 0,
        "deletions": 21,
        "changes": 21,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/lib%2Fprefix-title.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/lib%2Fprefix-title.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fprefix-title.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,21 +0,0 @@\n-'use strict';\n-const path = require('path');\n-\n-module.exports = (file, base, separator) => {\n-\tlet prefix = file\n-\t\t// Only replace this.base if it is found at the start of the path\n-\t\t.replace(base, (match, offset) => offset === 0 ? '' : match)\n-\t\t.replace(/\\.spec/, '')\n-\t\t.replace(/\\.test/, '')\n-\t\t.replace(/test-/g, '')\n-\t\t.replace(/\\.js$/, '')\n-\t\t.split(path.sep)\n-\t\t.filter(p => p !== '__tests__')\n-\t\t.join(separator);\n-\n-\tif (prefix.length > 0) {\n-\t\tprefix += separator;\n-\t}\n-\n-\treturn prefix;\n-};"
      },
      {
        "sha": "700fdbcd1cc61cea1d325daae8455c690e451628",
        "filename": "lib/process-adapter.js",
        "status": "removed",
        "additions": 0,
        "deletions": 118,
        "changes": 118,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/lib%2Fprocess-adapter.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/lib%2Fprocess-adapter.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fprocess-adapter.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,118 +0,0 @@\n-'use strict';\n-const fs = require('fs');\n-const path = require('path');\n-const debug = require('debug')('ava');\n-const sourceMapSupport = require('source-map-support');\n-const installPrecompiler = require('require-precompiled');\n-\n-// Parse and re-emit AVA messages\n-process.on('message', message => {\n-\tif (!message.ava) {\n-\t\treturn;\n-\t}\n-\n-\tprocess.emit(message.name, message.data);\n-});\n-\n-exports.send = (name, data) => {\n-\tprocess.send({\n-\t\tname: `ava-${name}`,\n-\t\tdata,\n-\t\tava: true\n-\t});\n-};\n-\n-// `process.channel` was added in Node.js 7.1.0, but the channel was available\n-// through an undocumented API as `process._channel`.\n-const ipcChannel = process.channel || process._channel;\n-let allowUnref = true;\n-exports.unrefChannel = () => {\n-\tif (allowUnref) {\n-\t\tipcChannel.unref();\n-\t}\n-};\n-exports.forceRefChannel = () => {\n-\tallowUnref = false;\n-\tipcChannel.ref();\n-};\n-\n-const opts = JSON.parse(process.argv[2]);\n-require('./worker-options').set(opts);\n-\n-// Remove arguments received from fork.js and leave those specified by the user.\n-process.argv.splice(2, 2);\n-\n-// Fake TTY support\n-if (opts.tty) {\n-\tprocess.stdout.isTTY = true;\n-\tprocess.stdout.columns = opts.tty.columns || 80;\n-\tprocess.stdout.rows = opts.tty.rows;\n-\n-\tconst tty = require('tty');\n-\tconst isatty = tty.isatty;\n-\n-\ttty.isatty = function (fd) {\n-\t\tif (fd === 1 || fd === process.stdout) {\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\treturn isatty(fd);\n-\t};\n-}\n-\n-if (debug.enabled) {\n-\t// Forward the `@ladjs/time-require` `--sorted` flag.\n-\t// Intended for internal optimization tests only.\n-\tif (opts._sorted) {\n-\t\tprocess.argv.push('--sorted');\n-\t}\n-\n-\trequire('@ladjs/time-require'); // eslint-disable-line import/no-unassigned-import\n-}\n-\n-const sourceMapCache = new Map();\n-const cacheDir = opts.cacheDir;\n-\n-exports.installSourceMapSupport = () => {\n-\tsourceMapSupport.install({\n-\t\tenvironment: 'node',\n-\t\thandleUncaughtExceptions: false,\n-\t\tretrieveSourceMap(source) {\n-\t\t\tif (sourceMapCache.has(source)) {\n-\t\t\t\treturn {\n-\t\t\t\t\turl: source,\n-\t\t\t\t\tmap: fs.readFileSync(sourceMapCache.get(source), 'utf8')\n-\t\t\t\t};\n-\t\t\t}\n-\t\t}\n-\t});\n-};\n-\n-exports.installPrecompilerHook = () => {\n-\tinstallPrecompiler(filename => {\n-\t\tconst precompiled = opts.precompiled[filename];\n-\n-\t\tif (precompiled) {\n-\t\t\tsourceMapCache.set(filename, path.join(cacheDir, `${precompiled}.js.map`));\n-\t\t\treturn fs.readFileSync(path.join(cacheDir, `${precompiled}.js`), 'utf8');\n-\t\t}\n-\n-\t\treturn null;\n-\t});\n-};\n-\n-/* eslint-disable node/no-deprecated-api */\n-exports.installDependencyTracking = (dependencies, testPath) => {\n-\tObject.keys(require.extensions).forEach(ext => {\n-\t\tconst wrappedHandler = require.extensions[ext];\n-\n-\t\trequire.extensions[ext] = (module, filename) => {\n-\t\t\tif (filename !== testPath) {\n-\t\t\t\tdependencies.add(filename);\n-\t\t\t}\n-\n-\t\t\twrappedHandler(module, filename);\n-\t\t};\n-\t});\n-};\n-/* eslint-enable node/no-deprecated-api */"
      },
      {
        "sha": "adfa402c54ab0391174dbd345392f6be53ce9985",
        "filename": "lib/reporters/colors.js",
        "status": "renamed",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Freporters%2Fcolors.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Freporters%2Fcolors.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Fcolors.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,5 +1,5 @@\n 'use strict';\n-const chalk = require('chalk');\n+const chalk = require('../chalk').get();\n \n module.exports = {\n \tlog: chalk.gray,",
        "previous_filename": "lib/colors.js"
      },
      {
        "sha": "a5af5e9ea109ab2041ee48410cf498284cd2d204",
        "filename": "lib/reporters/format-serialized-error.js",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Freporters%2Fformat-serialized-error.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Freporters%2Fformat-serialized-error.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Fformat-serialized-error.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,6 +1,6 @@\n 'use strict';\n-const chalk = require('chalk');\n const trimOffNewlines = require('trim-off-newlines');\n+const chalk = require('../chalk').get();\n \n function formatSerializedError(error) {\n \tconst printMessage = error.values.length === 0 ?"
      },
      {
        "sha": "a7e72191b268646e6943a275eb2a6bafd0c3b308",
        "filename": "lib/reporters/improper-usage-messages.js",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Freporters%2Fimproper-usage-messages.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Freporters%2Fimproper-usage-messages.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Fimproper-usage-messages.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,5 +1,5 @@\n 'use strict';\n-const chalk = require('chalk');\n+const chalk = require('../chalk').get();\n \n exports.forError = error => {\n \tif (!error.improperUsage) {"
      },
      {
        "sha": "7e8a4d8530901c599a2e25cc0ec719f3fd7295f3",
        "filename": "lib/reporters/mini.js",
        "status": "modified",
        "additions": 407,
        "deletions": 259,
        "changes": 666,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Freporters%2Fmini.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Freporters%2Fmini.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Fmini.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,346 +1,494 @@\n 'use strict';\n-const StringDecoder = require('string_decoder').StringDecoder;\n+const os = require('os');\n+const path = require('path');\n+const stream = require('stream');\n+\n const cliCursor = require('cli-cursor');\n-const lastLineTracker = require('last-line-stream/tracker');\n-const plur = require('plur');\n-const spinners = require('cli-spinners');\n-const chalk = require('chalk');\n const figures = require('figures');\n-const cliTruncate = require('cli-truncate');\n-const cross = require('figures').cross;\n const indentString = require('indent-string');\n-const ansiEscapes = require('ansi-escapes');\n+const ora = require('ora');\n+const plur = require('plur');\n const trimOffNewlines = require('trim-off-newlines');\n+const trimRight = require('trim-right');\n+\n+const chalk = require('../chalk').get();\n const codeExcerpt = require('../code-excerpt');\n-const colors = require('../colors');\n+const colors = require('./colors');\n const formatSerializedError = require('./format-serialized-error');\n const improperUsageMessages = require('./improper-usage-messages');\n+const prefixTitle = require('./prefix-title');\n+const whileCorked = require('./while-corked');\n \n-class MiniReporter {\n-\tconstructor(options) {\n-\t\tthis.options = Object.assign({}, options);\n-\n-\t\tchalk.enabled = this.options.color;\n-\t\tfor (const key of Object.keys(colors)) {\n-\t\t\tcolors[key].enabled = this.options.color;\n-\t\t}\n-\n-\t\tconst spinnerDef = spinners[process.platform === 'win32' ? 'line' : 'dots'];\n-\t\tthis.spinnerFrames = spinnerDef.frames.map(c => chalk.gray.dim(c));\n-\t\tthis.spinnerInterval = spinnerDef.interval;\n+class LineWriter extends stream.Writable {\n+\tconstructor(dest, spinner) {\n+\t\tsuper();\n \n-\t\tthis.reset();\n-\t\tthis.stream = process.stderr;\n-\t\tthis.stringDecoder = new StringDecoder();\n+\t\tthis.dest = dest;\n+\t\tthis.columns = dest.columns || 80;\n+\t\tthis.spinner = spinner;\n+\t\tthis.lastSpinnerText = '';\n \t}\n \n-\tstart() {\n-\t\tthis.interval = setInterval(() => {\n-\t\t\tthis.spinnerIndex = (this.spinnerIndex + 1) % this.spinnerFrames.length;\n-\t\t\tthis.write(this.prefix());\n-\t\t}, this.spinnerInterval);\n+\t_write(chunk, encoding, callback) {\n+\t\t// Discard the current spinner output. Any lines that were meant to be\n+\t\t// preserved should be rewritten.\n+\t\tthis.spinner.clear();\n \n-\t\treturn this.prefix('');\n+\t\tthis._writeWithSpinner(chunk.toString('utf8'));\n+\t\tcallback();\n \t}\n \n-\treset() {\n-\t\tthis.clearInterval();\n-\t\tthis.passCount = 0;\n-\t\tthis.knownFailureCount = 0;\n-\t\tthis.failCount = 0;\n-\t\tthis.skipCount = 0;\n-\t\tthis.todoCount = 0;\n-\t\tthis.rejectionCount = 0;\n-\t\tthis.exceptionCount = 0;\n-\t\tthis.currentStatus = '';\n-\t\tthis.currentTest = '';\n-\t\tthis.statusLineCount = 0;\n-\t\tthis.spinnerIndex = 0;\n-\t\tthis.lastLineTracker = lastLineTracker();\n-\t}\n+\t_writev(pieces, callback) {\n+\t\t// Discard the current spinner output. Any lines that were meant to be\n+\t\t// preserved should be rewritten.\n+\t\tthis.spinner.clear();\n \n-\tspinnerChar() {\n-\t\treturn this.spinnerFrames[this.spinnerIndex];\n+\t\tconst last = pieces.pop();\n+\t\tfor (const piece of pieces) {\n+\t\t\tthis.dest.write(piece.chunk);\n+\t\t}\n+\t\tthis._writeWithSpinner(last.chunk.toString('utf8'));\n+\t\tcallback();\n \t}\n \n-\tclearInterval() {\n-\t\tclearInterval(this.interval);\n-\t\tthis.interval = null;\n+\t_writeWithSpinner(str) {\n+\t\tif (!this.spinner.id) {\n+\t\t\tthis.dest.write(str);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tthis.lastSpinnerText = str;\n+\t\t// Ignore whitespace at the end of the chunk. We're continiously rewriting\n+\t\t// the last line through the spinner. Also be careful to remove the indent\n+\t\t// as the spinner adds its own.\n+\t\tthis.spinner.text = trimRight(str).slice(2);\n+\t\tthis.spinner.render();\n \t}\n \n-\ttest(test) {\n-\t\tif (test.todo) {\n-\t\t\tthis.todoCount++;\n-\t\t} else if (test.skip) {\n-\t\t\tthis.skipCount++;\n-\t\t} else if (test.error) {\n-\t\t\tthis.failCount++;\n+\twriteLine(str) {\n+\t\tif (str) {\n+\t\t\tthis.write(indentString(str, 2) + os.EOL);\n \t\t} else {\n-\t\t\tthis.passCount++;\n-\t\t\tif (test.failing) {\n-\t\t\t\tthis.knownFailureCount++;\n-\t\t\t}\n+\t\t\tthis.write(os.EOL);\n \t\t}\n+\t}\n+}\n \n-\t\tif (test.todo || test.skip) {\n-\t\t\treturn;\n-\t\t}\n+class MiniReporter {\n+\tconstructor(options) {\n+\t\tthis.reportStream = options.reportStream;\n+\t\tthis.stdStream = options.stdStream;\n+\t\tthis.watching = options.watching;\n+\n+\t\tthis.spinner = ora({\n+\t\t\tenabled: true,\n+\t\t\tcolor: options.spinner ? options.spinner.color : 'gray',\n+\t\t\thideCursor: false,\n+\t\t\tspinner: options.spinner || (process.platform === 'win32' ? 'line' : 'dots'),\n+\t\t\tstream: options.reportStream\n+\t\t});\n+\t\tthis.lineWriter = new LineWriter(this.reportStream, this.spinner);\n+\n+\t\tthis.consumeStateChange = whileCorked(this.reportStream, whileCorked(this.lineWriter, this.consumeStateChange));\n+\t\tthis.endRun = whileCorked(this.reportStream, whileCorked(this.lineWriter, this.endRun));\n \n-\t\treturn this.prefix(this._test(test));\n+\t\tthis.reset();\n \t}\n \n-\tprefix(str) {\n-\t\tstr = str || this.currentTest;\n-\t\tthis.currentTest = str;\n+\treset() {\n+\t\tif (this.removePreviousListener) {\n+\t\t\tthis.removePreviousListener();\n+\t\t}\n \n-\t\t// The space before the newline is required for proper formatting\n-\t\t// TODO(jamestalmage): Figure out why it's needed and document it here\n-\t\treturn ` \\n ${this.spinnerChar()} ${str}`;\n+\t\tthis.failFastEnabled = false;\n+\t\tthis.failures = [];\n+\t\tthis.filesWithMissingAvaImports = new Set();\n+\t\tthis.internalErrors = [];\n+\t\tthis.knownFailures = [];\n+\t\tthis.matching = false;\n+\t\tthis.prefixTitle = (testFile, title) => title;\n+\t\tthis.previousFailures = 0;\n+\t\tthis.removePreviousListener = null;\n+\t\tthis.stats = null;\n+\t\tthis.uncaughtExceptions = [];\n+\t\tthis.unhandledRejections = [];\n \t}\n \n-\t_test(test) {\n-\t\tconst SPINNER_WIDTH = 3;\n-\t\tconst PADDING = 1;\n-\t\tlet title = cliTruncate(test.title, process.stdout.columns - SPINNER_WIDTH - PADDING);\n+\tstartRun(plan) {\n+\t\tthis.reset();\n+\n+\t\tthis.failFastEnabled = plan.failFastEnabled;\n+\t\tthis.matching = plan.matching;\n+\t\tthis.previousFailures = plan.previousFailures;\n \n-\t\tif (test.error || test.failing) {\n-\t\t\ttitle = colors.error(test.title);\n+\t\tif (this.watching || plan.files.length > 1) {\n+\t\t\tthis.prefixTitle = (testFile, title) => prefixTitle(plan.filePathPrefix, testFile, title);\n \t\t}\n \n-\t\treturn title + '\\n' + this.reportCounts();\n-\t}\n+\t\tthis.removePreviousListener = plan.status.on('stateChange', evt => this.consumeStateChange(evt));\n \n-\tunhandledError(err) {\n-\t\tif (err.type === 'exception') {\n-\t\t\tthis.exceptionCount++;\n-\t\t} else {\n-\t\t\tthis.rejectionCount++;\n+\t\tif (this.watching && plan.runVector > 1) {\n+\t\t\tthis.reportStream.write(chalk.gray.dim('\\u2500'.repeat(this.lineWriter.columns)) + os.EOL);\n \t\t}\n+\n+\t\tcliCursor.hide(this.reportStream);\n+\t\tthis.lineWriter.writeLine();\n+\t\tthis.spinner.start();\n \t}\n \n-\treportCounts(time) {\n-\t\tconst lines = [\n-\t\t\tthis.passCount > 0 ? '\\n  ' + colors.pass(this.passCount, 'passed') : '',\n-\t\t\tthis.knownFailureCount > 0 ? '\\n  ' + colors.error(this.knownFailureCount, plur('known failure', this.knownFailureCount)) : '',\n-\t\t\tthis.failCount > 0 ? '\\n  ' + colors.error(this.failCount, 'failed') : '',\n-\t\t\tthis.skipCount > 0 ? '\\n  ' + colors.skip(this.skipCount, 'skipped') : '',\n-\t\t\tthis.todoCount > 0 ? '\\n  ' + colors.todo(this.todoCount, 'todo') : ''\n-\t\t].filter(Boolean);\n+\tconsumeStateChange(evt) { // eslint-disable-line complexity\n+\t\tswitch (evt.type) {\n+\t\t\tcase 'declared-test':\n+\t\t\t\t// Ignore\n+\t\t\t\tbreak;\n+\t\t\tcase 'hook-failed':\n+\t\t\t\tthis.failures.push(evt);\n+\t\t\t\tthis.writeTestSummary(evt);\n+\t\t\t\tbreak;\n+\t\t\tcase 'internal-error':\n+\t\t\t\tthis.internalErrors.push(evt);\n+\t\t\t\tif (evt.testFile) {\n+\t\t\t\t\tthis.writeWithCounts(colors.error(`${figures.cross} Internal error when running ${path.relative('.', evt.testFile)}`));\n+\t\t\t\t} else {\n+\t\t\t\t\tthis.writeWithCounts(colors.error(`${figures.cross} Internal error`));\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase 'missing-ava-import':\n+\t\t\t\tthis.filesWithMissingAvaImports.add(evt.testFile);\n+\t\t\t\tthis.writeWithCounts(colors.error(`${figures.cross} No tests found in ${path.relative('.', evt.testFile)}, make sure to import \"ava\" at the top of your test file`));\n+\t\t\t\tbreak;\n+\t\t\tcase 'selected-test':\n+\t\t\t\t// Ignore\n+\t\t\t\tbreak;\n+\t\t\tcase 'stats':\n+\t\t\t\tthis.stats = evt.stats;\n+\t\t\t\tbreak;\n+\t\t\tcase 'test-failed':\n+\t\t\t\tthis.failures.push(evt);\n+\t\t\t\tthis.writeTestSummary(evt);\n+\t\t\t\tbreak;\n+\t\t\tcase 'test-passed':\n+\t\t\t\tif (evt.knownFailing) {\n+\t\t\t\t\tthis.knownFailures.push(evt);\n+\t\t\t\t}\n+\t\t\t\tthis.writeTestSummary(evt);\n+\t\t\t\tbreak;\n+\t\t\tcase 'timeout':\n+\t\t\t\tthis.writeWithCounts(colors.error(`${figures.cross} Exited because no new tests completed within the last ${evt.period}ms of inactivity`));\n+\t\t\t\tbreak;\n+\t\t\tcase 'uncaught-exception':\n+\t\t\t\tthis.uncaughtExceptions.push(evt);\n+\t\t\t\tbreak;\n+\t\t\tcase 'unhandled-rejection':\n+\t\t\t\tthis.unhandledRejections.push(evt);\n+\t\t\t\tbreak;\n+\t\t\tcase 'worker-failed':\n+\t\t\t\t// Ignore\n+\t\t\t\tbreak;\n+\t\t\tcase 'worker-finished':\n+\t\t\t\t// Ignore\n+\t\t\t\tbreak;\n+\t\t\tcase 'worker-stderr':\n+\t\t\tcase 'worker-stdout':\n+\t\t\t\t// Forcibly clear the spinner, writing the chunk corrupts the TTY.\n+\t\t\t\tthis.spinner.clear();\n+\n+\t\t\t\tthis.stdStream.write(evt.chunk);\n+\t\t\t\t// If the chunk does not end with a linebreak, *forcibly* write one to\n+\t\t\t\t// ensure it remains visible in the TTY.\n+\t\t\t\t// Tests cannot assume their standard output is not interrupted. Indeed\n+\t\t\t\t// we multiplex stdout and stderr into a single stream. However as\n+\t\t\t\t// long as stdStream is different from reportStream users can read\n+\t\t\t\t// their original output by redirecting the streams.\n+\t\t\t\tif (evt.chunk[evt.chunk.length - 1] !== 0x0A) {\n+\t\t\t\t\t// Use write() rather than writeLine() so the (presumably corked)\n+\t\t\t\t\t// line writer will actually write the empty line before re-rendering\n+\t\t\t\t\t// the last spinner text below.\n+\t\t\t\t\tthis.lineWriter.write(os.EOL);\n+\t\t\t\t}\n \n-\t\tif (time && lines.length > 0) {\n-\t\t\tlines[0] += ' ' + time;\n+\t\t\t\tthis.lineWriter.write(this.lineWriter.lastSpinnerText);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tbreak;\n \t\t}\n-\n-\t\treturn lines.join('');\n \t}\n \n-\tfinish(runStatus) {\n-\t\tthis.clearInterval();\n-\t\tlet time;\n+\twriteWithCounts(str) {\n+\t\tif (!this.stats) {\n+\t\t\treturn this.lineWriter.writeLine(str);\n+\t\t}\n \n-\t\tif (this.options.watching) {\n-\t\t\ttime = chalk.gray.dim('[' + new Date().toLocaleTimeString('en-US', {hour12: false}) + ']');\n+\t\tstr = str || '';\n+\t\tif (str !== '') {\n+\t\t\tstr += os.EOL;\n \t\t}\n \n-\t\tlet status = this.reportCounts(time) + '\\n';\n+\t\tlet firstLinePostfix = this.watching ?\n+\t\t\t' ' + chalk.gray.dim('[' + new Date().toLocaleTimeString('en-US', {hour12: false}) + ']') :\n+\t\t\t'';\n \n-\t\tif (this.rejectionCount > 0) {\n-\t\t\tstatus += '  ' + colors.error(this.rejectionCount, plur('rejection', this.rejectionCount)) + '\\n';\n+\t\tif (this.stats.passedTests > 0) {\n+\t\t\tstr += os.EOL + colors.pass(`${this.stats.passedTests} passed`) + firstLinePostfix;\n+\t\t\tfirstLinePostfix = '';\n \t\t}\n-\n-\t\tif (this.exceptionCount > 0) {\n-\t\t\tstatus += '  ' + colors.error(this.exceptionCount, plur('exception', this.exceptionCount)) + '\\n';\n+\t\tif (this.stats.passedKnownFailingTests > 0) {\n+\t\t\tstr += os.EOL + colors.error(`${this.stats.passedKnownFailingTests} ${plur('known failure', this.stats.passedKnownFailingTests)}`);\n \t\t}\n-\n-\t\tif (runStatus.previousFailCount > 0) {\n-\t\t\tstatus += '  ' + colors.error(runStatus.previousFailCount, 'previous', plur('failure', runStatus.previousFailCount), 'in test files that were not rerun') + '\\n';\n+\t\tif (this.stats.failedHooks > 0) {\n+\t\t\tstr += os.EOL + colors.error(`${this.stats.failedHooks} ${plur('hook', this.stats.failedHooks)} failed`) + firstLinePostfix;\n+\t\t\tfirstLinePostfix = '';\n+\t\t}\n+\t\tif (this.stats.failedTests > 0) {\n+\t\t\tstr += os.EOL + colors.error(`${this.stats.failedTests} ${plur('test', this.stats.failedTests)} failed`) + firstLinePostfix;\n+\t\t\tfirstLinePostfix = '';\n+\t\t}\n+\t\tif (this.stats.skippedTests > 0) {\n+\t\t\tstr += os.EOL + colors.skip(`${this.stats.skippedTests} skipped`);\n+\t\t}\n+\t\tif (this.stats.todoTests > 0) {\n+\t\t\tstr += os.EOL + colors.todo(`${this.stats.todoTests} todo`);\n \t\t}\n \n-\t\tif (this.knownFailureCount > 0) {\n-\t\t\tfor (const test of runStatus.knownFailures) {\n-\t\t\t\tconst title = test.title;\n-\t\t\t\tstatus += '\\n   ' + colors.title(title) + '\\n';\n-\t\t\t\t// TODO: Output description with link\n-\t\t\t\t// status += colors.stack(description);\n+\t\tthis.lineWriter.writeLine(str);\n+\t}\n+\n+\twriteErr(evt) {\n+\t\tif (evt.err.source) {\n+\t\t\tthis.lineWriter.writeLine(colors.errorSource(`${evt.err.source.file}:${evt.err.source.line}`));\n+\t\t\tconst excerpt = codeExcerpt(evt.err.source, {maxWidth: this.lineWriter.columns - 2});\n+\t\t\tif (excerpt) {\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\tthis.lineWriter.writeLine(excerpt);\n \t\t\t}\n \t\t}\n \n-\t\tstatus += '\\n';\n-\t\tif (this.failCount > 0) {\n-\t\t\trunStatus.errors.forEach(test => {\n-\t\t\t\tif (!test.error) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n+\t\tif (evt.err.avaAssertionError) {\n+\t\t\tconst result = formatSerializedError(evt.err);\n+\t\t\tif (result.printMessage) {\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\tthis.lineWriter.writeLine(evt.err.message);\n+\t\t\t}\n \n-\t\t\t\tstatus += '  ' + colors.title(test.title) + '\\n';\n+\t\t\tif (result.formatted) {\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\tthis.lineWriter.writeLine(result.formatted);\n+\t\t\t}\n \n-\t\t\t\tif (test.logs) {\n-\t\t\t\t\ttest.logs.forEach(log => {\n-\t\t\t\t\t\tconst logLines = indentString(colors.log(log), 6);\n-\t\t\t\t\t\tconst logLinesWithLeadingFigure = logLines.replace(\n-\t\t\t\t\t\t\t/^ {6}/,\n-\t\t\t\t\t\t\t`    ${colors.information(figures.info)} `\n-\t\t\t\t\t\t);\n+\t\t\tconst message = improperUsageMessages.forError(evt.err);\n+\t\t\tif (message) {\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\tthis.lineWriter.writeLine(message);\n+\t\t\t}\n+\t\t} else if (evt.err.nonErrorObject) {\n+\t\t\tthis.lineWriter.writeLine(trimOffNewlines(evt.err.formatted));\n+\t\t} else {\n+\t\t\tthis.lineWriter.writeLine();\n+\t\t\tthis.lineWriter.writeLine(evt.err.summary);\n+\t\t}\n \n-\t\t\t\t\t\tstatus += logLinesWithLeadingFigure + '\\n';\n-\t\t\t\t\t});\n+\t\tif (evt.err.stack) {\n+\t\t\tconst stack = evt.err.stack;\n+\t\t\tif (stack.includes(os.EOL)) {\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\tthis.lineWriter.writeLine(colors.errorStack(stack));\n+\t\t\t}\n+\t\t}\n+\t}\n \n-\t\t\t\t\tstatus += '\\n';\n-\t\t\t\t}\n+\twriteLogs(evt) {\n+\t\tif (evt.logs) {\n+\t\t\tfor (const log of evt.logs) {\n+\t\t\t\tconst logLines = indentString(colors.log(log), 4);\n+\t\t\t\tconst logLinesWithLeadingFigure = logLines.replace(\n+\t\t\t\t\t/^ {4}/,\n+\t\t\t\t\t`  ${colors.information(figures.info)} `\n+\t\t\t\t);\n+\t\t\t\tthis.lineWriter.writeLine(logLinesWithLeadingFigure);\n+\t\t\t}\n+\t\t}\n+\t}\n \n-\t\t\t\tif (test.error.source) {\n-\t\t\t\t\tstatus += '  ' + colors.errorSource(test.error.source.file + ':' + test.error.source.line) + '\\n';\n+\twriteTestSummary(evt) {\n+\t\tif (evt.type === 'hook-failed' || evt.type === 'test-failed') {\n+\t\t\tthis.writeWithCounts(`${this.prefixTitle(evt.testFile, evt.title)}`);\n+\t\t} else if (evt.knownFailing) {\n+\t\t\tthis.writeWithCounts(`${colors.error(this.prefixTitle(evt.testFile, evt.title))}`);\n+\t\t} else {\n+\t\t\tthis.writeWithCounts(`${this.prefixTitle(evt.testFile, evt.title)}`);\n+\t\t}\n+\t}\n \n-\t\t\t\t\tconst excerpt = codeExcerpt(test.error.source, {maxWidth: process.stdout.columns});\n-\t\t\t\t\tif (excerpt) {\n-\t\t\t\t\t\tstatus += '\\n' + indentString(excerpt, 2) + '\\n';\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\twriteFailure(evt) {\n+\t\tthis.lineWriter.writeLine(`${colors.title(this.prefixTitle(evt.testFile, evt.title))}`);\n+\t\tthis.writeLogs(evt);\n+\t\tthis.lineWriter.writeLine();\n+\t\tthis.writeErr(evt);\n+\t}\n \n-\t\t\t\tif (test.error.avaAssertionError) {\n-\t\t\t\t\tconst result = formatSerializedError(test.error);\n-\t\t\t\t\tif (result.printMessage) {\n-\t\t\t\t\t\tstatus += '\\n' + indentString(test.error.message, 2) + '\\n';\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif (result.formatted) {\n-\t\t\t\t\t\tstatus += '\\n' + indentString(result.formatted, 2) + '\\n';\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tconst message = improperUsageMessages.forError(test.error);\n-\t\t\t\t\tif (message) {\n-\t\t\t\t\t\tstatus += '\\n' + indentString(message, 2) + '\\n';\n-\t\t\t\t\t}\n-\t\t\t\t} else if (test.error.message) {\n-\t\t\t\t\tstatus += '\\n' + indentString(test.error.message, 2) + '\\n';\n-\t\t\t\t}\n+\tendRun() { // eslint-disable-line complexity\n+\t\tthis.spinner.stop();\n+\t\tcliCursor.show(this.reportStream);\n \n-\t\t\t\tif (test.error.stack) {\n-\t\t\t\t\tconst stack = test.error.stack;\n-\t\t\t\t\tif (stack.includes('\\n')) {\n-\t\t\t\t\t\tstatus += '\\n' + indentString(colors.errorStack(stack), 2) + '\\n';\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\tif (!this.stats) {\n+\t\t\tthis.lineWriter.writeLine(colors.error(`${figures.cross} Couldn't find any files to test`));\n+\t\t\tthis.lineWriter.writeLine();\n+\t\t\treturn;\n+\t\t}\n \n-\t\t\t\tstatus += '\\n\\n\\n';\n-\t\t\t});\n+\t\tif (this.matching && this.stats.selectedTests === 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.error(`${figures.cross} Couldn't find any matching tests`));\n+\t\t\tthis.lineWriter.writeLine();\n+\t\t\treturn;\n \t\t}\n \n-\t\tif (this.rejectionCount > 0 || this.exceptionCount > 0) {\n-\t\t\t// TODO(sindresorhus): Figure out why this causes a test failure when switched to a for-of loop\n-\t\t\trunStatus.errors.forEach(err => {\n-\t\t\t\tif (err.title) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n+\t\tthis.lineWriter.writeLine();\n \n-\t\t\t\tif (err.type === 'exception' && err.name === 'AvaError') {\n-\t\t\t\t\tstatus += '  ' + colors.error(cross + ' ' + err.message) + '\\n\\n';\n-\t\t\t\t} else {\n-\t\t\t\t\tconst title = err.type === 'rejection' ? 'Unhandled rejection' : 'Uncaught exception';\n-\t\t\t\t\tstatus += '  ' + colors.title(`${title} in ${err.file}`) + '\\n';\n-\n-\t\t\t\t\tif (err.name) {\n-\t\t\t\t\t\tstatus += indentString(colors.stack(err.summary), 2) + '\\n';\n-\t\t\t\t\t\tstatus += indentString(colors.errorStack(err.stack), 2) + '\\n\\n';\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tstatus += '  Threw non-error: ' + err.summary + '\\n';\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n+\t\tlet firstLinePostfix = this.watching ?\n+\t\t\t' ' + chalk.gray.dim('[' + new Date().toLocaleTimeString('en-US', {hour12: false}) + ']') :\n+\t\t\t'';\n \n-\t\tif (runStatus.failFastEnabled === true && runStatus.failCount > 0 && (runStatus.remainingCount > 0 || runStatus.fileCount > runStatus.observationCount)) {\n-\t\t\tlet remaining = '';\n-\t\t\tif (runStatus.remainingCount > 0) {\n-\t\t\t\tremaining += `At least ${runStatus.remainingCount} ${plur('test was', 'tests were', runStatus.remainingCount)} skipped`;\n-\t\t\t\tif (runStatus.fileCount > runStatus.observationCount) {\n-\t\t\t\t\tremaining += ', as well as ';\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (runStatus.fileCount > runStatus.observationCount) {\n-\t\t\t\tconst skippedFileCount = runStatus.fileCount - runStatus.observationCount;\n-\t\t\t\tremaining += `${skippedFileCount} ${plur('test file', 'test files', skippedFileCount)}`;\n-\t\t\t\tif (runStatus.remainingCount === 0) {\n-\t\t\t\t\tremaining += ` ${plur('was', 'were', skippedFileCount)} skipped`;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tstatus += '  ' + colors.information('`--fail-fast` is on. ' + remaining + '.') + '\\n\\n';\n+\t\tif (this.stats.failedHooks > 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.error(`${this.stats.failedHooks} ${plur('hook', this.stats.failedHooks)} failed`) + firstLinePostfix);\n+\t\t\tfirstLinePostfix = '';\n+\t\t}\n+\t\tif (this.stats.failedTests > 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.error(`${this.stats.failedTests} ${plur('test', this.stats.failedTests)} failed`) + firstLinePostfix);\n+\t\t\tfirstLinePostfix = '';\n+\t\t}\n+\t\tif (this.stats.failedHooks === 0 && this.stats.failedTests === 0 && this.stats.passedTests > 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.pass(`${this.stats.passedTests} ${plur('test', this.stats.passedTests)} passed`) + firstLinePostfix);\n+\t\t\tfirstLinePostfix = '';\n+\t\t}\n+\t\tif (this.stats.passedKnownFailingTests > 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.error(`${this.stats.passedKnownFailingTests} ${plur('known failure', this.stats.passedKnownFailingTests)}`));\n+\t\t}\n+\t\tif (this.stats.skippedTests > 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.skip(`${this.stats.skippedTests} ${plur('test', this.stats.skippedTests)} skipped`));\n+\t\t}\n+\t\tif (this.stats.todoTests > 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.todo(`${this.stats.todoTests} ${plur('test', this.stats.todoTests)} todo`));\n+\t\t}\n+\t\tif (this.stats.unhandledRejections > 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.error(`${this.stats.unhandledRejections} unhandled ${plur('rejection', this.stats.unhandledRejections)}`));\n+\t\t}\n+\t\tif (this.stats.uncaughtExceptions > 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.error(`${this.stats.uncaughtExceptions} uncaught ${plur('exception', this.stats.uncaughtExceptions)}`));\n+\t\t}\n+\t\tif (this.previousFailures > 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.error(`${this.previousFailures} previous ${plur('failure', this.previousFailures)} in test files that were not rerun`));\n \t\t}\n \n-\t\tif (runStatus.hasExclusive === true && runStatus.remainingCount > 0) {\n-\t\t\tstatus += '  ' + colors.information('The .only() modifier is used in some tests.', runStatus.remainingCount, plur('test', runStatus.remainingCount), plur('was', 'were', runStatus.remainingCount), 'not run');\n+\t\tif (this.stats.passedKnownFailingTests > 0) {\n+\t\t\tthis.lineWriter.writeLine();\n+\t\t\tfor (const evt of this.knownFailures) {\n+\t\t\t\tthis.lineWriter.writeLine(colors.error(this.prefixTitle(evt.testFile, evt.title)));\n+\t\t\t}\n \t\t}\n \n-\t\treturn '\\n' + trimOffNewlines(status) + '\\n';\n-\t}\n+\t\tconst shouldWriteFailFastDisclaimer = this.failFastEnabled && (this.stats.remainingTests > 0 || this.stats.files > this.stats.finishedWorkers);\n \n-\tsection() {\n-\t\treturn '\\n' + chalk.gray.dim('\\u2500'.repeat(process.stdout.columns || 80));\n-\t}\n+\t\tif (this.failures.length > 0) {\n+\t\t\tconst writeTrailingLines = shouldWriteFailFastDisclaimer || this.internalErrors.length > 0 || this.uncaughtExceptions.length > 0 || this.unhandledRejections.length > 0;\n+\t\t\tthis.lineWriter.writeLine();\n \n-\tclear() {\n-\t\treturn '';\n-\t}\n+\t\t\tconst last = this.failures[this.failures.length - 1];\n+\t\t\tfor (const evt of this.failures) {\n+\t\t\t\tthis.writeFailure(evt);\n+\t\t\t\tif (evt !== last || writeTrailingLines) {\n+\t\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-\twrite(str) {\n-\t\tcliCursor.hide();\n-\t\tthis.currentStatus = str;\n-\t\tthis._update();\n-\t\tthis.statusLineCount = this.currentStatus.split('\\n').length;\n-\t}\n+\t\tif (this.internalErrors.length > 0) {\n+\t\t\tconst writeLeadingLine = this.failures.length === 0;\n+\t\t\tconst writeTrailingLines = shouldWriteFailFastDisclaimer || this.uncaughtExceptions.length > 0 || this.unhandledRejections.length > 0;\n \n-\tstdout(data) {\n-\t\tthis._update(data);\n-\t}\n+\t\t\tif (writeLeadingLine) {\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t}\n \n-\tstderr(data) {\n-\t\tthis._update(data);\n-\t}\n+\t\t\tconst last = this.internalErrors[this.internalErrors.length - 1];\n+\t\t\tfor (const evt of this.internalErrors) {\n+\t\t\t\tif (evt.testFile) {\n+\t\t\t\t\tthis.lineWriter.writeLine(colors.error(`${figures.cross} Internal error when running ${path.relative('.', evt.testFile)}`));\n+\t\t\t\t} else {\n+\t\t\t\t\tthis.lineWriter.writeLine(colors.error(`${figures.cross} Internal error`));\n+\t\t\t\t}\n+\t\t\t\tthis.lineWriter.writeLine(colors.stack(evt.err.summary));\n+\t\t\t\tthis.lineWriter.writeLine(colors.errorStack(evt.err.stack));\n+\t\t\t\tif (evt !== last || writeTrailingLines) {\n+\t\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-\t_update(data) {\n-\t\tlet str = '';\n-\t\tlet ct = this.statusLineCount;\n-\t\tconst columns = process.stdout.columns;\n-\t\tlet lastLine = this.lastLineTracker.lastLine();\n+\t\tif (this.uncaughtExceptions.length > 0) {\n+\t\t\tconst writeLeadingLine = this.failures.length === 0 && this.internalErrors.length === 0;\n+\t\t\tconst writeTrailingLines = shouldWriteFailFastDisclaimer || this.unhandledRejections.length > 0;\n \n-\t\t// Terminals automatically wrap text. We only need the last log line as seen on the screen.\n-\t\tlastLine = lastLine.substring(lastLine.length - (lastLine.length % columns));\n+\t\t\tif (writeLeadingLine) {\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t}\n \n-\t\t// Don't delete the last log line if it's completely empty.\n-\t\tif (lastLine.length > 0) {\n-\t\t\tct++;\n+\t\t\tconst last = this.uncaughtExceptions[this.uncaughtExceptions.length - 1];\n+\t\t\tfor (const evt of this.uncaughtExceptions) {\n+\t\t\t\tthis.lineWriter.writeLine(colors.title(`Uncaught exception in ${path.relative('.', evt.testFile)}`));\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\tthis.writeErr(evt);\n+\t\t\t\tif (evt !== last || writeTrailingLines) {\n+\t\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \n-\t\t// Erase the existing status message, plus the last log line.\n-\t\tstr += ansiEscapes.eraseLines(ct);\n+\t\tif (this.unhandledRejections.length > 0) {\n+\t\t\tconst writeLeadingLine = this.failures.length === 0 && this.internalErrors.length === 0 && this.uncaughtExceptions.length === 0;\n+\t\t\tconst writeTrailingLines = shouldWriteFailFastDisclaimer;\n \n-\t\t// Rewrite the last log line.\n-\t\tstr += lastLine;\n-\n-\t\tif (str.length > 0) {\n-\t\t\tthis.stream.write(str);\n-\t\t}\n+\t\t\tif (writeLeadingLine) {\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t}\n \n-\t\tif (data) {\n-\t\t\t// Send new log data to the terminal, and update the last line status.\n-\t\t\tthis.lastLineTracker.update(this.stringDecoder.write(data));\n-\t\t\tthis.stream.write(data);\n+\t\t\tconst last = this.unhandledRejections[this.unhandledRejections.length - 1];\n+\t\t\tfor (const evt of this.unhandledRejections) {\n+\t\t\t\tthis.lineWriter.writeLine(colors.title(`Unhandled rejection in ${path.relative('.', evt.testFile)}`));\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\tthis.writeErr(evt);\n+\t\t\t\tif (evt !== last || writeTrailingLines) {\n+\t\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \n-\t\tlet currentStatus = this.currentStatus;\n-\n-\t\tif (currentStatus.length > 0) {\n-\t\t\tlastLine = this.lastLineTracker.lastLine();\n-\t\t\t// We need a newline at the end of the last log line, before the status message.\n-\t\t\t// However, if the last log line is the exact width of the terminal a newline is implied,\n-\t\t\t// and adding a second will cause problems.\n-\t\t\tif (lastLine.length % columns) {\n-\t\t\t\tcurrentStatus = '\\n' + currentStatus;\n+\t\tif (shouldWriteFailFastDisclaimer) {\n+\t\t\tlet remaining = '';\n+\t\t\tif (this.stats.remainingTests > 0) {\n+\t\t\t\tremaining += `At least ${this.stats.remainingTests} ${plur('test was', 'tests were', this.stats.remainingTests)} skipped`;\n+\t\t\t\tif (this.stats.files > this.stats.finishedWorkers) {\n+\t\t\t\t\tremaining += ', as well as ';\n+\t\t\t\t}\n \t\t\t}\n-\t\t\t// Rewrite the status message.\n-\t\t\tthis.stream.write(currentStatus);\n+\t\t\tif (this.stats.files > this.stats.finishedWorkers) {\n+\t\t\t\tconst skippedFileCount = this.stats.files - this.stats.finishedWorkers;\n+\t\t\t\tremaining += `${skippedFileCount} ${plur('test file', 'test files', skippedFileCount)}`;\n+\t\t\t\tif (this.stats.remainingTests === 0) {\n+\t\t\t\t\tremaining += ` ${plur('was', 'were', skippedFileCount)} skipped`;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tthis.lineWriter.writeLine(colors.information(`\\`--fail-fast\\` is on. ${remaining}.`));\n \t\t}\n+\n+\t\tthis.lineWriter.writeLine();\n \t}\n }\n-\n module.exports = MiniReporter;"
      },
      {
        "sha": "83636ef027fffe774753f180c71f0c1cd1039a4d",
        "filename": "lib/reporters/prefix-title.js",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Freporters%2Fprefix-title.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Freporters%2Fprefix-title.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Fprefix-title.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,21 @@\n+'use strict';\n+const path = require('path');\n+const figures = require('figures');\n+const chalk = require('../chalk').get();\n+\n+const SEPERATOR = ' ' + chalk.gray.dim(figures.pointerSmall) + ' ';\n+\n+module.exports = (base, file, title) => {\n+\tconst prefix = file\n+\t\t// Only replace base if it is found at the start of the path\n+\t\t.replace(base, (match, offset) => offset === 0 ? '' : match)\n+\t\t.replace(/\\.spec/, '')\n+\t\t.replace(/\\.test/, '')\n+\t\t.replace(/test-/g, '')\n+\t\t.replace(/\\.js$/, '')\n+\t\t.split(path.sep)\n+\t\t.filter(p => p !== '__tests__')\n+\t\t.join(SEPERATOR);\n+\n+\treturn prefix + SEPERATOR + title;\n+};"
      },
      {
        "sha": "e8594059b59ede0d0cdff266142b79e0a5be49a8",
        "filename": "lib/reporters/tap.js",
        "status": "modified",
        "additions": 131,
        "deletions": 42,
        "changes": 173,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Freporters%2Ftap.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Freporters%2Ftap.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Ftap.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,13 +1,19 @@\n 'use strict';\n-const supertap = require('supertap');\n+const os = require('os');\n+const path = require('path');\n+\n+const plur = require('plur');\n const stripAnsi = require('strip-ansi');\n+const supertap = require('supertap');\n \n-function dumpError(error, includeMessage) {\n+const prefixTitle = require('./prefix-title');\n+\n+function dumpError(error) {\n \tconst obj = Object.assign({}, error.object);\n \tif (error.name) {\n \t\tobj.name = error.name;\n \t}\n-\tif (includeMessage && error.message) {\n+\tif (error.message) {\n \t\tobj.message = error.message;\n \t}\n \n@@ -26,6 +32,11 @@ function dumpError(error, includeMessage) {\n \t\t}\n \t}\n \n+\tif (error.nonErrorObject) {\n+\t\tobj.message = 'Non-error object';\n+\t\tobj.formatted = stripAnsi(error.formatted);\n+\t}\n+\n \tif (error.stack) {\n \t\tobj.at = error.stack.split('\\n')[0];\n \t}\n@@ -34,60 +45,138 @@ function dumpError(error, includeMessage) {\n }\n \n class TapReporter {\n-\tconstructor() {\n+\tconstructor(options) {\n \t\tthis.i = 0;\n-\t}\n \n-\tstart() {\n-\t\treturn supertap.start();\n-\t}\n+\t\tthis.stdStream = options.stdStream;\n+\t\tthis.reportStream = options.reportStream;\n \n-\ttest(test) {\n-\t\treturn supertap.test(test.title, {\n-\t\t\tpassed: !test.error,\n-\t\t\tindex: ++this.i,\n-\t\t\ttodo: test.todo,\n-\t\t\tskip: test.skip,\n-\t\t\tcomment: test.logs,\n-\t\t\terror: test.error ? dumpError(test.error, true) : null\n-\t\t});\n+\t\tthis.crashCount = 0;\n+\t\tthis.filesWithMissingAvaImports = new Set();\n+\t\tthis.prefixTitle = (testFile, title) => title;\n+\t\tthis.stats = null;\n \t}\n \n-\tunhandledError(err) {\n-\t\tlet error;\n-\n-\t\t// AvaErrors don't have stack traces\n-\t\tif (err.type !== 'exception' || err.name !== 'AvaError') {\n-\t\t\terror = dumpError(err, false);\n+\tstartRun(plan) {\n+\t\tif (plan.files.length > 1) {\n+\t\t\tthis.prefixTitle = (testFile, title) => prefixTitle(plan.filePathPrefix, testFile, title);\n \t\t}\n \n-\t\treturn supertap.test(err.message, {\n-\t\t\tpassed: false,\n-\t\t\tindex: ++this.i,\n-\t\t\terror\n-\t\t});\n+\t\tplan.status.on('stateChange', evt => this.consumeStateChange(evt));\n+\n+\t\tthis.reportStream.write(supertap.start() + os.EOL);\n \t}\n \n-\tfinish(runStatus) {\n-\t\treturn supertap.finish({\n-\t\t\tpassed: runStatus.passCount,\n-\t\t\tfailed: runStatus.failCount,\n-\t\t\tskipped: runStatus.skipCount,\n-\t\t\tcrashed: runStatus.rejectionCount + runStatus.exceptionCount\n-\t\t});\n+\tendRun() {\n+\t\tif (this.stats) {\n+\t\t\tthis.reportStream.write(supertap.finish({\n+\t\t\t\tcrashed: this.crashCount,\n+\t\t\t\tfailed: this.stats.failedHooks + this.stats.failedTests,\n+\t\t\t\tpassed: this.stats.passedTests + this.stats.passedKnownFailingTests,\n+\t\t\t\tskipped: this.stats.skippedTests,\n+\t\t\t\ttodo: this.stats.todoTests\n+\t\t\t}) + os.EOL);\n+\t\t} else {\n+\t\t\tthis.reportStream.write(supertap.finish({\n+\t\t\t\tcrashed: this.crashCount,\n+\t\t\t\tfailed: 0,\n+\t\t\t\tpassed: 0,\n+\t\t\t\tskipped: 0,\n+\t\t\t\ttodo: 0\n+\t\t\t}) + os.EOL);\n+\t\t}\n \t}\n \n-\twrite(str) {\n-\t\tconsole.log(str);\n+\twriteTest(evt, flags) {\n+\t\tthis.reportStream.write(supertap.test(this.prefixTitle(evt.testFile, evt.title), {\n+\t\t\tcomment: evt.logs,\n+\t\t\terror: evt.err ? dumpError(evt.err) : null,\n+\t\t\tindex: ++this.i,\n+\t\t\tpassed: flags.passed,\n+\t\t\tskip: flags.skip,\n+\t\t\ttodo: flags.todo\n+\t\t}) + os.EOL);\n \t}\n \n-\tstdout(data) {\n-\t\tprocess.stderr.write(data);\n+\twriteCrash(evt, title) {\n+\t\tthis.crashCount++;\n+\t\tthis.reportStream.write(supertap.test(title || evt.err.summary || evt.type, {\n+\t\t\tcomment: evt.logs,\n+\t\t\terror: evt.err ? dumpError(evt.err) : null,\n+\t\t\tindex: ++this.i,\n+\t\t\tpassed: false,\n+\t\t\tskip: false,\n+\t\t\ttodo: false\n+\t\t}) + os.EOL);\n \t}\n \n-\tstderr(data) {\n-\t\tthis.stdout(data);\n+\tconsumeStateChange(evt) { // eslint-disable-line complexity\n+\t\tconst fileStats = this.stats && evt.testFile ? this.stats.byFile.get(evt.testFile) : null;\n+\n+\t\tswitch (evt.type) {\n+\t\t\tcase 'declared-test':\n+\t\t\t\t// Ignore\n+\t\t\t\tbreak;\n+\t\t\tcase 'hook-failed':\n+\t\t\t\tthis.writeTest(evt, {passed: false, todo: false, skip: false});\n+\t\t\t\tbreak;\n+\t\t\tcase 'internal-error':\n+\t\t\t\tthis.writeCrash(evt);\n+\t\t\t\tbreak;\n+\t\t\tcase 'missing-ava-import':\n+\t\t\t\tthis.filesWithMissingAvaImports.add(evt.testFile);\n+\t\t\t\tthis.writeCrash(evt, `No tests found in ${path.relative('.', evt.testFile)}, make sure to import \"ava\" at the top of your test file`);\n+\t\t\t\tbreak;\n+\t\t\tcase 'selected-test':\n+\t\t\t\tif (evt.skip) {\n+\t\t\t\t\tthis.writeTest(evt, {passed: true, todo: false, skip: true});\n+\t\t\t\t} else if (evt.todo) {\n+\t\t\t\t\tthis.writeTest(evt, {passed: false, todo: true, skip: false});\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase 'stats':\n+\t\t\t\tthis.stats = evt.stats;\n+\t\t\t\tbreak;\n+\t\t\tcase 'test-failed':\n+\t\t\t\tthis.writeTest(evt, {passed: false, todo: false, skip: false});\n+\t\t\t\tbreak;\n+\t\t\tcase 'test-passed':\n+\t\t\t\tthis.writeTest(evt, {passed: true, todo: false, skip: false});\n+\t\t\t\tbreak;\n+\t\t\tcase 'timeout':\n+\t\t\t\tthis.writeCrash(evt, `Exited because no new tests completed within the last ${evt.period}ms of inactivity`);\n+\t\t\t\tbreak;\n+\t\t\tcase 'uncaught-exception':\n+\t\t\t\tthis.writeCrash(evt);\n+\t\t\t\tbreak;\n+\t\t\tcase 'unhandled-rejection':\n+\t\t\t\tthis.writeCrash(evt);\n+\t\t\t\tbreak;\n+\t\t\tcase 'worker-failed':\n+\t\t\t\tif (!this.filesWithMissingAvaImports.has(evt.testFile)) {\n+\t\t\t\t\tif (evt.nonZeroExitCode) {\n+\t\t\t\t\t\tthis.writeCrash(evt, `${path.relative('.', evt.testFile)} exited with a non-zero exit code: ${evt.nonZeroExitCode}`);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthis.writeCrash(evt, `${path.relative('.', evt.testFile)} exited due to ${evt.signal}`);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase 'worker-finished':\n+\t\t\t\tif (!evt.forcedExit && !this.filesWithMissingAvaImports.has(evt.testFile)) {\n+\t\t\t\t\tif (fileStats.declaredTests === 0) {\n+\t\t\t\t\t\tthis.writeCrash(evt, `No tests found in ${path.relative('.', evt.testFile)}`);\n+\t\t\t\t\t} else if (!this.failFastEnabled && fileStats.remainingTests > 0) {\n+\t\t\t\t\t\tthis.writeCrash(evt, `${fileStats.remainingTests} ${plur('test', fileStats.remainingTests)} remaining in ${path.relative('.', evt.testFile)}`);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase 'worker-stderr':\n+\t\t\tcase 'worker-stdout':\n+\t\t\t\tthis.stdStream.write(evt.chunk);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tbreak;\n+\t\t}\n \t}\n }\n-\n module.exports = TapReporter;"
      },
      {
        "sha": "c5e0a553debd4be6bfef4ed2b1cce2d36f9a6a3c",
        "filename": "lib/reporters/verbose.js",
        "status": "modified",
        "additions": 311,
        "deletions": 148,
        "changes": 459,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Freporters%2Fverbose.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Freporters%2Fverbose.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Fverbose.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,210 +1,373 @@\n 'use strict';\n-const indentString = require('indent-string');\n-const prettyMs = require('pretty-ms');\n+const os = require('os');\n+const path = require('path');\n+const stream = require('stream');\n+\n const figures = require('figures');\n-const chalk = require('chalk');\n+const indentString = require('indent-string');\n const plur = require('plur');\n+const prettyMs = require('pretty-ms');\n const trimOffNewlines = require('trim-off-newlines');\n+\n+const chalk = require('../chalk').get();\n const codeExcerpt = require('../code-excerpt');\n-const colors = require('../colors');\n+const colors = require('./colors');\n const formatSerializedError = require('./format-serialized-error');\n const improperUsageMessages = require('./improper-usage-messages');\n+const prefixTitle = require('./prefix-title');\n+const whileCorked = require('./while-corked');\n+\n+class LineWriter extends stream.Writable {\n+\tconstructor(dest) {\n+\t\tsuper();\n+\n+\t\tthis.dest = dest;\n+\t\tthis.columns = dest.columns || 80;\n+\t\tthis.lastLineIsEmpty = false;\n+\t}\n+\n+\t_write(chunk, encoding, callback) {\n+\t\tthis.dest.write(chunk);\n+\t\tcallback();\n+\t}\n+\n+\twriteLine(str) {\n+\t\tif (str) {\n+\t\t\tthis.write(indentString(str, 2) + os.EOL);\n+\t\t\tthis.lastLineIsEmpty = false;\n+\t\t} else {\n+\t\t\tthis.write(os.EOL);\n+\t\t\tthis.lastLineIsEmpty = true;\n+\t\t}\n+\t}\n+\n+\tensureEmptyLine() {\n+\t\tif (!this.lastLineIsEmpty) {\n+\t\t\tthis.writeLine();\n+\t\t}\n+\t}\n+}\n \n class VerboseReporter {\n \tconstructor(options) {\n-\t\tthis.options = Object.assign({}, options);\n+\t\tthis.reportStream = options.reportStream;\n+\t\tthis.stdStream = options.stdStream;\n+\t\tthis.watching = options.watching;\n \n-\t\tchalk.enabled = this.options.color;\n-\t\tfor (const key of Object.keys(colors)) {\n-\t\t\tcolors[key].enabled = this.options.color;\n-\t\t}\n+\t\tthis.lineWriter = new LineWriter(this.reportStream);\n+\t\tthis.consumeStateChange = whileCorked(this.reportStream, this.consumeStateChange);\n+\t\tthis.endRun = whileCorked(this.reportStream, this.endRun);\n+\n+\t\tthis.reset();\n \t}\n \n-\tstart() {\n-\t\treturn '';\n+\treset() {\n+\t\tif (this.removePreviousListener) {\n+\t\t\tthis.removePreviousListener();\n+\t\t}\n+\n+\t\tthis.failFastEnabled = false;\n+\t\tthis.failures = [];\n+\t\tthis.filesWithMissingAvaImports = new Set();\n+\t\tthis.knownFailures = [];\n+\t\tthis.lastLineIsEmpty = false;\n+\t\tthis.matching = false;\n+\t\tthis.prefixTitle = (testFile, title) => title;\n+\t\tthis.previousFailures = 0;\n+\t\tthis.removePreviousListener = null;\n+\t\tthis.stats = null;\n \t}\n \n-\ttest(test) {\n-\t\tconst lines = [];\n-\t\tif (test.error) {\n-\t\t\tlines.push('  ' + colors.error(figures.cross) + ' ' + test.title + ' ' + colors.error(test.error.message));\n-\t\t} else if (test.todo) {\n-\t\t\tlines.push('  ' + colors.todo('- ' + test.title));\n-\t\t} else if (test.skip) {\n-\t\t\tlines.push('  ' + colors.skip('- ' + test.title));\n-\t\t} else if (test.failing) {\n-\t\t\tlines.push('  ' + colors.error(figures.tick) + ' ' + colors.error(test.title));\n-\t\t} else {\n-\t\t\t// Display duration only over a threshold\n-\t\t\tconst threshold = 100;\n-\t\t\tconst duration = test.duration > threshold ? colors.duration(' (' + prettyMs(test.duration) + ')') : '';\n+\tstartRun(plan) {\n+\t\tthis.reset();\n \n-\t\t\tlines.push('  ' + colors.pass(figures.tick) + ' ' + test.title + duration);\n+\t\tthis.failFastEnabled = plan.failFastEnabled;\n+\t\tthis.matching = plan.matching;\n+\t\tthis.previousFailures = plan.previousFailures;\n+\n+\t\tif (this.watching || plan.files.length > 1) {\n+\t\t\tthis.prefixTitle = (testFile, title) => prefixTitle(plan.filePathPrefix, testFile, title);\n \t\t}\n \n-\t\tif (test.logs) {\n-\t\t\ttest.logs.forEach(log => {\n-\t\t\t\tconst logLines = indentString(colors.log(log), 6);\n-\t\t\t\tconst logLinesWithLeadingFigure = logLines.replace(\n-\t\t\t\t\t/^ {6}/,\n-\t\t\t\t\t`    ${colors.information(figures.info)} `\n-\t\t\t\t);\n+\t\tthis.removePreviousListener = plan.status.on('stateChange', evt => this.consumeStateChange(evt));\n \n-\t\t\t\tlines.push(logLinesWithLeadingFigure);\n-\t\t\t});\n+\t\tif (this.watching && plan.runVector > 1) {\n+\t\t\tthis.lineWriter.write(chalk.gray.dim('\\u2500'.repeat(this.reportStream.columns || 80)) + os.EOL);\n \t\t}\n \n-\t\treturn lines.length > 0 ? lines.join('\\n') : undefined;\n+\t\tthis.lineWriter.writeLine();\n \t}\n \n-\tunhandledError(err) {\n-\t\tif (err.type === 'exception' && err.name === 'AvaError') {\n-\t\t\treturn colors.error('  ' + figures.cross + ' ' + err.message);\n+\tconsumeStateChange(evt) { // eslint-disable-line complexity\n+\t\tconst fileStats = this.stats && evt.testFile ? this.stats.byFile.get(evt.testFile) : null;\n+\n+\t\tswitch (evt.type) {\n+\t\t\tcase 'declared-test':\n+\t\t\t\t// Ignore\n+\t\t\t\tbreak;\n+\t\t\tcase 'hook-failed':\n+\t\t\t\tthis.failures.push(evt);\n+\t\t\t\tthis.writeTestSummary(evt);\n+\t\t\t\tbreak;\n+\t\t\tcase 'internal-error':\n+\t\t\t\tif (evt.testFile) {\n+\t\t\t\t\tthis.lineWriter.writeLine(colors.error(`${figures.cross} Internal error when running ${path.relative('.', evt.testFile)}`));\n+\t\t\t\t} else {\n+\t\t\t\t\tthis.lineWriter.writeLine(colors.error(`${figures.cross} Internal error`));\n+\t\t\t\t}\n+\t\t\t\tthis.lineWriter.writeLine(colors.stack(evt.err.summary));\n+\t\t\t\tthis.lineWriter.writeLine(colors.errorStack(evt.err.stack));\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\tbreak;\n+\t\t\tcase 'missing-ava-import':\n+\t\t\t\tthis.filesWithMissingAvaImports.add(evt.testFile);\n+\t\t\t\tthis.lineWriter.writeLine(colors.error(`${figures.cross} No tests found in ${path.relative('.', evt.testFile)}, make sure to import \"ava\" at the top of your test file`));\n+\t\t\t\tbreak;\n+\t\t\tcase 'selected-test':\n+\t\t\t\tif (evt.skip) {\n+\t\t\t\t\tthis.lineWriter.writeLine(colors.skip(`- ${this.prefixTitle(evt.testFile, evt.title)}`));\n+\t\t\t\t} else if (evt.todo) {\n+\t\t\t\t\tthis.lineWriter.writeLine(colors.todo(`- ${this.prefixTitle(evt.testFile, evt.title)}`));\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase 'stats':\n+\t\t\t\tthis.stats = evt.stats;\n+\t\t\t\tbreak;\n+\t\t\tcase 'test-failed':\n+\t\t\t\tthis.failures.push(evt);\n+\t\t\t\tthis.writeTestSummary(evt);\n+\t\t\t\tbreak;\n+\t\t\tcase 'test-passed':\n+\t\t\t\tif (evt.knownFailing) {\n+\t\t\t\t\tthis.knownFailures.push(evt);\n+\t\t\t\t}\n+\t\t\t\tthis.writeTestSummary(evt);\n+\t\t\t\tbreak;\n+\t\t\tcase 'timeout':\n+\t\t\t\tthis.lineWriter.writeLine(colors.error(`${figures.cross} Exited because no new tests completed within the last ${evt.period}ms of inactivity`));\n+\t\t\t\tbreak;\n+\t\t\tcase 'uncaught-exception':\n+\t\t\t\tthis.lineWriter.ensureEmptyLine();\n+\t\t\t\tthis.lineWriter.writeLine(colors.title(`Uncaught exception in ${path.relative('.', evt.testFile)}`));\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\tthis.writeErr(evt);\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\tbreak;\n+\t\t\tcase 'unhandled-rejection':\n+\t\t\t\tthis.lineWriter.ensureEmptyLine();\n+\t\t\t\tthis.lineWriter.writeLine(colors.title(`Unhandled rejection in ${path.relative('.', evt.testFile)}`));\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\tthis.writeErr(evt);\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\tbreak;\n+\t\t\tcase 'worker-failed':\n+\t\t\t\tif (!this.filesWithMissingAvaImports.has(evt.testFile)) {\n+\t\t\t\t\tif (evt.nonZeroExitCode) {\n+\t\t\t\t\t\tthis.lineWriter.writeLine(colors.error(`${figures.cross} ${path.relative('.', evt.testFile)} exited with a non-zero exit code: ${evt.nonZeroExitCode}`));\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthis.lineWriter.writeLine(colors.error(`${figures.cross} ${path.relative('.', evt.testFile)} exited due to ${evt.signal}`));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase 'worker-finished':\n+\t\t\t\tif (!evt.forcedExit && !this.filesWithMissingAvaImports.has(evt.testFile)) {\n+\t\t\t\t\tif (fileStats.declaredTests === 0) {\n+\t\t\t\t\t\tthis.lineWriter.writeLine(colors.error(`${figures.cross} No tests found in ${path.relative('.', evt.testFile)}`));\n+\t\t\t\t\t} else if (!this.failFastEnabled && fileStats.remainingTests > 0) {\n+\t\t\t\t\t\tthis.lineWriter.writeLine(colors.error(`${figures.cross} ${fileStats.remainingTests} ${plur('test', fileStats.remainingTests)} remaining in ${path.relative('.', evt.testFile)}`));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase 'worker-stderr':\n+\t\t\tcase 'worker-stdout':\n+\t\t\t\tthis.stdStream.write(evt.chunk);\n+\t\t\t\t// If the chunk does not end with a linebreak, *forcibly* write one to\n+\t\t\t\t// ensure it remains visible in the TTY.\n+\t\t\t\t// Tests cannot assume their standard output is not interrupted. Indeed\n+\t\t\t\t// we multiplex stdout and stderr into a single stream. However as\n+\t\t\t\t// long as stdStream is different from reportStream users can read\n+\t\t\t\t// their original output by redirecting the streams.\n+\t\t\t\tif (evt.chunk[evt.chunk.length - 1] !== 0x0A) {\n+\t\t\t\t\tthis.reportStream.write(os.EOL);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tbreak;\n \t\t}\n+\t}\n \n-\t\tconst title = err.type === 'rejection' ? 'Unhandled rejection' : 'Uncaught exception';\n-\t\tlet output = '  ' + colors.title(`${title} in ${err.file}`) + '\\n';\n+\twriteErr(evt) {\n+\t\tif (evt.err.source) {\n+\t\t\tthis.lineWriter.writeLine(colors.errorSource(`${evt.err.source.file}:${evt.err.source.line}`));\n+\t\t\tconst excerpt = codeExcerpt(evt.err.source, {maxWidth: this.reportStream.columns - 2});\n+\t\t\tif (excerpt) {\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\tthis.lineWriter.writeLine(excerpt);\n+\t\t\t}\n+\t\t}\n \n-\t\tif (err.name) {\n-\t\t\toutput += indentString(colors.stack(err.summary), 2) + '\\n';\n-\t\t\toutput += indentString(colors.errorStack(err.stack), 2) + '\\n\\n';\n+\t\tif (evt.err.avaAssertionError) {\n+\t\t\tconst result = formatSerializedError(evt.err);\n+\t\t\tif (result.printMessage) {\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\tthis.lineWriter.writeLine(evt.err.message);\n+\t\t\t}\n+\n+\t\t\tif (result.formatted) {\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\tthis.lineWriter.writeLine(result.formatted);\n+\t\t\t}\n+\n+\t\t\tconst message = improperUsageMessages.forError(evt.err);\n+\t\t\tif (message) {\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\tthis.lineWriter.writeLine(message);\n+\t\t\t}\n+\t\t} else if (evt.err.nonErrorObject) {\n+\t\t\tthis.lineWriter.writeLine(trimOffNewlines(evt.err.formatted));\n \t\t} else {\n-\t\t\toutput += '  Threw non-error: ' + err.summary + '\\n';\n+\t\t\tthis.lineWriter.writeLine();\n+\t\t\tthis.lineWriter.writeLine(evt.err.summary);\n \t\t}\n \n-\t\toutput += '\\n';\n-\n-\t\treturn output;\n+\t\tif (evt.err.stack) {\n+\t\t\tconst stack = evt.err.stack;\n+\t\t\tif (stack.includes('\\n')) {\n+\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\tthis.lineWriter.writeLine(colors.errorStack(stack));\n+\t\t\t}\n+\t\t}\n \t}\n \n-\tfinish(runStatus) {\n-\t\tlet output = '';\n-\n-\t\tconst lines = [\n-\t\t\trunStatus.failCount > 0 ?\n-\t\t\t\t'  ' + colors.error(runStatus.failCount, plur('test', runStatus.failCount), 'failed') :\n-\t\t\t\t'  ' + colors.pass(runStatus.passCount, plur('test', runStatus.passCount), 'passed'),\n-\t\t\trunStatus.knownFailureCount > 0 ? '  ' + colors.error(runStatus.knownFailureCount, plur('known failure', runStatus.knownFailureCount)) : '',\n-\t\t\trunStatus.skipCount > 0 ? '  ' + colors.skip(runStatus.skipCount, plur('test', runStatus.skipCount), 'skipped') : '',\n-\t\t\trunStatus.todoCount > 0 ? '  ' + colors.todo(runStatus.todoCount, plur('test', runStatus.todoCount), 'todo') : '',\n-\t\t\trunStatus.rejectionCount > 0 ? '  ' + colors.error(runStatus.rejectionCount, 'unhandled', plur('rejection', runStatus.rejectionCount)) : '',\n-\t\t\trunStatus.exceptionCount > 0 ? '  ' + colors.error(runStatus.exceptionCount, 'uncaught', plur('exception', runStatus.exceptionCount)) : '',\n-\t\t\trunStatus.previousFailCount > 0 ? '  ' + colors.error(runStatus.previousFailCount, 'previous', plur('failure', runStatus.previousFailCount), 'in test files that were not rerun') : ''\n-\t\t].filter(Boolean);\n-\n-\t\tif (lines.length > 0) {\n-\t\t\tif (this.options.watching) {\n-\t\t\t\tlines[0] += ' ' + chalk.gray.dim('[' + new Date().toLocaleTimeString('en-US', {hour12: false}) + ']');\n+\twriteLogs(evt) {\n+\t\tif (evt.logs) {\n+\t\t\tfor (const log of evt.logs) {\n+\t\t\t\tconst logLines = indentString(colors.log(log), 4);\n+\t\t\t\tconst logLinesWithLeadingFigure = logLines.replace(\n+\t\t\t\t\t/^ {4}/,\n+\t\t\t\t\t`  ${colors.information(figures.info)} `\n+\t\t\t\t);\n+\t\t\t\tthis.lineWriter.writeLine(logLinesWithLeadingFigure);\n \t\t\t}\n-\t\t\toutput += lines.join('\\n') + '\\n';\n \t\t}\n+\t}\n+\n+\twriteTestSummary(evt) {\n+\t\tif (evt.type === 'hook-failed' || evt.type === 'test-failed') {\n+\t\t\tthis.lineWriter.writeLine(`${colors.error(figures.cross)} ${this.prefixTitle(evt.testFile, evt.title)} ${colors.error(evt.err.message)}`);\n+\t\t} else if (evt.knownFailing) {\n+\t\t\tthis.lineWriter.writeLine(`${colors.error(figures.tick)} ${colors.error(this.prefixTitle(evt.testFile, evt.title))}`);\n+\t\t} else {\n+\t\t\t// Display duration only over a threshold\n+\t\t\tconst threshold = 100;\n+\t\t\tconst duration = evt.duration > threshold ? colors.duration(' (' + prettyMs(evt.duration) + ')') : '';\n \n-\t\tif (runStatus.knownFailureCount > 0) {\n-\t\t\trunStatus.knownFailures.forEach(test => {\n-\t\t\t\toutput += '\\n\\n  ' + colors.error(test.title) + '\\n';\n-\t\t\t});\n+\t\t\tthis.lineWriter.writeLine(`${colors.pass(figures.tick)} ${this.prefixTitle(evt.testFile, evt.title)}${duration}`);\n \t\t}\n \n-\t\toutput += '\\n';\n-\t\tif (runStatus.failCount > 0) {\n-\t\t\trunStatus.tests.forEach(test => {\n-\t\t\t\tif (!test.error) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n+\t\tthis.writeLogs(evt);\n+\t}\n \n-\t\t\t\toutput += '  ' + colors.title(test.title) + '\\n';\n+\twriteFailure(evt) {\n+\t\tthis.lineWriter.writeLine(`${colors.title(this.prefixTitle(evt.testFile, evt.title))}`);\n+\t\tthis.writeLogs(evt);\n+\t\tthis.lineWriter.writeLine();\n+\t\tthis.writeErr(evt);\n+\t}\n \n-\t\t\t\tif (test.logs) {\n-\t\t\t\t\ttest.logs.forEach(log => {\n-\t\t\t\t\t\tconst logLines = indentString(colors.log(log), 6);\n-\t\t\t\t\t\tconst logLinesWithLeadingFigure = logLines.replace(\n-\t\t\t\t\t\t\t/^ {6}/,\n-\t\t\t\t\t\t\t`    ${colors.information(figures.info)} `\n-\t\t\t\t\t\t);\n+\tendRun() { // eslint-disable-line complexity\n+\t\tif (!this.stats) {\n+\t\t\tthis.lineWriter.writeLine(colors.error(`${figures.cross} Couldn't find any files to test`));\n+\t\t\tthis.lineWriter.writeLine();\n+\t\t\treturn;\n+\t\t}\n \n-\t\t\t\t\t\toutput += logLinesWithLeadingFigure + '\\n';\n-\t\t\t\t\t});\n+\t\tif (this.matching && this.stats.selectedTests === 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.error(`${figures.cross} Couldn't find any matching tests`));\n+\t\t\tthis.lineWriter.writeLine();\n+\t\t\treturn;\n+\t\t}\n \n-\t\t\t\t\toutput += '\\n';\n-\t\t\t\t}\n+\t\tthis.lineWriter.writeLine();\n \n-\t\t\t\tif (test.error.source) {\n-\t\t\t\t\toutput += '  ' + colors.errorSource(test.error.source.file + ':' + test.error.source.line) + '\\n';\n+\t\tlet firstLinePostfix = this.watching ?\n+\t\t\t' ' + chalk.gray.dim('[' + new Date().toLocaleTimeString('en-US', {hour12: false}) + ']') :\n+\t\t\t'';\n \n-\t\t\t\t\tconst excerpt = codeExcerpt(test.error.source, {maxWidth: process.stdout.columns});\n-\t\t\t\t\tif (excerpt) {\n-\t\t\t\t\t\toutput += '\\n' + indentString(excerpt, 2) + '\\n';\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\tif (this.stats.failedHooks > 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.error(`${this.stats.failedHooks} ${plur('hook', this.stats.failedHooks)} failed`) + firstLinePostfix);\n+\t\t\tfirstLinePostfix = '';\n+\t\t}\n+\t\tif (this.stats.failedTests > 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.error(`${this.stats.failedTests} ${plur('test', this.stats.failedTests)} failed`) + firstLinePostfix);\n+\t\t\tfirstLinePostfix = '';\n+\t\t}\n+\t\tif (this.stats.failedHooks === 0 && this.stats.failedTests === 0 && this.stats.passedTests > 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.pass(`${this.stats.passedTests} ${plur('test', this.stats.passedTests)} passed`) + firstLinePostfix);\n+\t\t\tfirstLinePostfix = '';\n+\t\t}\n+\t\tif (this.stats.passedKnownFailingTests > 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.error(`${this.stats.passedKnownFailingTests} ${plur('known failure', this.stats.passedKnownFailingTests)}`));\n+\t\t}\n+\t\tif (this.stats.skippedTests > 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.skip(`${this.stats.skippedTests} ${plur('test', this.stats.skippedTests)} skipped`));\n+\t\t}\n+\t\tif (this.stats.todoTests > 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.todo(`${this.stats.todoTests} ${plur('test', this.stats.todoTests)} todo`));\n+\t\t}\n+\t\tif (this.stats.unhandledRejections > 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.error(`${this.stats.unhandledRejections} unhandled ${plur('rejection', this.stats.unhandledRejections)}`));\n+\t\t}\n+\t\tif (this.stats.uncaughtExceptions > 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.error(`${this.stats.uncaughtExceptions} uncaught ${plur('exception', this.stats.uncaughtExceptions)}`));\n+\t\t}\n+\t\tif (this.previousFailures > 0) {\n+\t\t\tthis.lineWriter.writeLine(colors.error(`${this.previousFailures} previous ${plur('failure', this.previousFailures)} in test files that were not rerun`));\n+\t\t}\n \n-\t\t\t\tif (test.error.avaAssertionError) {\n-\t\t\t\t\tconst result = formatSerializedError(test.error);\n-\t\t\t\t\tif (result.printMessage) {\n-\t\t\t\t\t\toutput += '\\n' + indentString(test.error.message, 2) + '\\n';\n-\t\t\t\t\t}\n+\t\tif (this.stats.passedKnownFailingTests > 0) {\n+\t\t\tthis.lineWriter.writeLine();\n+\t\t\tfor (const evt of this.knownFailures) {\n+\t\t\t\tthis.lineWriter.writeLine(colors.error(this.prefixTitle(evt.testFile, evt.title)));\n+\t\t\t}\n+\t\t}\n \n-\t\t\t\t\tif (result.formatted) {\n-\t\t\t\t\t\toutput += '\\n' + indentString(result.formatted, 2) + '\\n';\n-\t\t\t\t\t}\n+\t\tconst shouldWriteFailFastDisclaimer = this.failFastEnabled && (this.stats.remainingTests > 0 || this.stats.files > this.stats.finishedWorkers);\n \n-\t\t\t\t\tconst message = improperUsageMessages.forError(test.error);\n-\t\t\t\t\tif (message) {\n-\t\t\t\t\t\toutput += '\\n' + indentString(message, 2) + '\\n';\n-\t\t\t\t\t}\n-\t\t\t\t} else if (test.error.message) {\n-\t\t\t\t\toutput += '\\n' + indentString(test.error.message, 2) + '\\n';\n-\t\t\t\t}\n+\t\tif (this.failures.length > 0) {\n+\t\t\tthis.lineWriter.writeLine();\n \n-\t\t\t\tif (test.error.stack) {\n-\t\t\t\t\tconst stack = test.error.stack;\n-\t\t\t\t\tif (stack.includes('\\n')) {\n-\t\t\t\t\t\toutput += '\\n' + indentString(colors.errorStack(stack), 2) + '\\n';\n-\t\t\t\t\t}\n+\t\t\tconst lastFailure = this.failures[this.failures.length - 1];\n+\t\t\tfor (const evt of this.failures) {\n+\t\t\t\tthis.writeFailure(evt);\n+\t\t\t\tif (evt !== lastFailure || shouldWriteFailFastDisclaimer) {\n+\t\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\t\tthis.lineWriter.writeLine();\n+\t\t\t\t\tthis.lineWriter.writeLine();\n \t\t\t\t}\n-\n-\t\t\t\toutput += '\\n\\n\\n';\n-\t\t\t});\n+\t\t\t}\n \t\t}\n \n-\t\tif (runStatus.failFastEnabled === true && runStatus.failCount > 0 && (runStatus.remainingCount > 0 || runStatus.fileCount > runStatus.observationCount)) {\n+\t\tif (shouldWriteFailFastDisclaimer) {\n \t\t\tlet remaining = '';\n-\t\t\tif (runStatus.remainingCount > 0) {\n-\t\t\t\tremaining += `At least ${runStatus.remainingCount} ${plur('test was', 'tests were', runStatus.remainingCount)} skipped`;\n-\t\t\t\tif (runStatus.fileCount > runStatus.observationCount) {\n+\t\t\tif (this.stats.remainingTests > 0) {\n+\t\t\t\tremaining += `At least ${this.stats.remainingTests} ${plur('test was', 'tests were', this.stats.remainingTests)} skipped`;\n+\t\t\t\tif (this.stats.files > this.stats.finishedWorkers) {\n \t\t\t\t\tremaining += ', as well as ';\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif (runStatus.fileCount > runStatus.observationCount) {\n-\t\t\t\tconst skippedFileCount = runStatus.fileCount - runStatus.observationCount;\n+\t\t\tif (this.stats.files > this.stats.finishedWorkers) {\n+\t\t\t\tconst skippedFileCount = this.stats.files - this.stats.finishedWorkers;\n \t\t\t\tremaining += `${skippedFileCount} ${plur('test file', 'test files', skippedFileCount)}`;\n-\t\t\t\tif (runStatus.remainingCount === 0) {\n+\t\t\t\tif (this.stats.remainingTests === 0) {\n \t\t\t\t\tremaining += ` ${plur('was', 'were', skippedFileCount)} skipped`;\n \t\t\t\t}\n \t\t\t}\n-\t\t\toutput += '  ' + colors.information('`--fail-fast` is on. ' + remaining + '.') + '\\n\\n';\n-\t\t}\n-\n-\t\tif (runStatus.hasExclusive === true && runStatus.remainingCount > 0) {\n-\t\t\toutput += '  ' + colors.information('The .only() modifier is used in some tests.', runStatus.remainingCount, plur('test', runStatus.remainingCount), plur('was', 'were', runStatus.remainingCount), 'not run');\n+\t\t\tthis.lineWriter.writeLine(colors.information(`\\`--fail-fast\\` is on. ${remaining}.`));\n \t\t}\n \n-\t\treturn '\\n' + trimOffNewlines(output) + '\\n';\n-\t}\n-\n-\tsection() {\n-\t\treturn chalk.gray.dim('\\u2500'.repeat(process.stdout.columns || 80));\n-\t}\n-\n-\twrite(str) {\n-\t\tconsole.error(str);\n-\t}\n-\n-\tstdout(data) {\n-\t\tprocess.stderr.write(data);\n-\t}\n-\n-\tstderr(data) {\n-\t\tprocess.stderr.write(data);\n+\t\tthis.lineWriter.writeLine();\n \t}\n }\n "
      },
      {
        "sha": "1c1e382b10aa94d5acd92c1b89327d6fa5e5c6bd",
        "filename": "lib/reporters/while-corked.js",
        "status": "added",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Freporters%2Fwhile-corked.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Freporters%2Fwhile-corked.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Fwhile-corked.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,12 @@\n+'use strict';\n+function whileCorked(stream, fn) {\n+\treturn function () {\n+\t\tstream.cork();\n+\t\ttry {\n+\t\t\tfn.apply(this, arguments);\n+\t\t} finally {\n+\t\t\tstream.uncork();\n+\t\t}\n+\t};\n+}\n+module.exports = whileCorked;"
      },
      {
        "sha": "e2fc64ab98c993d09a6a5fd6aa84e1ea2b46f749",
        "filename": "lib/run-status.js",
        "status": "modified",
        "additions": 128,
        "deletions": 118,
        "changes": 246,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Frun-status.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Frun-status.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Frun-status.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,138 +1,148 @@\n 'use strict';\n-const EventEmitter = require('events');\n-const chalk = require('chalk');\n-const flatten = require('arr-flatten');\n-const figures = require('figures');\n-const autoBind = require('auto-bind');\n-const prefixTitle = require('./prefix-title');\n+const cloneDeep = require('lodash.clonedeep');\n+const Emittery = require('./emittery');\n \n-function sum(arr, key) {\n-\tlet result = 0;\n-\n-\tarr.forEach(item => {\n-\t\tresult += item[key];\n-\t});\n-\n-\treturn result;\n-}\n-\n-class RunStatus extends EventEmitter {\n-\tconstructor(opts) {\n+class RunStatus extends Emittery {\n+\tconstructor(files) {\n \t\tsuper();\n \n-\t\topts = opts || {};\n-\t\tthis.prefixTitles = opts.prefixTitles !== false;\n-\t\tthis.hasExclusive = Boolean(opts.runOnlyExclusive);\n-\t\tthis.base = opts.base || '';\n-\t\tthis.rejectionCount = 0;\n-\t\tthis.exceptionCount = 0;\n-\t\tthis.passCount = 0;\n-\t\tthis.knownFailureCount = 0;\n-\t\tthis.skipCount = 0;\n-\t\tthis.todoCount = 0;\n-\t\tthis.failCount = 0;\n-\t\tthis.fileCount = opts.fileCount || 0;\n-\t\tthis.testCount = 0;\n-\t\tthis.remainingCount = 0;\n-\t\tthis.previousFailCount = 0;\n-\t\tthis.knownFailures = [];\n-\t\tthis.errors = [];\n-\t\tthis.stats = [];\n-\t\tthis.tests = [];\n-\t\tthis.failFastEnabled = opts.failFast || false;\n-\t\tthis.updateSnapshots = opts.updateSnapshots || false;\n-\t\tthis.observationCount = 0;\n-\n-\t\tautoBind(this);\n-\t}\n-\n-\tobserveFork(emitter) {\n-\t\tthis.observationCount++;\n-\t\temitter\n-\t\t\t.on('teardown', this.handleTeardown)\n-\t\t\t.on('stats', this.handleStats)\n-\t\t\t.on('test', this.handleTest)\n-\t\t\t.on('unhandledRejections', this.handleRejections)\n-\t\t\t.on('uncaughtException', this.handleExceptions)\n-\t\t\t.on('stdout', this.handleOutput.bind(this, 'stdout'))\n-\t\t\t.on('stderr', this.handleOutput.bind(this, 'stderr'));\n+\t\tthis.stats = {\n+\t\t\tbyFile: new Map(),\n+\t\t\tdeclaredTests: 0,\n+\t\t\tfailedHooks: 0,\n+\t\t\tfailedTests: 0,\n+\t\t\tfailedWorkers: 0,\n+\t\t\tfiles,\n+\t\t\tfinishedWorkers: 0,\n+\t\t\tinternalErrors: 0,\n+\t\t\tremainingTests: 0,\n+\t\t\tpassedKnownFailingTests: 0,\n+\t\t\tpassedTests: 0,\n+\t\t\tselectedTests: 0,\n+\t\t\tskippedTests: 0,\n+\t\t\ttimeouts: 0,\n+\t\t\ttodoTests: 0,\n+\t\t\tuncaughtExceptions: 0,\n+\t\t\tunhandledRejections: 0\n+\t\t};\n \t}\n \n-\thandleRejections(data) {\n-\t\tthis.rejectionCount += data.rejections.length;\n-\n-\t\tdata.rejections.forEach(err => {\n-\t\t\terr.type = 'rejection';\n-\t\t\terr.file = data.file;\n-\t\t\tthis.emit('error', err, this);\n-\t\t\tthis.errors.push(err);\n+\tobserveWorker(worker, testFile) {\n+\t\tthis.stats.byFile.set(testFile, {\n+\t\t\tdeclaredTests: 0,\n+\t\t\tfailedHooks: 0,\n+\t\t\tfailedTests: 0,\n+\t\t\tinternalErrors: 0,\n+\t\t\tremainingTests: 0,\n+\t\t\tpassedKnownFailingTests: 0,\n+\t\t\tpassedTests: 0,\n+\t\t\tselectedTests: 0,\n+\t\t\tskippedTests: 0,\n+\t\t\ttodoTests: 0,\n+\t\t\tuncaughtExceptions: 0,\n+\t\t\tunhandledRejections: 0\n \t\t});\n+\t\tworker.onStateChange(data => this.emitStateChange(data));\n \t}\n \n-\thandleExceptions(data) {\n-\t\tthis.exceptionCount++;\n-\t\tconst err = data.exception;\n-\t\terr.type = 'exception';\n-\t\terr.file = data.file;\n-\t\tthis.emit('error', err, this);\n-\t\tthis.errors.push(err);\n-\t}\n-\n-\thandleTeardown(data) {\n-\t\tthis.emit('dependencies', data.file, data.dependencies, this);\n-\t\tthis.emit('touchedFiles', data.touchedFiles);\n-\t}\n-\n-\thandleStats(stats) {\n-\t\tthis.emit('stats', stats, this);\n-\n-\t\tif (stats.hasExclusive) {\n-\t\t\tthis.hasExclusive = true;\n+\temitStateChange(evt) {\n+\t\tconst stats = this.stats;\n+\t\tconst fileStats = this.stats.byFile.get(evt.testFile);\n+\n+\t\tlet changedStats = true;\n+\t\tswitch (evt.type) {\n+\t\t\tcase 'declared-test':\n+\t\t\t\tstats.declaredTests++;\n+\t\t\t\tfileStats.declaredTests++;\n+\t\t\t\tbreak;\n+\t\t\tcase 'hook-failed':\n+\t\t\t\tstats.failedHooks++;\n+\t\t\t\tfileStats.failedHooks++;\n+\t\t\t\tbreak;\n+\t\t\tcase 'internal-error':\n+\t\t\t\tstats.internalErrors++;\n+\t\t\t\tif (evt.testFile) {\n+\t\t\t\t\tfileStats.internalErrors++;\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase 'selected-test':\n+\t\t\t\tstats.selectedTests++;\n+\t\t\t\tfileStats.selectedTests++;\n+\t\t\t\tif (evt.skip) {\n+\t\t\t\t\tstats.skippedTests++;\n+\t\t\t\t\tfileStats.skippedTests++;\n+\t\t\t\t} else if (evt.todo) {\n+\t\t\t\t\tstats.todoTests++;\n+\t\t\t\t\tfileStats.todoTests++;\n+\t\t\t\t} else {\n+\t\t\t\t\tstats.remainingTests++;\n+\t\t\t\t\tfileStats.remainingTests++;\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase 'test-failed':\n+\t\t\t\tstats.failedTests++;\n+\t\t\t\tfileStats.failedTests++;\n+\t\t\t\tstats.remainingTests--;\n+\t\t\t\tfileStats.remainingTests--;\n+\t\t\t\tbreak;\n+\t\t\tcase 'test-passed':\n+\t\t\t\tif (evt.knownFailing) {\n+\t\t\t\t\tstats.passedKnownFailingTests++;\n+\t\t\t\t\tfileStats.passedKnownFailingTests++;\n+\t\t\t\t} else {\n+\t\t\t\t\tstats.passedTests++;\n+\t\t\t\t\tfileStats.passedTests++;\n+\t\t\t\t}\n+\t\t\t\tstats.remainingTests--;\n+\t\t\t\tfileStats.remainingTests--;\n+\t\t\t\tbreak;\n+\t\t\tcase 'timeout':\n+\t\t\t\tstats.timeouts++;\n+\t\t\t\tbreak;\n+\t\t\tcase 'uncaught-exception':\n+\t\t\t\tstats.uncaughtExceptions++;\n+\t\t\t\tfileStats.uncaughtExceptions++;\n+\t\t\t\tbreak;\n+\t\t\tcase 'unhandled-rejection':\n+\t\t\t\tstats.unhandledRejections++;\n+\t\t\t\tfileStats.unhandledRejections++;\n+\t\t\t\tbreak;\n+\t\t\tcase 'worker-failed':\n+\t\t\t\tstats.failedWorkers++;\n+\t\t\t\tbreak;\n+\t\t\tcase 'worker-finished':\n+\t\t\t\tstats.finishedWorkers++;\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tchangedStats = false;\n+\t\t\t\tbreak;\n \t\t}\n \n-\t\tthis.testCount += stats.testCount;\n-\t}\n-\n-\thandleTest(test) {\n-\t\ttest.title = this.prefixTitle(test.file) + test.title;\n-\n-\t\tif (test.error) {\n-\t\t\tthis.errors.push(test);\n+\t\tif (changedStats) {\n+\t\t\tthis.emit('stateChange', {type: 'stats', stats: cloneDeep(stats)});\n \t\t}\n-\n-\t\tif (test.failing && !test.error) {\n-\t\t\tthis.knownFailures.push(test);\n-\t\t}\n-\n-\t\tthis.emit('test', test, this);\n+\t\tthis.emit('stateChange', evt);\n \t}\n \n-\tprefixTitle(file) {\n-\t\tif (!this.prefixTitles) {\n-\t\t\treturn '';\n+\tsuggestExitCode(circumstances) {\n+\t\tif (circumstances.matching && this.stats.selectedTests === 0) {\n+\t\t\treturn 1;\n \t\t}\n \n-\t\tconst separator = ' ' + chalk.gray.dim(figures.pointerSmall) + ' ';\n-\n-\t\treturn prefixTitle(file, this.base, separator);\n-\t}\n-\n-\thandleOutput(channel, data) {\n-\t\tthis.emit(channel, data, this);\n-\t}\n+\t\tif (\n+\t\t\tthis.stats.declaredTests === 0 ||\n+\t\t\tthis.stats.internalErrors > 0 ||\n+\t\t\tthis.stats.failedHooks > 0 ||\n+\t\t\tthis.stats.failedTests > 0 ||\n+\t\t\tthis.stats.failedWorkers > 0 ||\n+\t\t\tthis.stats.timeouts > 0 ||\n+\t\t\tthis.stats.uncaughtExceptions > 0 ||\n+\t\t\tthis.stats.unhandledRejections > 0\n+\t\t) {\n+\t\t\treturn 1;\n+\t\t}\n \n-\tprocessResults(results) {\n-\t\t// Assemble stats from all tests\n-\t\tthis.stats = results.map(result => result.stats);\n-\t\tthis.tests = results.map(result => result.tests);\n-\t\tthis.tests = flatten(this.tests);\n-\t\tthis.passCount = sum(this.stats, 'passCount');\n-\t\tthis.knownFailureCount = sum(this.stats, 'knownFailureCount');\n-\t\tthis.skipCount = sum(this.stats, 'skipCount');\n-\t\tthis.todoCount = sum(this.stats, 'todoCount');\n-\t\tthis.failCount = sum(this.stats, 'failCount');\n-\t\tthis.remainingCount = this.testCount - this.passCount - this.failCount - this.skipCount - this.todoCount - this.knownFailureCount;\n+\t\treturn 0;\n \t}\n }\n-\n module.exports = RunStatus;"
      },
      {
        "sha": "62419c93a7aabcd71164f30fbd7665d6aaeff0cd",
        "filename": "lib/runner.js",
        "status": "modified",
        "additions": 92,
        "deletions": 86,
        "changes": 178,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Frunner.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Frunner.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Frunner.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,13 +1,14 @@\n 'use strict';\n-const EventEmitter = require('events');\n const path = require('path');\n const matcher = require('matcher');\n const ContextRef = require('./context-ref');\n const createChain = require('./create-chain');\n+const Emittery = require('./emittery');\n const snapshotManager = require('./snapshot-manager');\n+const serializeError = require('./serialize-error');\n const Runnable = require('./test');\n \n-class Runner extends EventEmitter {\n+class Runner extends Emittery {\n \tconstructor(options) {\n \t\tsuper();\n \n@@ -26,16 +27,6 @@ class Runner extends EventEmitter {\n \t\tthis.boundCompareTestSnapshot = this.compareTestSnapshot.bind(this);\n \t\tthis.interrupted = false;\n \t\tthis.snapshots = null;\n-\t\tthis.stats = {\n-\t\t\tfailCount: 0,\n-\t\t\tfailedHookCount: 0,\n-\t\t\thasExclusive: false,\n-\t\t\tknownFailureCount: 0,\n-\t\t\tpassCount: 0,\n-\t\t\tskipCount: 0,\n-\t\t\ttestCount: 0,\n-\t\t\ttodoCount: 0\n-\t\t};\n \t\tthis.tasks = {\n \t\t\tafter: [],\n \t\t\tafterAlways: [],\n@@ -89,11 +80,17 @@ class Runner extends EventEmitter {\n \t\t\t\t\t// --match selects TODO tests.\n \t\t\t\t\tif (matcher([specifiedTitle], this.match).length === 1) {\n \t\t\t\t\t\tmetadata.exclusive = true;\n-\t\t\t\t\t\tthis.stats.hasExclusive = true;\n+\t\t\t\t\t\tthis.runOnlyExclusive = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tthis.tasks.todo.push({title: specifiedTitle, metadata});\n+\t\t\t\tthis.emit('stateChange', {\n+\t\t\t\t\ttype: 'declared-test',\n+\t\t\t\t\ttitle: specifiedTitle,\n+\t\t\t\t\tknownFailing: false,\n+\t\t\t\t\ttodo: true\n+\t\t\t\t});\n \t\t\t} else {\n \t\t\t\tif (implementations.length === 0) {\n \t\t\t\t\tthrow new TypeError('Expected an implementation. Use `test.todo()` for tests without an implementation.');\n@@ -139,10 +136,16 @@ class Runner extends EventEmitter {\n \t\t\t\t\t\t\ttask.metadata.exclusive = matcher([title], this.match).length === 1;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (task.metadata.exclusive) {\n-\t\t\t\t\t\t\tthis.stats.hasExclusive = true;\n+\t\t\t\t\t\t\tthis.runOnlyExclusive = true;\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tthis.tasks[metadata.serial ? 'serial' : 'concurrent'].push(task);\n+\t\t\t\t\t\tthis.emit('stateChange', {\n+\t\t\t\t\t\t\ttype: 'declared-test',\n+\t\t\t\t\t\t\ttitle,\n+\t\t\t\t\t\t\tknownFailing: metadata.failing,\n+\t\t\t\t\t\t\ttodo: false\n+\t\t\t\t\t\t});\n \t\t\t\t\t} else if (!metadata.skipped) {\n \t\t\t\t\t\tthis.tasks[metadata.type + (metadata.always ? 'Always' : '')].push(task);\n \t\t\t\t\t}\n@@ -178,15 +181,16 @@ class Runner extends EventEmitter {\n \n \tsaveSnapshotState() {\n \t\tif (this.snapshots) {\n-\t\t\tconst files = this.snapshots.save();\n-\t\t\tif (files) {\n-\t\t\t\tthis.emit('touched', files);\n-\t\t\t}\n-\t\t} else if (this.updateSnapshots) {\n+\t\t\treturn this.snapshots.save();\n+\t\t}\n+\n+\t\tif (this.updateSnapshots) {\n \t\t\t// TODO: There may be unused snapshot files if no test caused the\n \t\t\t// snapshots to be loaded. Prune them. But not if tests (including hooks!)\n \t\t\t// were skipped. Perhaps emit a warning if this occurs?\n \t\t}\n+\n+\t\treturn null;\n \t}\n \n \tonRun(runnable) {\n@@ -278,8 +282,13 @@ class Runner extends EventEmitter {\n \t\t\t// Only emit results for failed hooks.\n \t\t\tfor (const result of outcome.storedResults) {\n \t\t\t\tif (!result.passed) {\n-\t\t\t\t\tthis.stats.failedHookCount++;\n-\t\t\t\t\tthis.emit('hook-failed', result);\n+\t\t\t\t\tthis.emit('stateChange', {\n+\t\t\t\t\t\ttype: 'hook-failed',\n+\t\t\t\t\t\ttitle: result.title,\n+\t\t\t\t\t\terr: serializeError('Hook failure', true, result.error),\n+\t\t\t\t\t\tduration: result.duration,\n+\t\t\t\t\t\tlogs: result.logs\n+\t\t\t\t\t});\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn false;\n@@ -306,20 +315,27 @@ class Runner extends EventEmitter {\n \t\t\t\ttitle: task.title\n \t\t\t});\n \t\t\treturn this.runSingle(test).then(result => {\n-\t\t\t\tif (!result.passed) {\n-\t\t\t\t\tthis.stats.failCount++;\n-\t\t\t\t\tthis.emit('test', result);\n-\t\t\t\t\t// Don't run `afterEach` hooks if the test failed.\n-\t\t\t\t\treturn false;\n+\t\t\t\tif (result.passed) {\n+\t\t\t\t\tthis.emit('stateChange', {\n+\t\t\t\t\t\ttype: 'test-passed',\n+\t\t\t\t\t\ttitle: result.title,\n+\t\t\t\t\t\tduration: result.duration,\n+\t\t\t\t\t\tknownFailing: result.metadata.failing,\n+\t\t\t\t\t\tlogs: result.logs\n+\t\t\t\t\t});\n+\t\t\t\t\treturn this.runHooks(this.tasks.afterEach, contextRef, hookSuffix);\n \t\t\t\t}\n \n-\t\t\t\tif (result.metadata.failing) {\n-\t\t\t\t\tthis.stats.knownFailureCount++;\n-\t\t\t\t} else {\n-\t\t\t\t\tthis.stats.passCount++;\n-\t\t\t\t}\n-\t\t\t\tthis.emit('test', result);\n-\t\t\t\treturn this.runHooks(this.tasks.afterEach, contextRef, hookSuffix);\n+\t\t\t\tthis.emit('stateChange', {\n+\t\t\t\t\ttype: 'test-failed',\n+\t\t\t\t\ttitle: result.title,\n+\t\t\t\t\terr: serializeError('Test failure', true, result.error),\n+\t\t\t\t\tduration: result.duration,\n+\t\t\t\t\tknownFailing: result.metadata.failing,\n+\t\t\t\t\tlogs: result.logs\n+\t\t\t\t});\n+\t\t\t\t// Don't run `afterEach` hooks if the test failed.\n+\t\t\t\treturn false;\n \t\t\t});\n \t\t}).then(hooksAndTestOk => {\n \t\t\treturn this.runHooks(this.tasks.afterEachAlways, contextRef, hookSuffix).then(alwaysOk => {\n@@ -329,65 +345,63 @@ class Runner extends EventEmitter {\n \t}\n \n \tstart() {\n-\t\tconst runOnlyExclusive = this.stats.hasExclusive || this.runOnlyExclusive;\n-\n-\t\tconst todoTitles = [];\n-\t\tfor (const task of this.tasks.todo) {\n-\t\t\tif (runOnlyExclusive && !task.metadata.exclusive) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tthis.stats.testCount++;\n-\t\t\tthis.stats.todoCount++;\n-\t\t\ttodoTitles.push(task.title);\n-\t\t}\n-\n \t\tconst concurrentTests = [];\n \t\tconst serialTests = [];\n-\t\tconst skippedTests = [];\n \t\tfor (const task of this.tasks.serial) {\n-\t\t\tif (runOnlyExclusive && !task.metadata.exclusive) {\n+\t\t\tif (this.runOnlyExclusive && !task.metadata.exclusive) {\n \t\t\t\tcontinue;\n \t\t\t}\n \n-\t\t\tthis.stats.testCount++;\n-\t\t\tif (task.metadata.skipped) {\n-\t\t\t\tthis.stats.skipCount++;\n-\t\t\t\tskippedTests.push({\n-\t\t\t\t\tfailing: task.metadata.failing,\n-\t\t\t\t\ttitle: task.title\n-\t\t\t\t});\n-\t\t\t} else {\n+\t\t\tthis.emit('stateChange', {\n+\t\t\t\ttype: 'selected-test',\n+\t\t\t\ttitle: task.title,\n+\t\t\t\tknownFailing: task.metadata.failing,\n+\t\t\t\tskip: task.metadata.skipped,\n+\t\t\t\ttodo: false\n+\t\t\t});\n+\n+\t\t\tif (!task.metadata.skipped) {\n \t\t\t\tserialTests.push(task);\n \t\t\t}\n \t\t}\n \t\tfor (const task of this.tasks.concurrent) {\n-\t\t\tif (runOnlyExclusive && !task.metadata.exclusive) {\n+\t\t\tif (this.runOnlyExclusive && !task.metadata.exclusive) {\n \t\t\t\tcontinue;\n \t\t\t}\n \n-\t\t\tthis.stats.testCount++;\n-\t\t\tif (task.metadata.skipped) {\n-\t\t\t\tthis.stats.skipCount++;\n-\t\t\t\tskippedTests.push({\n-\t\t\t\t\tfailing: task.metadata.failing,\n-\t\t\t\t\ttitle: task.title\n-\t\t\t\t});\n-\t\t\t} else if (this.serial) {\n-\t\t\t\tserialTests.push(task);\n-\t\t\t} else {\n-\t\t\t\tconcurrentTests.push(task);\n+\t\t\tthis.emit('stateChange', {\n+\t\t\t\ttype: 'selected-test',\n+\t\t\t\ttitle: task.title,\n+\t\t\t\tknownFailing: task.metadata.failing,\n+\t\t\t\tskip: task.metadata.skipped,\n+\t\t\t\ttodo: false\n+\t\t\t});\n+\n+\t\t\tif (!task.metadata.skipped) {\n+\t\t\t\tif (this.serial) {\n+\t\t\t\t\tserialTests.push(task);\n+\t\t\t\t} else {\n+\t\t\t\t\tconcurrentTests.push(task);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\tif (concurrentTests.length === 0 && serialTests.length === 0) {\n-\t\t\tthis.emit('start', {\n-\t\t\t\t// `ended` is always resolved with `undefined`.\n-\t\t\t\tended: Promise.resolve(undefined),\n-\t\t\t\tskippedTests,\n-\t\t\t\tstats: this.stats,\n-\t\t\t\ttodoTitles\n+\t\tfor (const task of this.tasks.todo) {\n+\t\t\tif (this.runOnlyExclusive && !task.metadata.exclusive) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tthis.emit('stateChange', {\n+\t\t\t\ttype: 'selected-test',\n+\t\t\t\ttitle: task.title,\n+\t\t\t\tknownFailing: false,\n+\t\t\t\tskip: false,\n+\t\t\t\ttodo: true\n \t\t\t});\n+\t\t}\n+\n+\t\tif (concurrentTests.length === 0 && serialTests.length === 0) {\n+\t\t\tthis.emit('finish');\n \t\t\t// Don't run any hooks if there are no tests to run.\n \t\t\treturn;\n \t\t}\n@@ -443,23 +457,15 @@ class Runner extends EventEmitter {\n \t\tconst beforeExitHandler = this.beforeExitHandler.bind(this);\n \t\tprocess.on('beforeExit', beforeExitHandler);\n \n-\t\tconst ended = concurrentPromise\n+\t\tconcurrentPromise\n \t\t\t// Only run `after` hooks if all hooks and tests passed.\n \t\t\t.then(ok => ok && this.runHooks(this.tasks.after, contextRef))\n \t\t\t// Always run `after.always` hooks.\n \t\t\t.then(() => this.runHooks(this.tasks.afterAlways, contextRef))\n \t\t\t.then(() => {\n \t\t\t\tprocess.removeListener('beforeExit', beforeExitHandler);\n-\t\t\t\t// `ended` is always resolved with `undefined`.\n-\t\t\t\treturn undefined;\n-\t\t\t});\n-\n-\t\tthis.emit('start', {\n-\t\t\tended,\n-\t\t\tskippedTests,\n-\t\t\tstats: this.stats,\n-\t\t\ttodoTitles\n-\t\t});\n+\t\t\t})\n+\t\t\t.then(() => this.emit('finish'), err => this.emit('error', err));\n \t}\n \n \tinterrupt() {"
      },
      {
        "sha": "502f129feabcf92878846b3cb04d4fdbf537270d",
        "filename": "lib/serialize-error.js",
        "status": "modified",
        "additions": 55,
        "deletions": 32,
        "changes": 87,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fserialize-error.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fserialize-error.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fserialize-error.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,9 +1,12 @@\n 'use strict';\n const path = require('path');\n const cleanYamlObject = require('clean-yaml-object');\n+const concordance = require('concordance');\n+const isError = require('is-error');\n const StackUtils = require('stack-utils');\n const assert = require('./assert');\n const beautifyStack = require('./beautify-stack');\n+const concordanceOptions = require('./concordance-options').default;\n \n function isAvaAssertionError(source) {\n \treturn source instanceof assert.AssertionError;\n@@ -46,52 +49,49 @@ function buildSource(source) {\n \t};\n }\n \n-module.exports = error => {\n-\tconst stack = typeof error.stack === 'string' ?\n-\t\tbeautifyStack(error.stack) :\n-\t\tnull;\n+function trySerializeError(err, shouldBeautifyStack) {\n+\tconst stack = shouldBeautifyStack ? beautifyStack(err.stack) : err.stack;\n \n \tconst retval = {\n-\t\tavaAssertionError: isAvaAssertionError(error),\n-\t\tsource: buildSource(extractSource(stack))\n+\t\tavaAssertionError: isAvaAssertionError(err),\n+\t\tnonErrorObject: false,\n+\t\tsource: buildSource(extractSource(stack)),\n+\t\tstack\n \t};\n-\tif (stack) {\n-\t\tretval.stack = stack;\n-\t}\n \n \tif (retval.avaAssertionError) {\n-\t\tretval.improperUsage = error.improperUsage;\n-\t\tretval.message = error.message;\n-\t\tretval.name = error.name;\n-\t\tretval.statements = error.statements;\n-\t\tretval.values = error.values;\n-\n-\t\tif (error.fixedSource) {\n-\t\t\tconst source = buildSource(error.fixedSource);\n+\t\tretval.improperUsage = err.improperUsage;\n+\t\tretval.message = err.message;\n+\t\tretval.name = err.name;\n+\t\tretval.statements = err.statements;\n+\t\tretval.values = err.values;\n+\n+\t\tif (err.fixedSource) {\n+\t\t\tconst source = buildSource(err.fixedSource);\n \t\t\tif (source) {\n \t\t\t\tretval.source = source;\n \t\t\t}\n \t\t}\n \n-\t\tif (error.assertion) {\n-\t\t\tretval.assertion = error.assertion;\n+\t\tif (err.assertion) {\n+\t\t\tretval.assertion = err.assertion;\n \t\t}\n-\t\tif (error.operator) {\n-\t\t\tretval.operator = error.operator;\n+\t\tif (err.operator) {\n+\t\t\tretval.operator = err.operator;\n \t\t}\n \t} else {\n-\t\tretval.object = cleanYamlObject(error, filter); // Cleanly copy non-standard properties\n-\t\tif (typeof error.message === 'string') {\n-\t\t\tretval.message = error.message;\n+\t\tretval.object = cleanYamlObject(err, filter); // Cleanly copy non-standard properties\n+\t\tif (typeof err.message === 'string') {\n+\t\t\tretval.message = err.message;\n \t\t}\n-\t\tif (typeof error.name === 'string') {\n-\t\t\tretval.name = error.name;\n+\t\tif (typeof err.name === 'string') {\n+\t\t\tretval.name = err.name;\n \t\t}\n \t}\n \n-\tif (typeof error.stack === 'string') {\n-\t\tconst lines = error.stack.split('\\n');\n-\t\tif (error.name === 'SyntaxError' && !lines[0].startsWith('SyntaxError')) {\n+\tif (typeof err.stack === 'string') {\n+\t\tconst lines = err.stack.split('\\n');\n+\t\tif (err.name === 'SyntaxError' && !lines[0].startsWith('SyntaxError')) {\n \t\t\tretval.summary = '';\n \t\t\tfor (const line of lines) {\n \t\t\t\tretval.summary += line + '\\n';\n@@ -103,9 +103,32 @@ module.exports = error => {\n \t\t} else {\n \t\t\tretval.summary = lines[0];\n \t\t}\n-\t} else {\n-\t\tretval.summary = JSON.stringify(error);\n \t}\n \n \treturn retval;\n-};\n+}\n+\n+function serializeError(origin, shouldBeautifyStack, err) {\n+\tif (!isError(err)) {\n+\t\treturn {\n+\t\t\tavaAssertionError: false,\n+\t\t\tnonErrorObject: true,\n+\t\t\tformatted: concordance.formatDescriptor(concordance.describe(err, concordanceOptions), concordanceOptions)\n+\t\t};\n+\t}\n+\n+\ttry {\n+\t\treturn trySerializeError(err, shouldBeautifyStack);\n+\t} catch (_) {\n+\t\tconst replacement = new Error(`${origin}: Could not serialize error`);\n+\t\treturn {\n+\t\t\tavaAssertionError: false,\n+\t\t\tnonErrorObject: false,\n+\t\t\tname: replacement.name,\n+\t\t\tmessage: replacement.message,\n+\t\t\tstack: replacement.stack,\n+\t\t\tsummary: replacement.message\n+\t\t};\n+\t}\n+}\n+module.exports = serializeError;"
      },
      {
        "sha": "b7f45b9dcd9d5fa707e2d0e299ac8d9eb177c36c",
        "filename": "lib/test-worker.js",
        "status": "removed",
        "additions": 0,
        "deletions": 260,
        "changes": 260,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/lib%2Ftest-worker.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/lib%2Ftest-worker.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Ftest-worker.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,260 +0,0 @@\n-'use strict';\n-\n-// Check if the test is being run without AVA cli\n-{\n-\tconst path = require('path');\n-\tconst chalk = require('chalk'); // This processes the --color/--no-color argument passed by fork.js\n-\n-\tconst isForked = typeof process.send === 'function';\n-\tif (!isForked) {\n-\t\tconst fp = path.relative('.', process.argv[1]);\n-\n-\t\tconsole.log();\n-\t\tconsole.error('Test files must be run with the AVA CLI:\\n\\n    ' + chalk.grey.dim('$') + ' ' + chalk.cyan('ava ' + fp) + '\\n');\n-\n-\t\tprocess.exit(1); // eslint-disable-line unicorn/no-process-exit\n-\t}\n-}\n-\n-const currentlyUnhandled = require('currently-unhandled')();\n-const isObj = require('is-obj');\n-\n-const adapter = require('./process-adapter');\n-const serializeError = require('./serialize-error');\n-const opts = require('./worker-options').get();\n-\n-// Store details about the test run, to be sent to the parent process later.\n-const dependencies = new Set();\n-const touchedFiles = new Set();\n-\n-// Set when main.js is required (since test files should have `require('ava')`).\n-let runner = null;\n-\n-// Track when exiting begins, to avoid repeatedly sending stats, or sending\n-// individual test results once stats have been sent. This is necessary since\n-// exit() can be invoked from the worker process and over IPC.\n-let exiting = false;\n-function exit() {\n-\tif (exiting) {\n-\t\treturn;\n-\t}\n-\texiting = true;\n-\n-\t// Reference the IPC channel so the exit sequence can be completed.\n-\tadapter.forceRefChannel();\n-\n-\tconst stats = {\n-\t\tfailCount: runner.stats.failCount + runner.stats.failedHookCount,\n-\t\tknownFailureCount: runner.stats.knownFailureCount,\n-\t\tpassCount: runner.stats.passCount,\n-\t\tskipCount: runner.stats.skipCount,\n-\t\ttestCount: runner.stats.testCount,\n-\t\ttodoCount: runner.stats.todoCount\n-\t};\n-\tadapter.send('results', {stats});\n-}\n-\n-exports.setRunner = newRunner => {\n-\trunner = newRunner;\n-\trunner.on('dependency', file => {\n-\t\tdependencies.add(file);\n-\t});\n-\trunner.on('touched', files => {\n-\t\tfor (const file of files) {\n-\t\t\ttouchedFiles.add(file);\n-\t\t}\n-\t});\n-\trunner.on('start', started => {\n-\t\tadapter.send('stats', {\n-\t\t\ttestCount: started.stats.testCount,\n-\t\t\thasExclusive: started.stats.hasExclusive\n-\t\t});\n-\n-\t\tfor (const partial of started.skippedTests) {\n-\t\t\tadapter.send('test', {\n-\t\t\t\tduration: null,\n-\t\t\t\terror: null,\n-\t\t\t\tfailing: partial.failing,\n-\t\t\t\tlogs: [],\n-\t\t\t\tskip: true,\n-\t\t\t\ttitle: partial.title,\n-\t\t\t\ttodo: false,\n-\t\t\t\ttype: 'test'\n-\t\t\t});\n-\t\t}\n-\t\tfor (const title of started.todoTitles) {\n-\t\t\tadapter.send('test', {\n-\t\t\t\tduration: null,\n-\t\t\t\terror: null,\n-\t\t\t\tfailing: false,\n-\t\t\t\tlogs: [],\n-\t\t\t\tskip: true,\n-\t\t\t\ttitle,\n-\t\t\t\ttodo: true,\n-\t\t\t\ttype: 'test'\n-\t\t\t});\n-\t\t}\n-\n-\t\tstarted.ended.then(() => {\n-\t\t\trunner.saveSnapshotState();\n-\t\t\treturn exit();\n-\t\t}).catch(err => {\n-\t\t\thandleUncaughtException(err);\n-\t\t});\n-\t});\n-\trunner.on('hook-failed', result => {\n-\t\tadapter.send('test', {\n-\t\t\tduration: result.duration,\n-\t\t\terror: serializeError(result.error),\n-\t\t\tfailing: result.metadata.failing,\n-\t\t\tlogs: result.logs,\n-\t\t\tskip: result.metadata.skip,\n-\t\t\ttitle: result.title,\n-\t\t\ttodo: result.metadata.todo,\n-\t\t\ttype: result.metadata.type\n-\t\t});\n-\t});\n-\trunner.on('test', result => {\n-\t\tadapter.send('test', {\n-\t\t\tduration: result.duration,\n-\t\t\terror: result.passed ? null : serializeError(result.error),\n-\t\t\tfailing: result.metadata.failing,\n-\t\t\tlogs: result.logs,\n-\t\t\tskip: result.metadata.skip,\n-\t\t\ttitle: result.title,\n-\t\t\ttodo: result.metadata.todo,\n-\t\t\ttype: result.metadata.type\n-\t\t});\n-\t});\n-};\n-\n-function attributeLeakedError(err) {\n-\tif (!runner) {\n-\t\treturn false;\n-\t}\n-\n-\treturn runner.attributeLeakedError(err);\n-}\n-\n-function handleUncaughtException(exception) {\n-\tif (attributeLeakedError(exception)) {\n-\t\treturn;\n-\t}\n-\n-\tlet serialized;\n-\ttry {\n-\t\tserialized = serializeError(exception);\n-\t} catch (ignore) { // eslint-disable-line unicorn/catch-error-name\n-\t\t// Avoid using serializeError\n-\t\tconst err = new Error('Failed to serialize uncaught exception');\n-\t\tserialized = {\n-\t\t\tavaAssertionError: false,\n-\t\t\tname: err.name,\n-\t\t\tmessage: err.message,\n-\t\t\tstack: err.stack\n-\t\t};\n-\t}\n-\n-\t// Ensure the IPC channel is referenced. The uncaught exception will kick off\n-\t// the teardown sequence, for which the messages must be received.\n-\tadapter.forceRefChannel();\n-\n-\tadapter.send('uncaughtException', {exception: serialized});\n-}\n-\n-const attributedRejections = new Set();\n-process.on('unhandledRejection', (reason, promise) => {\n-\tif (attributeLeakedError(reason)) {\n-\t\tattributedRejections.add(promise);\n-\t}\n-});\n-\n-process.on('uncaughtException', handleUncaughtException);\n-\n-let tearingDown = false;\n-process.on('ava-teardown', () => {\n-\t// AVA-teardown can be sent more than once\n-\tif (tearingDown) {\n-\t\treturn;\n-\t}\n-\ttearingDown = true;\n-\n-\t// Reference the IPC channel so the teardown sequence can be completed.\n-\tadapter.forceRefChannel();\n-\n-\tlet rejections = currentlyUnhandled()\n-\t\t.filter(rejection => !attributedRejections.has(rejection.promise));\n-\n-\tif (rejections.length > 0) {\n-\t\trejections = rejections.map(rejection => {\n-\t\t\tlet reason = rejection.reason;\n-\t\t\tif (!isObj(reason) || typeof reason.message !== 'string') {\n-\t\t\t\treason = {\n-\t\t\t\t\tmessage: String(reason)\n-\t\t\t\t};\n-\t\t\t}\n-\t\t\treturn serializeError(reason);\n-\t\t});\n-\n-\t\tadapter.send('unhandledRejections', {rejections});\n-\t}\n-\n-\t// Include dependencies in the final teardown message. This ensures the full\n-\t// set of dependencies is included no matter how the process exits, unless\n-\t// it flat out crashes. Also include any files that AVA touched during the\n-\t// test run. This allows the watcher to ignore modifications to those files.\n-\tadapter.send('teardown', {\n-\t\tdependencies: Array.from(dependencies),\n-\t\ttouchedFiles: Array.from(touchedFiles)\n-\t});\n-});\n-\n-process.on('ava-exit', () => {\n-\tprocess.exit(0); // eslint-disable-line xo/no-process-exit\n-});\n-\n-process.on('ava-init-exit', () => {\n-\texit();\n-});\n-\n-process.on('ava-peer-failed', () => {\n-\tif (runner) {\n-\t\trunner.interrupt();\n-\t}\n-});\n-\n-// Store value in case to prevent required modules from modifying it.\n-const testPath = opts.file;\n-\n-// Install before processing opts.require, so if helpers are added to the\n-// require configuration the *compiled* helper will be loaded.\n-adapter.installDependencyTracking(dependencies, testPath);\n-adapter.installSourceMapSupport();\n-adapter.installPrecompilerHook();\n-\n-try {\n-\t(opts.require || []).forEach(x => {\n-\t\tconst required = require(x);\n-\n-\t\ttry {\n-\t\t\tif (required[Symbol.for('esm\\u200D:package')]) {\n-\t\t\t\trequire = required(module); // eslint-disable-line no-global-assign\n-\t\t\t}\n-\t\t} catch (_) {}\n-\t});\n-\n-\trequire(testPath);\n-} catch (err) {\n-\thandleUncaughtException(err);\n-} finally {\n-\tadapter.send('loaded-file', {avaRequired: Boolean(runner)});\n-\n-\tif (runner) {\n-\t\t// Unreference the IPC channel if the test file required AVA. This stops it\n-\t\t// from keeping the event loop busy, which means the `beforeExit` event can be\n-\t\t// used to detect when tests stall.\n-\t\t// If AVA was not required then the parent process will initiated a teardown\n-\t\t// sequence, for which this process ought to stay active.\n-\t\tadapter.unrefChannel();\n-\t}\n-}"
      },
      {
        "sha": "13404e4cc9778e76b42f917b66bc5262b54be8ec",
        "filename": "lib/test.js",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Ftest.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -312,7 +312,7 @@ class Test {\n \t\ttry {\n \t\t\treturn {\n \t\t\t\tok: true,\n-\t\t\t\tretval: this.fn(this.createExecutionContext())\n+\t\t\t\tretval: this.fn.call(null, this.createExecutionContext())\n \t\t\t};\n \t\t} catch (err) {\n \t\t\treturn {"
      },
      {
        "sha": "c8efe4ff7ff2c48b611be77786af5b75d6754058",
        "filename": "lib/watcher.js",
        "status": "modified",
        "additions": 71,
        "deletions": 44,
        "changes": 115,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fwatcher.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fwatcher.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fwatcher.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -78,7 +78,7 @@ class TestDependency {\n }\n \n class Watcher {\n-\tconstructor(logger, api, files, sources) {\n+\tconstructor(reporter, api, files, sources) {\n \t\tthis.debouncer = new Debouncer(this);\n \t\tthis.avaFiles = new AvaFiles({\n \t\t\tfiles,\n@@ -89,46 +89,49 @@ class Watcher {\n \t\tthis.runVector = 0;\n \t\tthis.previousFiles = files;\n \t\tthis.run = (specificFiles, updateSnapshots) => {\n+\t\t\tconst clearLogOnNextRun = this.clearLogOnNextRun && this.runVector > 0;\n \t\t\tif (this.runVector > 0) {\n-\t\t\t\tconst cleared = this.clearLogOnNextRun && logger.clear();\n-\t\t\t\tif (!cleared) {\n-\t\t\t\t\tlogger.reset();\n-\t\t\t\t\tlogger.section();\n-\t\t\t\t}\n \t\t\t\tthis.clearLogOnNextRun = true;\n-\n-\t\t\t\tlogger.reset();\n-\t\t\t\tlogger.start();\n \t\t\t}\n-\n-\t\t\tthis.runVector += 1;\n-\n-\t\t\tconst currentVector = this.runVector;\n+\t\t\tthis.runVector++;\n \n \t\t\tlet runOnlyExclusive = false;\n-\n \t\t\tif (specificFiles) {\n \t\t\t\tconst exclusiveFiles = specificFiles.filter(file => this.filesWithExclusiveTests.indexOf(file) !== -1);\n-\n \t\t\t\trunOnlyExclusive = exclusiveFiles.length !== this.filesWithExclusiveTests.length;\n-\n \t\t\t\tif (runOnlyExclusive) {\n \t\t\t\t\t// The test files that previously contained exclusive tests are always\n \t\t\t\t\t// run, together with the remaining specific files.\n \t\t\t\t\tconst remainingFiles = diff(specificFiles, exclusiveFiles);\n \t\t\t\t\tspecificFiles = this.filesWithExclusiveTests.concat(remainingFiles);\n \t\t\t\t}\n+\n+\t\t\t\tthis.pruneFailures(specificFiles);\n \t\t\t}\n \n \t\t\tthis.touchedFiles.clear();\n \t\t\tthis.previousFiles = specificFiles || files;\n-\t\t\tthis.busy = api.run(this.previousFiles, {runOnlyExclusive, updateSnapshots: updateSnapshots === true})\n+\t\t\tthis.busy = api.run(this.previousFiles, {\n+\t\t\t\tclearLogOnNextRun,\n+\t\t\t\tpreviousFailures: this.sumPreviousFailures(this.runVector),\n+\t\t\t\trunOnlyExclusive,\n+\t\t\t\trunVector: this.runVector,\n+\t\t\t\tupdateSnapshots: updateSnapshots === true\n+\t\t\t})\n \t\t\t\t.then(runStatus => {\n-\t\t\t\t\trunStatus.previousFailCount = this.sumPreviousFailures(currentVector);\n-\t\t\t\t\tlogger.finish(runStatus);\n-\n-\t\t\t\t\tconst badCounts = runStatus.failCount + runStatus.rejectionCount + runStatus.exceptionCount;\n-\t\t\t\t\tthis.clearLogOnNextRun = this.clearLogOnNextRun && badCounts === 0;\n+\t\t\t\t\treporter.endRun();\n+\n+\t\t\t\t\tif (this.clearLogOnNextRun && (\n+\t\t\t\t\t\trunStatus.stats.failedHooks > 0 ||\n+\t\t\t\t\t\trunStatus.stats.failedTests > 0 ||\n+\t\t\t\t\t\trunStatus.stats.failedWorkers > 0 ||\n+\t\t\t\t\t\trunStatus.stats.internalErrors > 0 ||\n+\t\t\t\t\t\trunStatus.stats.timeouts > 0 ||\n+\t\t\t\t\t\trunStatus.stats.uncaughtExceptions > 0 ||\n+\t\t\t\t\t\trunStatus.stats.unhandledRejections > 0\n+\t\t\t\t\t)) {\n+\t\t\t\t\t\tthis.clearLogOnNextRun = false;\n+\t\t\t\t\t}\n \t\t\t\t})\n \t\t\t\t.catch(rethrowAsync);\n \t\t};\n@@ -168,10 +171,14 @@ class Watcher {\n \ttrackTestDependencies(api) {\n \t\tconst relative = absPath => nodePath.relative(process.cwd(), absPath);\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('dependencies', (file, dependencies) => {\n-\t\t\t\tconst sourceDeps = dependencies.map(x => relative(x)).filter(this.avaFiles.isSource);\n-\t\t\t\tthis.updateTestDependencies(file, sourceDeps);\n+\t\tapi.on('run', plan => {\n+\t\t\tplan.status.on('stateChange', evt => {\n+\t\t\t\tif (evt.type !== 'dependencies') {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tconst sourceDeps = evt.dependencies.map(x => relative(x)).filter(this.avaFiles.isSource);\n+\t\t\t\tthis.updateTestDependencies(evt.testFile, sourceDeps);\n \t\t\t});\n \t\t});\n \t}\n@@ -198,18 +205,29 @@ class Watcher {\n \t}\n \n \ttrackTouchedFiles(api) {\n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('touchedFiles', files => {\n-\t\t\t\tfor (const file of files) {\n+\t\tapi.on('run', plan => {\n+\t\t\tplan.status.on('stateChange', evt => {\n+\t\t\t\tif (evt.type !== 'touched-files') {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tfor (const file of evt.files) {\n \t\t\t\t\tthis.touchedFiles.add(nodePath.relative(process.cwd(), file));\n \t\t\t\t}\n \t\t\t});\n \t\t});\n \t}\n \n \ttrackExclusivity(api) {\n-\t\tapi.on('stats', stats => {\n-\t\t\tthis.updateExclusivity(stats.file, stats.hasExclusive);\n+\t\tapi.on('run', plan => {\n+\t\t\tplan.status.on('stateChange', evt => {\n+\t\t\t\tif (evt.type !== 'worker-finished') {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tconst fileStats = plan.status.stats.byFile.get(evt.testFile);\n+\t\t\t\tthis.updateExclusivity(evt.testFile, fileStats.declaredTests > fileStats.selectedTests);\n+\t\t\t});\n \t\t});\n \t}\n \n@@ -224,25 +242,34 @@ class Watcher {\n \t}\n \n \ttrackFailures(api) {\n-\t\tapi.on('test-run', (runStatus, files) => {\n-\t\t\tfiles.forEach(file => {\n-\t\t\t\tthis.pruneFailures(nodePath.relative(process.cwd(), file));\n-\t\t\t});\n+\t\tapi.on('run', plan => {\n+\t\t\tthis.pruneFailures(plan.files);\n \n \t\t\tconst currentVector = this.runVector;\n-\t\t\trunStatus.on('error', err => {\n-\t\t\t\tthis.countFailure(err.file, currentVector);\n-\t\t\t});\n-\t\t\trunStatus.on('test', result => {\n-\t\t\t\tif (result.error) {\n-\t\t\t\t\tthis.countFailure(result.file, currentVector);\n+\t\t\tplan.status.on('stateChange', evt => {\n+\t\t\t\tif (!evt.testFile) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tswitch (evt.type) {\n+\t\t\t\t\tcase 'hook-failed':\n+\t\t\t\t\tcase 'internal-error':\n+\t\t\t\t\tcase 'test-failed':\n+\t\t\t\t\tcase 'uncaught-exception':\n+\t\t\t\t\tcase 'unhandled-rejection':\n+\t\t\t\t\tcase 'worker-failed':\n+\t\t\t\t\t\tthis.countFailure(evt.testFile, currentVector);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t});\n \t\t});\n \t}\n \n-\tpruneFailures(file) {\n-\t\tthis.filesWithFailures = this.filesWithFailures.filter(state => state.file !== file);\n+\tpruneFailures(files) {\n+\t\tconst toPrune = new Set(files);\n+\t\tthis.filesWithFailures = this.filesWithFailures.filter(state => !toPrune.has(state.file));\n \t}\n \n \tcountFailure(file, vector) {\n@@ -280,7 +307,7 @@ class Watcher {\n \t\tunlinkedTests.forEach(testFile => {\n \t\t\tthis.updateTestDependencies(testFile, []);\n \t\t\tthis.updateExclusivity(testFile, false);\n-\t\t\tthis.pruneFailures(testFile);\n+\t\t\tthis.pruneFailures([testFile]);\n \t\t});\n \t}\n "
      },
      {
        "sha": "a6ef18f94568501758be186c029b40a8690f752d",
        "filename": "lib/worker/consume-argv.js",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Fconsume-argv.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Fconsume-argv.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fworker%2Fconsume-argv.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,5 @@\n+'use strict';\n+require('./options').set(JSON.parse(process.argv[2]));\n+\n+// Remove arguments received from fork.js and leave those specified by the user.\n+process.argv.splice(2, 2);"
      },
      {
        "sha": "6f87d79c562c35b7ead6508514cb73cc313c4417",
        "filename": "lib/worker/dependency-tracker.js",
        "status": "added",
        "additions": 43,
        "deletions": 0,
        "changes": 43,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Fdependency-tracker.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Fdependency-tracker.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fworker%2Fdependency-tracker.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,43 @@\n+'use strict';\n+/* eslint-disable node/no-deprecated-api */\n+const ipc = require('./ipc');\n+\n+const seenDependencies = new Set();\n+let newDependencies = [];\n+function flush() {\n+\tif (newDependencies.length === 0) {\n+\t\treturn;\n+\t}\n+\n+\tipc.send({type: 'dependencies', dependencies: newDependencies});\n+\tnewDependencies = [];\n+}\n+exports.flush = flush;\n+\n+function track(filename) {\n+\tif (seenDependencies.has(filename)) {\n+\t\treturn;\n+\t}\n+\n+\tif (newDependencies.length === 0) {\n+\t\tprocess.nextTick(flush);\n+\t}\n+\tseenDependencies.add(filename);\n+\tnewDependencies.push(filename);\n+}\n+exports.track = track;\n+\n+function install(testPath) {\n+\tObject.keys(require.extensions).forEach(ext => {\n+\t\tconst wrappedHandler = require.extensions[ext];\n+\n+\t\trequire.extensions[ext] = (module, filename) => {\n+\t\t\tif (filename !== testPath) {\n+\t\t\t\ttrack(filename);\n+\t\t\t}\n+\n+\t\t\twrappedHandler(module, filename);\n+\t\t};\n+\t});\n+}\n+exports.install = install;"
      },
      {
        "sha": "f8c4a9fe638b45535d538b5d6b52ce461d573975",
        "filename": "lib/worker/ensure-forked.js",
        "status": "added",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Fensure-forked.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Fensure-forked.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fworker%2Fensure-forked.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,14 @@\n+'use strict';\n+const path = require('path');\n+const chalk = require('chalk'); // Use default Chalk instance.\n+\n+// Check if the test is being run without AVA cli\n+const isForked = typeof process.send === 'function';\n+if (!isForked) {\n+\tconst fp = path.relative('.', process.argv[1]);\n+\n+\tconsole.log();\n+\tconsole.error(`Test files must be run with the AVA CLI:\\n\\n    ${chalk.grey.dim('$')} ${chalk.cyan('ava ' + fp)}\\n`);\n+\n+\tprocess.exit(1); // eslint-disable-line unicorn/no-process-exit\n+}"
      },
      {
        "sha": "8f3a45bdb629655b6a358046e15b5eb51c2598f9",
        "filename": "lib/worker/fake-tty.js",
        "status": "added",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Ffake-tty.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Ffake-tty.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fworker%2Ffake-tty.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,16 @@\n+'use strict';\n+const tty = require('tty');\n+const options = require('./options').get();\n+\n+if (options.tty) {\n+\tObject.assign(process.stdout, {isTTY: true}, options.tty);\n+\n+\tconst isatty = tty.isatty;\n+\ttty.isatty = function (fd) {\n+\t\tif (fd === 1 || fd === process.stdout) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\treturn isatty(fd);\n+\t};\n+}"
      },
      {
        "sha": "695edae0ff3646bd5603758499ac5c73b25469e3",
        "filename": "lib/worker/ipc.js",
        "status": "added",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Fipc.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Fipc.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fworker%2Fipc.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,54 @@\n+'use strict';\n+const Emittery = require('../emittery');\n+\n+// `process.channel` was added in Node.js 7.1.0, but the channel was available\n+// through an undocumented API as `process._channel`.\n+const channel = process.channel || process._channel;\n+\n+const emitter = new Emittery();\n+process.on('message', message => {\n+\tif (!message.ava) {\n+\t\treturn;\n+\t}\n+\n+\tswitch (message.ava.type) {\n+\t\tcase 'peer-failed':\n+\t\t\temitter.emit('peerFailed');\n+\t\t\tbreak;\n+\t\tcase 'pong':\n+\t\t\temitter.emit('pong');\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tbreak;\n+\t}\n+});\n+\n+exports.peerFailed = emitter.once('peerFailed');\n+\n+function send(evt) {\n+\tif (process.connected) {\n+\t\tprocess.send({ava: evt});\n+\t}\n+}\n+exports.send = send;\n+\n+function unref() {\n+\tchannel.unref();\n+}\n+exports.unref = unref;\n+\n+let pendingPings = Promise.resolve();\n+function flush() {\n+\tchannel.ref();\n+\tconst promise = pendingPings.then(() => {\n+\t\tsend({type: 'ping'});\n+\t\treturn emitter.once('pong');\n+\t}).then(() => {\n+\t\tif (promise === pendingPings) {\n+\t\t\tunref();\n+\t\t}\n+\t});\n+\tpendingPings = promise;\n+\treturn promise;\n+}\n+exports.flush = flush;"
      },
      {
        "sha": "585bface966da1039c99c6c754b1c514bfa3d264",
        "filename": "lib/worker/load-chalk.js",
        "status": "added",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Fload-chalk.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Fload-chalk.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fworker%2Fload-chalk.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,2 @@\n+'use strict';\n+require('../chalk').set(); // Use default options, which means processing the --color/--no-color argument passed by fork.js"
      },
      {
        "sha": "d1f2bbe2e7a71d0640854629edfe0bba022b9f48",
        "filename": "lib/worker/main.js",
        "status": "renamed",
        "additions": 1,
        "deletions": 17,
        "changes": 18,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Fmain.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Fmain.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fworker%2Fmain.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,21 +1,5 @@\n 'use strict';\n-const worker = require('./test-worker');\n-const Runner = require('./runner');\n-const opts = require('./worker-options').get();\n-\n-const runner = new Runner({\n-\tfailFast: opts.failFast,\n-\tfailWithoutAssertions: opts.failWithoutAssertions,\n-\tfile: opts.file,\n-\tmatch: opts.match,\n-\tprojectDir: opts.projectDir,\n-\trunOnlyExclusive: opts.runOnlyExclusive,\n-\tserial: opts.serial,\n-\tsnapshotDir: opts.snapshotDir,\n-\tupdateSnapshots: opts.updateSnapshots\n-});\n-\n-worker.setRunner(runner);\n+const runner = require('./subprocess').getRunner();\n \n const makeCjsExport = () => {\n \tfunction test() {",
        "previous_filename": "lib/main.js"
      },
      {
        "sha": "65a7c1756e9ee97e7430e057ae36b8481fdef6a6",
        "filename": "lib/worker/options.js",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Foptions.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Foptions.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fworker%2Foptions.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "previous_filename": "lib/worker-options.js"
      },
      {
        "sha": "9229ee8ea7d87be288d60c047c4b9dc6bfa57026",
        "filename": "lib/worker/precompiler-hook.js",
        "status": "added",
        "additions": 40,
        "deletions": 0,
        "changes": 40,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Fprecompiler-hook.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Fprecompiler-hook.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fworker%2Fprecompiler-hook.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,40 @@\n+'use strict';\n+const fs = require('fs');\n+const path = require('path');\n+const sourceMapSupport = require('source-map-support');\n+const installPrecompiler = require('require-precompiled');\n+const options = require('./options').get();\n+\n+const sourceMapCache = new Map();\n+const cacheDir = options.cacheDir;\n+\n+function installSourceMapSupport() {\n+\tsourceMapSupport.install({\n+\t\tenvironment: 'node',\n+\t\thandleUncaughtExceptions: false,\n+\t\tretrieveSourceMap(source) {\n+\t\t\tif (sourceMapCache.has(source)) {\n+\t\t\t\treturn {\n+\t\t\t\t\turl: source,\n+\t\t\t\t\tmap: fs.readFileSync(sourceMapCache.get(source), 'utf8')\n+\t\t\t\t};\n+\t\t\t}\n+\t\t}\n+\t});\n+}\n+\n+function install() {\n+\tinstallSourceMapSupport();\n+\n+\tinstallPrecompiler(filename => {\n+\t\tconst precompiled = options.precompiled[filename];\n+\n+\t\tif (precompiled) {\n+\t\t\tsourceMapCache.set(filename, path.join(cacheDir, `${precompiled}.js.map`));\n+\t\t\treturn fs.readFileSync(path.join(cacheDir, `${precompiled}.js`), 'utf8');\n+\t\t}\n+\n+\t\treturn null;\n+\t});\n+}\n+exports.install = install;"
      },
      {
        "sha": "591211ea91b4f482fe4be0266d4c7ea30f05f6cf",
        "filename": "lib/worker/subprocess.js",
        "status": "added",
        "additions": 130,
        "deletions": 0,
        "changes": 130,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Fsubprocess.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/lib%2Fworker%2Fsubprocess.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fworker%2Fsubprocess.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,130 @@\n+'use strict';\n+const currentlyUnhandled = require('currently-unhandled')();\n+\n+/* eslint-disable unicorn/no-process-exit */\n+/* eslint-disable import/no-unassigned-import */\n+require('./ensure-forked');\n+require('./load-chalk');\n+require('./consume-argv');\n+require('./fake-tty');\n+\n+const nowAndTimers = require('../now-and-timers');\n+const Runner = require('../runner');\n+const serializeError = require('../serialize-error');\n+const dependencyTracking = require('./dependency-tracker');\n+const ipc = require('./ipc');\n+const options = require('./options').get();\n+const precompilerHook = require('./precompiler-hook');\n+\n+function exit(code) {\n+\tif (!process.exitCode) {\n+\t\tprocess.exitCode = code;\n+\t}\n+\n+\tdependencyTracking.flush();\n+\treturn ipc.flush().then(() => process.exit());\n+}\n+\n+const runner = new Runner({\n+\tfailFast: options.failFast,\n+\tfailWithoutAssertions: options.failWithoutAssertions,\n+\tfile: options.file,\n+\tmatch: options.match,\n+\tprojectDir: options.projectDir,\n+\trunOnlyExclusive: options.runOnlyExclusive,\n+\tserial: options.serial,\n+\tsnapshotDir: options.snapshotDir,\n+\tupdateSnapshots: options.updateSnapshots\n+});\n+\n+ipc.peerFailed.then(() => {\n+\trunner.interrupt();\n+});\n+\n+const attributedRejections = new Set();\n+process.on('unhandledRejection', (reason, promise) => {\n+\tif (runner.attributeLeakedError(reason)) {\n+\t\tattributedRejections.add(promise);\n+\t}\n+});\n+\n+runner.on('dependency', dependencyTracking.track);\n+runner.on('stateChange', state => ipc.send(state));\n+\n+runner.on('error', err => {\n+\tipc.send({type: 'internal-error', err: serializeError('Internal runner error', false, err)});\n+\texit(1);\n+});\n+\n+runner.on('finish', () => {\n+\ttry {\n+\t\tconst touchedFiles = runner.saveSnapshotState();\n+\t\tif (touchedFiles) {\n+\t\t\tipc.send({type: 'touched-files', files: touchedFiles});\n+\t\t}\n+\t} catch (err) {\n+\t\tipc.send({type: 'internal-error', err: serializeError('Internal runner error', false, err)});\n+\t\texit(1);\n+\t\treturn;\n+\t}\n+\n+\tnowAndTimers.setImmediate(() => {\n+\t\tcurrentlyUnhandled().filter(rejection => {\n+\t\t\treturn !attributedRejections.has(rejection.promise);\n+\t\t}).forEach(rejection => {\n+\t\t\tipc.send({type: 'unhandled-rejection', err: serializeError('Unhandled rejection', true, rejection.reason)});\n+\t\t});\n+\n+\t\texit(0);\n+\t});\n+});\n+\n+process.on('uncaughtException', err => {\n+\tif (runner.attributeLeakedError(err)) {\n+\t\treturn;\n+\t}\n+\n+\tipc.send({type: 'uncaught-exception', err: serializeError('Uncaught exception', true, err)});\n+\texit(1);\n+});\n+\n+let accessedRunner = false;\n+exports.getRunner = () => {\n+\taccessedRunner = true;\n+\treturn runner;\n+};\n+\n+// Store value in case to prevent required modules from modifying it.\n+const testPath = options.file;\n+\n+// Install before processing options.require, so if helpers are added to the\n+// require configuration the *compiled* helper will be loaded.\n+dependencyTracking.install(testPath);\n+precompilerHook.install();\n+\n+try {\n+\t(options.require || []).forEach(x => {\n+\t\tconst required = require(x);\n+\n+\t\ttry {\n+\t\t\tif (required[Symbol.for('esm\\u200D:package')]) {\n+\t\t\t\trequire = required(module); // eslint-disable-line no-global-assign\n+\t\t\t}\n+\t\t} catch (_) {}\n+\t});\n+\n+\trequire(testPath);\n+\n+\tif (accessedRunner) {\n+\t\t// Unreference the IPC channel if the test file required AVA. This stops it\n+\t\t// from keeping the event loop busy, which means the `beforeExit` event can be\n+\t\t// used to detect when tests stall.\n+\t\tipc.unref();\n+\t} else {\n+\t\tipc.send({type: 'missing-ava-import'});\n+\t\texit(1);\n+\t}\n+} catch (err) {\n+\tipc.send({type: 'uncaught-exception', err: serializeError('Uncaught exception', true, err)});\n+\texit(1);\n+}"
      },
      {
        "sha": "db31fa5539e0a1fbd12bd2f49e3f748fea85db7e",
        "filename": "package-lock.json",
        "status": "modified",
        "additions": 4216,
        "deletions": 3091,
        "changes": 7307,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/package-lock.json",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/package-lock.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/package-lock.json?ref=348a794ff123391389b9a0fed7e362c6aea1722d"
      },
      {
        "sha": "b78cab0d15966d25898c9c7e2ec3e6426a53ad89",
        "filename": "package.json",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/package.json",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/package.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/package.json?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -12,8 +12,7 @@\n \t\"scripts\": {\n \t\t\"lint\": \"xo && (cd test/fixture && xo '**' '!{source-map-initial,syntax-error}.js' '!snapshots/test-sourcemaps/build/**')\",\n \t\t\"test\": \"npm run lint && flow check test/flow-types && tsc --noEmit -p test/ts-types && nyc tap --no-cov --timeout=300 --jobs=4 test/*.js test/reporters/*.js\",\n-\t\t\"test-win\": \"tap --no-cov --reporter=classic --timeout=300 --jobs=4 test/*.js test/reporters/*.js\",\n-\t\t\"visual\": \"node test/visual/run-visual-tests.js\"\n+\t\t\"test-win\": \"tap --no-cov --reporter=classic --timeout=300 --jobs=1 test/*.js test/reporters/*.js\"\n \t},\n \t\"files\": [\n \t\t\"lib\",\n@@ -67,7 +66,6 @@\n \t\t\"@babel/plugin-syntax-async-generators\": \"7.0.0-beta.44\",\n \t\t\"@babel/plugin-syntax-object-rest-spread\": \"7.0.0-beta.44\",\n \t\t\"@concordance/react\": \"^1.0.0\",\n-\t\t\"@ladjs/time-require\": \"^0.1.4\",\n \t\t\"ansi-escapes\": \"^3.1.0\",\n \t\t\"ansi-styles\": \"^3.2.1\",\n \t\t\"arr-flatten\": \"^1.1.0\",\n@@ -82,7 +80,6 @@\n \t\t\"clean-stack\": \"^1.1.1\",\n \t\t\"clean-yaml-object\": \"^0.1.0\",\n \t\t\"cli-cursor\": \"^2.1.0\",\n-\t\t\"cli-spinners\": \"^1.1.0\",\n \t\t\"cli-truncate\": \"^1.1.0\",\n \t\t\"co-with-promise\": \"^4.6.0\",\n \t\t\"code-excerpt\": \"^2.1.1\",\n@@ -92,6 +89,7 @@\n \t\t\"currently-unhandled\": \"^0.4.1\",\n \t\t\"debug\": \"^3.1.0\",\n \t\t\"dot-prop\": \"^4.2.0\",\n+\t\t\"emittery\": \"^0.3.0\",\n \t\t\"empower-core\": \"^0.6.1\",\n \t\t\"equal-length\": \"^1.0.0\",\n \t\t\"figures\": \"^2.0.0\",\n@@ -104,11 +102,10 @@\n \t\t\"is-ci\": \"^1.1.0\",\n \t\t\"is-error\": \"^2.2.1\",\n \t\t\"is-generator-fn\": \"^1.0.0\",\n-\t\t\"is-obj\": \"^1.0.0\",\n \t\t\"is-observable\": \"^1.1.0\",\n \t\t\"is-promise\": \"^2.1.0\",\n-\t\t\"last-line-stream\": \"^1.0.0\",\n \t\t\"lodash.clone\": \"^4.5.0\",\n+\t\t\"lodash.clonedeep\": \"^4.5.0\",\n \t\t\"lodash.clonedeepwith\": \"^4.5.0\",\n \t\t\"lodash.debounce\": \"^4.0.3\",\n \t\t\"lodash.difference\": \"^4.3.0\",\n@@ -121,6 +118,7 @@\n \t\t\"ms\": \"^2.1.1\",\n \t\t\"multimatch\": \"^2.1.0\",\n \t\t\"observable-to-promise\": \"^0.5.0\",\n+\t\t\"ora\": \"^2.0.0\",\n \t\t\"package-hash\": \"^2.0.0\",\n \t\t\"pkg-conf\": \"^2.1.0\",\n \t\t\"plur\": \"^2.0.0\",\n@@ -136,6 +134,7 @@\n \t\t\"supertap\": \"^1.0.0\",\n \t\t\"supports-color\": \"^5.3.0\",\n \t\t\"trim-off-newlines\": \"^1.0.1\",\n+\t\t\"trim-right\": \"^1.0.1\",\n \t\t\"unique-temp-dir\": \"^1.0.0\",\n \t\t\"update-notifier\": \"^2.4.0\"\n \t},\n@@ -150,12 +149,12 @@\n \t\t\"get-stream\": \"^3.0.0\",\n \t\t\"git-branch\": \"^1.0.0\",\n \t\t\"has-ansi\": \"^3.0.0\",\n-\t\t\"inquirer\": \"^5.1.0\",\n \t\t\"lolex\": \"^2.3.2\",\n \t\t\"nyc\": \"^11.6.0\",\n \t\t\"proxyquire\": \"^2.0.1\",\n \t\t\"react\": \"^16.3.0\",\n \t\t\"react-test-renderer\": \"^16.3.0\",\n+\t\t\"replace-string\": \"^1.1.0\",\n \t\t\"signal-exit\": \"^3.0.0\",\n \t\t\"sinon\": \"^4.5.0\",\n \t\t\"source-map-fixtures\": \"^2.1.0\","
      },
      {
        "sha": "8c6ba74376bfe23ca54e9f66382055f2f25bf979",
        "filename": "profile.js",
        "status": "modified",
        "additions": 49,
        "deletions": 51,
        "changes": 100,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/profile.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/profile.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/profile.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,11 +1,11 @@\n 'use strict';\n+require('./lib/worker/load-chalk'); // eslint-disable-line import/no-unassigned-import\n \n // Iron-node does not work with forked processes\n // This cli command will run a single file in the current process.\n // Intended to be used with iron-node for profiling purposes.\n \n const path = require('path');\n-const EventEmitter = require('events');\n const meow = require('meow');\n const Promise = require('bluebird');\n const pkgConf = require('pkg-conf');\n@@ -14,6 +14,8 @@ const arrify = require('arrify');\n const resolveCwd = require('resolve-cwd');\n const babelConfigHelper = require('./lib/babel-config');\n const CachingPrecompiler = require('./lib/caching-precompiler');\n+const RunStatus = require('./lib/run-status');\n+const VerboseReporter = require('./lib/reporters/verbose');\n \n function resolveModules(modules) {\n \treturn arrify(modules).map(name => {\n@@ -96,65 +98,61 @@ babelConfigHelper.build(process.cwd(), cacheDir, babelConfigHelper.validate(conf\n \t\t\trequire: resolveModules(conf.require)\n \t\t};\n \n-\t\tconst events = new EventEmitter();\n-\t\tevents.on('loaded-file', () => {});\n-\n-\t\tlet failCount = 0;\n-\t\tlet uncaughtExceptionCount = 0;\n-\n \t\t// Mock the behavior of a parent process\n+\t\tprocess.connected = true;\n \t\tprocess.channel = {ref() {}, unref() {}};\n-\t\tprocess.send = data => {\n-\t\t\tif (data && data.ava) {\n-\t\t\t\tconst name = data.name.replace(/^ava-/, '');\n-\n-\t\t\t\tif (events.listeners(name).length > 0) {\n-\t\t\t\t\tevents.emit(name, data.data);\n-\t\t\t\t} else {\n-\t\t\t\t\tconsole.log('UNHANDLED AVA EVENT:', name, data.data);\n-\t\t\t\t}\n-\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tconsole.log('NON AVA EVENT:', data);\n-\t\t};\n-\n-\t\tevents.on('test', data => {\n-\t\t\tconsole.log('TEST:', data.title, data.error);\n-\t\t});\n-\n-\t\tevents.on('results', data => {\n-\t\t\tif (console.profileEnd) {\n-\t\t\t\tconsole.profileEnd();\n-\t\t\t}\n-\n-\t\t\tconsole.log('RESULTS:', data.stats);\n \n-\t\t\tfailCount = data.stats.failCount;\n-\t\t\tsetImmediate(() => process.emit('ava-teardown'));\n+\t\tconst reporter = new VerboseReporter({\n+\t\t\treportStream: process.stdout,\n+\t\t\tstdStream: process.stderr,\n+\t\t\twatching: false\n \t\t});\n \n-\t\tevents.on('teardown', () => {\n-\t\t\tif (process.exit) {\n-\t\t\t\tprocess.exit(failCount + uncaughtExceptionCount); // eslint-disable-line unicorn/no-process-exit\n+\t\tconst runStatus = new RunStatus([file]);\n+\t\trunStatus.observeWorker({\n+\t\t\tfile,\n+\t\t\tonStateChange(listener) {\n+\t\t\t\tconst emit = evt => listener(Object.assign(evt, {testFile: file}));\n+\t\t\t\tprocess.send = data => {\n+\t\t\t\t\tif (data && data.ava) {\n+\t\t\t\t\t\tconst evt = data.ava;\n+\t\t\t\t\t\tif (evt.type === 'ping') {\n+\t\t\t\t\t\t\tif (console.profileEnd) {\n+\t\t\t\t\t\t\t\tconsole.profileEnd();\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tif (process.exitCode) {\n+\t\t\t\t\t\t\t\temit({type: 'worker-failed', nonZeroExitCode: process.exitCode});\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\temit({type: 'worker-finished', forcedExit: false});\n+\t\t\t\t\t\t\t\tprocess.exitCode = runStatus.suggestExitCode({matching: false});\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tsetImmediate(() => {\n+\t\t\t\t\t\t\t\treporter.endRun();\n+\t\t\t\t\t\t\t\tprocess.emit('message', {ava: {type: 'pong'}});\n+\t\t\t\t\t\t\t});\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\temit(data.ava);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t};\n \t\t\t}\n+\t\t}, file);\n+\n+\t\treporter.startRun({\n+\t\t\tfailFastEnabled: false,\n+\t\t\tfiles: [file],\n+\t\t\tmatching: false,\n+\t\t\tpreviousFailures: 0,\n+\t\t\tstatus: runStatus\n \t\t});\n \n-\t\tevents.on('stats', () => {\n-\t\t\tsetImmediate(() => {\n-\t\t\t\tprocess.emit('ava-run', {});\n-\t\t\t});\n-\t\t});\n-\n-\t\tevents.on('uncaughtException', data => {\n-\t\t\tuncaughtExceptionCount++;\n-\t\t\tlet stack = data && data.exception && data.exception.stack;\n-\t\t\tstack = stack || data;\n-\t\t\tconsole.log(stack);\n+\t\tprocess.on('beforeExit', () => {\n+\t\t\tprocess.exitCode = process.exitCode || runStatus.suggestExitCode({matching: false});\n \t\t});\n \n-\t\t// `test-worker` will read process.argv[2] for options\n+\t\t// The \"subprocess\" will read process.argv[2] for options\n \t\tprocess.argv[2] = JSON.stringify(opts);\n \t\tprocess.argv.length = 3;\n \n@@ -163,6 +161,6 @@ babelConfigHelper.build(process.cwd(), cacheDir, babelConfigHelper.validate(conf\n \t\t}\n \n \t\tsetImmediate(() => {\n-\t\t\trequire('./lib/test-worker'); // eslint-disable-line import/no-unassigned-import\n+\t\t\trequire('./lib/worker/subprocess'); // eslint-disable-line import/no-unassigned-import\n \t\t});\n \t});"
      },
      {
        "sha": "4a4a537b4eec46170f2a561ebf329c0689b12977",
        "filename": "test/api.js",
        "status": "modified",
        "additions": 301,
        "deletions": 616,
        "changes": 917,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fapi.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fapi.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fapi.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,7 +1,8 @@\n 'use strict';\n+require('../lib/chalk').set();\n+\n const path = require('path');\n const fs = require('fs');\n-const figures = require('figures');\n const del = require('del');\n const test = require('tap').test;\n const Api = require('../api');\n@@ -27,8 +28,8 @@ test('ES2015 support', t => {\n \tconst api = apiCreator();\n \n \treturn api.run([path.join(__dirname, 'fixture/es2015.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 1);\n \t\t});\n });\n \n@@ -39,166 +40,26 @@ test('precompile helpers', t => {\n \t});\n \n \treturn api.run()\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 1);\n \t\t});\n });\n \n test('generators support', t => {\n \tconst api = apiCreator();\n \n \treturn api.run([path.join(__dirname, 'fixture/generators.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 1);\n \t\t});\n });\n \n test('async/await support', t => {\n \tconst api = apiCreator();\n \n \treturn api.run([path.join(__dirname, 'fixture/async-await.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 2);\n-\t\t});\n-});\n-\n-test('test title prefixes — multiple files', t => {\n-\tt.plan(5);\n-\n-\tconst separator = ` ${figures.pointerSmall} `;\n-\tconst files = [\n-\t\tpath.join(__dirname, 'fixture/async-await.js'),\n-\t\tpath.join(__dirname, 'fixture/generators.js'),\n-\t\tpath.join(__dirname, 'fixture/subdir/in-a-subdir.js')\n-\t];\n-\tconst expected = [\n-\t\t['async-await', 'async function'].join(separator),\n-\t\t['async-await', 'arrow async function'].join(separator),\n-\t\t['generators', 'generator function'].join(separator),\n-\t\t['subdir', 'in-a-subdir', 'subdir'].join(separator)\n-\t];\n-\tlet index;\n-\n-\tconst api = apiCreator();\n-\n-\tapi.run(files)\n-\t\t.then(() => {\n-\t\t\t// If all lines were removed from expected output\n-\t\t\t// actual output matches expected output\n-\t\t\tt.is(expected.length, 0);\n-\t\t});\n-\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('test', a => {\n-\t\t\tindex = expected.indexOf(a.title);\n-\n-\t\t\tt.true(index >= 0);\n-\n-\t\t\t// Remove line from expected output\n-\t\t\texpected.splice(index, 1);\n-\t\t});\n-\t});\n-});\n-\n-test('test title prefixes — single file', t => {\n-\tt.plan(2);\n-\n-\tconst separator = ` ${figures.pointerSmall} `;\n-\tconst files = [\n-\t\tpath.join(__dirname, 'fixture/generators.js')\n-\t];\n-\tconst expected = [\n-\t\t['generator function'].join(separator)\n-\t];\n-\tlet index;\n-\n-\tconst api = apiCreator();\n-\n-\tapi.run(files)\n-\t\t.then(() => {\n-\t\t\t// If all lines were removed from expected output\n-\t\t\t// actual output matches expected output\n-\t\t\tt.is(expected.length, 0);\n-\t\t});\n-\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('test', a => {\n-\t\t\tindex = expected.indexOf(a.title);\n-\n-\t\t\tt.true(index >= 0);\n-\n-\t\t\t// Remove line from expected output\n-\t\t\texpected.splice(index, 1);\n-\t\t});\n-\t});\n-});\n-\n-test('test title prefixes — single file (explicit)', t => {\n-\tt.plan(2);\n-\n-\tconst separator = ` ${figures.pointerSmall} `;\n-\tconst files = [\n-\t\tpath.join(__dirname, 'fixture/generators.js')\n-\t];\n-\tconst expected = [\n-\t\t['generators', 'generator function'].join(separator)\n-\t];\n-\tlet index;\n-\n-\tconst api = apiCreator({\n-\t\texplicitTitles: true\n-\t});\n-\n-\tapi.run(files)\n-\t\t.then(() => {\n-\t\t\t// If all lines were removed from expected output\n-\t\t\t// actual output matches expected output\n-\t\t\tt.is(expected.length, 0);\n-\t\t});\n-\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('test', a => {\n-\t\t\tindex = expected.indexOf(a.title);\n-\n-\t\t\tt.true(index >= 0);\n-\n-\t\t\t// Remove line from expected output\n-\t\t\texpected.splice(index, 1);\n-\t\t});\n-\t});\n-});\n-\n-test('display filename prefixes for failed test stack traces', t => {\n-\tconst files = [\n-\t\tpath.join(__dirname, 'fixture/es2015.js'),\n-\t\tpath.join(__dirname, 'fixture/one-pass-one-fail.js')\n-\t];\n-\n-\tconst api = apiCreator();\n-\n-\treturn api.run(files)\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 2);\n-\t\t\tt.is(result.failCount, 1);\n-\t\t\tt.match(result.errors[0].title, /one-pass-one-fail \\S this is a failing test/);\n-\t\t});\n-});\n-\n-// This is a seperate test because we can't ensure the order of the errors (to match them), and this is easier than\n-// sorting.\n-test('display filename prefixes for failed test stack traces in subdirs', t => {\n-\tconst files = [\n-\t\tpath.join(__dirname, 'fixture/es2015.js'),\n-\t\tpath.join(__dirname, 'fixture/subdir/failing-subdir.js')\n-\t];\n-\n-\tconst api = apiCreator();\n-\n-\treturn api.run(files)\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n-\t\t\tt.is(result.failCount, 1);\n-\t\t\tt.match(result.errors[0].title, /subdir \\S failing-subdir \\S subdir fail/);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 2);\n \t\t});\n });\n \n@@ -209,17 +70,24 @@ test('fail-fast mode - single file & serial', t => {\n \n \tconst tests = [];\n \n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('test', test => {\n-\t\t\ttests.push({\n-\t\t\t\tok: !test.error,\n-\t\t\t\ttitle: test.title\n-\t\t\t});\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'test-failed') {\n+\t\t\t\ttests.push({\n+\t\t\t\t\tok: false,\n+\t\t\t\t\ttitle: evt.title\n+\t\t\t\t});\n+\t\t\t} else if (evt.type === 'test-passed') {\n+\t\t\t\ttests.push({\n+\t\t\t\t\tok: true,\n+\t\t\t\t\ttitle: evt.title\n+\t\t\t\t});\n+\t\t\t}\n \t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/fail-fast/single-file/test.js')])\n-\t\t.then(result => {\n+\t\t.then(runStatus => {\n \t\t\tt.ok(api.options.failFast);\n \t\t\tt.strictDeepEqual(tests, [{\n \t\t\t\tok: true,\n@@ -231,8 +99,8 @@ test('fail-fast mode - single file & serial', t => {\n \t\t\t\tok: true,\n \t\t\t\ttitle: 'third pass'\n \t\t\t}]);\n-\t\t\tt.is(result.passCount, 2);\n-\t\t\tt.is(result.failCount, 1);\n+\t\t\tt.is(runStatus.stats.passedTests, 2);\n+\t\t\tt.is(runStatus.stats.failedTests, 1);\n \t\t});\n });\n \n@@ -244,30 +112,41 @@ test('fail-fast mode - multiple files & serial', t => {\n \n \tconst tests = [];\n \n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('test', test => {\n-\t\t\ttests.push({\n-\t\t\t\tok: !test.error,\n-\t\t\t\ttitle: test.title\n-\t\t\t});\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'test-failed') {\n+\t\t\t\ttests.push({\n+\t\t\t\t\tok: false,\n+\t\t\t\t\ttestFile: evt.testFile,\n+\t\t\t\t\ttitle: evt.title\n+\t\t\t\t});\n+\t\t\t} else if (evt.type === 'test-passed') {\n+\t\t\t\ttests.push({\n+\t\t\t\t\tok: true,\n+\t\t\t\t\ttestFile: evt.testFile,\n+\t\t\t\t\ttitle: evt.title\n+\t\t\t\t});\n+\t\t\t}\n \t\t});\n \t});\n \n \treturn api.run([\n \t\tpath.join(__dirname, 'fixture/fail-fast/multiple-files/fails.js'),\n \t\tpath.join(__dirname, 'fixture/fail-fast/multiple-files/passes.js')\n \t])\n-\t\t.then(result => {\n+\t\t.then(runStatus => {\n \t\t\tt.ok(api.options.failFast);\n \t\t\tt.strictDeepEqual(tests, [{\n \t\t\t\tok: true,\n-\t\t\t\ttitle: `fails ${figures.pointerSmall} first pass`\n+\t\t\t\ttestFile: path.join(__dirname, 'fixture/fail-fast/multiple-files/fails.js'),\n+\t\t\t\ttitle: 'first pass'\n \t\t\t}, {\n \t\t\t\tok: false,\n-\t\t\t\ttitle: `fails ${figures.pointerSmall} second fail`\n+\t\t\t\ttestFile: path.join(__dirname, 'fixture/fail-fast/multiple-files/fails.js'),\n+\t\t\t\ttitle: 'second fail'\n \t\t\t}]);\n-\t\t\tt.is(result.passCount, 1);\n-\t\t\tt.is(result.failCount, 1);\n+\t\t\tt.is(runStatus.stats.passedTests, 1);\n+\t\t\tt.is(runStatus.stats.failedTests, 1);\n \t\t});\n });\n \n@@ -279,36 +158,49 @@ test('fail-fast mode - multiple files & interrupt', t => {\n \n \tconst tests = [];\n \n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('test', test => {\n-\t\t\ttests.push({\n-\t\t\t\tok: !test.error,\n-\t\t\t\ttitle: test.title\n-\t\t\t});\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'test-failed') {\n+\t\t\t\ttests.push({\n+\t\t\t\t\tok: false,\n+\t\t\t\t\ttestFile: evt.testFile,\n+\t\t\t\t\ttitle: evt.title\n+\t\t\t\t});\n+\t\t\t} else if (evt.type === 'test-passed') {\n+\t\t\t\ttests.push({\n+\t\t\t\t\tok: true,\n+\t\t\t\t\ttestFile: evt.testFile,\n+\t\t\t\t\ttitle: evt.title\n+\t\t\t\t});\n+\t\t\t}\n \t\t});\n \t});\n \n \treturn api.run([\n \t\tpath.join(__dirname, 'fixture/fail-fast/multiple-files/fails.js'),\n \t\tpath.join(__dirname, 'fixture/fail-fast/multiple-files/passes-slow.js')\n \t])\n-\t\t.then(result => {\n+\t\t.then(runStatus => {\n \t\t\tt.ok(api.options.failFast);\n \t\t\tt.strictDeepEqual(tests, [{\n \t\t\t\tok: true,\n-\t\t\t\ttitle: `fails ${figures.pointerSmall} first pass`\n+\t\t\t\ttestFile: path.join(__dirname, 'fixture/fail-fast/multiple-files/fails.js'),\n+\t\t\t\ttitle: 'first pass'\n \t\t\t}, {\n \t\t\t\tok: false,\n-\t\t\t\ttitle: `fails ${figures.pointerSmall} second fail`\n+\t\t\t\ttestFile: path.join(__dirname, 'fixture/fail-fast/multiple-files/fails.js'),\n+\t\t\t\ttitle: 'second fail'\n \t\t\t}, {\n \t\t\t\tok: true,\n-\t\t\t\ttitle: `fails ${figures.pointerSmall} third pass`\n+\t\t\t\ttestFile: path.join(__dirname, 'fixture/fail-fast/multiple-files/fails.js'),\n+\t\t\t\ttitle: 'third pass'\n \t\t\t}, {\n \t\t\t\tok: true,\n-\t\t\t\ttitle: `passes-slow ${figures.pointerSmall} first pass`\n+\t\t\t\ttestFile: path.join(__dirname, 'fixture/fail-fast/multiple-files/passes-slow.js'),\n+\t\t\t\ttitle: 'first pass'\n \t\t\t}]);\n-\t\t\tt.is(result.passCount, 3);\n-\t\t\tt.is(result.failCount, 1);\n+\t\t\tt.is(runStatus.stats.passedTests, 3);\n+\t\t\tt.is(runStatus.stats.failedTests, 1);\n \t\t});\n });\n \n@@ -319,32 +211,37 @@ test('fail-fast mode - crash & serial', t => {\n \t});\n \n \tconst tests = [];\n-\tconst errors = [];\n-\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('test', test => {\n-\t\t\ttests.push({\n-\t\t\t\tok: !test.error,\n-\t\t\t\ttitle: test.title\n-\t\t\t});\n-\t\t});\n-\t\trunStatus.on('error', err => {\n-\t\t\terrors.push(err);\n+\tconst workerFailures = [];\n+\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'test-failed') {\n+\t\t\t\ttests.push({\n+\t\t\t\t\tok: false,\n+\t\t\t\t\ttitle: evt.title\n+\t\t\t\t});\n+\t\t\t} else if (evt.type === 'test-passed') {\n+\t\t\t\ttests.push({\n+\t\t\t\t\tok: true,\n+\t\t\t\t\ttitle: evt.title\n+\t\t\t\t});\n+\t\t\t} else if (evt.type === 'worker-failed') {\n+\t\t\t\tworkerFailures.push(evt);\n+\t\t\t}\n \t\t});\n \t});\n \n \treturn api.run([\n \t\tpath.join(__dirname, 'fixture/fail-fast/crash/crashes.js'),\n \t\tpath.join(__dirname, 'fixture/fail-fast/crash/passes.js')\n \t])\n-\t\t.then(result => {\n+\t\t.then(runStatus => {\n \t\t\tt.ok(api.options.failFast);\n \t\t\tt.strictDeepEqual(tests, []);\n-\t\t\tt.is(errors.length, 1);\n-\t\t\tt.is(errors[0].name, 'AvaError');\n-\t\t\tt.is(errors[0].message, `${path.join('test', 'fixture', 'fail-fast', 'crash', 'crashes.js')} exited with a non-zero exit code: 1`);\n-\t\t\tt.is(result.passCount, 0);\n-\t\t\tt.is(result.failCount, 0);\n+\t\t\tt.is(workerFailures.length, 1);\n+\t\t\tt.is(workerFailures[0].testFile, path.join(__dirname, 'fixture', 'fail-fast', 'crash', 'crashes.js'));\n+\t\t\tt.is(runStatus.stats.passedTests, 0);\n+\t\t\tt.is(runStatus.stats.failedTests, 0);\n \t\t});\n });\n \n@@ -356,32 +253,37 @@ test('fail-fast mode - timeout & serial', t => {\n \t});\n \n \tconst tests = [];\n-\tconst errors = [];\n-\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('test', test => {\n-\t\t\ttests.push({\n-\t\t\t\tok: !test.error,\n-\t\t\t\ttitle: test.title\n-\t\t\t});\n-\t\t});\n-\t\trunStatus.on('error', err => {\n-\t\t\terrors.push(err);\n+\tconst timeouts = [];\n+\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'test-failed') {\n+\t\t\t\ttests.push({\n+\t\t\t\t\tok: false,\n+\t\t\t\t\ttitle: evt.title\n+\t\t\t\t});\n+\t\t\t} else if (evt.type === 'test-passed') {\n+\t\t\t\ttests.push({\n+\t\t\t\t\tok: true,\n+\t\t\t\t\ttitle: evt.title\n+\t\t\t\t});\n+\t\t\t} else if (evt.type === 'timeout') {\n+\t\t\t\ttimeouts.push(evt);\n+\t\t\t}\n \t\t});\n \t});\n \n \treturn api.run([\n \t\tpath.join(__dirname, 'fixture/fail-fast/timeout/fails.js'),\n \t\tpath.join(__dirname, 'fixture/fail-fast/timeout/passes.js')\n \t])\n-\t\t.then(result => {\n+\t\t.then(runStatus => {\n \t\t\tt.ok(api.options.failFast);\n \t\t\tt.strictDeepEqual(tests, []);\n-\t\t\tt.is(errors.length, 1);\n-\t\t\tt.is(errors[0].name, 'AvaError');\n-\t\t\tt.is(errors[0].message, 'Exited because no new tests completed within the last 100ms of inactivity');\n-\t\t\tt.is(result.passCount, 0);\n-\t\t\tt.is(result.failCount, 0);\n+\t\t\tt.is(timeouts.length, 1);\n+\t\t\tt.is(timeouts[0].period, 100);\n+\t\t\tt.is(runStatus.stats.passedTests, 0);\n+\t\t\tt.is(runStatus.stats.failedTests, 0);\n \t\t});\n });\n \n@@ -390,29 +292,14 @@ test('fail-fast mode - no errors', t => {\n \t\tfailFast: true\n \t});\n \n-\tconst tests = [];\n-\tconst errors = [];\n-\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('test', test => {\n-\t\t\ttests.push({\n-\t\t\t\tok: !test.error,\n-\t\t\t\ttitle: test.title\n-\t\t\t});\n-\t\t});\n-\t\trunStatus.on('error', err => {\n-\t\t\terrors.push(err);\n-\t\t});\n-\t});\n-\n \treturn api.run([\n \t\tpath.join(__dirname, 'fixture/fail-fast/without-error/a.js'),\n \t\tpath.join(__dirname, 'fixture/fail-fast/without-error/b.js')\n \t])\n-\t\t.then(result => {\n+\t\t.then(runStatus => {\n \t\t\tt.ok(api.options.failFast);\n-\t\t\tt.is(result.passCount, 2);\n-\t\t\tt.is(result.failCount, 0);\n+\t\t\tt.is(runStatus.stats.passedTests, 2);\n+\t\t\tt.is(runStatus.stats.failedTests, 0);\n \t\t});\n });\n \n@@ -422,28 +309,19 @@ test('serial execution mode', t => {\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/serial.js')])\n-\t\t.then(result => {\n+\t\t.then(runStatus => {\n \t\t\tt.ok(api.options.serial);\n-\t\t\tt.is(result.passCount, 3);\n-\t\t\tt.is(result.failCount, 0);\n-\t\t});\n-});\n-\n-test('circular references on assertions do not break process.send', t => {\n-\tconst api = apiCreator();\n-\n-\treturn api.run([path.join(__dirname, 'fixture/circular-reference-on-assertion.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.failCount, 1);\n+\t\t\tt.is(runStatus.stats.passedTests, 3);\n+\t\t\tt.is(runStatus.stats.failedTests, 0);\n \t\t});\n });\n \n test('run from package.json folder by default', t => {\n \tconst api = apiCreator();\n \n \treturn api.run([path.join(__dirname, 'fixture/process-cwd-default.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 1);\n \t\t});\n });\n \n@@ -452,54 +330,8 @@ test('control worker\\'s process.cwd() with projectDir option', t => {\n \tconst api = apiCreator({projectDir: path.dirname(fullPath)});\n \n \treturn api.run([fullPath])\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n-\t\t});\n-});\n-\n-test('unhandled promises will throw an error', t => {\n-\tt.plan(3);\n-\n-\tconst api = apiCreator();\n-\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('error', data => {\n-\t\t\tt.is(data.name, 'Error');\n-\t\t\tt.match(data.message, /You can't handle this!/);\n-\t\t});\n-\t});\n-\n-\treturn api.run([path.join(__dirname, 'fixture/loud-rejection.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n-\t\t});\n-});\n-\n-test('uncaught exception will throw an error', t => {\n-\tt.plan(3);\n-\n-\tconst api = apiCreator();\n-\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('error', data => {\n-\t\t\tt.is(data.name, 'Error');\n-\t\t\tt.match(data.message, /Can't catch me!/);\n-\t\t});\n-\t});\n-\n-\treturn api.run([path.join(__dirname, 'fixture/uncaught-exception.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n-\t\t});\n-});\n-\n-test('errors can occur without messages', t => {\n-\tconst api = apiCreator();\n-\n-\treturn api.run([path.join(__dirname, 'fixture/error-without-message.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.failCount, 1);\n-\t\t\tt.is(result.errors.length, 1);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 1);\n \t\t});\n });\n \n@@ -510,17 +342,19 @@ test('stack traces for exceptions are corrected using a source map file', t => {\n \t\tcacheEnabled: true\n \t});\n \n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('error', data => {\n-\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n-\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n-\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-file.js:4.*$/m);\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'uncaught-exception') {\n+\t\t\t\tt.match(evt.err.message, /Thrown by source-map-fixtures/);\n+\t\t\t\tt.match(evt.err.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n+\t\t\t\tt.match(evt.err.stack, /^.*?Immediate\\b.*source-map-file.js:4.*$/m);\n+\t\t\t}\n \t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/source-map-file.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 1);\n \t\t});\n });\n \n@@ -531,17 +365,19 @@ test('stack traces for exceptions are corrected using a source map file in what\n \t\tcacheEnabled: true\n \t});\n \n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('error', data => {\n-\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n-\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n-\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-file-browser-env.js:7.*$/m);\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'uncaught-exception') {\n+\t\t\t\tt.match(evt.err.message, /Thrown by source-map-fixtures/);\n+\t\t\t\tt.match(evt.err.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n+\t\t\t\tt.match(evt.err.stack, /^.*?Immediate\\b.*source-map-file-browser-env.js:7.*$/m);\n+\t\t\t}\n \t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/source-map-file-browser-env.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 1);\n \t\t});\n });\n \n@@ -569,13 +405,21 @@ test('enhanced assertion formatting necessary whitespace and empty strings', t =\n \n \tt.plan(14);\n \tconst api = apiCreator();\n+\tconst errors = [];\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'test-failed') {\n+\t\t\t\terrors.push(evt.err);\n+\t\t\t}\n+\t\t});\n+\t});\n \treturn api.run([path.join(__dirname, 'fixture/enhanced-assertion-formatting.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.errors.length, 3);\n-\t\t\tt.is(result.passCount, 0);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(errors.length, 3);\n+\t\t\tt.is(runStatus.stats.passedTests, 0);\n \n-\t\t\tresult.errors.forEach((error, errorIndex) => {\n-\t\t\t\terror.error.statements.forEach((statement, statementIndex) => {\n+\t\t\terrors.forEach((error, errorIndex) => {\n+\t\t\t\terror.statements.forEach((statement, statementIndex) => {\n \t\t\t\t\tt.match(statement[0], expected[errorIndex][statementIndex]);\n \t\t\t\t});\n \t\t\t});\n@@ -589,17 +433,19 @@ test('stack traces for exceptions are corrected using a source map file (cache o\n \t\tcacheEnabled: false\n \t});\n \n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('error', data => {\n-\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n-\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n-\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-file.js:4.*$/m);\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'uncaught-exception') {\n+\t\t\t\tt.match(evt.err.message, /Thrown by source-map-fixtures/);\n+\t\t\t\tt.match(evt.err.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n+\t\t\t\tt.match(evt.err.stack, /^.*?Immediate\\b.*source-map-file.js:4.*$/m);\n+\t\t\t}\n \t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/source-map-file.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 1);\n \t\t});\n });\n \n@@ -610,17 +456,19 @@ test('stack traces for exceptions are corrected using a source map, taking an in\n \t\tcacheEnabled: true\n \t});\n \n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('error', data => {\n-\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n-\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n-\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-initial-input.js:14.*$/m);\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'uncaught-exception') {\n+\t\t\t\tt.match(evt.err.message, /Thrown by source-map-fixtures/);\n+\t\t\t\tt.match(evt.err.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n+\t\t\t\tt.match(evt.err.stack, /^.*?Immediate\\b.*source-map-initial-input.js:14.*$/m);\n+\t\t\t}\n \t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/source-map-initial.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 1);\n \t\t});\n });\n \n@@ -631,187 +479,87 @@ test('stack traces for exceptions are corrected using a source map, taking an in\n \t\tcacheEnabled: false\n \t});\n \n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('error', data => {\n-\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n-\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n-\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-initial-input.js:14.*$/m);\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'uncaught-exception') {\n+\t\t\t\tt.match(evt.err.message, /Thrown by source-map-fixtures/);\n+\t\t\t\tt.match(evt.err.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n+\t\t\t\tt.match(evt.err.stack, /^.*?Immediate\\b.*source-map-initial-input.js:14.*$/m);\n+\t\t\t}\n \t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/source-map-initial.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 1);\n \t\t});\n });\n \n test('absolute paths', t => {\n \tconst api = apiCreator();\n \n \treturn api.run([path.resolve('test/fixture/es2015.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 1);\n \t\t});\n });\n \n test('symlink to directory containing test files', t => {\n \tconst api = apiCreator();\n \n \treturn api.run([path.join(__dirname, 'fixture/symlink')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 1);\n \t\t});\n });\n \n test('symlink to test file directly', t => {\n \tconst api = apiCreator();\n \n \treturn api.run([path.join(__dirname, 'fixture/symlinkfile.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 1);\n \t\t});\n });\n \n test('search directories recursively for files', t => {\n \tconst api = apiCreator();\n \n \treturn api.run([path.join(__dirname, 'fixture/subdir')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 2);\n-\t\t\tt.is(result.failCount, 1);\n-\t\t});\n-});\n-\n-test('titles of both passing and failing tests and AssertionErrors are returned', t => {\n-\tconst api = apiCreator();\n-\n-\treturn api.run([path.join(__dirname, 'fixture/one-pass-one-fail.js')])\n-\t\t.then(result => {\n-\t\t\tt.match(result.errors[0].title, /this is a failing test/);\n-\t\t\tt.match(result.tests[0].title, /this is a passing test/);\n-\t\t\tt.match(result.errors[0].error.name, /AssertionError/);\n-\t\t});\n-});\n-\n-test('empty test files cause an AvaError to be emitted', t => {\n-\tt.plan(2);\n-\n-\tconst api = apiCreator();\n-\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('error', err => {\n-\t\t\tt.is(err.name, 'AvaError');\n-\t\t\tt.match(err.message, /No tests found.*?import \"ava\"/);\n-\t\t});\n-\t});\n-\n-\treturn api.run([path.join(__dirname, 'fixture/empty.js')]);\n-});\n-\n-test('test file with no tests causes an AvaError to be emitted', t => {\n-\tt.plan(2);\n-\n-\tconst api = apiCreator();\n-\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('error', err => {\n-\t\t\tt.is(err.name, 'AvaError');\n-\t\t\tt.match(err.message, /No tests/);\n-\t\t});\n-\t});\n-\n-\treturn api.run([path.join(__dirname, 'fixture/no-tests.js')]);\n-});\n-\n-test('test file that immediately exits with 0 exit code', t => {\n-\tt.plan(2);\n-\n-\tconst api = apiCreator();\n-\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('error', err => {\n-\t\t\tt.is(err.name, 'AvaError');\n-\t\t\tt.match(err.message, /Test results were not received from/);\n-\t\t});\n-\t});\n-\n-\treturn api.run([path.join(__dirname, 'fixture/immediate-0-exit.js')]);\n-});\n-\n-test('test file that immediately exits with 3 exit code', t => {\n-\tt.plan(3);\n-\n-\tconst api = apiCreator();\n-\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('error', err => {\n-\t\t\tt.is(err.name, 'AvaError');\n-\t\t\tt.is(err.file, path.join('test', 'fixture', 'immediate-3-exit.js'));\n-\t\t\tt.match(err.message, /exited with a non-zero exit code: 3/);\n-\t\t});\n-\t});\n-\n-\treturn api.run([path.join(__dirname, 'fixture/immediate-3-exit.js')]);\n-});\n-\n-test('testing nonexistent files causes an AvaError to be emitted', t => {\n-\tt.plan(2);\n-\n-\tconst api = apiCreator();\n-\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('error', err => {\n-\t\t\tt.is(err.name, 'AvaError');\n-\t\t\tt.match(err.message, /Couldn't find any files to test/);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 2);\n+\t\t\tt.is(runStatus.stats.failedTests, 1);\n \t\t});\n-\t});\n-\n-\treturn api.run([path.join(__dirname, 'fixture/broken.js')]);\n });\n \n test('test file in node_modules is ignored', t => {\n-\tt.plan(2);\n+\tt.plan(1);\n \n \tconst api = apiCreator();\n-\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('error', err => {\n-\t\t\tt.is(err.name, 'AvaError');\n-\t\t\tt.match(err.message, /Couldn't find any files to test/);\n+\treturn api.run([path.join(__dirname, 'fixture/ignored-dirs/node_modules/test.js')])\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.declaredTests, 0);\n \t\t});\n-\t});\n-\n-\treturn api.run([path.join(__dirname, 'fixture/ignored-dirs/node_modules/test.js')]);\n });\n \n test('test file in fixtures is ignored', t => {\n-\tt.plan(2);\n+\tt.plan(1);\n \n \tconst api = apiCreator();\n-\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('error', err => {\n-\t\t\tt.is(err.name, 'AvaError');\n-\t\t\tt.match(err.message, /Couldn't find any files to test/);\n+\treturn api.run([path.join(__dirname, 'fixture/ignored-dirs/fixtures/test.js')])\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.declaredTests, 0);\n \t\t});\n-\t});\n-\n-\treturn api.run([path.join(__dirname, 'fixture/ignored-dirs/fixtures/test.js')]);\n });\n \n test('test file in helpers is ignored', t => {\n-\tt.plan(2);\n+\tt.plan(1);\n \n \tconst api = apiCreator();\n-\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('error', err => {\n-\t\t\tt.is(err.name, 'AvaError');\n-\t\t\tt.match(err.message, /Couldn't find any files to test/);\n+\treturn api.run([path.join(__dirname, 'fixture/ignored-dirs/helpers/test.js')])\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.declaredTests, 0);\n \t\t});\n-\t});\n-\n-\treturn api.run([path.join(__dirname, 'fixture/ignored-dirs/helpers/test.js')]);\n });\n \n test('Node.js-style --require CLI argument', t => {\n@@ -822,8 +570,8 @@ test('Node.js-style --require CLI argument', t => {\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/validate-installed-global.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 1);\n \t\t});\n });\n \n@@ -882,35 +630,26 @@ test('test file with only skipped tests does not create a failure', t => {\n \tconst api = apiCreator();\n \n \treturn api.run([path.join(__dirname, 'fixture/skip-only.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.tests.length, 1);\n-\t\t\tt.true(result.tests[0].skip);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.selectedTests, 1);\n+\t\t\tt.is(runStatus.stats.skippedTests, 1);\n+\t\t\tt.is(runStatus.stats.failedTests, 0);\n \t\t});\n });\n \n test('test file with only skipped tests does not run hooks', t => {\n \tconst api = apiCreator();\n \n \treturn api.run([path.join(__dirname, 'fixture/hooks-skipped.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.tests.length, 1);\n-\t\t\tt.is(result.skipCount, 1);\n-\t\t\tt.is(result.passCount, 0);\n-\t\t\tt.is(result.failCount, 0);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.selectedTests, 1);\n+\t\t\tt.is(runStatus.stats.skippedTests, 1);\n+\t\t\tt.is(runStatus.stats.passedTests, 0);\n+\t\t\tt.is(runStatus.stats.failedTests, 0);\n+\t\t\tt.is(runStatus.stats.failedHooks, 0);\n \t\t});\n });\n \n-test('resets state before running', t => {\n-\tconst api = apiCreator();\n-\n-\treturn api.run([path.resolve('test/fixture/es2015.js')]).then(result => {\n-\t\tt.is(result.passCount, 1);\n-\t\treturn api.run([path.resolve('test/fixture/es2015.js')]);\n-\t}).then(result => {\n-\t\tt.is(result.passCount, 1);\n-\t});\n-});\n-\n test('emits dependencies for test files', t => {\n \tt.plan(8);\n \n@@ -919,10 +658,10 @@ test('emits dependencies for test files', t => {\n \t});\n \n \tconst testFiles = [\n-\t\tpath.normalize('test/fixture/with-dependencies/no-tests.js'),\n-\t\tpath.normalize('test/fixture/with-dependencies/test.js'),\n-\t\tpath.normalize('test/fixture/with-dependencies/test-failure.js'),\n-\t\tpath.normalize('test/fixture/with-dependencies/test-uncaught-exception.js')\n+\t\tpath.resolve('test/fixture/with-dependencies/no-tests.js'),\n+\t\tpath.resolve('test/fixture/with-dependencies/test.js'),\n+\t\tpath.resolve('test/fixture/with-dependencies/test-failure.js'),\n+\t\tpath.resolve('test/fixture/with-dependencies/test-uncaught-exception.js')\n \t];\n \n \tconst sourceFiles = [\n@@ -931,64 +670,32 @@ test('emits dependencies for test files', t => {\n \t\tpath.resolve('test/fixture/with-dependencies/dep-3.custom')\n \t];\n \n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('dependencies', (file, dependencies) => {\n-\t\t\tt.notEqual(testFiles.indexOf(file), -1);\n-\t\t\tt.strictDeepEqual(dependencies.slice(-3), sourceFiles);\n-\t\t});\n-\n-\t\t// The test files are designed to cause errors so ignore them here.\n-\t\trunStatus.on('error', () => {});\n-\t});\n-\n-\tconst result = api.run(['test/fixture/with-dependencies/*test*.js']);\n-\n-\treturn result.catch(() => {});\n-});\n-\n-test('emits stats for test files', t => {\n-\tt.plan(2);\n-\n-\tconst api = apiCreator();\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('stats', stats => {\n-\t\t\tif (stats.file === path.normalize('test/fixture/exclusive.js')) {\n-\t\t\t\tt.is(stats.hasExclusive, true);\n-\t\t\t} else if (stats.file === path.normalize('test/fixture/generators.js')) {\n-\t\t\t\tt.is(stats.hasExclusive, false);\n-\t\t\t} else {\n-\t\t\t\tt.ok(false);\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'dependencies') {\n+\t\t\t\tt.notEqual(testFiles.indexOf(evt.testFile), -1);\n+\t\t\t\tt.strictDeepEqual(evt.dependencies.slice(-3), sourceFiles);\n \t\t\t}\n \t\t});\n \t});\n \n-\treturn api.run([\n-\t\t'test/fixture/exclusive.js',\n-\t\t'test/fixture/generators.js'\n-\t]);\n+\treturn api.run(['test/fixture/with-dependencies/*test*.js']);\n });\n \n test('verify test count', t => {\n-\tt.plan(8);\n+\tt.plan(4);\n \n \tconst api = apiCreator();\n \n-\tapi.on('test-run', runStatus => {\n-\t\tt.is(runStatus.passCount, 0);\n-\t\tt.is(runStatus.failCount, 0);\n-\t\tt.is(runStatus.skipCount, 0);\n-\t\tt.is(runStatus.todoCount, 0);\n-\t});\n-\n \treturn api.run([\n \t\tpath.join(__dirname, 'fixture/test-count.js'),\n \t\tpath.join(__dirname, 'fixture/test-count-2.js'),\n \t\tpath.join(__dirname, 'fixture/test-count-3.js')\n-\t]).then(result => {\n-\t\tt.is(result.passCount, 4, 'pass count');\n-\t\tt.is(result.failCount, 3, 'fail count');\n-\t\tt.is(result.skipCount, 3, 'skip count');\n-\t\tt.is(result.todoCount, 3, 'todo count');\n+\t]).then(runStatus => {\n+\t\tt.is(runStatus.stats.passedTests, 4, 'pass count');\n+\t\tt.is(runStatus.stats.failedTests, 3, 'fail count');\n+\t\tt.is(runStatus.stats.skippedTests, 3, 'skip count');\n+\t\tt.is(runStatus.stats.todoTests, 3, 'todo count');\n \t});\n });\n \n@@ -1005,15 +712,17 @@ test('babel.testOptions with a custom plugin', t => {\n \t\tprojectDir: __dirname\n \t});\n \n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('test', data => {\n-\t\t\tt.is(data.title, 'FOO');\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'test-passed') {\n+\t\t\t\tt.is(evt.title, 'FOO');\n+\t\t\t}\n \t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/babelrc/test.js')])\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 1);\n \t\t}, t.threw);\n });\n \n@@ -1024,15 +733,17 @@ test('babel.testOptions.babelrc effectively defaults to true', t => {\n \t\tprojectDir: path.join(__dirname, 'fixture/babelrc')\n \t});\n \n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('test', data => {\n-\t\t\tt.ok((data.title === 'foo') || (data.title === 'repeated test: foo'));\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'test-passed') {\n+\t\t\t\tt.ok((evt.title === 'foo') || (evt.title === 'repeated test: foo'));\n+\t\t\t}\n \t\t});\n \t});\n \n \treturn api.run()\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 2);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 2);\n \t\t});\n });\n \n@@ -1047,15 +758,17 @@ test('babel.testOptions.babelrc can explicitly be true', t => {\n \t\tprojectDir: path.join(__dirname, 'fixture/babelrc')\n \t});\n \n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('test', data => {\n-\t\t\tt.ok(data.title === 'foo' || data.title === 'repeated test: foo');\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'test-passed') {\n+\t\t\t\tt.ok(evt.title === 'foo' || evt.title === 'repeated test: foo');\n+\t\t\t}\n \t\t});\n \t});\n \n \treturn api.run()\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 2);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 2);\n \t\t});\n });\n \n@@ -1070,15 +783,17 @@ test('babel.testOptions.babelrc can explicitly be false', t => {\n \t\tprojectDir: path.join(__dirname, 'fixture/babelrc')\n \t});\n \n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('test', data => {\n-\t\t\tt.is(data.title, 'foo');\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'test-passed') {\n+\t\t\t\tt.is(evt.title, 'foo');\n+\t\t\t}\n \t\t});\n \t});\n \n \treturn api.run()\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 1);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 1);\n \t\t});\n });\n \n@@ -1096,15 +811,17 @@ test('babelConfig.testOptions merges plugins with .babelrc', t => {\n \t\tprojectDir: path.join(__dirname, 'fixture/babelrc')\n \t});\n \n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('test', data => {\n-\t\t\tt.ok(data.title === 'FOO' || data.title === 'repeated test: foo');\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'test-passed') {\n+\t\t\t\tt.ok(evt.title === 'FOO' || evt.title === 'repeated test: foo');\n+\t\t\t}\n \t\t});\n \t});\n \n \treturn api.run()\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 2);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 2);\n \t\t});\n });\n \n@@ -1122,88 +839,45 @@ test('babelConfig.testOptions with extends still merges plugins with .babelrc',\n \t\tprojectDir: path.join(__dirname, 'fixture/babelrc')\n \t});\n \n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('test', data => {\n-\t\t\tt.ok(data.title === 'BAR' || data.title === 'repeated test: bar');\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'test-passed') {\n+\t\t\t\tt.ok(evt.title === 'BAR' || evt.title === 'repeated test: bar');\n+\t\t\t}\n \t\t});\n \t});\n \n \treturn api.run()\n-\t\t.then(result => {\n-\t\t\tt.is(result.passCount, 2);\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 2);\n \t\t});\n });\n \n-test('using --match with no matching tests causes an AvaError to be emitted', t => {\n-\tt.plan(2);\n-\n-\tconst api = apiCreator({\n-\t\tmatch: ['can\\'t match this']\n-\t});\n-\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('test', data => {\n-\t\t\tt.fail(`Unexpected test run: ${data.title}`);\n-\t\t});\n-\t\trunStatus.on('error', err => {\n-\t\t\tt.is(err.name, 'AvaError');\n-\t\t\tt.match(err.message, /Couldn't find any matching tests/);\n-\t\t});\n-\t});\n-\n-\treturn api.run([\n-\t\tpath.join(__dirname, 'fixture/match-no-match.js'),\n-\t\tpath.join(__dirname, 'fixture/match-no-match-2.js'),\n-\t\tpath.join(__dirname, 'fixture/test-count.js')\n-\t]);\n-});\n-\n test('using --match with matching tests will only report those passing tests', t => {\n-\tt.plan(2);\n+\tt.plan(3);\n \n \tconst api = apiCreator({\n \t\tmatch: ['this test will match']\n \t});\n \n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('test', data => {\n-\t\t\tt.match(data.title, /^match-no-match-2 .+ this test will match$/);\n-\t\t});\n-\t\trunStatus.on('error', err => {\n-\t\t\tt.fail(`Unexpected failure: ${err}`);\n+\tapi.on('run', plan => {\n+\t\tplan.status.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'selected-test') {\n+\t\t\t\tt.match(evt.testFile, /match-no-match-2/);\n+\t\t\t\tt.is(evt.title, 'this test will match');\n+\t\t\t}\n \t\t});\n \t});\n \n \treturn api.run([\n \t\tpath.join(__dirname, 'fixture/match-no-match.js'),\n \t\tpath.join(__dirname, 'fixture/match-no-match-2.js'),\n \t\tpath.join(__dirname, 'fixture/test-count.js')\n-\t]).then(result => {\n-\t\tt.is(result.passCount, 1);\n-\t}).catch(() => {\n-\t\tt.fail();\n+\t]).then(runStatus => {\n+\t\tt.is(runStatus.stats.passedTests, 1);\n \t});\n });\n \n-test('errors thrown when running files are emitted', t => {\n-\tt.plan(3);\n-\n-\tconst api = apiCreator();\n-\n-\tapi.on('test-run', runStatus => {\n-\t\trunStatus.on('error', err => {\n-\t\t\tt.is(err.name, 'SyntaxError');\n-\t\t\tt.is(err.file, path.join('test', 'fixture', 'syntax-error.js'));\n-\t\t\tt.match(err.message, /Unexpected token/);\n-\t\t});\n-\t});\n-\n-\treturn api.run([\n-\t\tpath.join(__dirname, 'fixture/es2015.js'),\n-\t\tpath.join(__dirname, 'fixture/syntax-error.js')\n-\t]);\n-});\n-\n function generatePassDebugTests(execArgv, expectedInspectIndex) {\n \ttest(`pass ${execArgv.join(' ')} to fork`, t => {\n \t\tconst api = apiCreator({testOnlyExecArgv: execArgv});\n@@ -1223,8 +897,8 @@ function generatePassDebugIntegrationTests(execArgv) {\n \ttest(`pass ${execArgv.join(' ')} to fork`, t => {\n \t\tconst api = apiCreator({testOnlyExecArgv: execArgv});\n \t\treturn api.run([path.join(__dirname, 'fixture/debug-arg.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n+\t\t\t.then(runStatus => {\n+\t\t\t\tt.is(runStatus.stats.passedTests, 1);\n \t\t\t});\n \t});\n }\n@@ -1233,8 +907,8 @@ function generatePassInspectIntegrationTests(execArgv) {\n \ttest(`pass ${execArgv.join(' ')} to fork`, t => {\n \t\tconst api = apiCreator({testOnlyExecArgv: execArgv});\n \t\treturn api.run([path.join(__dirname, 'fixture/inspect-arg.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n+\t\t\t.then(runStatus => {\n+\t\t\t\tt.is(runStatus.stats.passedTests, 1);\n \t\t\t});\n \t});\n }\n@@ -1260,3 +934,14 @@ if (Number(process.version.split('.')[0].slice(1)) < 8) {\n \tgeneratePassInspectIntegrationTests(['--inspect=9229']);\n \tgeneratePassInspectIntegrationTests(['--inspect']);\n }\n+\n+test('`esm` package support', t => {\n+\tconst api = apiCreator({\n+\t\trequire: [require.resolve('esm')]\n+\t});\n+\n+\treturn api.run([path.join(__dirname, 'fixture/esm-pkg/test.js')])\n+\t\t.then(runStatus => {\n+\t\t\tt.is(runStatus.stats.passedTests, 1);\n+\t\t});\n+});"
      },
      {
        "sha": "4f86e93f5d75ba2af455ead75730dad1c0a286e5",
        "filename": "test/assert.js",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fassert.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fassert.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fassert.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,5 +1,6 @@\n 'use strict';\n-require('../lib/worker-options').set({color: false});\n+require('../lib/chalk').set();\n+require('../lib/worker/options').set({color: false});\n \n const path = require('path');\n const stripAnsi = require('strip-ansi');"
      },
      {
        "sha": "f74160258cd0fe33bc5c1ce3cad74851916e50f6",
        "filename": "test/babel-config.js",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fbabel-config.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fbabel-config.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fbabel-config.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,4 +1,6 @@\n 'use strict';\n+require('../lib/chalk').set();\n+\n const assert = require('assert');\n const fs = require('fs');\n const path = require('path');"
      },
      {
        "sha": "90c852e5271bd468c30bf783da453a71637c8421",
        "filename": "test/beautify-stack.js",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fbeautify-stack.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fbeautify-stack.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fbeautify-stack.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,5 +1,6 @@\n 'use strict';\n-require('../lib/worker-options').set({});\n+require('../lib/chalk').set();\n+require('../lib/worker/options').set({});\n \n const proxyquire = require('proxyquire').noPreserveCache();\n const test = require('tap').test;"
      },
      {
        "sha": "eb29316f1c50755d44413c4bbe47d5536a4b7dda",
        "filename": "test/cli.js",
        "status": "modified",
        "additions": 125,
        "deletions": 138,
        "changes": 263,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fcli.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fcli.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fcli.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -34,7 +34,8 @@ function execCli(args, opts, cb) {\n \tconst processPromise = new Promise(resolve => {\n \t\tchild = childProcess.spawn(process.execPath, [cliPath].concat(args), {\n \t\t\tcwd: dirname,\n-\t\t\tenv,\n+\t\t\tenv: Object.assign({CI: '1'}, env), // Force CI to ensure the correct reporter is selected\n+\t\t\t// env,\n \t\t\tstdio: [null, 'pipe', 'pipe']\n \t\t});\n \n@@ -84,160 +85,160 @@ test('enabling long stack traces will provide detailed debug information', t =>\n });\n \n test('`AssertionError` should capture infinity stack trace', t => {\n-\texecCli('fixture/infinity-stack-trace.js', (err, stdout, stderr) => {\n+\texecCli('fixture/infinity-stack-trace.js', (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stderr, /c \\(.+?infinity-stack-trace\\.js:6:20\\)/);\n-\t\tt.match(stderr, /b \\(.+?infinity-stack-trace\\.js:7:18\\)/);\n-\t\tt.match(stderr, /a \\(.+?infinity-stack-trace\\.js:8:18\\)/);\n+\t\tt.match(stdout, /c \\(.+?infinity-stack-trace\\.js:6:20\\)/);\n+\t\tt.match(stdout, /b \\(.+?infinity-stack-trace\\.js:7:18\\)/);\n+\t\tt.match(stdout, /a \\(.+?infinity-stack-trace\\.js:8:18\\)/);\n \t\tt.end();\n \t});\n });\n \n test('timeout', t => {\n-\texecCli(['fixture/long-running.js', '-T', '1s'], (err, stdout, stderr) => {\n+\texecCli(['fixture/long-running.js', '-T', '1s'], (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stderr, /Exited because no new tests completed within the last 1000ms of inactivity/);\n+\t\tt.match(stdout, /Exited because no new tests completed within the last 1000ms of inactivity/);\n \t\tt.end();\n \t});\n });\n \n test('include anonymous functions in error reports', t => {\n-\texecCli('fixture/error-in-anonymous-function.js', (err, stdout, stderr) => {\n+\texecCli('fixture/error-in-anonymous-function.js', (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stderr, /test\\/fixture\\/error-in-anonymous-function\\.js:4:8/);\n+\t\tt.match(stdout, /test\\/fixture\\/error-in-anonymous-function\\.js:4:8/);\n \t\tt.end();\n \t});\n });\n \n test('improper use of t.throws will be reported to the console', t => {\n-\texecCli('fixture/improper-t-throws/throws.js', (err, stdout, stderr) => {\n+\texecCli('fixture/improper-t-throws/throws.js', (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stderr, /Improper usage of `t\\.throws\\(\\)` detected/);\n-\t\tt.match(stderr, /should be detected/);\n-\t\tt.match(stderr, /Try wrapping the first argument/);\n+\t\tt.match(stdout, /Improper usage of `t\\.throws\\(\\)` detected/);\n+\t\tt.match(stdout, /should be detected/);\n+\t\tt.match(stdout, /Try wrapping the first argument/);\n \t\tt.end();\n \t});\n });\n \n test('improper use of t.throws from within a Promise will be reported to the console', t => {\n-\texecCli('fixture/improper-t-throws/promise.js', (err, stdout, stderr) => {\n+\texecCli('fixture/improper-t-throws/promise.js', (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stderr, /Improper usage of `t\\.throws\\(\\)` detected/);\n-\t\tt.match(stderr, /should be detected/);\n-\t\tt.match(stderr, /Try wrapping the first argument/);\n+\t\tt.match(stdout, /Improper usage of `t\\.throws\\(\\)` detected/);\n+\t\tt.match(stdout, /should be detected/);\n+\t\tt.match(stdout, /Try wrapping the first argument/);\n \t\tt.end();\n \t});\n });\n \n test('improper use of t.throws from within a pending promise, even if caught and rethrown immediately, will be reported to the console', t => {\n-\texecCli('fixture/improper-t-throws/leaked-from-promise.js', (err, stdout, stderr) => {\n+\texecCli('fixture/improper-t-throws/leaked-from-promise.js', (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stderr, /Improper usage of `t\\.throws\\(\\)` detected/);\n-\t\tt.match(stderr, /should be detected/);\n-\t\tt.match(stderr, /Try wrapping the first argument/);\n+\t\tt.match(stdout, /Improper usage of `t\\.throws\\(\\)` detected/);\n+\t\tt.match(stdout, /should be detected/);\n+\t\tt.match(stdout, /Try wrapping the first argument/);\n \t\tt.end();\n \t});\n });\n \n test('improper use of t.throws from within an async callback will be reported to the console', t => {\n-\texecCli('fixture/improper-t-throws/async-callback.js', (err, stdout, stderr) => {\n+\texecCli('fixture/improper-t-throws/async-callback.js', (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stderr, /Improper usage of `t\\.throws\\(\\)` detected/);\n-\t\tt.match(stderr, /should be detected/);\n-\t\tt.match(stderr, /Try wrapping the first argument/);\n+\t\tt.match(stdout, /Improper usage of `t\\.throws\\(\\)` detected/);\n+\t\tt.match(stdout, /should be detected/);\n+\t\tt.match(stdout, /Try wrapping the first argument/);\n \t\tt.end();\n \t});\n });\n \n test('improper use of t.throws, swallowed as an unhandled rejection, will be reported to the console', t => {\n-\texecCli('fixture/improper-t-throws/unhandled-rejection.js', (err, stdout, stderr) => {\n+\texecCli('fixture/improper-t-throws/unhandled-rejection.js', (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stderr, /Improper usage of `t\\.throws\\(\\)` detected/);\n-\t\tt.match(stderr, /should be detected/);\n-\t\tt.match(stderr, /Try wrapping the first argument/);\n+\t\tt.match(stdout, /Improper usage of `t\\.throws\\(\\)` detected/);\n+\t\tt.match(stdout, /should be detected/);\n+\t\tt.match(stdout, /Try wrapping the first argument/);\n \t\tt.end();\n \t});\n });\n \n test('improper use of t.throws, even if caught, will be reported to the console', t => {\n-\texecCli('fixture/improper-t-throws/caught.js', (err, stdout, stderr) => {\n+\texecCli('fixture/improper-t-throws/caught.js', (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stderr, /Improper usage of `t\\.throws\\(\\)` detected/);\n-\t\tt.notMatch(stderr, /should be detected/);\n-\t\tt.match(stderr, /Try wrapping the first argument/);\n+\t\tt.match(stdout, /Improper usage of `t\\.throws\\(\\)` detected/);\n+\t\tt.notMatch(stdout, /should be detected/);\n+\t\tt.match(stdout, /Try wrapping the first argument/);\n \t\tt.end();\n \t});\n });\n \n test('improper use of t.throws, even if caught and then rethrown immediately, will be reported to the console', t => {\n-\texecCli('fixture/improper-t-throws/caught-and-leaked.js', (err, stdout, stderr) => {\n+\texecCli('fixture/improper-t-throws/caught-and-leaked.js', (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stderr, /Improper usage of `t\\.throws\\(\\)` detected/);\n-\t\tt.match(stderr, /should be detected/);\n-\t\tt.match(stderr, /Try wrapping the first argument/);\n+\t\tt.match(stdout, /Improper usage of `t\\.throws\\(\\)` detected/);\n+\t\tt.match(stdout, /should be detected/);\n+\t\tt.match(stdout, /Try wrapping the first argument/);\n \t\tt.end();\n \t});\n });\n \n test('improper use of t.throws, even if caught and then later rethrown, will be reported to the console', t => {\n-\texecCli('fixture/improper-t-throws/caught-and-leaked-slowly.js', (err, stdout, stderr) => {\n+\texecCli('fixture/improper-t-throws/caught-and-leaked-slowly.js', (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stderr, /Improper usage of `t\\.throws\\(\\)` detected/);\n-\t\tt.match(stderr, /should be detected/);\n-\t\tt.match(stderr, /Try wrapping the first argument/);\n+\t\tt.match(stdout, /Improper usage of `t\\.throws\\(\\)` detected/);\n+\t\tt.match(stdout, /should be detected/);\n+\t\tt.match(stdout, /Try wrapping the first argument/);\n \t\tt.end();\n \t});\n });\n \n test('improper use of t.throws, even if caught and then rethrown too slowly, will be reported to the console', t => {\n-\texecCli('fixture/improper-t-throws/caught-and-leaked-too-slowly.js', (err, stdout, stderr) => {\n+\texecCli('fixture/improper-t-throws/caught-and-leaked-too-slowly.js', (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stderr, /Improper usage of `t\\.throws\\(\\)` detected/);\n-\t\tt.notMatch(stderr, /should be detected/);\n-\t\tt.match(stderr, /Try wrapping the first argument/);\n+\t\tt.match(stdout, /Improper usage of `t\\.throws\\(\\)` detected/);\n+\t\tt.notMatch(stdout, /should be detected/);\n+\t\tt.match(stdout, /Try wrapping the first argument/);\n \t\tt.end();\n \t});\n });\n \n test('precompiler require hook does not apply to source files', t => {\n \tt.plan(3);\n \n-\texecCli('fixture/babel-hook.js', (err, stdout, stderr) => {\n+\texecCli('fixture/babel-hook.js', (err, stdout) => {\n \t\tt.ok(err);\n \t\tt.is(err.code, 1);\n-\t\tt.match(stderr, /Unexpected (token|reserved word)/);\n+\t\tt.match(stdout, /Unexpected (token|reserved word)/);\n \t\tt.end();\n \t});\n });\n \n test('pkg-conf(resolve-dir): works as expected when run from the package.json directory', t => {\n-\texecCli(['--verbose'], {dirname: 'fixture/pkg-conf/resolve-dir'}, (err, stdout, stderr) => {\n+\texecCli(['--verbose'], {dirname: 'fixture/pkg-conf/resolve-dir'}, (err, stdout) => {\n \t\tt.ifError(err);\n-\t\tt.match(stderr, /dir-a-base-1/);\n-\t\tt.match(stderr, /dir-a-base-2/);\n-\t\tt.notMatch(stderr, /dir-a-wrapper/);\n+\t\tt.match(stdout, /dir-a-base-1/);\n+\t\tt.match(stdout, /dir-a-base-2/);\n+\t\tt.notMatch(stdout, /dir-a-wrapper/);\n \t\tt.notMatch(stdout, /dir-a-wrapper/);\n \t\tt.end();\n \t});\n });\n \n test('pkg-conf(resolve-dir): resolves tests from the package.json dir if none are specified on cli', t => {\n-\texecCli(['--verbose'], {dirname: 'fixture/pkg-conf/resolve-dir/dir-a-wrapper'}, (err, stdout, stderr) => {\n+\texecCli(['--verbose'], {dirname: 'fixture/pkg-conf/resolve-dir/dir-a-wrapper'}, (err, stdout) => {\n \t\tt.ifError(err);\n-\t\tt.match(stderr, /dir-a-base-1/);\n-\t\tt.match(stderr, /dir-a-base-2/);\n-\t\tt.notMatch(stderr, /dir-a-wrapper/);\n+\t\tt.match(stdout, /dir-a-base-1/);\n+\t\tt.match(stdout, /dir-a-base-2/);\n+\t\tt.notMatch(stdout, /dir-a-wrapper/);\n \t\tt.notMatch(stdout, /dir-a-wrapper/);\n \t\tt.end();\n \t});\n });\n \n test('pkg-conf(resolve-dir): resolves tests process.cwd() if globs are passed on the command line', t => {\n-\texecCli(['--verbose', 'dir-a/*.js'], {dirname: 'fixture/pkg-conf/resolve-dir/dir-a-wrapper'}, (err, stdout, stderr) => {\n+\texecCli(['--verbose', 'dir-a/*.js'], {dirname: 'fixture/pkg-conf/resolve-dir/dir-a-wrapper'}, (err, stdout) => {\n \t\tt.ifError(err);\n-\t\tt.match(stderr, /dir-a-wrapper-3/);\n-\t\tt.match(stderr, /dir-a-wrapper-4/);\n-\t\tt.notMatch(stderr, /dir-a-base/);\n+\t\tt.match(stdout, /dir-a-wrapper-3/);\n+\t\tt.match(stdout, /dir-a-wrapper-4/);\n+\t\tt.notMatch(stdout, /dir-a-base/);\n \t\tt.notMatch(stdout, /dir-a-base/);\n \t\tt.end();\n \t});\n@@ -246,15 +247,15 @@ test('pkg-conf(resolve-dir): resolves tests process.cwd() if globs are passed on\n test('watcher reruns test files when they changed', t => {\n \tlet killed = false;\n \n-\tconst child = execCli(['--verbose', '--watch', 'test.js'], {dirname: 'fixture/watcher'}, err => {\n+\tconst child = execCli(['--verbose', '--watch', 'test.js'], {dirname: 'fixture/watcher', env: {CI: ''}}, err => {\n \t\tt.ok(killed);\n \t\tt.ifError(err);\n \t\tt.end();\n \t});\n \n \tlet buffer = '';\n \tlet passedFirst = false;\n-\tchild.stderr.on('data', str => {\n+\tchild.stdout.on('data', str => {\n \t\tbuffer += str;\n \t\tif (/1 test passed/.test(buffer)) {\n \t\t\tif (!passedFirst) {\n@@ -272,15 +273,15 @@ test('watcher reruns test files when they changed', t => {\n test('watcher reruns test files when source dependencies change', t => {\n \tlet killed = false;\n \n-\tconst child = execCli(['--verbose', '--watch', 'test-*.js'], {dirname: 'fixture/watcher/with-dependencies'}, err => {\n+\tconst child = execCli(['--verbose', '--watch', 'test-*.js'], {dirname: 'fixture/watcher/with-dependencies', env: {CI: ''}}, err => {\n \t\tt.ok(killed);\n \t\tt.ifError(err);\n \t\tt.end();\n \t});\n \n \tlet buffer = '';\n \tlet passedFirst = false;\n-\tchild.stderr.on('data', str => {\n+\tchild.stdout.on('data', str => {\n \t\tbuffer += str;\n \t\tif (/2 tests passed/.test(buffer) && !passedFirst) {\n \t\t\ttouch.sync(path.join(__dirname, 'fixture/watcher/with-dependencies/source.js'));\n@@ -296,15 +297,15 @@ test('watcher reruns test files when source dependencies change', t => {\n test('watcher does not rerun test files when they write snapshot files', t => {\n \tlet killed = false;\n \n-\tconst child = execCli(['--verbose', '--watch', '--update-snapshots', 'test.js'], {dirname: 'fixture/snapshots'}, err => {\n+\tconst child = execCli(['--verbose', '--watch', '--update-snapshots', 'test.js'], {dirname: 'fixture/snapshots', env: {CI: ''}}, err => {\n \t\tt.ok(killed);\n \t\tt.ifError(err);\n \t\tt.end();\n \t});\n \n \tlet buffer = '';\n \tlet passedFirst = false;\n-\tchild.stderr.on('data', str => {\n+\tchild.stdout.on('data', str => {\n \t\tbuffer += str;\n \t\tif (/2 tests passed/.test(buffer) && !passedFirst) {\n \t\t\tbuffer = '';\n@@ -322,15 +323,15 @@ test('watcher does not rerun test files when they write snapshot files', t => {\n test('watcher reruns test files when snapshot dependencies change', t => {\n \tlet killed = false;\n \n-\tconst child = execCli(['--verbose', '--watch', '--update-snapshots', 'test.js'], {dirname: 'fixture/snapshots'}, err => {\n+\tconst child = execCli(['--verbose', '--watch', '--update-snapshots', 'test.js'], {dirname: 'fixture/snapshots', env: {CI: ''}}, err => {\n \t\tt.ok(killed);\n \t\tt.ifError(err);\n \t\tt.end();\n \t});\n \n \tlet buffer = '';\n \tlet passedFirst = false;\n-\tchild.stderr.on('data', str => {\n+\tchild.stdout.on('data', str => {\n \t\tbuffer += str;\n \t\tif (/2 tests passed/.test(buffer)) {\n \t\t\tbuffer = '';\n@@ -350,7 +351,7 @@ test('watcher reruns test files when snapshot dependencies change', t => {\n test('`\"tap\": true` config is ignored when --watch is given', t => {\n \tlet killed = false;\n \n-\tconst child = execCli(['--watch', '--verbose', 'test.js'], {dirname: 'fixture/watcher/tap-in-conf'}, () => {\n+\tconst child = execCli(['--watch', '--verbose', 'test.js'], {dirname: 'fixture/watcher/tap-in-conf', env: {CI: ''}}, () => {\n \t\tt.ok(killed);\n \t\tt.end();\n \t});\n@@ -371,7 +372,7 @@ test('`\"tap\": true` config is ignored when --watch is given', t => {\n ['--watch', '-w'].forEach(watchFlag => {\n \t['--tap', '-t'].forEach(tapFlag => {\n \t\ttest(`bails when ${tapFlag} reporter is used while ${watchFlag} is given`, t => {\n-\t\t\texecCli([tapFlag, watchFlag, 'test.js'], {dirname: 'fixture/watcher'}, (err, stdout, stderr) => {\n+\t\t\texecCli([tapFlag, watchFlag, 'test.js'], {dirname: 'fixture/watcher', env: {CI: ''}}, (err, stdout, stderr) => {\n \t\t\t\tt.is(err.code, 1);\n \t\t\t\tt.match(stderr, 'The TAP reporter is not available when using watch mode.');\n \t\t\t\tt.end();\n@@ -465,9 +466,9 @@ test('handles NODE_PATH', t => {\n });\n \n test('works when no files are found', t => {\n-\texecCli('!*', (err, stdout, stderr) => {\n+\texecCli('!*', (err, stdout) => {\n \t\tt.is(err.code, 1);\n-\t\tt.match(stderr, 'Couldn\\'t find any files to test');\n+\t\tt.match(stdout, 'Couldn\\'t find any files to test');\n \t\tt.end();\n \t});\n });\n@@ -501,7 +502,7 @@ test('use current working directory if `package.json` is not found', () => {\n \n \tfs.writeFileSync(testFilePath, `import test from ${JSON.stringify(avaPath)};\\ntest('test', t => { t.pass(); });`);\n \n-\treturn execa(process.execPath, [cliPath], {cwd});\n+\treturn execa(process.execPath, [cliPath], {cwd, env: {CI: '1'}});\n });\n \n test('workers ensure test files load the same version of ava', t => {\n@@ -522,20 +523,6 @@ test('workers ensure test files load the same version of ava', t => {\n \t});\n });\n \n-test('worker errors are treated as uncaught exceptions', t => {\n-\texecCli(['--no-color', '--verbose', 'test.js'], {dirname: 'fixture/trigger-worker-exception'}, (_, __, stderr) => {\n-\t\tt.match(stderr, /Forced error/);\n-\t\tt.end();\n-\t});\n-});\n-\n-test('uncaught exceptions are raised for worker errors even if the error cannot be serialized', t => {\n-\texecCli(['--no-color', '--verbose', 'test-fallback.js'], {dirname: 'fixture/trigger-worker-exception'}, (_, __, stderr) => {\n-\t\tt.match(stderr, /Failed to serialize uncaught exception/);\n-\t\tt.end();\n-\t});\n-});\n-\n test('tests without assertions do not fail if failWithoutAssertions option is set to false', t => {\n \texecCli([], {dirname: 'fixture/pkg-conf/fail-without-assertions'}, err => {\n \t\tt.ifError(err);\n@@ -544,22 +531,22 @@ test('tests without assertions do not fail if failWithoutAssertions option is se\n });\n \n test('callback tests fail if event loop empties before they\\'re ended', t => {\n-\texecCli('callback.js', {dirname: 'fixture/stalled-tests'}, (_, __, stderr) => {\n-\t\tt.match(stderr, /`t\\.end\\(\\)` was never called/);\n+\texecCli('callback.js', {dirname: 'fixture/stalled-tests'}, (_, stdout) => {\n+\t\tt.match(stdout, /`t\\.end\\(\\)` was never called/);\n \t\tt.end();\n \t});\n });\n \n test('observable tests fail if event loop empties before they\\'re resolved', t => {\n-\texecCli('observable.js', {dirname: 'fixture/stalled-tests'}, (_, __, stderr) => {\n-\t\tt.match(stderr, /Observable returned by test never completed/);\n+\texecCli('observable.js', {dirname: 'fixture/stalled-tests'}, (_, stdout) => {\n+\t\tt.match(stdout, /Observable returned by test never completed/);\n \t\tt.end();\n \t});\n });\n \n test('promise tests fail if event loop empties before they\\'re resolved', t => {\n-\texecCli('promise.js', {dirname: 'fixture/stalled-tests'}, (_, __, stderr) => {\n-\t\tt.match(stderr, /Promise returned by test never resolved/);\n+\texecCli('promise.js', {dirname: 'fixture/stalled-tests'}, (_, stdout) => {\n+\t\tt.match(stdout, /Promise returned by test never resolved/);\n \t\tt.end();\n \t});\n });\n@@ -608,17 +595,17 @@ test('one', t => {\n })`;\n \tfs.writeFileSync(path.join(cwd, 'test.js'), initial);\n \n-\tconst run = () => execa(process.execPath, [cliPath, '--verbose', '--no-color'], {cwd, reject: false});\n+\tconst run = () => execa(process.execPath, [cliPath, '--verbose', '--no-color'], {cwd, env: {CI: '1'}, reject: false});\n \treturn run().then(result => {\n-\t\tt.match(result.stderr, /1 test passed/);\n+\t\tt.match(result.stdout, /1 test passed/);\n \n \t\tfs.writeFileSync(path.join(cwd, 'test.js'), `${initial}\n test('two', t => {\n \tt.snapshot({two: true})\n })`);\n \t\treturn run();\n \t}).then(result => {\n-\t\tt.match(result.stderr, /2 tests passed/);\n+\t\tt.match(result.stdout, /2 tests passed/);\n \n \t\tfs.writeFileSync(path.join(cwd, 'test.js'), `${initial}\n test('two', t => {\n@@ -627,20 +614,20 @@ test('two', t => {\n \n \t\treturn run();\n \t}).then(result => {\n-\t\tt.match(result.stderr, /1 test failed/);\n+\t\tt.match(result.stdout, /1 test failed/);\n \t});\n });\n \n test('outdated snapshot version is reported to the console', t => {\n \tconst snapPath = path.join(__dirname, 'fixture', 'snapshots', 'test.js.snap');\n \tfs.writeFileSync(snapPath, Buffer.from([0x0A, 0x00, 0x00]));\n \n-\texecCli(['test.js'], {dirname: 'fixture/snapshots'}, (err, stdout, stderr) => {\n+\texecCli(['test.js'], {dirname: 'fixture/snapshots'}, (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stderr, /The snapshot file is v0, but only v1 is supported\\./);\n-\t\tt.match(stderr, /File path:/);\n-\t\tt.match(stderr, snapPath);\n-\t\tt.match(stderr, /Please run AVA again with the .*--update-snapshots.* flag to upgrade\\./);\n+\t\tt.match(stdout, /The snapshot file is v0, but only v1 is supported\\./);\n+\t\tt.match(stdout, /File path:/);\n+\t\tt.match(stdout, snapPath);\n+\t\tt.match(stdout, /Please run AVA again with the .*--update-snapshots.* flag to upgrade\\./);\n \t\tt.end();\n \t});\n });\n@@ -649,12 +636,12 @@ test('newer snapshot version is reported to the console', t => {\n \tconst snapPath = path.join(__dirname, 'fixture', 'snapshots', 'test.js.snap');\n \tfs.writeFileSync(snapPath, Buffer.from([0x0A, 0xFF, 0xFF]));\n \n-\texecCli(['test.js'], {dirname: 'fixture/snapshots'}, (err, stdout, stderr) => {\n+\texecCli(['test.js'], {dirname: 'fixture/snapshots'}, (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stderr, /The snapshot file is v65535, but only v1 is supported\\./);\n-\t\tt.match(stderr, /File path:/);\n-\t\tt.match(stderr, snapPath);\n-\t\tt.match(stderr, /You should upgrade AVA\\./);\n+\t\tt.match(stdout, /The snapshot file is v65535, but only v1 is supported\\./);\n+\t\tt.match(stdout, /File path:/);\n+\t\tt.match(stdout, snapPath);\n+\t\tt.match(stdout, /You should upgrade AVA\\./);\n \t\tt.end();\n \t});\n });\n@@ -663,12 +650,12 @@ test('snapshot corruption is reported to the console', t => {\n \tconst snapPath = path.join(__dirname, 'fixture', 'snapshots', 'test.js.snap');\n \tfs.writeFileSync(snapPath, Buffer.from([0x0A, 0x01, 0x00]));\n \n-\texecCli(['test.js'], {dirname: 'fixture/snapshots'}, (err, stdout, stderr) => {\n+\texecCli(['test.js'], {dirname: 'fixture/snapshots'}, (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stderr, /The snapshot file is corrupted\\./);\n-\t\tt.match(stderr, /File path:/);\n-\t\tt.match(stderr, snapPath);\n-\t\tt.match(stderr, /Please run AVA again with the .*--update-snapshots.* flag to recreate it\\./);\n+\t\tt.match(stdout, /The snapshot file is corrupted\\./);\n+\t\tt.match(stdout, /File path:/);\n+\t\tt.match(stdout, snapPath);\n+\t\tt.match(stdout, /Please run AVA again with the .*--update-snapshots.* flag to recreate it\\./);\n \t\tt.end();\n \t});\n });\n@@ -677,12 +664,12 @@ test('legacy snapshot files are reported to the console', t => {\n \tconst snapPath = path.join(__dirname, 'fixture', 'snapshots', 'test.js.snap');\n \tfs.writeFileSync(snapPath, Buffer.from('// Jest Snapshot v1, https://goo.gl/fbAQLP\\n'));\n \n-\texecCli(['test.js'], {dirname: 'fixture/snapshots'}, (err, stdout, stderr) => {\n+\texecCli(['test.js'], {dirname: 'fixture/snapshots'}, (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stderr, /The snapshot file was created with AVA 0\\.19\\. It's not supported by this AVA version\\./);\n-\t\tt.match(stderr, /File path:/);\n-\t\tt.match(stderr, snapPath);\n-\t\tt.match(stderr, /Please run AVA again with the .*--update-snapshots.* flag to upgrade\\./);\n+\t\tt.match(stdout, /The snapshot file was created with AVA 0\\.19\\. It's not supported by this AVA version\\./);\n+\t\tt.match(stdout, /File path:/);\n+\t\tt.match(stdout, snapPath);\n+\t\tt.match(stdout, /Please run AVA again with the .*--update-snapshots.* flag to upgrade\\./);\n \t\tt.end();\n \t});\n });\n@@ -717,10 +704,10 @@ test('snapshots infer their location from sourcemaps', t => {\n \tconst verifySnapFixtureFiles = relFilePath => {\n \t\tt.true(fs.existsSync(relFilePath));\n \t};\n-\texecCli([], {dirname: relativeFixtureDir}, (err, stdout, stderr) => {\n+\texecCli([], {dirname: relativeFixtureDir}, (err, stdout) => {\n \t\tt.ifError(err);\n \t\tsnapFixtureFilePaths.forEach(x => verifySnapFixtureFiles(x));\n-\t\tt.match(stderr, /6 passed/);\n+\t\tt.match(stdout, /6 tests passed/);\n \t\tt.end();\n \t});\n });\n@@ -756,82 +743,82 @@ test('snapshots resolved location from \"snapshotDir\" in AVA config', t => {\n \tconst verifySnapFixtureFiles = relFilePath => {\n \t\tt.true(fs.existsSync(relFilePath));\n \t};\n-\texecCli([], {dirname: relativeFixtureDir}, (err, stdout, stderr) => {\n+\texecCli([], {dirname: relativeFixtureDir}, (err, stdout) => {\n \t\tt.ifError(err);\n \t\tsnapFixtureFilePaths.forEach(x => verifySnapFixtureFiles(x));\n-\t\tt.match(stderr, /6 passed/);\n+\t\tt.match(stdout, /6 tests passed/);\n \t\tt.end();\n \t});\n });\n \n test('--no-color disables formatting colors', t => {\n-\texecCli(['--no-color', '--verbose', 'formatting-color.js'], {dirname: 'fixture'}, (err, stdout, stderr) => {\n+\texecCli(['--no-color', '--verbose', 'formatting-color.js'], {dirname: 'fixture'}, (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.is(stripAnsi(stderr), stderr);\n+\t\tt.is(stripAnsi(stdout), stdout);\n \t\tt.end();\n \t});\n });\n \n test('--color enables formatting colors', t => {\n-\texecCli(['--color', '--verbose', 'formatting-color.js'], {dirname: 'fixture'}, (err, stdout, stderr) => {\n+\texecCli(['--color', '--verbose', 'formatting-color.js'], {dirname: 'fixture'}, (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.isNot(stripAnsi(stderr), stderr);\n+\t\tt.isNot(stripAnsi(stdout), stdout);\n \t\tt.end();\n \t});\n });\n \n test('sets NODE_ENV to test when it is not set', t => {\n-\texecCli([path.join('fixture', 'node-env-test.js')], {env: {}}, (err, stdout, stderr) => {\n+\texecCli([path.join('fixture', 'node-env-test.js')], {env: {}}, (err, stdout) => {\n \t\tt.ifError(err);\n-\t\tt.match(stderr, /1 passed/);\n+\t\tt.match(stdout, /1 test passed/);\n \t\tt.end();\n \t});\n });\n \n test('doesn\\'t set NODE_ENV when it is set', t => {\n-\texecCli([path.join('fixture', 'node-env-foo.js')], {env: {NODE_ENV: 'foo'}}, (err, stdout, stderr) => {\n+\texecCli([path.join('fixture', 'node-env-foo.js')], {env: {NODE_ENV: 'foo'}}, (err, stdout) => {\n \t\tt.ifError(err);\n-\t\tt.match(stderr, /1 passed/);\n+\t\tt.match(stdout, /1 test passed/);\n \t\tt.end();\n \t});\n });\n \n test('skips test file compilation when babel=false and compileEnhancements=false', t => {\n-\texecCli(['import.js'], {dirname: 'fixture/no-babel-compilation'}, (err, stdout, stderr) => {\n+\texecCli(['import.js'], {dirname: 'fixture/no-babel-compilation'}, (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stderr, /SyntaxError: Unexpected (reserved word|token import)/);\n+\t\tt.match(stdout, /SyntaxError: Unexpected (reserved word|token import)/);\n \t\tt.end();\n \t});\n });\n \n test('skips helper file compilation when babel=false and compileEnhancements=false', t => {\n-\texecCli(['require-helper.js'], {dirname: 'fixture/no-babel-compilation'}, (err, stdout, stderr) => {\n+\texecCli(['require-helper.js'], {dirname: 'fixture/no-babel-compilation'}, (err, stdout) => {\n \t\tt.ifError(err);\n-\t\tt.match(stderr, /1 passed/);\n+\t\tt.match(stdout, /1 test passed/);\n \t\tt.end();\n \t});\n });\n \n test('no power-assert when babel=false and compileEnhancements=false', t => {\n-\texecCli(['no-power-assert.js'], {dirname: 'fixture/no-babel-compilation'}, (err, stdout, stderr) => {\n+\texecCli(['no-power-assert.js'], {dirname: 'fixture/no-babel-compilation'}, (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.notMatch(stripAnsi(stderr), /bool\\n.*=> false/);\n+\t\tt.notMatch(stripAnsi(stdout), /bool\\n.*=> false/);\n \t\tt.end();\n \t});\n });\n \n test('skips stage-4 transform when babel=false and compileEnhancements=true', t => {\n-\texecCli(['import.js'], {dirname: 'fixture/just-enhancement-compilation'}, (err, stdout, stderr) => {\n+\texecCli(['import.js'], {dirname: 'fixture/just-enhancement-compilation'}, (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stderr, /SyntaxError: Unexpected (reserved word|token import)/);\n+\t\tt.match(stdout, /SyntaxError: Unexpected (reserved word|token import)/);\n \t\tt.end();\n \t});\n });\n \n test('power-assert when babel=false and compileEnhancements=true', t => {\n-\texecCli(['power-assert.js'], {dirname: 'fixture/just-enhancement-compilation'}, (err, stdout, stderr) => {\n+\texecCli(['power-assert.js'], {dirname: 'fixture/just-enhancement-compilation'}, (err, stdout) => {\n \t\tt.ok(err);\n-\t\tt.match(stripAnsi(stderr), /bool\\n.*=> false/);\n+\t\tt.match(stripAnsi(stdout), /bool\\n.*=> false/);\n \t\tt.end();\n \t});\n });"
      },
      {
        "sha": "0c13c547a1bc2ab9fa78a6b5fc11c57e81d5b9a0",
        "filename": "test/code-excerpt.js",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fcode-excerpt.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fcode-excerpt.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fcode-excerpt.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,4 +1,6 @@\n 'use strict';\n+require('../lib/chalk').set();\n+\n const fs = require('fs');\n const tempWrite = require('temp-write');\n const chalk = require('chalk');"
      },
      {
        "sha": "0204ac28b652127b1ff2519c0acb0c73360d3930",
        "filename": "test/fixture/chalk-disabled.js",
        "status": "removed",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fchalk-disabled.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fchalk-disabled.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Fchalk-disabled.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,6 +0,0 @@\n-import chalk from 'chalk';\n-import test from '../..';\n-\n-test('should not support colors', t => {\n-\tt.false(chalk.enabled);\n-});"
      },
      {
        "sha": "0827cc370b18003448050c4fad6c29dcb2e9b0be",
        "filename": "test/fixture/chalk-enabled.js",
        "status": "removed",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fchalk-enabled.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fchalk-enabled.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Fchalk-enabled.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,6 +0,0 @@\n-import chalk from 'chalk';\n-import test from '../..';\n-\n-test('should support colors', t => {\n-\tt.true(chalk.enabled);\n-});"
      },
      {
        "sha": "476e0f9f29f8b75791528dd2524512a34f84a124",
        "filename": "test/fixture/circular-reference-on-assertion.js",
        "status": "removed",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fcircular-reference-on-assertion.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fcircular-reference-on-assertion.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Fcircular-reference-on-assertion.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,7 +0,0 @@\n-import test from '../..';\n-\n-test('test', t => {\n-\tconst circular = ['a', 'b'];\n-\tcircular.push(circular);\n-\tt.deepEqual([circular, 'c'], [circular, 'd']);\n-});"
      },
      {
        "sha": "f8f6b3ac718d51784e46c9ea31e5a24641dbb00f",
        "filename": "test/fixture/destructuring-public-api.js",
        "status": "removed",
        "additions": 0,
        "deletions": 19,
        "changes": 19,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fdestructuring-public-api.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fdestructuring-public-api.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Fdestructuring-public-api.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,19 +0,0 @@\n-import test from '../..';\n-\n-test.beforeEach(t => {\n-\tt.context = 'bar';\n-});\n-\n-test.cb('callback mode', ({context: foo, ...t}) => {\n-\tt.is(foo, 'bar');\n-\tt.end();\n-});\n-\n-test.cb('callback mode #2', ({context: foo, end, ...t}) => {\n-\tt.is(foo, 'bar');\n-\tend();\n-});\n-\n-test('sync', ({context: foo, ...t}) => {\n-\tt.is(foo, 'bar');\n-});"
      },
      {
        "sha": "03d71544642e32bebdd5a25256fb1a0143ec2875",
        "filename": "test/fixture/empty.js",
        "status": "removed",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fempty.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fempty.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Fempty.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,8 +0,0 @@\n-/*\n-                         __\n-    ____   _____ _______/  |_ ___.__.\n-  _/ __ \\ /     \\\\____ \\   __<   |  |\n-  \\  ___/|  Y Y  \\  |_> >  |  \\___  |\n-   \\___  >__|_|  /   __/|__|  / ____|\n-       \\/      \\/|__|         \\/\n- */"
      },
      {
        "sha": "775933f27aceaef924a866f118721f2ec081c1b6",
        "filename": "test/fixture/error-without-message.js",
        "status": "removed",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Ferror-without-message.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Ferror-without-message.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Ferror-without-message.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,5 +0,0 @@\n-import test from '../..';\n-\n-test('throw an error without a message', () => {\n-\tthrow new Error(); // eslint-disable-line unicorn/error-message\n-});"
      },
      {
        "sha": "c8260ef903887db20ec770d3e7f68cfffc9724ef",
        "filename": "test/fixture/exclusive-nonexclusive.js",
        "status": "removed",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fexclusive-nonexclusive.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fexclusive-nonexclusive.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Fexclusive-nonexclusive.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,9 +0,0 @@\n-import test from '../..';\n-\n-test.only('only', t => {\n-\tt.pass();\n-});\n-\n-test('test', t => {\n-\tt.fail();\n-});"
      },
      {
        "sha": "d596e260996a6d9d3184f5e2805ddf16fbefa8ad",
        "filename": "test/fixture/exclusive.js",
        "status": "removed",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fexclusive.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fexclusive.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Fexclusive.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,5 +0,0 @@\n-import test from '../..';\n-\n-test.only('test', t => {\n-\tt.pass();\n-});"
      },
      {
        "sha": "576e765ffa735271f5f5019aa49a707f5c1cb1e6",
        "filename": "test/fixture/fake-timers.js",
        "status": "removed",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Ffake-timers.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Ffake-timers.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Ffake-timers.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,7 +0,0 @@\n-import sinon from 'sinon';\n-import test from '../..';\n-\n-test('test', t => {\n-\tsinon.useFakeTimers(Date.now() + 10000);\n-\tt.pass();\n-});"
      },
      {
        "sha": "6876942aa4a7511da7a2012d6bd1785cc335744e",
        "filename": "test/fixture/hooks-failing.js",
        "status": "removed",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fhooks-failing.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fhooks-failing.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Fhooks-failing.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,10 +0,0 @@\n-import test from '../..';\n-\n-test.beforeEach(fail);\n-test('pass', pass);\n-\n-function pass() {}\n-\n-function fail(t) {\n-\tt.fail();\n-}"
      },
      {
        "sha": "4938ba919e410008332753fac16f9428fe7240cf",
        "filename": "test/fixture/hooks-passing.js",
        "status": "removed",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fhooks-passing.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fhooks-passing.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Fhooks-passing.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,11 +0,0 @@\n-import test from '../..';\n-\n-test.before(pass);\n-test.beforeEach(pass);\n-test.after(pass);\n-test.afterEach(pass);\n-test('pass', pass);\n-\n-function pass(t) {\n-\tt.pass();\n-}"
      },
      {
        "sha": "0dfdf055b438464c35da34880351abdbaa872216",
        "filename": "test/fixture/immediate-0-exit.js",
        "status": "removed",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fimmediate-0-exit.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fimmediate-0-exit.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Fimmediate-0-exit.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,2 +0,0 @@\n-'use strict';\n-process.exit(0); // eslint-disable-line unicorn/no-process-exit"
      },
      {
        "sha": "3cf096b8b9d56499291f6a952ed59abb74d1df2d",
        "filename": "test/fixture/immediate-3-exit.js",
        "status": "removed",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fimmediate-3-exit.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fimmediate-3-exit.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Fimmediate-3-exit.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,2 +0,0 @@\n-'use strict';\n-process.exit(3); // eslint-disable-line unicorn/no-process-exit"
      },
      {
        "sha": "08fbedb42964d690f335988fb08a8b71cde92d13",
        "filename": "test/fixture/loud-rejection.js",
        "status": "removed",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Floud-rejection.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Floud-rejection.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Floud-rejection.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,9 +0,0 @@\n-import test from '../..';\n-\n-test.cb('creates an unhandled rejection', t => {\n-\tPromise.reject(new Error('You can\\'t handle this!'));\n-\n-\tsetTimeout(() => {\n-\t\tt.end();\n-\t});\n-});"
      },
      {
        "sha": "a3211c86217ce666e7841f6e5c64bce3e458d065",
        "filename": "test/fixture/report/README.md",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2FREADME.md",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2FREADME.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Freport%2FREADME.md?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,3 @@\n+To run these tests directly, `cd` into the respective directories and invoke via `node ../../../../cli.js`.\n+\n+Note that the `report` helper sorts the test files before running tests."
      },
      {
        "sha": "9ca43678f738c3bd204b5adbb89b716ae6cb99b2",
        "filename": "test/fixture/report/failfast/a.js",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Ffailfast%2Fa.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Ffailfast%2Fa.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Freport%2Ffailfast%2Fa.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,3 @@\n+import test from '../../../..';\n+\n+test('fails', t => t.fail());"
      },
      {
        "sha": "a20cc6d161efb04d8c9ea567f03f4265c03d0a56",
        "filename": "test/fixture/report/failfast/b.js",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Ffailfast%2Fb.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Ffailfast%2Fb.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Freport%2Ffailfast%2Fb.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,3 @@\n+import test from '../../../..';\n+\n+test('passes', t => t.pass());"
      },
      {
        "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
        "filename": "test/fixture/report/failfast/package.json",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Ffailfast%2Fpackage.json",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Ffailfast%2Fpackage.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Freport%2Ffailfast%2Fpackage.json?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1 @@\n+{}"
      },
      {
        "sha": "cb8c65a8f9bc7dbf6ad31447cb85ac1752b8a73f",
        "filename": "test/fixture/report/failfast2/a.js",
        "status": "added",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Ffailfast2%2Fa.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Ffailfast2%2Fa.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Freport%2Ffailfast2%2Fa.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,4 @@\n+import test from '../../../..';\n+\n+test('fails', t => t.fail());\n+test('passes', t => t.pass());"
      },
      {
        "sha": "a20cc6d161efb04d8c9ea567f03f4265c03d0a56",
        "filename": "test/fixture/report/failfast2/b.js",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Ffailfast2%2Fb.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Ffailfast2%2Fb.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Freport%2Ffailfast2%2Fb.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,3 @@\n+import test from '../../../..';\n+\n+test('passes', t => t.pass());"
      },
      {
        "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
        "filename": "test/fixture/report/failfast2/package.json",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Ffailfast2%2Fpackage.json",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Ffailfast2%2Fpackage.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Freport%2Ffailfast2%2Fpackage.json?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1 @@\n+{}"
      },
      {
        "sha": "b1894d947ee5a307d501f74ee84dd07e2f48eff3",
        "filename": "test/fixture/report/only/a.js",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fonly%2Fa.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fonly%2Fa.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Freport%2Fonly%2Fa.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,5 @@\n+import test from '../../../..';\n+\n+test.only('only', t => t.pass());\n+\n+test('passes', t => t.pass());"
      },
      {
        "sha": "a20cc6d161efb04d8c9ea567f03f4265c03d0a56",
        "filename": "test/fixture/report/only/b.js",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fonly%2Fb.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fonly%2Fb.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Freport%2Fonly%2Fb.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,3 @@\n+import test from '../../../..';\n+\n+test('passes', t => t.pass());"
      },
      {
        "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
        "filename": "test/fixture/report/only/package.json",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fonly%2Fpackage.json",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fonly%2Fpackage.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Freport%2Fonly%2Fpackage.json?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1 @@\n+{}"
      },
      {
        "sha": "5535a7fa7b0165f02325d44e7cc62fbc46325e97",
        "filename": "test/fixture/report/regular/bad-test-chain.js",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fregular%2Fbad-test-chain.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fregular%2Fbad-test-chain.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Freport%2Fregular%2Fbad-test-chain.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,3 @@\n+import test from '../../../..';\n+\n+test.serial.test('passes', t => t.pass());"
      },
      {
        "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
        "filename": "test/fixture/report/regular/package.json",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fregular%2Fpackage.json",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fregular%2Fpackage.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Freport%2Fregular%2Fpackage.json?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1 @@\n+{}"
      },
      {
        "sha": "9801c480fedceff88dbae84691e142b2c4eb9169",
        "filename": "test/fixture/report/regular/slow.js",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fregular%2Fslow.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fregular%2Fslow.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Freport%2Fregular%2Fslow.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,5 @@\n+import test from '../../../..';\n+\n+test.cb('slow', t => {\n+\tsetTimeout(t.end, 200);\n+});"
      },
      {
        "sha": "4825784ba3120a1bf6100feee742a796fbef7630",
        "filename": "test/fixture/report/regular/test.js",
        "status": "added",
        "additions": 50,
        "deletions": 0,
        "changes": 50,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fregular%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fregular%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Freport%2Fregular%2Ftest.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,50 @@\n+import test from '../../../..';\n+\n+console.log('stdout');\n+console.error('stderr');\n+\n+test('passes', t => t.pass());\n+\n+test.todo('todo');\n+\n+test.skip('skip', t => t.pass());\n+\n+test('fails', t => t.fail());\n+\n+test.failing('known failure', t => t.fail());\n+\n+test.failing('no longer failing', t => t.pass());\n+\n+test('logs', t => {\n+\tt.log('hello');\n+\tt.log('world');\n+\tt.fail();\n+});\n+\n+test('formatted', t => {\n+\tt.deepEqual('foo', 'bar');\n+});\n+\n+test('power-assert', t => {\n+\tconst foo = 'bar';\n+\tt.falsy(foo);\n+});\n+\n+test('bad throws', t => {\n+\tconst fn = () => {\n+\t\tthrow new Error('err');\n+\t};\n+\tt.throws(fn());\n+});\n+\n+test('bad notThrows', t => {\n+\tconst fn = () => {\n+\t\tthrow new Error('err');\n+\t};\n+\tt.notThrows(fn());\n+});\n+\n+test('implementation throws non-error', () => {\n+\tconst err = null;\n+\tthrow err;\n+});"
      },
      {
        "sha": "6a2a2c3064cb2aa217cba0717449ba4b2305418e",
        "filename": "test/fixture/report/regular/uncaught-exception.js",
        "status": "added",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fregular%2Funcaught-exception.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fregular%2Funcaught-exception.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Freport%2Fregular%2Funcaught-exception.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,8 @@\n+import test from '../../../..';\n+\n+test('passes', t => {\n+\tsetTimeout(() => {\n+\t\tthrow new Error('Can\\'t catch me');\n+\t});\n+\tt.pass();\n+});"
      },
      {
        "sha": "0ec2c15c15d7a67d40a0f9a69ddce3c3e17fd43b",
        "filename": "test/fixture/report/regular/unhandled-rejection.js",
        "status": "added",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fregular%2Funhandled-rejection.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fregular%2Funhandled-rejection.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Freport%2Fregular%2Funhandled-rejection.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,12 @@\n+import test from '../../../..';\n+\n+test('passes', t => {\n+\tPromise.reject(new Error('Can\\'t catch me'));\n+\tt.pass();\n+});\n+\n+test('unhandled non-error rejection', t => {\n+\tconst err = null;\n+\tPromise.reject(err);\n+\tt.pass();\n+});"
      },
      {
        "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
        "filename": "test/fixture/report/watch/package.json",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fwatch%2Fpackage.json",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fwatch%2Fpackage.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Freport%2Fwatch%2Fpackage.json?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1 @@\n+{}"
      },
      {
        "sha": "a20cc6d161efb04d8c9ea567f03f4265c03d0a56",
        "filename": "test/fixture/report/watch/test.js",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fwatch%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Freport%2Fwatch%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Freport%2Fwatch%2Ftest.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,3 @@\n+import test from '../../../..';\n+\n+test('passes', t => t.pass());"
      },
      {
        "sha": "b44af4aaade48708c01b655cf9e8984dcf5cfca5",
        "filename": "test/fixture/syntax-error.js",
        "status": "removed",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fsyntax-error.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Fsyntax-error.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Fsyntax-error.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,5 +0,0 @@\n-import test from 'ava';\n-\n-test.(t => {\n-\tt.pass();\n-});"
      },
      {
        "sha": "72f11c6f4c39915e127ea1533212c848ba789f09",
        "filename": "test/fixture/uncaught-exception.js",
        "status": "removed",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Funcaught-exception.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffixture%2Funcaught-exception.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Funcaught-exception.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,8 +0,0 @@\n-import test from '../..';\n-\n-test('throw an uncaught exception', t => {\n-\tsetImmediate(() => {\n-\t\tthrow new Error(`Can't catch me!`);\n-\t});\n-\tt.pass();\n-});"
      },
      {
        "sha": "5e14e3cc17a9575c02dc5487744d1bb0db9302ec",
        "filename": "test/fixture/worker-argv.js",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Fworker-argv.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Ffixture%2Fworker-argv.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Fworker-argv.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,5 +1,5 @@\n import test from '../..';\n \n test('argv', t => {\n-\tt.deepEqual(process.argv, [process.execPath, require.resolve('../../lib/test-worker.js'), '--hello', 'world']);\n+\tt.deepEqual(process.argv, [process.execPath, require.resolve('../../lib/worker/subprocess.js'), '--hello', 'world']);\n });"
      },
      {
        "sha": "0f280cdaef1ae59b2f7337b69e0a15cbcb4c07ac",
        "filename": "test/fork.js",
        "status": "removed",
        "additions": 0,
        "deletions": 153,
        "changes": 153,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffork.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Ffork.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffork.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,153 +0,0 @@\n-'use strict';\n-const path = require('path');\n-const tap = require('tap');\n-const _fork = require('../lib/fork.js');\n-const CachingPrecompiler = require('../lib/caching-precompiler');\n-\n-const skip = tap.skip;\n-const test = tap.test;\n-\n-const cacheDir = path.join(__dirname, '../node_modules/.cache/ava');\n-const isNode4 = /\\d+/.exec(process.version)[0] === '4';\n-const precompiler = new CachingPrecompiler({\n-\tbabelCacheKeys: {},\n-\tgetBabelOptions() {\n-\t\treturn {\n-\t\t\tbabelrc: false,\n-\t\t\tpresets: [require.resolve('@ava/babel-preset-stage-4')]\n-\t\t};\n-\t},\n-\tpath: cacheDir\n-});\n-\n-function fork(testPath, options) {\n-\tconst hash = precompiler.precompileFile(testPath);\n-\tconst precompiled = {};\n-\tprecompiled[testPath] = hash;\n-\n-\treturn _fork(testPath, Object.assign({\n-\t\tcacheDir,\n-\t\tprecompiled\n-\t}, options));\n-}\n-\n-function fixture(name) {\n-\treturn path.join(__dirname, 'fixture', name);\n-}\n-\n-test('emits test event', t => {\n-\tt.plan(1);\n-\n-\tfork(fixture('generators.js'))\n-\t\t.on('test', tt => {\n-\t\t\tt.is(tt.title, 'generator function');\n-\t\t\tt.end();\n-\t\t});\n-});\n-\n-test('resolves promise with tests info', t => {\n-\tt.plan(3);\n-\n-\tconst file = fixture('generators.js');\n-\n-\treturn fork(file)\n-\t\t.then(info => {\n-\t\t\tt.is(info.stats.passCount, 1);\n-\t\t\tt.is(info.tests.length, 1);\n-\t\t\tt.is(info.file, path.relative('.', file));\n-\t\t\tt.end();\n-\t\t});\n-});\n-\n-test('exit after tests are finished', t => {\n-\tt.plan(2);\n-\n-\tconst start = Date.now();\n-\tlet cleanupCompleted = false;\n-\n-\tfork(fixture('slow-exit.js'))\n-\t\t.on('exit', () => {\n-\t\t\tt.true(Date.now() - start < 10000, 'test waited for a pending setTimeout');\n-\t\t\tt.true(cleanupCompleted, 'cleanup did not complete');\n-\t\t})\n-\t\t.on('cleanup-completed', event => {\n-\t\t\tcleanupCompleted = event.completed;\n-\t\t});\n-});\n-\n-test('rejects promise if the process exits with a non-zero code', t => {\n-\treturn fork(fixture('immediate-3-exit.js'))\n-\t\t.catch(err => {\n-\t\t\tt.is(err.name, 'AvaError');\n-\t\t\tt.is(err.message, path.join('test', 'fixture', 'immediate-3-exit.js') + ' exited with a non-zero exit code: 3');\n-\t\t});\n-});\n-\n-test('rejects promise if the process exits without results', t => {\n-\treturn fork(fixture('immediate-0-exit.js'))\n-\t\t.catch(err => {\n-\t\t\tt.is(err.name, 'AvaError');\n-\t\t\tt.is(err.message, 'Test results were not received from ' + path.join('test', 'fixture', 'immediate-0-exit.js'));\n-\t\t});\n-});\n-\n-test('rejects promise if the process is killed', t => {\n-\tconst forked = fork(fixture('es2015.js'));\n-\treturn forked\n-\t\t.on('stats', function () {\n-\t\t\tthis.kill('SIGKILL');\n-\t\t})\n-\t\t.catch(err => {\n-\t\t\tt.is(err.name, 'AvaError');\n-\t\t\tt.is(err.message, path.join('test', 'fixture', 'es2015.js') + ' exited due to SIGKILL');\n-\t\t});\n-});\n-\n-test('fake timers do not break duration', t => {\n-\treturn fork(fixture('fake-timers.js'))\n-\t\t.then(info => {\n-\t\t\tconst duration = info.tests[0].duration;\n-\t\t\tt.true(duration < 1000, `${duration} < 1000`);\n-\t\t\tt.is(info.stats.failCount, 0);\n-\t\t\tt.is(info.stats.passCount, 1);\n-\t\t\tt.end();\n-\t\t});\n-});\n-\n-test('babelrc is ignored', t => {\n-\treturn fork(fixture('babelrc/test.js'))\n-\t\t.then(info => {\n-\t\t\tt.is(info.stats.passCount, 1);\n-\t\t\tt.end();\n-\t\t});\n-});\n-\n-(isNode4 ? skip : test)(\n-'`esm` package support', t => {\n-\treturn fork(fixture('esm-pkg/test.js'), {\n-\t\trequire: [require.resolve('esm')]\n-\t})\n-\t\t.then(info => {\n-\t\t\tt.is(info.stats.passCount, 1);\n-\t\t\tt.end();\n-\t\t});\n-});\n-\n-// TODO: Skipped until we can do this properly in #1455\n-test('color support is initialized correctly', t => {\n-\tt.plan(1);\n-\n-\treturn Promise.all([\n-\t\tfork(fixture('chalk-enabled.js'), {color: true}),\n-\t\tfork(fixture('chalk-disabled.js'), {color: false}),\n-\t\tfork(fixture('chalk-disabled.js'), {})\n-\t]).then(infos => {\n-\t\tfor (const info of infos) {\n-\t\t\tif (info.stats.failCount > 0) {\n-\t\t\t\tt.fail(`${info.file} failed`);\n-\t\t\t}\n-\t\t}\n-\n-\t\tt.is(infos.length, 3);\n-\t});\n-}, {skip: true});"
      },
      {
        "sha": "bce6ddb288bee8f63edb07124d753b652d261524",
        "filename": "test/helper/colors.js",
        "status": "removed",
        "additions": 0,
        "deletions": 40,
        "changes": 40,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Fhelper%2Fcolors.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Fhelper%2Fcolors.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fhelper%2Fcolors.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,40 +0,0 @@\n-/**\n- * This module is maintained to promote separation between the tests and the\n- * implementation.\n- */\n-'use strict';\n-\n-const ansiStyles = require('ansi-styles');\n-\n-function make(name) {\n-\tconst style = ansiStyles[name];\n-\treturn function (string) {\n-\t\treturn style.open + string + style.close;\n-\t};\n-}\n-const bold = make('bold');\n-const white = make('white');\n-const gray = make('gray');\n-\n-// The following color definitions are contextual so that they produce expected\n-// values which mimic the behavior of the Chalk library.\n-const isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');\n-const openDim = isSimpleWindowsTerm ? '' : ansiStyles.dim.open;\n-const openBlue = isSimpleWindowsTerm ? '\\u001B[94m' : ansiStyles.blue.open;\n-// \"Use `bold` by default on Windows\"\n-// https://github.com/chalk/chalk/issues/36\n-const blue = string => openBlue + string + ansiStyles.blue.close;\n-// \"(Windows) chalk.gray.dim not visible\"\n-// https://github.com/chalk/chalk/issues/58\n-const dimGray = string => gray(openDim + string + ansiStyles.dim.close);\n-\n-module.exports = {\n-\tblue,\n-\tboldWhite: string => bold(white(string)),\n-\tdimGray,\n-\tgray,\n-\tgreen: make('green'),\n-\tmagenta: make('magenta'),\n-\tred: make('red'),\n-\tyellow: make('yellow')\n-};"
      },
      {
        "sha": "d3cddc254f2a04e1242c9313d8c8302f19b87158",
        "filename": "test/helper/compare-line-output.js",
        "status": "removed",
        "additions": 0,
        "deletions": 30,
        "changes": 30,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Fhelper%2Fcompare-line-output.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Fhelper%2Fcompare-line-output.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fhelper%2Fcompare-line-output.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,30 +0,0 @@\n-'use strict';\n-const SKIP_UNTIL_EMPTY_LINE = Symbol('SKIP_UNTIL_EMPTY_LINE');\n-\n-function compareLineOutput(t, actual, lineExpectations) {\n-\tconst actualLines = actual.split('\\n');\n-\tlet expectationIndex = 0;\n-\tlet lineIndex = 0;\n-\n-\twhile (lineIndex < actualLines.length && expectationIndex < lineExpectations.length) {\n-\t\tconst line = actualLines[lineIndex++];\n-\t\tconst expected = lineExpectations[expectationIndex++];\n-\n-\t\tif (expected === SKIP_UNTIL_EMPTY_LINE) {\n-\t\t\tlineIndex = actualLines.indexOf('', lineIndex);\n-\t\t\tcontinue;\n-\t\t}\n-\n-\t\tif (typeof expected === 'string') {\n-\t\t\t// Assertion titles use 1-based line indexes\n-\t\t\tt.is(line, expected, `line ${lineIndex} ≪${line}≫ is ≪${expected}≫`);\n-\t\t} else {\n-\t\t\tt.match(line, expected, `line ${lineIndex} ≪${line}≫ matches ${expected}`);\n-\t\t}\n-\t}\n-\n-\tt.is(lineIndex, actualLines.length, `Compared ${lineIndex} of ${actualLines.length} lines`);\n-}\n-\n-module.exports = compareLineOutput;\n-compareLineOutput.SKIP_UNTIL_EMPTY_LINE = SKIP_UNTIL_EMPTY_LINE;"
      },
      {
        "sha": "18c0be9b7f87093ab7b95cc551c4c3091cb5a93c",
        "filename": "test/helper/error-from-worker.js",
        "status": "removed",
        "additions": 0,
        "deletions": 23,
        "changes": 23,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Fhelper%2Ferror-from-worker.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Fhelper%2Ferror-from-worker.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fhelper%2Ferror-from-worker.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,23 +0,0 @@\n-'use strict';\n-\n-const serializeError = require('../../lib/serialize-error');\n-\n-module.exports = function (err, options) {\n-\toptions = Object.assign({}, options);\n-\n-\tif (options.stack) {\n-\t\terr.stack = options.stack;\n-\t}\n-\n-\tconst serialized = serializeError(err);\n-\n-\tif (options.type) {\n-\t\tserialized.type = options.type;\n-\t}\n-\n-\tif (options.file) {\n-\t\tserialized.file = options.file;\n-\t}\n-\n-\treturn serialized;\n-};"
      },
      {
        "sha": "43327ba7063f9465a363d17ca7ce788c14d6b25c",
        "filename": "test/helper/fix-reporter-env.js",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fhelper%2Ffix-reporter-env.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fhelper%2Ffix-reporter-env.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fhelper%2Ffix-reporter-env.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,27 @@\n+'use strict';\n+const os = require('os');\n+const lolex = require('lolex');\n+\n+const fixColors = () => {\n+\t// Force consistent and high-fidelity logs.\n+\tprocess.env.FORCE_COLOR = 3;\n+\tObject.defineProperty(process, 'platform', {value: 'darwin', enumerable: true, configurable: true});\n+};\n+\n+module.exports = () => {\n+\t// Fix timestamps.\n+\tlolex.install({\n+\t\tnow: new Date(2014, 11, 19, 17, 19, 12, 200).getTime(),\n+\t\ttoFake: [\n+\t\t\t'Date'\n+\t\t]\n+\t});\n+\n+\t// Fix line endings.\n+\tObject.defineProperty(os, 'EOL', {value: '\\n'});\n+\n+\tfixColors();\n+\trequire('../../lib/chalk').set({enabled: true, level: 3});\n+};\n+\n+module.exports.onlyColors = fixColors;"
      },
      {
        "sha": "5e4a951fc2467e26a19a43ecd93889e6072d2748",
        "filename": "test/helper/replay-report.js",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fhelper%2Freplay-report.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fhelper%2Freplay-report.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fhelper%2Freplay-report.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,15 @@\n+#!/usr/bin/env node\n+'use strict';\n+/* eslint-disable no-await-in-loop */\n+const fs = require('fs');\n+const TTYStream = require('./tty-stream');\n+\n+const lines = fs.readFileSync(process.argv[2], 'utf8').split(TTYStream.SEPARATOR.toString('utf8'));\n+const delay = () => new Promise(resolve => setTimeout(resolve, 1000));\n+\n+(async () => {\n+\twhile (lines.length > 0) {\n+\t\tprocess.stdout.write(lines.shift());\n+\t\tawait delay();\n+\t}\n+})();"
      },
      {
        "sha": "1971fe8ab87a7f44b4add864416a48633746089d",
        "filename": "test/helper/report-worker.js",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fhelper%2Freport-worker.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fhelper%2Freport-worker.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fhelper%2Freport-worker.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,3 @@\n+'use strict';\n+require('./fix-reporter-env').onlyColors();\n+require('../../lib/worker/subprocess'); // eslint-disable-line import/no-unassigned-import"
      },
      {
        "sha": "8f6b2ecfd8223bbfca22718147c75699b040fb31",
        "filename": "test/helper/report.js",
        "status": "added",
        "additions": 124,
        "deletions": 0,
        "changes": 124,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fhelper%2Freport.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fhelper%2Freport.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fhelper%2Freport.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,124 @@\n+'use strict';\n+const childProcess = require('child_process');\n+const fs = require('fs');\n+const path = require('path');\n+const globby = require('globby');\n+const proxyquire = require('proxyquire');\n+const replaceString = require('replace-string');\n+\n+let _Api = null;\n+const createApi = options => {\n+\tif (!_Api) {\n+\t\t_Api = proxyquire('../../api', {\n+\t\t\t'./lib/fork': proxyquire('../../lib/fork', {\n+\t\t\t\tchild_process: Object.assign({}, childProcess, { // eslint-disable-line camelcase\n+\t\t\t\t\tfork(filename, argv, options) {\n+\t\t\t\t\t\treturn childProcess.fork(path.join(__dirname, 'report-worker.js'), argv, options);\n+\t\t\t\t\t}\n+\t\t\t\t})\n+\t\t\t})\n+\t\t});\n+\t}\n+\n+\treturn new _Api(options);\n+};\n+\n+// At least in Appveyor with Node.js 6, IPC can overtake stdout/stderr\n+let hasReliableStdIO = true;\n+exports.captureStdIOReliability = () => {\n+\tif (process.platform === 'win32' && parseInt(process.versions.node, 10) < 8) {\n+\t\thasReliableStdIO = false;\n+\t}\n+};\n+\n+exports.assert = (t, logFile, buffer, stripOptions) => {\n+\tlet existing = null;\n+\ttry {\n+\t\texisting = fs.readFileSync(logFile);\n+\t} catch (err) {}\n+\tif (existing === null || process.env.UPDATE_REPORTER_LOG) {\n+\t\tfs.writeFileSync(logFile, buffer);\n+\t\texisting = buffer;\n+\t}\n+\n+\tlet expected = existing.toString('utf8');\n+\t// At least in Appveyor with Node.js 6, IPC can overtake stdout/stderr. This\n+\t// causes the reporter to emit in a different order, resulting in a test\n+\t// failure. \"Fix\" by not asserting on the stdout/stderr reporting at all.\n+\tif (stripOptions.stripStdIO && !hasReliableStdIO) {\n+\t\texpected = expected.replace(/(---tty-stream-chunk-separator\\n)(stderr|stdout)\\n/g, stripOptions.alsoStripSeparator ? '' : '$1');\n+\t}\n+\n+\tconst actual = buffer.toString('utf8');\n+\tif (actual === expected) {\n+\t\tt.pass();\n+\t} else {\n+\t\t// Log the entire actual and expected values, so they can be diffed\n+\t\t// manually. TAP's diff output is really confusing in this situation.\n+\t\tconsole.dir({actual, expected});\n+\t\tt.fail('Output did not match expectation');\n+\t}\n+};\n+\n+exports.sanitizers = {\n+\tcwd: str => replaceString(str, process.cwd(), '~'),\n+\tposix: str => replaceString(str, '\\\\', '/'),\n+\tslow: str => str.replace(/(slow.+?)\\(\\d+m?s\\)/g, '$1 (000ms)'),\n+\t// At least in Appveyor with Node.js 6, IPC can overtake stdout/stderr. This\n+\t// causes the reporter to emit in a different order, resulting in a test\n+\t// failure. \"Fix\" by not asserting on the stdout/stderr reporting at all.\n+\tunreliableProcessIO(str) {\n+\t\tif (hasReliableStdIO) {\n+\t\t\treturn str;\n+\t\t}\n+\t\treturn str === 'stdout\\n' || str === 'stderr\\n' ? '' : str;\n+\t}\n+};\n+\n+const run = (type, reporter) => {\n+\tconst projectDir = path.join(__dirname, '../fixture/report', type.toLowerCase());\n+\n+\tconst api = createApi({\n+\t\tfailFast: type === 'failFast' || type === 'failFast2',\n+\t\tfailWithoutAssertions: false,\n+\t\tserial: type === 'failFast' || type === 'failFast2',\n+\t\trequire: [],\n+\t\tcacheEnable: true,\n+\t\tcompileEnhancements: true,\n+\t\tmatch: [],\n+\t\tbabelConfig: {testOptions: {}},\n+\t\tresolveTestsFrom: projectDir,\n+\t\tprojectDir,\n+\t\ttimeout: undefined,\n+\t\tconcurrency: 1,\n+\t\tupdateSnapshots: false,\n+\t\tsnapshotDir: false,\n+\t\tcolor: true\n+\t});\n+\n+\tapi.on('run', plan => reporter.startRun(plan));\n+\n+\tconst files = globby.sync('*.js', {cwd: projectDir}).sort();\n+\tif (type !== 'watch') {\n+\t\treturn api.run(files).then(() => {\n+\t\t\treporter.endRun();\n+\t\t});\n+\t}\n+\n+\t// Mimick watch mode\n+\treturn api.run(files, {clearLogOnNextRun: false, previousFailures: 0, runVector: 1}).then(() => {\n+\t\treporter.endRun();\n+\t\treturn api.run(files, {clearLogOnNextRun: true, previousFailures: 2, runVector: 2});\n+\t}).then(() => {\n+\t\treporter.endRun();\n+\t\treturn api.run(files, {clearLogOnNextRun: false, previousFailures: 0, runVector: 3});\n+\t}).then(() => {\n+\t\treporter.endRun();\n+\t});\n+};\n+\n+exports.regular = reporter => run('regular', reporter);\n+exports.failFast = reporter => run('failFast', reporter);\n+exports.failFast2 = reporter => run('failFast2', reporter);\n+exports.only = reporter => run('only', reporter);\n+exports.watch = reporter => run('watch', reporter);"
      },
      {
        "sha": "eb3d317063cb5e42e42f295efacef298bf6161b0",
        "filename": "test/helper/tty-stream.js",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fhelper%2Ftty-stream.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fhelper%2Ftty-stream.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fhelper%2Ftty-stream.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,66 @@\n+'use strict';\n+const stream = require('stream');\n+const ansiEscapes = require('ansi-escapes');\n+\n+class TTYStream extends stream.Writable {\n+\tconstructor(options) {\n+\t\tsuper();\n+\n+\t\tthis.isTTY = true;\n+\t\tthis.columns = options.columns;\n+\n+\t\tthis.sanitizers = options.sanitizers || [];\n+\t\tthis.chunks = [];\n+\t\tthis.spinnerActivity = [];\n+\t}\n+\n+\t_write(chunk, encoding, callback) {\n+\t\tif (this.spinnerActivity.length > 0) {\n+\t\t\tthis.chunks.push(Buffer.concat(this.spinnerActivity), TTYStream.SEPARATOR);\n+\t\t\tthis.spinnerActivity = [];\n+\t\t}\n+\n+\t\tconst str = this.sanitizers.reduce((str, sanitizer) => sanitizer(str), chunk.toString('utf8'));\n+\t\t// Ignore the chunk if it was scrubbed completely. Still count 0-length\n+\t\t// chunks.\n+\t\tif (str !== '' || chunk.length === 0) {\n+\t\t\tthis.chunks.push(\n+\t\t\t\tBuffer.from(str, 'utf8'),\n+\t\t\t\tTTYStream.SEPARATOR\n+\t\t\t);\n+\t\t}\n+\t\tcallback();\n+\t}\n+\n+\t_writev(chunks, callback) {\n+\t\tif (this.spinnerActivity.length > 0) {\n+\t\t\tthis.chunks.push(Buffer.concat(this.spinnerActivity), TTYStream.SEPARATOR);\n+\t\t\tthis.spinnerActivity = [];\n+\t\t}\n+\t\tfor (const obj of chunks) {\n+\t\t\tthis.chunks.push(Buffer.from(this.sanitizers.reduce((str, sanitizer) => sanitizer(str), obj.chunk.toString('utf8')), 'utf8'));\n+\t\t}\n+\t\tthis.chunks.push(TTYStream.SEPARATOR);\n+\t\tcallback();\n+\t}\n+\n+\tasBuffer() {\n+\t\treturn Buffer.concat(this.chunks);\n+\t}\n+\n+\tclearLine() {\n+\t\tthis.spinnerActivity.push(Buffer.from(ansiEscapes.eraseLine, 'ascii'));\n+\t}\n+\n+\tcursorTo(x, y) {\n+\t\tthis.spinnerActivity.push(Buffer.from(ansiEscapes.cursorTo(x, y), 'ascii'));\n+\t}\n+\n+\tmoveCursor(dx, dy) {\n+\t\tthis.spinnerActivity.push(Buffer.from(ansiEscapes.cursorMove(dx, dy), 'ascii'));\n+\t}\n+}\n+\n+TTYStream.SEPARATOR = Buffer.from('---tty-stream-chunk-separator\\n', 'utf8');\n+\n+module.exports = TTYStream;"
      },
      {
        "sha": "31e511d842d723685629387797ee225ddba66dcc",
        "filename": "test/hooks.js",
        "status": "modified",
        "additions": 46,
        "deletions": 70,
        "changes": 116,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fhooks.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fhooks.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fhooks.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,38 +1,13 @@\n 'use strict';\n-require('../lib/worker-options').set({});\n+require('../lib/chalk').set();\n+require('../lib/worker/options').set({});\n \n-const path = require('path');\n const test = require('tap').test;\n const Runner = require('../lib/runner');\n-const _fork = require('../lib/fork.js');\n-const CachingPrecompiler = require('../lib/caching-precompiler');\n-\n-const cacheDir = path.join(__dirname, '../node_modules/.cache/ava');\n-const precompiler = new CachingPrecompiler({\n-\tbabelCacheKeys: {},\n-\tgetBabelOptions() {\n-\t\treturn {\n-\t\t\tbabelrc: false,\n-\t\t\tpresets: [require.resolve('@ava/babel-preset-stage-4')]\n-\t\t};\n-\t},\n-\tpath: cacheDir\n-});\n-\n-function fork(testPath) {\n-\tconst hash = precompiler.precompileFile(testPath);\n-\tconst precompiled = {};\n-\tprecompiled[testPath] = hash;\n-\n-\treturn _fork(testPath, {\n-\t\tcacheDir,\n-\t\tprecompiled\n-\t});\n-}\n \n const promiseEnd = (runner, next) => {\n \treturn new Promise(resolve => {\n-\t\trunner.on('start', data => resolve(data.ended));\n+\t\tresolve(runner.once('finish'));\n \t\tnext(runner);\n \t}).then(() => runner);\n };\n@@ -56,10 +31,16 @@ test('before', t => {\n });\n \n test('after', t => {\n-\tt.plan(3);\n+\tt.plan(2);\n \n \tconst arr = [];\n \treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'test-passed') {\n+\t\t\t\tt.pass();\n+\t\t\t}\n+\t\t});\n+\n \t\trunner.chain.after(() => {\n \t\t\tarr.push('b');\n \t\t});\n@@ -68,47 +49,53 @@ test('after', t => {\n \t\t\ta.pass();\n \t\t\tarr.push('a');\n \t\t});\n-\t}).then(runner => {\n-\t\tt.is(runner.stats.passCount, 1);\n-\t\tt.is(runner.stats.failCount, 0);\n+\t}).then(() => {\n \t\tt.strictDeepEqual(arr, ['a', 'b']);\n \t});\n });\n \n test('after not run if test failed', t => {\n-\tt.plan(3);\n+\tt.plan(2);\n \n \tconst arr = [];\n \treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'test-failed') {\n+\t\t\t\tt.pass();\n+\t\t\t}\n+\t\t});\n+\n \t\trunner.chain.after(() => {\n \t\t\tarr.push('a');\n \t\t});\n \n \t\trunner.chain('test', () => {\n \t\t\tthrow new Error('something went wrong');\n \t\t});\n-\t}).then(runner => {\n-\t\tt.is(runner.stats.passCount, 0);\n-\t\tt.is(runner.stats.failCount, 1);\n+\t}).then(() => {\n \t\tt.strictDeepEqual(arr, []);\n \t});\n });\n \n test('after.always run even if test failed', t => {\n-\tt.plan(3);\n+\tt.plan(2);\n \n \tconst arr = [];\n \treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'test-failed') {\n+\t\t\t\tt.pass();\n+\t\t\t}\n+\t\t});\n+\n \t\trunner.chain.after.always(() => {\n \t\t\tarr.push('a');\n \t\t});\n \n \t\trunner.chain('test', () => {\n \t\t\tthrow new Error('something went wrong');\n \t\t});\n-\t}).then(runner => {\n-\t\tt.is(runner.stats.passCount, 0);\n-\t\tt.is(runner.stats.failCount, 1);\n+\t}).then(() => {\n \t\tt.strictDeepEqual(arr, ['a']);\n \t});\n });\n@@ -217,6 +204,12 @@ test('fail if beforeEach hook fails', t => {\n \n \tconst arr = [];\n \treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'hook-failed') {\n+\t\t\t\tt.pass();\n+\t\t\t}\n+\t\t});\n+\n \t\trunner.chain.beforeEach(a => {\n \t\t\tarr.push('a');\n \t\t\ta.fail();\n@@ -226,8 +219,7 @@ test('fail if beforeEach hook fails', t => {\n \t\t\tarr.push('b');\n \t\t\ta.pass();\n \t\t});\n-\t}).then(runner => {\n-\t\tt.is(runner.stats.failedHookCount, 1);\n+\t}).then(() => {\n \t\tt.strictDeepEqual(arr, ['a']);\n \t});\n });\n@@ -410,9 +402,13 @@ test('ensure hooks run only around tests', t => {\n });\n \n test('shared context', t => {\n-\tt.plan(1);\n-\n \treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'hook-failed' || evt.type === 'test-failed') {\n+\t\t\t\tt.fail();\n+\t\t\t}\n+\t\t});\n+\n \t\trunner.chain.before(a => {\n \t\t\ta.deepEqual(a.context, {});\n \t\t\ta.context.arr = ['a'];\n@@ -445,15 +441,17 @@ test('shared context', t => {\n \t\t\ta.is(a.context.prop, 'test');\n \t\t\ta.context.prop = 'afterEach';\n \t\t});\n-\t}).then(runner => {\n-\t\tt.is(runner.stats.failCount, 0);\n \t});\n });\n \n test('shared context of any type', t => {\n-\tt.plan(1);\n-\n \treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.on('stateChange', evt => {\n+\t\t\tif (evt.type === 'hook-failed' || evt.type === 'test-failed') {\n+\t\t\t\tt.fail();\n+\t\t\t}\n+\t\t});\n+\n \t\trunner.chain.beforeEach(a => {\n \t\t\ta.context = 'foo';\n \t\t});\n@@ -462,27 +460,5 @@ test('shared context of any type', t => {\n \t\t\ta.pass();\n \t\t\ta.is(a.context, 'foo');\n \t\t});\n-\t}).then(runner => {\n-\t\tt.is(runner.stats.failCount, 0);\n \t});\n });\n-\n-test('don\\'t display hook title if it did not fail', t => {\n-\tt.plan(2);\n-\n-\treturn fork(path.join(__dirname, 'fixture/hooks-passing.js'))\n-\t\t.on('test', test => {\n-\t\t\tt.strictDeepEqual(test.error, null);\n-\t\t\tt.is(test.title, 'pass');\n-\t\t});\n-});\n-\n-test('display hook title if it failed', t => {\n-\tt.plan(2);\n-\n-\treturn fork(path.join(__dirname, 'fixture/hooks-failing.js'))\n-\t\t.on('test', test => {\n-\t\t\tt.is(test.error.name, 'AssertionError');\n-\t\t\tt.is(test.title, 'beforeEach hook for pass');\n-\t\t});\n-});"
      },
      {
        "sha": "aa4723e1bce8d48912192ae4a18281cb8b535544",
        "filename": "test/logger.js",
        "status": "removed",
        "additions": 0,
        "deletions": 167,
        "changes": 167,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Flogger.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Flogger.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Flogger.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,167 +0,0 @@\n-'use strict';\n-const test = require('tap').test;\n-const Logger = require('../lib/logger');\n-const TapReporter = require('../lib/reporters/tap');\n-\n-test('only call start if supported by reporter', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.start = undefined;\n-\tlogger.start();\n-\tt.end();\n-});\n-\n-test('only write if start is supported by reporter', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.start = undefined;\n-\tlogger.write = t.fail;\n-\tlogger.start();\n-\tt.end();\n-});\n-\n-test('only call reset if supported by reporter', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.reset = undefined;\n-\tlogger.reset();\n-\tt.end();\n-});\n-\n-test('only write if reset is supported by reporter', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.reset = undefined;\n-\tlogger.write = t.fail;\n-\tlogger.reset();\n-\tt.end();\n-});\n-\n-test('only call section if supported by reporter', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.section = undefined;\n-\tlogger.section();\n-\tt.end();\n-});\n-\n-test('only write if section is supported by reporter', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.section = undefined;\n-\tlogger.write = t.fail;\n-\tlogger.section();\n-\tt.end();\n-});\n-\n-test('only call clear if supported by reporter', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.clear = undefined;\n-\tlogger.clear();\n-\tt.end();\n-});\n-\n-test('only write if clear is supported by reporter', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.clear = undefined;\n-\tlogger.write = t.fail;\n-\tlogger.clear();\n-\tt.end();\n-});\n-\n-test('return false if clear is not supported by reporter', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.clear = undefined;\n-\tt.false(logger.clear());\n-\tt.end();\n-});\n-\n-test('return true if clear is supported by reporter', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.clear = () => {};\n-\tt.true(logger.clear());\n-\tt.end();\n-});\n-\n-test('writes the reporter reset result', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.reset = () => 'test reset';\n-\tlogger.write = str => {\n-\t\tt.equal(str, 'test reset');\n-\t\tt.end();\n-\t};\n-\tlogger.reset();\n-});\n-\n-test('only call unhandledError if supported by reporter', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.unhandledError = undefined;\n-\tlogger.unhandledError();\n-\tt.end();\n-});\n-\n-test('only write if unhandledError is supported by reporter', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.unhandledError = undefined;\n-\tlogger.write = t.fail;\n-\tlogger.unhandledError();\n-\tt.end();\n-});\n-\n-test('only call finish if supported by reporter', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.finish = undefined;\n-\tlogger.finish();\n-\tt.end();\n-});\n-\n-test('only write if finish is supported by reporter', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.finish = undefined;\n-\tlogger.write = t.fail;\n-\tlogger.finish();\n-\tt.end();\n-});\n-\n-test('only call write if supported by reporter', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.write = undefined;\n-\tlogger.write();\n-\tt.end();\n-});\n-\n-test('only call stdout if supported by reporter', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.stdout = undefined;\n-\tlogger.stdout();\n-\tt.end();\n-});\n-\n-test('don\\'t alter data when calling stdout', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.stdout = function (data) {\n-\t\tt.equal(data, 'test data');\n-\t\tt.end();\n-\t};\n-\tlogger.stdout('test data');\n-});\n-\n-test('only call stderr if supported by reporter', t => {\n-\tconst tapReporter = new TapReporter();\n-\tconst logger = new Logger(tapReporter);\n-\ttapReporter.stderr = undefined;\n-\tlogger.stderr();\n-\tt.end();\n-});"
      },
      {
        "sha": "7ce179bc99731b0cc41481976c44112534005b50",
        "filename": "test/observable.js",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fobservable.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fobservable.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fobservable.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,5 +1,6 @@\n 'use strict';\n-require('../lib/worker-options').set({});\n+require('../lib/chalk').set();\n+require('../lib/worker/options').set({});\n \n const test = require('tap').test;\n const Test = require('../lib/test');"
      },
      {
        "sha": "7d7a3d50b9e442ce06c767e050b36e5cf051ef3c",
        "filename": "test/promise.js",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fpromise.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Fpromise.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fpromise.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,5 +1,6 @@\n 'use strict';\n-require('../lib/worker-options').set({color: false});\n+require('../lib/chalk').set();\n+require('../lib/worker/options').set({color: false});\n \n const Promise = require('bluebird');\n const test = require('tap').test;"
      },
      {
        "sha": "bb971c11fb606f67aef1ee47dba949056600c668",
        "filename": "test/reporters/format-serialized-error.js",
        "status": "removed",
        "additions": 0,
        "deletions": 130,
        "changes": 130,
        "blob_url": "https://github.com/avajs/ava/blob/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Freporters%2Fformat-serialized-error.js",
        "raw_url": "https://github.com/avajs/ava/raw/c41efb0203c9fca6309df5f4bf5d347b4b66f6d3/test%2Freporters%2Fformat-serialized-error.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Freporters%2Fformat-serialized-error.js?ref=c41efb0203c9fca6309df5f4bf5d347b4b66f6d3",
        "patch": "@@ -1,130 +0,0 @@\n-'use strict';\n-const chalk = require('chalk');\n-const concordance = require('concordance');\n-const test = require('tap').test;\n-const formatSerializedError = require('../../lib/reporters/format-serialized-error');\n-\n-test('indicates message should not be printed if it is empty', t => {\n-\tconst err = {\n-\t\tmessage: '',\n-\t\tstatements: [],\n-\t\tvalues: [{label: '', formatted: ''}]\n-\t};\n-\tt.false(formatSerializedError(err).printMessage);\n-\tt.end();\n-});\n-\n-test('indicates message should not be printed if the first value label starts with the message', t => {\n-\tconst err = {\n-\t\tmessage: 'foo',\n-\t\tstatements: [],\n-\t\tvalues: [{label: 'foobar', formatted: ''}]\n-\t};\n-\tt.false(formatSerializedError(err).printMessage);\n-\tt.end();\n-});\n-\n-test('indicates message should be printed if not empty and the first value label does not start with the message', t => {\n-\tconst err = {\n-\t\tmessage: 'foo',\n-\t\tstatements: [],\n-\t\tvalues: [{label: 'barfoo', formatted: ''}]\n-\t};\n-\tt.true(formatSerializedError(err).printMessage);\n-\tt.end();\n-});\n-\n-test('print multiple values', t => {\n-\tconst err = {\n-\t\tstatements: [],\n-\t\tvalues: [\n-\t\t\t{\n-\t\t\t\tlabel: 'Actual:',\n-\t\t\t\tformatted: concordance.format([1, 2, 3])\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tlabel: 'Expected:',\n-\t\t\t\tformatted: concordance.format({a: 1, b: 2, c: 3})\n-\t\t\t}\n-\t\t]\n-\t};\n-\n-\tt.is(formatSerializedError(err).formatted, [\n-\t\t'Actual:\\n',\n-\t\t`${err.values[0].formatted}\\n`,\n-\t\t'Expected:\\n',\n-\t\terr.values[1].formatted\n-\t].join('\\n'));\n-\tt.end();\n-});\n-\n-test('print single value', t => {\n-\tconst err = {\n-\t\tstatements: [],\n-\t\tvalues: [\n-\t\t\t{\n-\t\t\t\tlabel: 'Actual:',\n-\t\t\t\tformatted: concordance.format([1, 2, 3])\n-\t\t\t}\n-\t\t]\n-\t};\n-\n-\tt.is(formatSerializedError(err).formatted, [\n-\t\t'Actual:\\n',\n-\t\terr.values[0].formatted\n-\t].join('\\n'));\n-\tt.end();\n-});\n-\n-test('print multiple statements', t => {\n-\tconst err = {\n-\t\tstatements: [\n-\t\t\t['actual.a[0]', concordance.format(1)],\n-\t\t\t['actual.a', concordance.format([1])],\n-\t\t\t['actual', concordance.format({a: [1]})]\n-\t\t],\n-\t\tvalues: []\n-\t};\n-\n-\tt.is(formatSerializedError(err).formatted, [\n-\t\t`actual.a[0]\\n${chalk.grey('=>')} ${concordance.format(1)}`,\n-\t\t`actual.a\\n${chalk.grey('=>')} ${concordance.format([1])}`,\n-\t\t`actual\\n${chalk.grey('=>')} ${concordance.format({a: [1]})}`\n-\t].join('\\n\\n'));\n-\tt.end();\n-});\n-\n-test('print single statement', t => {\n-\tconst err = {\n-\t\tstatements: [\n-\t\t\t['actual.a[0]', concordance.format(1)]\n-\t\t],\n-\t\tvalues: []\n-\t};\n-\n-\tt.is(formatSerializedError(err).formatted, [\n-\t\t`actual.a[0]\\n${chalk.grey('=>')} ${concordance.format(1)}`\n-\t].join('\\n\\n'));\n-\tt.end();\n-});\n-\n-test('print statements after values', t => {\n-\tconst err = {\n-\t\tstatements: [\n-\t\t\t['actual.a[0]', concordance.format(1)]\n-\t\t],\n-\t\tvalues: [\n-\t\t\t{\n-\t\t\t\tlabel: 'Actual:',\n-\t\t\t\tformatted: concordance.format([1, 2, 3])\n-\t\t\t}\n-\t\t]\n-\t};\n-\n-\tt.is(formatSerializedError(err).formatted, [\n-\t\t'Actual:',\n-\t\t`${err.values[0].formatted}`,\n-\t\t`actual.a[0]\\n${chalk.grey('=>')} ${concordance.format(1)}`\n-\t].join('\\n\\n'));\n-\tt.end();\n-});"
      },
      {
        "sha": "190d87de0f417df9357a1ca444c59c8f39da5e4b",
        "filename": "test/reporters/improper-usage-messages.js",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Freporters%2Fimproper-usage-messages.js",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Freporters%2Fimproper-usage-messages.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Freporters%2Fimproper-usage-messages.js?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -1,4 +1,6 @@\n 'use strict';\n+require('../../lib/chalk').set();\n+\n const test = require('tap').test;\n const improperUsageMessages = require('../../lib/reporters/improper-usage-messages');\n "
      },
      {
        "sha": "f40158c7958c8fafaa3549067dc2d55dd37c6049",
        "filename": "test/reporters/mini.failfast.log",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Freporters%2Fmini.failfast.log",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Freporters%2Fmini.failfast.log",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Freporters%2Fmini.failfast.log?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,27 @@\n+\u001b[?25l---tty-stream-chunk-separator\n+\n+---tty-stream-chunk-separator\n+* ---tty-stream-chunk-separator\n+\u001b[2K\u001b[1G---tty-stream-chunk-separator\n+* a \u001b[90m\u001b[2m›\u001b[22m\u001b[39m fails\n+\n+  \u001b[31m1 test failed\u001b[39m---tty-stream-chunk-separator\n+\u001b[2K\u001b[1G\u001b[1A\u001b[2K\u001b[1G\u001b[1A\u001b[2K\u001b[1G---tty-stream-chunk-separator\n+\u001b[?25h\n+  \u001b[31m1 test failed\u001b[39m\n+\n+  \u001b[1m\u001b[37ma \u001b[90m\u001b[2m›\u001b[1m\u001b[37m fails\u001b[39m\u001b[22m\n+\n+  \u001b[90m~/test/fixture/report/failfast/a.js:3\u001b[39m\n+\n+   \u001b[90m2:\u001b[39m                              \n+  \u001b[41m 3: test('fails', t => t.fail());\u001b[49m\n+   \u001b[90m4:\u001b[39m                              \n+\n+  Test failed via `t.fail()`\n+\n+\n+\n+  \u001b[35m`--fail-fast` is on. 1 test file was skipped.\u001b[39m\n+\n+---tty-stream-chunk-separator"
      },
      {
        "sha": "e08e380f4de78e19b56e49c7223dc7bb9887404f",
        "filename": "test/reporters/mini.failfast2.log",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/avajs/ava/blob/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Freporters%2Fmini.failfast2.log",
        "raw_url": "https://github.com/avajs/ava/raw/348a794ff123391389b9a0fed7e362c6aea1722d/test%2Freporters%2Fmini.failfast2.log",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Freporters%2Fmini.failfast2.log?ref=348a794ff123391389b9a0fed7e362c6aea1722d",
        "patch": "@@ -0,0 +1,27 @@\n+\u001b[?25l---tty-stream-chunk-separator\n+\n+---tty-stream-chunk-separator\n+* ---tty-stream-chunk-separator\n+\u001b[2K\u001b[1G---tty-stream-chunk-separator\n+* a \u001b[90m\u001b[2m›\u001b[22m\u001b[39m fails\n+\n+  \u001b[31m1 test failed\u001b[39m---tty-stream-chunk-separator\n+\u001b[2K\u001b[1G\u001b[1A\u001b[2K\u001b[1G\u001b[1A\u001b[2K\u001b[1G---tty-stream-chunk-separator\n+\u001b[?25h\n+  \u001b[31m1 test failed\u001b[39m\n+\n+  \u001b[1m\u001b[37ma \u001b[90m\u001b[2m›\u001b[1m\u001b[37m fails\u001b[39m\u001b[22m\n+\n+  \u001b[90m~/test/fixture/report/failfast2/a.js:3\u001b[39m\n+\n+   \u001b[90m2:\u001b[39m                               \n+  \u001b[41m 3: test('fails', t => t.fail()); \u001b[49m\n+   \u001b[90m4:\u001b[39m test('passes', t => t.pass());\n+\n+  Test failed via `t.fail()`\n+\n+\n+\n+  \u001b[35m`--fail-fast` is on. At least 1 test was skipped, as well as 1 test file.\u001b[39m\n+\n+---tty-stream-chunk-separator"
      }
    ]
  },
  {
    "url": "https://api.github.com/repos/avajs/ava/issues/1693",
    "repository_url": "https://api.github.com/repos/avajs/ava",
    "labels_url": "https://api.github.com/repos/avajs/ava/issues/1693/labels{/name}",
    "comments_url": "https://api.github.com/repos/avajs/ava/issues/1693/comments",
    "events_url": "https://api.github.com/repos/avajs/ava/issues/1693/events",
    "html_url": "https://github.com/avajs/ava/pull/1693",
    "id": 294851336,
    "node_id": "MDExOlB1bGxSZXF1ZXN0MTY3NDgzNDA3",
    "number": 1693,
    "title": "Refactor how test files are told to run their tests, and more",
    "user": {
      "login": "novemberborn",
      "id": 33538,
      "node_id": "MDQ6VXNlcjMzNTM4",
      "avatar_url": "https://avatars.githubusercontent.com/u/33538?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/novemberborn",
      "html_url": "https://github.com/novemberborn",
      "followers_url": "https://api.github.com/users/novemberborn/followers",
      "following_url": "https://api.github.com/users/novemberborn/following{/other_user}",
      "gists_url": "https://api.github.com/users/novemberborn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/novemberborn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/novemberborn/subscriptions",
      "organizations_url": "https://api.github.com/users/novemberborn/orgs",
      "repos_url": "https://api.github.com/users/novemberborn/repos",
      "events_url": "https://api.github.com/users/novemberborn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/novemberborn/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2018-02-06T17:44:23Z",
    "updated_at": "2018-02-11T18:55:30Z",
    "closed_at": "2018-02-11T16:12:30Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "draft": false,
    "pull_request": {
      "url": "https://api.github.com/repos/avajs/ava/pulls/1693",
      "html_url": "https://github.com/avajs/ava/pull/1693",
      "diff_url": "https://github.com/avajs/ava/pull/1693.diff",
      "patch_url": "https://github.com/avajs/ava/pull/1693.patch",
      "merged_at": "2018-02-11T16:12:29Z"
    },
    "body": "Apologies, this is a big one! See the commits for details, but the highlights are:\r\n\r\n* Remove cruft remaining from when we switched to *always* using the limited concurrency mode.\r\n* The cache directory is now always relative to the project directory. Previously another unnecessary path lookup was done, which I think may have resulted in different cache paths if there were `package.json` files at different levels of the project.\r\n* Compile all test and helpers files before running any test. This doesn't improve time-to-first-test but it does mean that test files can depend on each other. AVA will correctly load the precompiled file. No tests are run if any file fails to compile.\r\n* The real file path is passed to the precompiler.\r\n* `execArgv` is computed when running a test file, not all at once for all files.\r\n* `--fail-fast` now works with limited concurrency mode, preventing new test files from being run. It also fails fast after a timeout or if a test file crashed. This is part of the work needed for #1158.\r\n* The mini and verbose reporters print the number of untested files after `--fail-fast`.\r\n* Improved output for unhandled rejections / uncaught exceptions in the mini and verbose reporters.\r\n* Test runners will now run tests as soon as (in the next tick) they're declared. The main process no longer instructs the workers to startrunning tests. Fixes #1674.",
    "reactions": {
      "url": "https://api.github.com/repos/avajs/ava/issues/1693/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/avajs/ava/issues/1693/timeline",
    "performed_via_github_app": null,
    "state_reason": null,
    "score": 1,
    "files": [
      {
        "sha": "52feef3fbaeb819a26ea8f897c71203e18f89816",
        "filename": "api.js",
        "status": "modified",
        "additions": 188,
        "deletions": 207,
        "changes": 395,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/api.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/api.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/api.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -5,12 +5,10 @@ const fs = require('fs');\n const os = require('os');\n const commonPathPrefix = require('common-path-prefix');\n const uniqueTempDir = require('unique-temp-dir');\n-const findCacheDir = require('find-cache-dir');\n const isCi = require('is-ci');\n const resolveCwd = require('resolve-cwd');\n const debounce = require('lodash.debounce');\n-const autoBind = require('auto-bind');\n-const Promise = require('bluebird');\n+const Bluebird = require('bluebird');\n const getPort = require('get-port');\n const arrify = require('arrify');\n const ms = require('ms');\n@@ -33,167 +31,214 @@ function resolveModules(modules) {\n \t});\n }\n \n-function getBlankResults() {\n-\treturn {\n-\t\tstats: {\n-\t\t\tknownFailureCount: 0,\n-\t\t\ttestCount: 0,\n-\t\t\tpassCount: 0,\n-\t\t\tskipCount: 0,\n-\t\t\ttodoCount: 0,\n-\t\t\tfailCount: 0\n-\t\t},\n-\t\ttests: []\n-\t};\n-}\n-\n class Api extends EventEmitter {\n \tconstructor(options) {\n \t\tsuper();\n-\t\tautoBind(this);\n \n \t\tthis.options = Object.assign({match: []}, options);\n \t\tthis.options.require = resolveModules(this.options.require);\n \t}\n \n-\t_runFile(file, runStatus, execArgv) {\n-\t\tconst precompiled = {};\n-\t\tif (this.precompiler) {\n-\t\t\tObject.assign(precompiled, this._precompiledHelpers);\n-\t\t\tconst hash = this.precompiler.precompileFile(file);\n-\t\t\tconst resolvedfpath = fs.realpathSync(file);\n-\t\t\tprecompiled[resolvedfpath] = hash;\n-\t\t}\n-\n-\t\tconst options = Object.assign({}, this.options, {precompiled});\n-\t\tif (runStatus.updateSnapshots) {\n-\t\t\t// Don't use in Object.assign() since it'll override options.updateSnapshots even when false.\n-\t\t\toptions.updateSnapshots = true;\n-\t\t}\n-\t\tconst emitter = fork(file, options, execArgv);\n-\t\trunStatus.observeFork(emitter);\n+\trun(files, runtimeOptions) {\n+\t\tconst apiOptions = this.options;\n+\t\truntimeOptions = runtimeOptions || {};\n \n-\t\treturn emitter;\n-\t}\n+\t\t// Each run will have its own status. It can only be created when test files\n+\t\t// have been found.\n+\t\tlet runStatus;\n \n-\trun(files, options) {\n-\t\treturn new AvaFiles({cwd: this.options.resolveTestsFrom, files})\n-\t\t\t.findTestFiles()\n-\t\t\t.then(files => this._run(files, options));\n-\t}\n+\t\t// Irrespectively, perform some setup now, before finding test files.\n+\t\tconst handleError = exception => {\n+\t\t\trunStatus.handleExceptions({\n+\t\t\t\texception,\n+\t\t\t\tfile: exception.file ? path.relative(process.cwd(), exception.file) : undefined\n+\t\t\t});\n+\t\t};\n+\n+\t\t// Track active forks and manage timeouts.\n+\t\tconst failFast = apiOptions.failFast === true;\n+\t\tlet bailed = false;\n+\t\tconst pendingForks = new Set();\n+\t\tlet restartTimer;\n+\t\tif (apiOptions.timeout) {\n+\t\t\tconst timeout = ms(apiOptions.timeout);\n+\n+\t\t\trestartTimer = debounce(() => {\n+\t\t\t\t// If failFast is active, prevent new test files from running after\n+\t\t\t\t// the current ones are exited.\n+\t\t\t\tif (failFast) {\n+\t\t\t\t\tbailed = true;\n+\t\t\t\t}\n \n-\t_onTimeout(runStatus) {\n-\t\tconst timeout = ms(this.options.timeout);\n-\t\tconst err = new AvaError(`Exited because no new tests completed within the last ${timeout}ms of inactivity`);\n-\t\tthis._handleError(runStatus, err);\n-\t\trunStatus.emit('timeout');\n-\t}\n+\t\t\t\tfor (const fork of pendingForks) {\n+\t\t\t\t\tfork.exit();\n+\t\t\t\t}\n \n-\t_setupTimeout(runStatus) {\n-\t\tconst timeout = ms(this.options.timeout);\n+\t\t\t\thandleError(new AvaError(`Exited because no new tests completed within the last ${timeout}ms of inactivity`));\n+\t\t\t}, timeout);\n+\t\t} else {\n+\t\t\trestartTimer = Object.assign(() => {}, {cancel() {}});\n+\t\t}\n \n-\t\trunStatus._restartTimer = debounce(() => {\n-\t\t\tthis._onTimeout(runStatus);\n-\t\t}, timeout);\n+\t\t// Find all test files.\n+\t\treturn new AvaFiles({cwd: apiOptions.resolveTestsFrom, files}).findTestFiles()\n+\t\t\t.then(files => {\n+\t\t\t\trunStatus = new RunStatus({\n+\t\t\t\t\trunOnlyExclusive: runtimeOptions.runOnlyExclusive,\n+\t\t\t\t\tprefixTitles: apiOptions.explicitTitles || files.length > 1,\n+\t\t\t\t\tbase: path.relative(process.cwd(), commonPathPrefix(files)) + path.sep,\n+\t\t\t\t\tfailFast,\n+\t\t\t\t\tfileCount: files.length,\n+\t\t\t\t\tupdateSnapshots: runtimeOptions.updateSnapshots\n+\t\t\t\t});\n \n-\t\trunStatus._restartTimer();\n-\t\trunStatus.on('test', runStatus._restartTimer);\n-\t}\n+\t\t\t\trunStatus.on('test', restartTimer);\n+\t\t\t\tif (failFast) {\n+\t\t\t\t\t// Prevent new test files from running once a test has failed.\n+\t\t\t\t\trunStatus.on('test', test => {\n+\t\t\t\t\t\tif (test.error) {\n+\t\t\t\t\t\t\tbailed = true;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tfor (const fork of pendingForks) {\n+\t\t\t\t\t\t\tfork.notifyOfPeerFailure();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});\n+\t\t\t\t}\n \n-\t_cancelTimeout(runStatus) {\n-\t\trunStatus._restartTimer.cancel();\n-\t}\n+\t\t\t\tthis.emit('test-run', runStatus, files);\n \n-\t_setupPrecompiler(files) {\n-\t\tconst isCacheEnabled = this.options.cacheEnabled !== false;\n-\t\tlet cacheDir = uniqueTempDir();\n+\t\t\t\t// Bail out early if no files were found.\n+\t\t\t\tif (files.length === 0) {\n+\t\t\t\t\thandleError(new AvaError('Couldn\\'t find any files to test'));\n+\t\t\t\t\treturn runStatus;\n+\t\t\t\t}\n \n-\t\tif (isCacheEnabled) {\n-\t\t\tconst foundDir = findCacheDir({\n-\t\t\t\tname: 'ava',\n-\t\t\t\tfiles\n+\t\t\t\t// Set up a fresh precompiler for each test run.\n+\t\t\t\treturn this._setupPrecompiler()\n+\t\t\t\t\t.then(precompilation => {\n+\t\t\t\t\t\tif (!precompilation) {\n+\t\t\t\t\t\t\treturn null;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Compile all test and helper files. Assumes the tests only load\n+\t\t\t\t\t\t// helpers from within the `resolveTestsFrom` directory. Without\n+\t\t\t\t\t\t// arguments this is the `projectDir`, else it's `process.cwd()`\n+\t\t\t\t\t\t// which may be nested too deeply.\n+\t\t\t\t\t\treturn new AvaFiles({cwd: this.options.resolveTestsFrom}).findTestHelpers().then(helpers => {\n+\t\t\t\t\t\t\treturn {\n+\t\t\t\t\t\t\t\tcacheDir: precompilation.cacheDir,\n+\t\t\t\t\t\t\t\tmap: files.concat(helpers).reduce((acc, file) => {\n+\t\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\t\tconst realpath = fs.realpathSync(file);\n+\t\t\t\t\t\t\t\t\t\tconst hash = precompilation.precompiler.precompileFile(realpath);\n+\t\t\t\t\t\t\t\t\t\tacc[realpath] = hash;\n+\t\t\t\t\t\t\t\t\t} catch (err) {\n+\t\t\t\t\t\t\t\t\t\tthrow Object.assign(err, {file});\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\treturn acc;\n+\t\t\t\t\t\t\t\t}, {})\n+\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t});\n+\t\t\t\t\t})\n+\t\t\t\t\t.then(precompilation => {\n+\t\t\t\t\t\t// Resolve the correct concurrency value.\n+\t\t\t\t\t\tlet concurrency = Math.min(os.cpus().length, isCi ? 2 : Infinity);\n+\t\t\t\t\t\tif (apiOptions.concurrency > 0) {\n+\t\t\t\t\t\t\tconcurrency = apiOptions.concurrency;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (apiOptions.serial) {\n+\t\t\t\t\t\t\tconcurrency = 1;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Try and run each file, limited by `concurrency`.\n+\t\t\t\t\t\treturn Bluebird.map(files, file => {\n+\t\t\t\t\t\t\t// No new files should be run once a test has timed out or failed,\n+\t\t\t\t\t\t\t// and failFast is enabled.\n+\t\t\t\t\t\t\tif (bailed) {\n+\t\t\t\t\t\t\t\treturn null;\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tlet forked;\n+\t\t\t\t\t\t\treturn Bluebird.resolve(\n+\t\t\t\t\t\t\t\tthis._computeForkExecArgv().then(execArgv => {\n+\t\t\t\t\t\t\t\t\tconst options = Object.assign({}, apiOptions, {\n+\t\t\t\t\t\t\t\t\t\t// If we're looking for matches, run every single test process in exclusive-only mode\n+\t\t\t\t\t\t\t\t\t\trunOnlyExclusive: apiOptions.match.length > 0 || runtimeOptions.runOnlyExclusive === true\n+\t\t\t\t\t\t\t\t\t});\n+\t\t\t\t\t\t\t\t\tif (precompilation) {\n+\t\t\t\t\t\t\t\t\t\toptions.cacheDir = precompilation.cacheDir;\n+\t\t\t\t\t\t\t\t\t\toptions.precompiled = precompilation.map;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\toptions.precompiled = {};\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tif (runtimeOptions.updateSnapshots) {\n+\t\t\t\t\t\t\t\t\t\t// Don't use in Object.assign() since it'll override options.updateSnapshots even when false.\n+\t\t\t\t\t\t\t\t\t\toptions.updateSnapshots = true;\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\tforked = fork(file, options, execArgv);\n+\t\t\t\t\t\t\t\t\tpendingForks.add(forked);\n+\t\t\t\t\t\t\t\t\trunStatus.observeFork(forked);\n+\t\t\t\t\t\t\t\t\trestartTimer();\n+\t\t\t\t\t\t\t\t\treturn forked;\n+\t\t\t\t\t\t\t\t}).catch(err => {\n+\t\t\t\t\t\t\t\t\t// Prevent new test files from running.\n+\t\t\t\t\t\t\t\t\tif (failFast) {\n+\t\t\t\t\t\t\t\t\t\tbailed = true;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\thandleError(Object.assign(err, {file}));\n+\t\t\t\t\t\t\t\t\treturn null;\n+\t\t\t\t\t\t\t\t})\n+\t\t\t\t\t\t\t).finally(() => {\n+\t\t\t\t\t\t\t\tpendingForks.delete(forked);\n+\t\t\t\t\t\t\t});\n+\t\t\t\t\t\t}, {concurrency});\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(err => {\n+\t\t\t\t\t\thandleError(err);\n+\t\t\t\t\t\treturn [];\n+\t\t\t\t\t})\n+\t\t\t\t\t.then(results => {\n+\t\t\t\t\t\trestartTimer.cancel();\n+\n+\t\t\t\t\t\t// Filter out undefined results (e.g. for files that were skipped after a timeout)\n+\t\t\t\t\t\tresults = results.filter(Boolean);\n+\t\t\t\t\t\tif (apiOptions.match.length > 0 && !runStatus.hasExclusive) {\n+\t\t\t\t\t\t\thandleError(new AvaError('Couldn\\'t find any matching tests'));\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\trunStatus.processResults(results);\n+\t\t\t\t\t\treturn runStatus;\n+\t\t\t\t\t});\n \t\t\t});\n-\t\t\tif (foundDir !== null) {\n-\t\t\t\tcacheDir = foundDir;\n-\t\t\t}\n-\t\t}\n+\t}\n \n-\t\tthis.options.cacheDir = cacheDir;\n+\t_setupPrecompiler() {\n+\t\tconst cacheDir = this.options.cacheEnabled === false ?\n+\t\t\tuniqueTempDir() :\n+\t\t\tpath.join(this.options.projectDir, 'node_modules', '.cache', 'ava');\n \n \t\tconst compileEnhancements = this.options.compileEnhancements !== false;\n \t\treturn babelConfigHelper.build(this.options.projectDir, cacheDir, this.options.babelConfig, compileEnhancements)\n \t\t\t.then(result => {\n-\t\t\t\tif (result) {\n-\t\t\t\t\tthis.precompiler = new CachingPrecompiler({\n+\t\t\t\treturn result ? {\n+\t\t\t\t\tcacheDir,\n+\t\t\t\t\tprecompiler: new CachingPrecompiler({\n \t\t\t\t\t\tpath: cacheDir,\n \t\t\t\t\t\tgetBabelOptions: result.getOptions,\n \t\t\t\t\t\tbabelCacheKeys: result.cacheKeys\n-\t\t\t\t\t});\n-\t\t\t\t}\n+\t\t\t\t\t})\n+\t\t\t\t} : null;\n \t\t\t});\n \t}\n \n-\t_precompileHelpers() {\n-\t\tthis._precompiledHelpers = {};\n-\t\tif (!this.precompiler) {\n-\t\t\treturn Promise.resolve();\n-\t\t}\n-\n-\t\t// Assumes the tests only load helpers from within the `resolveTestsFrom`\n-\t\t// directory. Without arguments this is the `projectDir`, else it's\n-\t\t// `process.cwd()` which may be nested too deeply. This will be solved\n-\t\t// as we implement RFC 001 and move helper compilation into the worker\n-\t\t// processes, avoiding the need for precompilation.\n-\t\treturn new AvaFiles({cwd: this.options.resolveTestsFrom})\n-\t\t\t.findTestHelpers()\n-\t\t\t.each(file => { // eslint-disable-line array-callback-return\n-\t\t\t\tconst hash = this.precompiler.precompileFile(file);\n-\t\t\t\tthis._precompiledHelpers[file] = hash;\n-\t\t\t});\n-\t}\n-\n-\t_run(files, options) {\n-\t\toptions = options || {};\n-\n-\t\tconst runStatus = new RunStatus({\n-\t\t\trunOnlyExclusive: options.runOnlyExclusive,\n-\t\t\tprefixTitles: this.options.explicitTitles || files.length > 1,\n-\t\t\tbase: path.relative(process.cwd(), commonPathPrefix(files)) + path.sep,\n-\t\t\tfailFast: this.options.failFast,\n-\t\t\tupdateSnapshots: options.updateSnapshots\n-\t\t});\n-\n-\t\tthis.emit('test-run', runStatus, files);\n-\n-\t\tif (files.length === 0) {\n-\t\t\tconst err = new AvaError('Couldn\\'t find any files to test');\n-\t\t\tthis._handleError(runStatus, err);\n-\t\t\treturn Promise.resolve(runStatus);\n+\t_computeForkExecArgv() {\n+\t\tconst execArgv = this.options.testOnlyExecArgv || process.execArgv;\n+\t\tif (execArgv.length === 0) {\n+\t\t\treturn Promise.resolve(execArgv);\n \t\t}\n \n-\t\treturn this._setupPrecompiler(files)\n-\t\t\t.then(() => this._precompileHelpers())\n-\t\t\t.then(() => {\n-\t\t\t\tif (this.options.timeout) {\n-\t\t\t\t\tthis._setupTimeout(runStatus);\n-\t\t\t\t}\n-\n-\t\t\t\tlet concurrency = Math.min(os.cpus().length, isCi ? 2 : Infinity);\n-\n-\t\t\t\tif (this.options.concurrency > 0) {\n-\t\t\t\t\tconcurrency = this.options.concurrency;\n-\t\t\t\t}\n-\n-\t\t\t\tif (this.options.serial) {\n-\t\t\t\t\tconcurrency = 1;\n-\t\t\t\t}\n-\n-\t\t\t\treturn this._runWithPool(files, runStatus, concurrency);\n-\t\t\t});\n-\t}\n-\n-\t_computeForkExecArgs(files) {\n-\t\tconst execArgv = this.options.testOnlyExecArgv || process.execArgv;\n \t\tlet debugArgIndex = -1;\n \n \t\t// --inspect-brk is used in addition to --inspect to break on first line and wait\n@@ -219,85 +264,21 @@ class Api extends EventEmitter {\n \t\t}\n \n \t\tif (debugArgIndex === -1) {\n-\t\t\treturn Promise.resolve([]);\n+\t\t\treturn Promise.resolve(execArgv);\n \t\t}\n \n-\t\treturn Promise\n-\t\t\t.map(files, () => getPort())\n-\t\t\t.map(port => {\n-\t\t\t\tconst forkExecArgv = execArgv.slice();\n-\t\t\t\tlet flagName = isInspect ? '--inspect' : '--debug';\n-\t\t\t\tconst oldValue = forkExecArgv[debugArgIndex];\n-\t\t\t\tif (oldValue.indexOf('brk') > 0) {\n-\t\t\t\t\tflagName += '-brk';\n-\t\t\t\t}\n-\n-\t\t\t\tforkExecArgv[debugArgIndex] = `${flagName}=${port}`;\n-\n-\t\t\t\treturn forkExecArgv;\n-\t\t\t});\n-\t}\n-\n-\t_handleError(runStatus, err) {\n-\t\trunStatus.handleExceptions({\n-\t\t\texception: err,\n-\t\t\tfile: err.file ? path.relative(process.cwd(), err.file) : undefined\n-\t\t});\n-\t}\n+\t\treturn getPort().then(port => {\n+\t\t\tconst forkExecArgv = execArgv.slice();\n+\t\t\tlet flagName = isInspect ? '--inspect' : '--debug';\n+\t\t\tconst oldValue = forkExecArgv[debugArgIndex];\n+\t\t\tif (oldValue.indexOf('brk') > 0) {\n+\t\t\t\tflagName += '-brk';\n+\t\t\t}\n \n-\t_runWithPool(files, runStatus, concurrency) {\n-\t\tconst tests = [];\n-\t\tlet execArgvList;\n+\t\t\tforkExecArgv[debugArgIndex] = `${flagName}=${port}`;\n \n-\t\trunStatus.on('timeout', () => {\n-\t\t\ttests.forEach(fork => {\n-\t\t\t\tfork.exit();\n-\t\t\t});\n+\t\t\treturn forkExecArgv;\n \t\t});\n-\n-\t\treturn this._computeForkExecArgs(files)\n-\t\t\t.then(argvList => {\n-\t\t\t\texecArgvList = argvList;\n-\t\t\t})\n-\t\t\t.return(files)\n-\t\t\t.map((file, index) => {\n-\t\t\t\treturn new Promise(resolve => {\n-\t\t\t\t\tconst forkArgs = execArgvList[index];\n-\t\t\t\t\tconst test = this._runFile(file, runStatus, forkArgs);\n-\t\t\t\t\ttests.push(test);\n-\n-\t\t\t\t\t// If we're looking for matches, run every single test process in exclusive-only mode\n-\t\t\t\t\tconst options = {\n-\t\t\t\t\t\trunOnlyExclusive: this.options.match.length > 0\n-\t\t\t\t\t};\n-\n-\t\t\t\t\tresolve(test.run(options));\n-\t\t\t\t}).catch(err => {\n-\t\t\t\t\terr.file = file;\n-\t\t\t\t\tthis._handleError(runStatus, err);\n-\t\t\t\t\treturn getBlankResults();\n-\t\t\t\t});\n-\t\t\t}, {concurrency})\n-\t\t\t.then(results => {\n-\t\t\t\t// Filter out undefined results (usually result of caught exceptions)\n-\t\t\t\tresults = results.filter(Boolean);\n-\n-\t\t\t\t// Cancel debounced _onTimeout() from firing\n-\t\t\t\tif (this.options.timeout) {\n-\t\t\t\t\tthis._cancelTimeout(runStatus);\n-\t\t\t\t}\n-\n-\t\t\t\tif (this.options.match.length > 0 && !runStatus.hasExclusive) {\n-\t\t\t\t\tresults = [];\n-\n-\t\t\t\t\tconst err = new AvaError('Couldn\\'t find any matching tests');\n-\t\t\t\t\tthis._handleError(runStatus, err);\n-\t\t\t\t}\n-\n-\t\t\t\trunStatus.processResults(results);\n-\n-\t\t\t\treturn runStatus;\n-\t\t\t});\n \t}\n }\n "
      },
      {
        "sha": "72c4a9e1b808051d84258b17afcc2dd69486b393",
        "filename": "index.d.ts",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/index.d.ts",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/index.d.ts",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/index.d.ts?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -168,6 +168,10 @@ export interface SerialInterface<Context = {}> {\n \t(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n \t(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n \n+\tafter: AfterInterface<Context>;\n+\tafterEach: AfterInterface<Context>;\n+\tbefore: BeforeInterface<Context>;\n+\tbeforeEach: BeforeInterface<Context>;\n \tcb: CbInterface<Context>;\n \tfailing: FailingInterface<Context>;\n \tonly: OnlyInterface<Context>;"
      },
      {
        "sha": "6c460f9c687f133ec5e9853941568f415a6b495c",
        "filename": "index.js.flow",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/index.js.flow",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/index.js.flow",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/index.js.flow?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -171,6 +171,10 @@ export interface SerialInterface<Context = {}> {\n \t(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n \t(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n \n+\tafter: AfterInterface<Context>;\n+\tafterEach: AfterInterface<Context>;\n+\tbefore: BeforeInterface<Context>;\n+\tbeforeEach: BeforeInterface<Context>;\n \tcb: CbInterface<Context>;\n \tfailing: FailingInterface<Context>;\n \tonly: OnlyInterface<Context>;"
      },
      {
        "sha": "113d07335487e978ad4641c88e449c0a5bc100a7",
        "filename": "lib/concordance-options.js",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Fconcordance-options.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Fconcordance-options.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fconcordance-options.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -4,7 +4,7 @@ const chalk = require('chalk');\n const stripAnsi = require('strip-ansi');\n const cloneDeepWith = require('lodash.clonedeepwith');\n const reactPlugin = require('@concordance/react');\n-const options = require('./globals').options;\n+const options = require('./worker-options').get();\n \n // Wrap Concordance's React plugin. Change the name to avoid collisions if in\n // the future users can register plugins themselves."
      },
      {
        "sha": "3cdbb41c35b0536c1c8603ec3dcfdf316fb7694b",
        "filename": "lib/concurrent.js",
        "status": "removed",
        "additions": 0,
        "deletions": 64,
        "changes": 64,
        "blob_url": "https://github.com/avajs/ava/blob/51a0ff02d4c4dcb9036e7f56c0860dfee330e238/lib%2Fconcurrent.js",
        "raw_url": "https://github.com/avajs/ava/raw/51a0ff02d4c4dcb9036e7f56c0860dfee330e238/lib%2Fconcurrent.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fconcurrent.js?ref=51a0ff02d4c4dcb9036e7f56c0860dfee330e238",
        "patch": "@@ -1,64 +0,0 @@\n-'use strict';\n-\n-class Concurrent {\n-\tconstructor(runnables, bail) {\n-\t\tif (!Array.isArray(runnables)) {\n-\t\t\tthrow new TypeError('Expected an array of runnables');\n-\t\t}\n-\n-\t\tthis.runnables = runnables;\n-\t\tthis.bail = bail || false;\n-\t}\n-\n-\trun() {\n-\t\tlet allPassed = true;\n-\n-\t\tlet pending;\n-\t\tlet rejectPending;\n-\t\tlet resolvePending;\n-\t\tconst allPromises = [];\n-\t\tconst handlePromise = promise => {\n-\t\t\tif (!pending) {\n-\t\t\t\tpending = new Promise((resolve, reject) => {\n-\t\t\t\t\trejectPending = reject;\n-\t\t\t\t\tresolvePending = resolve;\n-\t\t\t\t});\n-\t\t\t}\n-\n-\t\t\tallPromises.push(promise.then(passed => {\n-\t\t\t\tif (!passed) {\n-\t\t\t\t\tallPassed = false;\n-\n-\t\t\t\t\tif (this.bail) {\n-\t\t\t\t\t\t// Stop if the test failed and bail mode is on.\n-\t\t\t\t\t\tresolvePending();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}, rejectPending));\n-\t\t};\n-\n-\t\tfor (const runnable of this.runnables) {\n-\t\t\tconst passedOrPromise = runnable.run();\n-\n-\t\t\tif (!passedOrPromise) {\n-\t\t\t\tif (this.bail) {\n-\t\t\t\t\t// Stop if the test failed and bail mode is on.\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\n-\t\t\t\tallPassed = false;\n-\t\t\t} else if (passedOrPromise !== true) {\n-\t\t\t\thandlePromise(passedOrPromise);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (pending) {\n-\t\t\tPromise.all(allPromises).then(resolvePending);\n-\t\t\treturn pending.then(() => allPassed);\n-\t\t}\n-\n-\t\treturn allPassed;\n-\t}\n-}\n-\n-module.exports = Concurrent;"
      },
      {
        "sha": "5529bfc3d284a2fd3512c22125ac1022ad1a5f66",
        "filename": "lib/context-ref.js",
        "status": "added",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Fcontext-ref.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Fcontext-ref.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fcontext-ref.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -0,0 +1,41 @@\n+'use strict';\n+const clone = require('lodash.clone');\n+\n+class ContextRef {\n+\tconstructor() {\n+\t\tthis.value = {};\n+\t}\n+\n+\tget() {\n+\t\treturn this.value;\n+\t}\n+\n+\tset(newValue) {\n+\t\tthis.value = newValue;\n+\t}\n+\n+\tcopy() {\n+\t\treturn new LateBinding(this); // eslint-disable-line no-use-before-define\n+\t}\n+}\n+module.exports = ContextRef;\n+\n+class LateBinding extends ContextRef {\n+\tconstructor(ref) {\n+\t\tsuper();\n+\t\tthis.ref = ref;\n+\t\tthis.bound = false;\n+\t}\n+\n+\tget() {\n+\t\tif (!this.bound) {\n+\t\t\tthis.set(clone(this.ref.get()));\n+\t\t}\n+\t\treturn super.get();\n+\t}\n+\n+\tset(newValue) {\n+\t\tthis.bound = true;\n+\t\tsuper.set(newValue);\n+\t}\n+}"
      },
      {
        "sha": "c303b9a59a334ef157e0bd90660ec3797156e927",
        "filename": "lib/create-chain.js",
        "status": "added",
        "additions": 108,
        "deletions": 0,
        "changes": 108,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Fcreate-chain.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Fcreate-chain.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fcreate-chain.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -0,0 +1,108 @@\n+'use strict';\n+const chainRegistry = new WeakMap();\n+\n+function startChain(name, call, defaults) {\n+\tconst fn = function () {\n+\t\tcall(Object.assign({}, defaults), Array.from(arguments));\n+\t};\n+\tObject.defineProperty(fn, 'name', {value: name});\n+\tchainRegistry.set(fn, {call, defaults, fullName: name});\n+\treturn fn;\n+}\n+\n+function extendChain(prev, name, flag) {\n+\tif (!flag) {\n+\t\tflag = name;\n+\t}\n+\n+\tconst fn = function () {\n+\t\tcallWithFlag(prev, flag, Array.from(arguments));\n+\t};\n+\tconst fullName = `${chainRegistry.get(prev).fullName}.${name}`;\n+\tObject.defineProperty(fn, 'name', {value: fullName});\n+\tprev[name] = fn;\n+\n+\tchainRegistry.set(fn, {flag, fullName, prev});\n+\treturn fn;\n+}\n+\n+function callWithFlag(prev, flag, args) {\n+\tconst combinedFlags = {[flag]: true};\n+\tdo {\n+\t\tconst step = chainRegistry.get(prev);\n+\t\tif (step.call) {\n+\t\t\tstep.call(Object.assign({}, step.defaults, combinedFlags), args);\n+\t\t\tprev = null;\n+\t\t} else {\n+\t\t\tcombinedFlags[step.flag] = true;\n+\t\t\tprev = step.prev;\n+\t\t}\n+\t} while (prev);\n+}\n+\n+function createHookChain(hook, isAfterHook) {\n+\t// Hook chaining rules:\n+\t// * `always` comes immediately after \"after hooks\"\n+\t// * `skip` must come at the end\n+\t// * no `only`\n+\t// * no repeating\n+\textendChain(hook, 'cb', 'callback');\n+\textendChain(hook, 'skip', 'skipped');\n+\textendChain(hook.cb, 'skip', 'skipped');\n+\tif (isAfterHook) {\n+\t\textendChain(hook, 'always');\n+\t\textendChain(hook.always, 'cb', 'callback');\n+\t\textendChain(hook.always, 'skip', 'skipped');\n+\t\textendChain(hook.always.cb, 'skip', 'skipped');\n+\t}\n+\treturn hook;\n+}\n+\n+function createChain(fn, defaults) {\n+\t// Test chaining rules:\n+\t// * `serial` must come at the start\n+\t// * `only` and `skip` must come at the end\n+\t// * `failing` must come at the end, but can be followed by `only` and `skip`\n+\t// * `only` and `skip` cannot be chained together\n+\t// * no repeating\n+\tconst root = startChain('test', fn, Object.assign({}, defaults, {type: 'test'}));\n+\textendChain(root, 'cb', 'callback');\n+\textendChain(root, 'failing');\n+\textendChain(root, 'only', 'exclusive');\n+\textendChain(root, 'serial');\n+\textendChain(root, 'skip', 'skipped');\n+\textendChain(root.cb, 'failing');\n+\textendChain(root.cb, 'only', 'exclusive');\n+\textendChain(root.cb, 'skip', 'skipped');\n+\textendChain(root.cb.failing, 'only', 'exclusive');\n+\textendChain(root.cb.failing, 'skip', 'skipped');\n+\textendChain(root.failing, 'only', 'exclusive');\n+\textendChain(root.failing, 'skip', 'skipped');\n+\textendChain(root.serial, 'cb', 'callback');\n+\textendChain(root.serial, 'failing');\n+\textendChain(root.serial, 'only', 'exclusive');\n+\textendChain(root.serial, 'skip', 'skipped');\n+\textendChain(root.serial.cb, 'failing');\n+\textendChain(root.serial.cb, 'only', 'exclusive');\n+\textendChain(root.serial.cb, 'skip', 'skipped');\n+\textendChain(root.serial.cb.failing, 'only', 'exclusive');\n+\textendChain(root.serial.cb.failing, 'skip', 'skipped');\n+\n+\troot.after = createHookChain(startChain('test.after', fn, Object.assign({}, defaults, {type: 'after'})), true);\n+\troot.afterEach = createHookChain(startChain('test.afterEach', fn, Object.assign({}, defaults, {type: 'afterEach'})), true);\n+\troot.before = createHookChain(startChain('test.before', fn, Object.assign({}, defaults, {type: 'before'})), false);\n+\troot.beforeEach = createHookChain(startChain('test.beforeEach', fn, Object.assign({}, defaults, {type: 'beforeEach'})), false);\n+\n+\troot.serial.after = createHookChain(startChain('test.after', fn, Object.assign({}, defaults, {serial: true, type: 'after'})), true);\n+\troot.serial.afterEach = createHookChain(startChain('test.afterEach', fn, Object.assign({}, defaults, {serial: true, type: 'afterEach'})), true);\n+\troot.serial.before = createHookChain(startChain('test.before', fn, Object.assign({}, defaults, {serial: true, type: 'before'})), false);\n+\troot.serial.beforeEach = createHookChain(startChain('test.beforeEach', fn, Object.assign({}, defaults, {serial: true, type: 'beforeEach'})), false);\n+\n+\t// \"todo\" tests cannot be chained. Allow todo tests to be flagged as needing\n+\t// to be serial.\n+\troot.todo = startChain('test.todo', fn, Object.assign({}, defaults, {type: 'test', todo: true}));\n+\troot.serial.todo = startChain('test.serial.todo', fn, Object.assign({}, defaults, {serial: true, type: 'test', todo: true}));\n+\n+\treturn root;\n+}\n+module.exports = createChain;"
      },
      {
        "sha": "7a7d4f73a947fe9882d072dfb40356254d7e6887",
        "filename": "lib/fork.js",
        "status": "modified",
        "additions": 9,
        "deletions": 30,
        "changes": 39,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Ffork.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Ffork.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Ffork.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -59,6 +59,7 @@ module.exports = (file, opts, execArgv) => {\n \t\t}\n \t};\n \n+\tlet loadedFile = false;\n \tconst testResults = [];\n \tlet results;\n \n@@ -100,21 +101,20 @@ module.exports = (file, opts, execArgv) => {\n \n \t\t\tif (results) {\n \t\t\t\tresolve(results);\n+\t\t\t} else if (loadedFile) {\n+\t\t\t\treject(new AvaError(`No tests found in ${relFile}`));\n \t\t\t} else {\n \t\t\t\treject(new AvaError(`Test results were not received from ${relFile}`));\n \t\t\t}\n \t\t});\n \n-\t\tps.on('no-tests', data => {\n-\t\t\tsend('teardown');\n-\n-\t\t\tlet message = `No tests found in ${relFile}`;\n+\t\tps.on('loaded-file', data => {\n+\t\t\tloadedFile = true;\n \n \t\t\tif (!data.avaRequired) {\n-\t\t\t\tmessage += ', make sure to import \"ava\" at the top of your test file';\n+\t\t\t\tsend('teardown');\n+\t\t\t\treject(new AvaError(`No tests found in ${relFile}, make sure to import \"ava\" at the top of your test file`));\n \t\t\t}\n-\n-\t\t\treject(new AvaError(message));\n \t\t});\n \t});\n \n@@ -142,34 +142,13 @@ module.exports = (file, opts, execArgv) => {\n \t\treturn promise;\n \t};\n \n-\tpromise.send = (name, data) => {\n-\t\tsend(name, data);\n-\t\treturn promise;\n-\t};\n-\n \tpromise.exit = () => {\n \t\tsend('init-exit');\n \t\treturn promise;\n \t};\n \n-\t// Send 'run' event only when fork is listening for it\n-\tlet isReady = false;\n-\n-\tps.on('stats', () => {\n-\t\tisReady = true;\n-\t});\n-\n-\tpromise.run = options => {\n-\t\tif (isReady) {\n-\t\t\tsend('run', options);\n-\t\t\treturn promise;\n-\t\t}\n-\n-\t\tps.on('stats', () => {\n-\t\t\tsend('run', options);\n-\t\t});\n-\n-\t\treturn promise;\n+\tpromise.notifyOfPeerFailure = () => {\n+\t\tsend('peer-failed');\n \t};\n \n \treturn promise;"
      },
      {
        "sha": "51176c11362abfa1247e6570ec4f73a0e53cdca4",
        "filename": "lib/globals.js",
        "status": "removed",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/avajs/ava/blob/51a0ff02d4c4dcb9036e7f56c0860dfee330e238/lib%2Fglobals.js",
        "raw_url": "https://github.com/avajs/ava/raw/51a0ff02d4c4dcb9036e7f56c0860dfee330e238/lib%2Fglobals.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fglobals.js?ref=51a0ff02d4c4dcb9036e7f56c0860dfee330e238",
        "patch": "@@ -1,10 +0,0 @@\n-'use strict';\n-\n-// Global objects / functions to be bound before requiring test file, so tests do not interfere\n-\n-const x = module.exports;\n-x.now = Date.now;\n-x.setTimeout = setTimeout;\n-x.clearTimeout = clearTimeout;\n-x.setImmediate = setImmediate;\n-x.options = {};"
      },
      {
        "sha": "9256f4979fe427389ccb12e7a30beb2cf1302ca4",
        "filename": "lib/logger.js",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Flogger.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Flogger.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Flogger.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -24,7 +24,7 @@ class Logger {\n \t}\n \n \ttest(test, runStatus) {\n-\t\tthis.write(this.reporter.test(test, runStatus), runStatus);\n+\t\tthis.write(this.reporter.test(test), runStatus);\n \t}\n \n \tunhandledError(err, runStatus) {"
      },
      {
        "sha": "0b7c325abbac385eb5d6222bdc64f290cdf910dc",
        "filename": "lib/main.js",
        "status": "modified",
        "additions": 5,
        "deletions": 83,
        "changes": 88,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Fmain.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Fmain.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fmain.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -1,100 +1,22 @@\n 'use strict';\n const worker = require('./test-worker');\n-const adapter = require('./process-adapter');\n-const serializeError = require('./serialize-error');\n-const globals = require('./globals');\n const Runner = require('./runner');\n+const opts = require('./worker-options').get();\n \n-const opts = globals.options;\n const runner = new Runner({\n-\tbail: opts.failFast,\n+\tfailFast: opts.failFast,\n \tfailWithoutAssertions: opts.failWithoutAssertions,\n \tfile: opts.file,\n \tmatch: opts.match,\n \tprojectDir: opts.projectDir,\n+\trunOnlyExclusive: opts.runOnlyExclusive,\n \tserial: opts.serial,\n-\tupdateSnapshots: opts.updateSnapshots,\n-\tsnapshotDir: opts.snapshotDir\n+\tsnapshotDir: opts.snapshotDir,\n+\tupdateSnapshots: opts.updateSnapshots\n });\n \n worker.setRunner(runner);\n \n-// If fail-fast is enabled, use this variable to detect\n-// that no more tests should be logged\n-let isFailed = false;\n-\n-function test(props) {\n-\tif (isFailed) {\n-\t\treturn;\n-\t}\n-\n-\tconst hasError = typeof props.error !== 'undefined';\n-\n-\t// Don't display anything if it's a passed hook\n-\tif (!hasError && props.type !== 'test') {\n-\t\treturn;\n-\t}\n-\n-\tif (hasError) {\n-\t\tprops.error = serializeError(props.error);\n-\t} else {\n-\t\tprops.error = null;\n-\t}\n-\n-\tadapter.send('test', props);\n-\n-\tif (hasError && opts.failFast) {\n-\t\tisFailed = true;\n-\t\texit();\n-\t}\n-}\n-\n-function exit() {\n-\t// Reference the IPC channel now that tests have finished running.\n-\tadapter.ipcChannel.ref();\n-\n-\tconst stats = runner.buildStats();\n-\tadapter.send('results', {stats});\n-}\n-\n-globals.setImmediate(() => {\n-\tconst hasExclusive = runner.tests.hasExclusive;\n-\tconst numberOfTests = runner.tests.testCount;\n-\n-\tif (numberOfTests === 0) {\n-\t\tadapter.send('no-tests', {avaRequired: true});\n-\t\treturn;\n-\t}\n-\n-\tadapter.send('stats', {\n-\t\ttestCount: numberOfTests,\n-\t\thasExclusive\n-\t});\n-\n-\trunner.on('test', test);\n-\n-\tprocess.on('ava-run', options => {\n-\t\t// Unreference the IPC channel. This stops it from keeping the event loop\n-\t\t// busy, which means the `beforeExit` event can be used to detect when tests\n-\t\t// stall.\n-\t\tadapter.ipcChannel.unref();\n-\n-\t\trunner.run(options)\n-\t\t\t.then(() => {\n-\t\t\t\trunner.saveSnapshotState();\n-\n-\t\t\t\treturn exit();\n-\t\t\t})\n-\t\t\t.catch(err => {\n-\t\t\t\tprocess.emit('uncaughtException', err);\n-\t\t\t});\n-\t});\n-\n-\tprocess.on('ava-init-exit', () => {\n-\t\texit();\n-\t});\n-});\n-\n const makeCjsExport = () => {\n \tfunction test() {\n \t\treturn runner.chain.apply(null, arguments);"
      },
      {
        "sha": "2576d7ef9c28044585e7b753574030e8193992f7",
        "filename": "lib/now-and-timers.js",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Fnow-and-timers.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Fnow-and-timers.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fnow-and-timers.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -0,0 +1,5 @@\n+'use strict';\n+const timers = require('timers');\n+\n+Object.assign(exports, timers);\n+exports.now = Date.now;"
      },
      {
        "sha": "e441059500fe5545fc3b0f908cdf8a0dfc1553f2",
        "filename": "lib/process-adapter.js",
        "status": "modified",
        "additions": 12,
        "deletions": 2,
        "changes": 14,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Fprocess-adapter.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Fprocess-adapter.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fprocess-adapter.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -24,10 +24,20 @@ exports.send = (name, data) => {\n \n // `process.channel` was added in Node.js 7.1.0, but the channel was available\n // through an undocumented API as `process._channel`.\n-exports.ipcChannel = process.channel || process._channel;\n+const ipcChannel = process.channel || process._channel;\n+let allowUnref = true;\n+exports.unrefChannel = () => {\n+\tif (allowUnref) {\n+\t\tipcChannel.unref();\n+\t}\n+};\n+exports.forceRefChannel = () => {\n+\tallowUnref = false;\n+\tipcChannel.ref();\n+};\n \n const opts = JSON.parse(process.argv[2]);\n-exports.opts = opts;\n+require('./worker-options').set(opts);\n \n // Fake TTY support\n if (opts.tty) {"
      },
      {
        "sha": "5dae12ff8c55cd33d4c3f2f60d3666abbdc71adb",
        "filename": "lib/reporters/mini.js",
        "status": "modified",
        "additions": 20,
        "deletions": 7,
        "changes": 27,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Freporters%2Fmini.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Freporters%2Fmini.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Fmini.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -236,22 +236,35 @@ class MiniReporter {\n \t\t\t\tif (err.type === 'exception' && err.name === 'AvaError') {\n \t\t\t\t\tstatus += '  ' + colors.error(cross + ' ' + err.message) + '\\n\\n';\n \t\t\t\t} else {\n-\t\t\t\t\tconst title = err.type === 'rejection' ? 'Unhandled Rejection' : 'Uncaught Exception';\n-\t\t\t\t\tstatus += '  ' + colors.title(title) + '\\n';\n+\t\t\t\t\tconst title = err.type === 'rejection' ? 'Unhandled rejection' : 'Uncaught exception';\n+\t\t\t\t\tstatus += '  ' + colors.title(`${title} in ${err.file}`) + '\\n';\n \n \t\t\t\t\tif (err.name) {\n-\t\t\t\t\t\tstatus += '  ' + colors.stack(err.summary) + '\\n';\n-\t\t\t\t\t\tstatus += colors.errorStack(err.stack) + '\\n\\n';\n+\t\t\t\t\t\tstatus += indentString(colors.stack(err.summary), 2) + '\\n';\n+\t\t\t\t\t\tstatus += indentString(colors.errorStack(err.stack), 2) + '\\n\\n';\n \t\t\t\t\t} else {\n \t\t\t\t\t\tstatus += '  Threw non-error: ' + err.summary + '\\n';\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t});\n \t\t}\n \n-\t\tif (runStatus.failFastEnabled === true && runStatus.remainingCount > 0 && runStatus.failCount > 0) {\n-\t\t\tconst remaining = 'At least ' + runStatus.remainingCount + ' ' + plur('test was', 'tests were', runStatus.remainingCount) + ' skipped.';\n-\t\t\tstatus += '  ' + colors.information('`--fail-fast` is on. ' + remaining) + '\\n\\n';\n+\t\tif (runStatus.failFastEnabled === true && runStatus.failCount > 0 && (runStatus.remainingCount > 0 || runStatus.fileCount > runStatus.observationCount)) {\n+\t\t\tlet remaining = '';\n+\t\t\tif (runStatus.remainingCount > 0) {\n+\t\t\t\tremaining += `At least ${runStatus.remainingCount} ${plur('test was', 'tests were', runStatus.remainingCount)} skipped`;\n+\t\t\t\tif (runStatus.fileCount > runStatus.observationCount) {\n+\t\t\t\t\tremaining += ', as well as ';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (runStatus.fileCount > runStatus.observationCount) {\n+\t\t\t\tconst skippedFileCount = runStatus.fileCount - runStatus.observationCount;\n+\t\t\t\tremaining += `${skippedFileCount} ${plur('test file', 'test files', skippedFileCount)}`;\n+\t\t\t\tif (runStatus.remainingCount === 0) {\n+\t\t\t\t\tremaining += ` ${plur('was', 'were', skippedFileCount)} skipped`;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tstatus += '  ' + colors.information('`--fail-fast` is on. ' + remaining + '.') + '\\n\\n';\n \t\t}\n \n \t\tif (runStatus.hasExclusive === true && runStatus.remainingCount > 0) {"
      },
      {
        "sha": "d0083c8fee8c8ebbe392926cfdaa5a6c2e074c1e",
        "filename": "lib/reporters/verbose.js",
        "status": "modified",
        "additions": 23,
        "deletions": 16,
        "changes": 39,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Freporters%2Fverbose.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Freporters%2Fverbose.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Fverbose.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -24,7 +24,7 @@ class VerboseReporter {\n \t\treturn '';\n \t}\n \n-\ttest(test, runStatus) {\n+\ttest(test) {\n \t\tconst lines = [];\n \t\tif (test.error) {\n \t\t\tlines.push('  ' + colors.error(figures.cross) + ' ' + test.title + ' ' + colors.error(test.error.message));\n@@ -34,8 +34,6 @@ class VerboseReporter {\n \t\t\tlines.push('  ' + colors.skip('- ' + test.title));\n \t\t} else if (test.failing) {\n \t\t\tlines.push('  ' + colors.error(figures.tick) + ' ' + colors.error(test.title));\n-\t\t} else if (runStatus.fileCount === 1 && runStatus.testCount === 1 && test.title === '[anonymous]') {\n-\t\t\t// No output\n \t\t} else {\n \t\t\t// Display duration only over a threshold\n \t\t\tconst threshold = 100;\n@@ -64,18 +62,14 @@ class VerboseReporter {\n \t\t\treturn colors.error('  ' + figures.cross + ' ' + err.message);\n \t\t}\n \n-\t\tconst types = {\n-\t\t\trejection: 'Unhandled Rejection',\n-\t\t\texception: 'Uncaught Exception'\n-\t\t};\n+\t\tconst title = err.type === 'rejection' ? 'Unhandled rejection' : 'Uncaught exception';\n+\t\tlet output = '  ' + colors.title(`${title} in ${err.file}`) + '\\n';\n \n-\t\tlet output = colors.error(types[err.type] + ':', err.file) + '\\n';\n-\n-\t\tif (err.stack) {\n-\t\t\toutput += '  ' + colors.stack(err.title || err.summary) + '\\n';\n-\t\t\toutput += '  ' + colors.stack(err.stack) + '\\n';\n+\t\tif (err.name) {\n+\t\t\toutput += indentString(colors.stack(err.summary), 2) + '\\n';\n+\t\t\toutput += indentString(colors.errorStack(err.stack), 2) + '\\n\\n';\n \t\t} else {\n-\t\t\toutput += '  ' + colors.stack(JSON.stringify(err)) + '\\n';\n+\t\t\toutput += '  Threw non-error: ' + err.summary + '\\n';\n \t\t}\n \n \t\toutput += '\\n';\n@@ -172,9 +166,22 @@ class VerboseReporter {\n \t\t\t});\n \t\t}\n \n-\t\tif (runStatus.failFastEnabled === true && runStatus.remainingCount > 0 && runStatus.failCount > 0) {\n-\t\t\tconst remaining = 'At least ' + runStatus.remainingCount + ' ' + plur('test was', 'tests were', runStatus.remainingCount) + ' skipped.';\n-\t\t\toutput += '  ' + colors.information('`--fail-fast` is on. ' + remaining) + '\\n\\n';\n+\t\tif (runStatus.failFastEnabled === true && runStatus.failCount > 0 && (runStatus.remainingCount > 0 || runStatus.fileCount > runStatus.observationCount)) {\n+\t\t\tlet remaining = '';\n+\t\t\tif (runStatus.remainingCount > 0) {\n+\t\t\t\tremaining += `At least ${runStatus.remainingCount} ${plur('test was', 'tests were', runStatus.remainingCount)} skipped`;\n+\t\t\t\tif (runStatus.fileCount > runStatus.observationCount) {\n+\t\t\t\t\tremaining += ', as well as ';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (runStatus.fileCount > runStatus.observationCount) {\n+\t\t\t\tconst skippedFileCount = runStatus.fileCount - runStatus.observationCount;\n+\t\t\t\tremaining += `${skippedFileCount} ${plur('test file', 'test files', skippedFileCount)}`;\n+\t\t\t\tif (runStatus.remainingCount === 0) {\n+\t\t\t\t\tremaining += ` ${plur('was', 'were', skippedFileCount)} skipped`;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\toutput += '  ' + colors.information('`--fail-fast` is on. ' + remaining + '.') + '\\n\\n';\n \t\t}\n \n \t\tif (runStatus.hasExclusive === true && runStatus.remainingCount > 0) {"
      },
      {
        "sha": "aae0367c88b9a8576b1c4eed496ac7edca5a4ad7",
        "filename": "lib/run-status.js",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Frun-status.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Frun-status.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Frun-status.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -31,7 +31,7 @@ class RunStatus extends EventEmitter {\n \t\tthis.skipCount = 0;\n \t\tthis.todoCount = 0;\n \t\tthis.failCount = 0;\n-\t\tthis.fileCount = 0;\n+\t\tthis.fileCount = opts.fileCount || 0;\n \t\tthis.testCount = 0;\n \t\tthis.remainingCount = 0;\n \t\tthis.previousFailCount = 0;\n@@ -41,11 +41,13 @@ class RunStatus extends EventEmitter {\n \t\tthis.tests = [];\n \t\tthis.failFastEnabled = opts.failFast || false;\n \t\tthis.updateSnapshots = opts.updateSnapshots || false;\n+\t\tthis.observationCount = 0;\n \n \t\tautoBind(this);\n \t}\n \n \tobserveFork(emitter) {\n+\t\tthis.observationCount++;\n \t\temitter\n \t\t\t.on('teardown', this.handleTeardown)\n \t\t\t.on('stats', this.handleStats)"
      },
      {
        "sha": "bb7817a384b5294e100b82c93ece7189c30b9ec7",
        "filename": "lib/runner.js",
        "status": "modified",
        "additions": 393,
        "deletions": 239,
        "changes": 632,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Frunner.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Frunner.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Frunner.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -1,267 +1,162 @@\n 'use strict';\n const EventEmitter = require('events');\n const path = require('path');\n-const Bluebird = require('bluebird');\n const matcher = require('matcher');\n+const ContextRef = require('./context-ref');\n+const createChain = require('./create-chain');\n const snapshotManager = require('./snapshot-manager');\n-const TestCollection = require('./test-collection');\n-const validateTest = require('./validate-test');\n-\n-const chainRegistry = new WeakMap();\n-\n-function startChain(name, call, defaults) {\n-\tconst fn = function () {\n-\t\tcall(Object.assign({}, defaults), Array.from(arguments));\n-\t};\n-\tObject.defineProperty(fn, 'name', {value: name});\n-\tchainRegistry.set(fn, {call, defaults, fullName: name});\n-\treturn fn;\n-}\n-\n-function extendChain(prev, name, flag) {\n-\tif (!flag) {\n-\t\tflag = name;\n-\t}\n-\n-\tconst fn = function () {\n-\t\tcallWithFlag(prev, flag, Array.from(arguments));\n-\t};\n-\tconst fullName = `${chainRegistry.get(prev).fullName}.${name}`;\n-\tObject.defineProperty(fn, 'name', {value: fullName});\n-\tprev[name] = fn;\n-\n-\tchainRegistry.set(fn, {flag, fullName, prev});\n-\treturn fn;\n-}\n-\n-function callWithFlag(prev, flag, args) {\n-\tconst combinedFlags = {[flag]: true};\n-\tdo {\n-\t\tconst step = chainRegistry.get(prev);\n-\t\tif (step.call) {\n-\t\t\tstep.call(Object.assign({}, step.defaults, combinedFlags), args);\n-\t\t\tprev = null;\n-\t\t} else {\n-\t\t\tcombinedFlags[step.flag] = true;\n-\t\t\tprev = step.prev;\n-\t\t}\n-\t} while (prev);\n-}\n-\n-function createHookChain(hook, isAfterHook) {\n-\t// Hook chaining rules:\n-\t// * `always` comes immediately after \"after hooks\"\n-\t// * `skip` must come at the end\n-\t// * no `only`\n-\t// * no repeating\n-\textendChain(hook, 'cb', 'callback');\n-\textendChain(hook, 'skip', 'skipped');\n-\textendChain(hook.cb, 'skip', 'skipped');\n-\tif (isAfterHook) {\n-\t\textendChain(hook, 'always');\n-\t\textendChain(hook.always, 'cb', 'callback');\n-\t\textendChain(hook.always, 'skip', 'skipped');\n-\t\textendChain(hook.always.cb, 'skip', 'skipped');\n-\t}\n-\treturn hook;\n-}\n-\n-function createChain(fn, defaults) {\n-\t// Test chaining rules:\n-\t// * `serial` must come at the start\n-\t// * `only` and `skip` must come at the end\n-\t// * `failing` must come at the end, but can be followed by `only` and `skip`\n-\t// * `only` and `skip` cannot be chained together\n-\t// * no repeating\n-\tconst root = startChain('test', fn, Object.assign({}, defaults, {type: 'test'}));\n-\textendChain(root, 'cb', 'callback');\n-\textendChain(root, 'failing');\n-\textendChain(root, 'only', 'exclusive');\n-\textendChain(root, 'serial');\n-\textendChain(root, 'skip', 'skipped');\n-\textendChain(root.cb, 'failing');\n-\textendChain(root.cb, 'only', 'exclusive');\n-\textendChain(root.cb, 'skip', 'skipped');\n-\textendChain(root.cb.failing, 'only', 'exclusive');\n-\textendChain(root.cb.failing, 'skip', 'skipped');\n-\textendChain(root.failing, 'only', 'exclusive');\n-\textendChain(root.failing, 'skip', 'skipped');\n-\textendChain(root.serial, 'cb', 'callback');\n-\textendChain(root.serial, 'failing');\n-\textendChain(root.serial, 'only', 'exclusive');\n-\textendChain(root.serial, 'skip', 'skipped');\n-\textendChain(root.serial.cb, 'failing');\n-\textendChain(root.serial.cb, 'only', 'exclusive');\n-\textendChain(root.serial.cb, 'skip', 'skipped');\n-\textendChain(root.serial.cb.failing, 'only', 'exclusive');\n-\textendChain(root.serial.cb.failing, 'skip', 'skipped');\n-\n-\troot.after = createHookChain(startChain('test.after', fn, Object.assign({}, defaults, {type: 'after'})), true);\n-\troot.afterEach = createHookChain(startChain('test.afterEach', fn, Object.assign({}, defaults, {type: 'afterEach'})), true);\n-\troot.before = createHookChain(startChain('test.before', fn, Object.assign({}, defaults, {type: 'before'})), false);\n-\troot.beforeEach = createHookChain(startChain('test.beforeEach', fn, Object.assign({}, defaults, {type: 'beforeEach'})), false);\n-\n-\t// Todo tests cannot be chained. Allow todo tests to be flagged as needing to\n-\t// be serial.\n-\troot.todo = startChain('test.todo', fn, Object.assign({}, defaults, {type: 'test', todo: true}));\n-\troot.serial.todo = startChain('test.serial.todo', fn, Object.assign({}, defaults, {serial: true, type: 'test', todo: true}));\n-\n-\treturn root;\n-}\n-\n-function wrapFunction(fn, args) {\n-\treturn function (t) {\n-\t\treturn fn.apply(this, [t].concat(args));\n-\t};\n-}\n+const Runnable = require('./test');\n \n class Runner extends EventEmitter {\n \tconstructor(options) {\n \t\tsuper();\n \n \t\toptions = options || {};\n-\n+\t\tthis.failFast = options.failFast === true;\n+\t\tthis.failWithoutAssertions = options.failWithoutAssertions !== false;\n \t\tthis.file = options.file;\n \t\tthis.match = options.match || [];\n \t\tthis.projectDir = options.projectDir;\n-\t\tthis.serial = options.serial;\n-\t\tthis.updateSnapshots = options.updateSnapshots;\n+\t\tthis.runOnlyExclusive = options.runOnlyExclusive === true;\n+\t\tthis.serial = options.serial === true;\n \t\tthis.snapshotDir = options.snapshotDir;\n+\t\tthis.updateSnapshots = options.updateSnapshots;\n \n-\t\tthis.hasStarted = false;\n-\t\tthis.results = [];\n+\t\tthis.activeRunnables = new Set();\n+\t\tthis.boundCompareTestSnapshot = this.compareTestSnapshot.bind(this);\n+\t\tthis.interrupted = false;\n \t\tthis.snapshots = null;\n-\t\tthis.tests = new TestCollection({\n-\t\t\tbail: options.bail,\n-\t\t\tfailWithoutAssertions: options.failWithoutAssertions,\n-\t\t\tcompareTestSnapshot: this.compareTestSnapshot.bind(this)\n-\t\t});\n-\n-\t\tthis.chain = createChain((opts, args) => {\n-\t\t\tlet title;\n-\t\t\tlet fn;\n-\t\t\tlet macroArgIndex;\n-\n-\t\t\tif (this.hasStarted) {\n-\t\t\t\tthrow new Error('All tests and hooks must be declared synchronously in your ' +\n-\t\t\t\t'test file, and cannot be nested within other tests or hooks.');\n-\t\t\t}\n-\n-\t\t\tif (typeof args[0] === 'string') {\n-\t\t\t\ttitle = args[0];\n-\t\t\t\tfn = args[1];\n-\t\t\t\tmacroArgIndex = 2;\n-\t\t\t} else {\n-\t\t\t\tfn = args[0];\n-\t\t\t\ttitle = null;\n-\t\t\t\tmacroArgIndex = 1;\n-\t\t\t}\n-\n-\t\t\tif (this.serial) {\n-\t\t\t\topts.serial = true;\n-\t\t\t}\n+\t\tthis.stats = {\n+\t\t\tfailCount: 0,\n+\t\t\tfailedHookCount: 0,\n+\t\t\thasExclusive: false,\n+\t\t\tknownFailureCount: 0,\n+\t\t\tpassCount: 0,\n+\t\t\tskipCount: 0,\n+\t\t\ttestCount: 0,\n+\t\t\ttodoCount: 0\n+\t\t};\n+\t\tthis.tasks = {\n+\t\t\tafter: [],\n+\t\t\tafterAlways: [],\n+\t\t\tafterEach: [],\n+\t\t\tafterEachAlways: [],\n+\t\t\tbefore: [],\n+\t\t\tbeforeEach: [],\n+\t\t\tconcurrent: [],\n+\t\t\tserial: [],\n+\t\t\ttodo: []\n+\t\t};\n \n-\t\t\tif (args.length > macroArgIndex) {\n-\t\t\t\targs = args.slice(macroArgIndex);\n-\t\t\t} else {\n-\t\t\t\targs = null;\n+\t\tconst uniqueTestTitles = new Set();\n+\t\tlet hasStarted = false;\n+\t\tlet scheduledStart = false;\n+\t\tthis.chain = createChain((metadata, args) => { // eslint-disable-line complexity\n+\t\t\tif (hasStarted) {\n+\t\t\t\tthrow new Error('All tests and hooks must be declared synchronously in your test file, and cannot be nested within other tests or hooks.');\n \t\t\t}\n-\n-\t\t\tif (Array.isArray(fn)) {\n-\t\t\t\tfn.forEach(fn => {\n-\t\t\t\t\tthis.addTest(title, opts, fn, args);\n+\t\t\tif (!scheduledStart) {\n+\t\t\t\tscheduledStart = true;\n+\t\t\t\tprocess.nextTick(() => {\n+\t\t\t\t\thasStarted = true;\n+\t\t\t\t\tthis.start();\n \t\t\t\t});\n-\t\t\t} else {\n-\t\t\t\tthis.addTest(title, opts, fn, args);\n \t\t\t}\n-\t\t}, {\n-\t\t\tserial: false,\n-\t\t\texclusive: false,\n-\t\t\tskipped: false,\n-\t\t\ttodo: false,\n-\t\t\tfailing: false,\n-\t\t\tcallback: false,\n-\t\t\talways: false\n-\t\t});\n-\t}\n \n-\taddTest(title, metadata, fn, args) {\n-\t\tif (args) {\n-\t\t\tif (fn.title) {\n-\t\t\t\ttitle = fn.title.apply(fn, [title || ''].concat(args));\n-\t\t\t}\n+\t\t\tconst specifiedTitle = typeof args[0] === 'string' ?\n+\t\t\t\targs.shift() :\n+\t\t\t\t'';\n+\t\t\tconst implementations = Array.isArray(args[0]) ?\n+\t\t\t\targs.shift() :\n+\t\t\t\targs.splice(0, 1);\n \n-\t\t\tfn = wrapFunction(fn, args);\n-\t\t}\n+\t\t\tif (metadata.todo) {\n+\t\t\t\tif (implementations.length > 0) {\n+\t\t\t\t\tthrow new TypeError('`todo` tests are not allowed to have an implementation. Use `test.skip()` for tests with an implementation.');\n+\t\t\t\t}\n \n-\t\tif (metadata.type === 'test' && this.match.length > 0) {\n-\t\t\tmetadata.exclusive = matcher([title || ''], this.match).length === 1;\n-\t\t}\n+\t\t\t\tif (specifiedTitle === '') {\n+\t\t\t\t\tthrow new TypeError('`todo` tests require a title');\n+\t\t\t\t}\n \n-\t\tconst validationError = validateTest(title, fn, metadata);\n-\t\tif (validationError !== null) {\n-\t\t\tthrow new TypeError(validationError);\n-\t\t}\n+\t\t\t\tif (uniqueTestTitles.has(specifiedTitle)) {\n+\t\t\t\t\tthrow new Error(`Duplicate test title: ${specifiedTitle}`);\n+\t\t\t\t} else {\n+\t\t\t\t\tuniqueTestTitles.add(specifiedTitle);\n+\t\t\t\t}\n \n-\t\tthis.tests.add({\n-\t\t\tmetadata,\n-\t\t\tfn,\n-\t\t\ttitle\n-\t\t});\n-\t}\n+\t\t\t\tif (this.match.length > 0) {\n+\t\t\t\t\t// --match selects TODO tests.\n+\t\t\t\t\tif (matcher([specifiedTitle], this.match).length === 1) {\n+\t\t\t\t\t\tmetadata.exclusive = true;\n+\t\t\t\t\t\tthis.stats.hasExclusive = true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n \n-\taddTestResult(result) {\n-\t\tconst test = result.result;\n-\t\tconst props = {\n-\t\t\tlogs: test.logs,\n-\t\t\tduration: test.duration,\n-\t\t\ttitle: test.title,\n-\t\t\terror: result.reason,\n-\t\t\ttype: test.metadata.type,\n-\t\t\tskip: test.metadata.skipped,\n-\t\t\ttodo: test.metadata.todo,\n-\t\t\tfailing: test.metadata.failing\n-\t\t};\n+\t\t\t\tthis.tasks.todo.push({title: specifiedTitle, metadata});\n+\t\t\t} else {\n+\t\t\t\tif (implementations.length === 0) {\n+\t\t\t\t\tthrow new TypeError('Expected an implementation. Use `test.todo()` for tests without an implementation.');\n+\t\t\t\t}\n \n-\t\tthis.results.push(result);\n-\t\tthis.emit('test', props);\n-\t}\n+\t\t\t\tfor (const implementation of implementations) {\n+\t\t\t\t\tlet title = implementation.title ?\n+\t\t\t\t\t\timplementation.title.apply(implementation, [specifiedTitle].concat(args)) :\n+\t\t\t\t\t\tspecifiedTitle;\n \n-\tbuildStats() {\n-\t\tconst stats = {\n-\t\t\tfailCount: 0,\n-\t\t\tknownFailureCount: 0,\n-\t\t\tpassCount: 0,\n-\t\t\tskipCount: 0,\n-\t\t\ttestCount: 0,\n-\t\t\ttodoCount: 0\n-\t\t};\n+\t\t\t\t\tif (typeof title !== 'string') {\n+\t\t\t\t\t\tthrow new TypeError('Test & hook titles must be strings');\n+\t\t\t\t\t}\n \n-\t\tfor (const result of this.results) {\n-\t\t\tif (!result.passed) {\n-\t\t\t\t// Includes hooks\n-\t\t\t\tstats.failCount++;\n-\t\t\t}\n+\t\t\t\t\tif (title === '') {\n+\t\t\t\t\t\tif (metadata.type === 'test') {\n+\t\t\t\t\t\t\tthrow new TypeError('Tests must have a title');\n+\t\t\t\t\t\t} else if (metadata.always) {\n+\t\t\t\t\t\t\ttitle = `${metadata.type}.always hook`;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\ttitle = `${metadata.type} hook`;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (metadata.type === 'test') {\n+\t\t\t\t\t\tif (uniqueTestTitles.has(title)) {\n+\t\t\t\t\t\t\tthrow new Error(`Duplicate test title: ${title}`);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tuniqueTestTitles.add(title);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \n-\t\t\tconst metadata = result.result.metadata;\n-\t\t\tif (metadata.type === 'test') {\n-\t\t\t\tstats.testCount++;\n-\n-\t\t\t\tif (metadata.skipped) {\n-\t\t\t\t\tstats.skipCount++;\n-\t\t\t\t} else if (metadata.todo) {\n-\t\t\t\t\tstats.todoCount++;\n-\t\t\t\t} else if (result.passed) {\n-\t\t\t\t\tif (metadata.failing) {\n-\t\t\t\t\t\tstats.knownFailureCount++;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tstats.passCount++;\n+\t\t\t\t\tconst task = {\n+\t\t\t\t\t\ttitle,\n+\t\t\t\t\t\timplementation,\n+\t\t\t\t\t\targs,\n+\t\t\t\t\t\tmetadata: Object.assign({}, metadata)\n+\t\t\t\t\t};\n+\n+\t\t\t\t\tif (metadata.type === 'test') {\n+\t\t\t\t\t\tif (this.match.length > 0) {\n+\t\t\t\t\t\t\t// --match overrides .only()\n+\t\t\t\t\t\t\ttask.metadata.exclusive = matcher([title], this.match).length === 1;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (task.metadata.exclusive) {\n+\t\t\t\t\t\t\tthis.stats.hasExclusive = true;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tthis.tasks[metadata.serial ? 'serial' : 'concurrent'].push(task);\n+\t\t\t\t\t} else if (!metadata.skipped) {\n+\t\t\t\t\t\tthis.tasks[metadata.type + (metadata.always ? 'Always' : '')].push(task);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t}\n-\n-\t\treturn stats;\n+\t\t}, {\n+\t\t\tserial: false,\n+\t\t\texclusive: false,\n+\t\t\tskipped: false,\n+\t\t\ttodo: false,\n+\t\t\tfailing: false,\n+\t\t\tcallback: false,\n+\t\t\talways: false\n+\t\t});\n \t}\n \n \tcompareTestSnapshot(options) {\n@@ -294,20 +189,279 @@ class Runner extends EventEmitter {\n \t\t}\n \t}\n \n-\trun(options) {\n-\t\tif (options.runOnlyExclusive && !this.tests.hasExclusive) {\n-\t\t\treturn Promise.resolve(null);\n+\tonRun(runnable) {\n+\t\tthis.activeRunnables.add(runnable);\n+\t}\n+\n+\tonRunComplete(runnable) {\n+\t\tthis.activeRunnables.delete(runnable);\n+\t}\n+\n+\tattributeLeakedError(err) {\n+\t\tfor (const runnable of this.activeRunnables) {\n+\t\t\tif (runnable.attributeLeakedError(err)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n \t\t}\n+\t\treturn false;\n+\t}\n+\n+\tbeforeExitHandler() {\n+\t\tfor (const runnable of this.activeRunnables) {\n+\t\t\trunnable.finishDueToInactivity();\n+\t\t}\n+\t}\n+\n+\trunMultiple(runnables) {\n+\t\tlet allPassed = true;\n+\t\tconst storedResults = [];\n+\t\tconst runAndStoreResult = runnable => {\n+\t\t\treturn this.runSingle(runnable).then(result => {\n+\t\t\t\tif (!result.passed) {\n+\t\t\t\t\tallPassed = false;\n+\t\t\t\t}\n+\t\t\t\tstoredResults.push(result);\n+\t\t\t});\n+\t\t};\n+\n+\t\tlet waitForSerial = Promise.resolve();\n+\t\treturn runnables.reduce((prev, runnable) => {\n+\t\t\tif (runnable.metadata.serial || this.serial) {\n+\t\t\t\twaitForSerial = prev.then(() => {\n+\t\t\t\t\t// Serial runnables run as long as there was no previous failure, unless\n+\t\t\t\t\t// the runnable should always be run.\n+\t\t\t\t\treturn (allPassed || runnable.metadata.always) && runAndStoreResult(runnable);\n+\t\t\t\t});\n+\t\t\t\treturn waitForSerial;\n+\t\t\t}\n \n-\t\tthis.hasStarted = true;\n-\t\tthis.tests.on('test', result => {\n-\t\t\tthis.addTestResult(result);\n+\t\t\treturn Promise.all([\n+\t\t\t\tprev,\n+\t\t\t\twaitForSerial.then(() => {\n+\t\t\t\t\t// Concurrent runnables are kicked off after the previous serial\n+\t\t\t\t\t// runnables have completed, as long as there was no previous failure\n+\t\t\t\t\t// (or if the runnable should always be run). One concurrent runnable's\n+\t\t\t\t\t// failure does not prevent the next runnable from running.\n+\t\t\t\t\treturn (allPassed || runnable.metadata.always) && runAndStoreResult(runnable);\n+\t\t\t\t})\n+\t\t\t]);\n+\t\t}, waitForSerial).then(() => ({allPassed, storedResults}));\n+\t}\n+\n+\trunSingle(runnable) {\n+\t\tthis.onRun(runnable);\n+\t\treturn runnable.run().then(result => {\n+\t\t\t// If run() throws or rejects then the entire test run crashes, so\n+\t\t\t// onRunComplete() doesn't *have* to be inside a finally().\n+\t\t\tthis.onRunComplete(runnable);\n+\t\t\treturn result;\n \t\t});\n-\t\treturn Bluebird.try(() => this.tests.build().run());\n \t}\n \n-\tattributeLeakedError(err) {\n-\t\treturn this.tests.attributeLeakedError(err);\n+\trunHooks(tasks, contextRef, titleSuffix) {\n+\t\tconst hooks = tasks.map(task => new Runnable({\n+\t\t\tcontextRef,\n+\t\t\tfailWithoutAssertions: false,\n+\t\t\tfn: task.args.length === 0 ?\n+\t\t\t\ttask.implementation :\n+\t\t\t\tt => task.implementation.apply(null, [t].concat(task.args)),\n+\t\t\tcompareTestSnapshot: this.boundCompareTestSnapshot,\n+\t\t\tmetadata: task.metadata,\n+\t\t\ttitle: `${task.title}${titleSuffix || ''}`\n+\t\t}));\n+\t\treturn this.runMultiple(hooks, this.serial).then(outcome => {\n+\t\t\tif (outcome.allPassed) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Only emit results for failed hooks.\n+\t\t\tfor (const result of outcome.storedResults) {\n+\t\t\t\tif (!result.passed) {\n+\t\t\t\t\tthis.stats.failedHookCount++;\n+\t\t\t\t\tthis.emit('hook-failed', result);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t});\n+\t}\n+\n+\trunTest(task, contextRef) {\n+\t\tconst hookSuffix = ` for ${task.title}`;\n+\t\treturn this.runHooks(this.tasks.beforeEach, contextRef, hookSuffix).then(hooksOk => {\n+\t\t\t// Don't run the test if a `beforeEach` hook failed.\n+\t\t\tif (!hooksOk) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\tconst test = new Runnable({\n+\t\t\t\tcontextRef,\n+\t\t\t\tfailWithoutAssertions: this.failWithoutAssertions,\n+\t\t\t\tfn: task.args.length === 0 ?\n+\t\t\t\t\ttask.implementation :\n+\t\t\t\t\tt => task.implementation.apply(null, [t].concat(task.args)),\n+\t\t\t\tcompareTestSnapshot: this.boundCompareTestSnapshot,\n+\t\t\t\tmetadata: task.metadata,\n+\t\t\t\ttitle: task.title\n+\t\t\t});\n+\t\t\treturn this.runSingle(test).then(result => {\n+\t\t\t\tif (!result.passed) {\n+\t\t\t\t\tthis.stats.failCount++;\n+\t\t\t\t\tthis.emit('test', result);\n+\t\t\t\t\t// Don't run `afterEach` hooks if the test failed.\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\n+\t\t\t\tif (result.metadata.failing) {\n+\t\t\t\t\tthis.stats.knownFailureCount++;\n+\t\t\t\t} else {\n+\t\t\t\t\tthis.stats.passCount++;\n+\t\t\t\t}\n+\t\t\t\tthis.emit('test', result);\n+\t\t\t\treturn this.runHooks(this.tasks.afterEach, contextRef, hookSuffix);\n+\t\t\t});\n+\t\t}).then(hooksAndTestOk => {\n+\t\t\treturn this.runHooks(this.tasks.afterEachAlways, contextRef, hookSuffix).then(alwaysOk => {\n+\t\t\t\treturn hooksAndTestOk && alwaysOk;\n+\t\t\t});\n+\t\t});\n+\t}\n+\n+\tstart() {\n+\t\tconst runOnlyExclusive = this.stats.hasExclusive || this.runOnlyExclusive;\n+\n+\t\tconst todoTitles = [];\n+\t\tfor (const task of this.tasks.todo) {\n+\t\t\tif (runOnlyExclusive && !task.metadata.exclusive) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tthis.stats.testCount++;\n+\t\t\tthis.stats.todoCount++;\n+\t\t\ttodoTitles.push(task.title);\n+\t\t}\n+\n+\t\tconst concurrentTests = [];\n+\t\tconst serialTests = [];\n+\t\tconst skippedTests = [];\n+\t\tfor (const task of this.tasks.serial) {\n+\t\t\tif (runOnlyExclusive && !task.metadata.exclusive) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tthis.stats.testCount++;\n+\t\t\tif (task.metadata.skipped) {\n+\t\t\t\tthis.stats.skipCount++;\n+\t\t\t\tskippedTests.push({\n+\t\t\t\t\tfailing: task.metadata.failing,\n+\t\t\t\t\ttitle: task.title\n+\t\t\t\t});\n+\t\t\t} else {\n+\t\t\t\tserialTests.push(task);\n+\t\t\t}\n+\t\t}\n+\t\tfor (const task of this.tasks.concurrent) {\n+\t\t\tif (runOnlyExclusive && !task.metadata.exclusive) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tthis.stats.testCount++;\n+\t\t\tif (task.metadata.skipped) {\n+\t\t\t\tthis.stats.skipCount++;\n+\t\t\t\tskippedTests.push({\n+\t\t\t\t\tfailing: task.metadata.failing,\n+\t\t\t\t\ttitle: task.title\n+\t\t\t\t});\n+\t\t\t} else if (this.serial) {\n+\t\t\t\tserialTests.push(task);\n+\t\t\t} else {\n+\t\t\t\tconcurrentTests.push(task);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (concurrentTests.length === 0 && serialTests.length === 0) {\n+\t\t\tthis.emit('start', {\n+\t\t\t\t// `ended` is always resolved with `undefined`.\n+\t\t\t\tended: Promise.resolve(undefined),\n+\t\t\t\tskippedTests,\n+\t\t\t\tstats: this.stats,\n+\t\t\t\ttodoTitles\n+\t\t\t});\n+\t\t\t// Don't run any hooks if there are no tests to run.\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tconst contextRef = new ContextRef();\n+\n+\t\t// Note that the hooks and tests always begin running asynchronously.\n+\t\tconst beforePromise = this.runHooks(this.tasks.before, contextRef);\n+\t\tconst serialPromise = beforePromise.then(beforeHooksOk => {\n+\t\t\t// Don't run tests if a `before` hook failed.\n+\t\t\tif (!beforeHooksOk) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\treturn serialTests.reduce((prev, task) => {\n+\t\t\t\treturn prev.then(prevOk => {\n+\t\t\t\t\t// Don't start tests after an interrupt.\n+\t\t\t\t\tif (this.interrupted) {\n+\t\t\t\t\t\treturn prevOk;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// Prevent subsequent tests from running if `failFast` is enabled and\n+\t\t\t\t\t// the previous test failed.\n+\t\t\t\t\tif (!prevOk && this.failFast) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treturn this.runTest(task, contextRef.copy());\n+\t\t\t\t});\n+\t\t\t}, Promise.resolve(true));\n+\t\t});\n+\t\tconst concurrentPromise = Promise.all([beforePromise, serialPromise]).then(prevOkays => {\n+\t\t\tconst beforeHooksOk = prevOkays[0];\n+\t\t\tconst serialOk = prevOkays[1];\n+\t\t\t// Don't run tests if a `before` hook failed, or if `failFast` is enabled\n+\t\t\t// and a previous serial test failed.\n+\t\t\tif (!beforeHooksOk || (!serialOk && this.failFast)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\t// Don't start tests after an interrupt.\n+\t\t\tif (this.interrupted) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// If a concurrent test fails, even if `failFast` is enabled it won't\n+\t\t\t// stop other concurrent tests from running.\n+\t\t\treturn Promise.all(concurrentTests.map(task => {\n+\t\t\t\treturn this.runTest(task, contextRef.copy());\n+\t\t\t})).then(allOkays => allOkays.every(ok => ok));\n+\t\t});\n+\n+\t\tconst beforeExitHandler = this.beforeExitHandler.bind(this);\n+\t\tprocess.on('beforeExit', beforeExitHandler);\n+\n+\t\tconst ended = concurrentPromise\n+\t\t\t// Only run `after` hooks if all hooks and tests passed.\n+\t\t\t.then(ok => ok && this.runHooks(this.tasks.after, contextRef))\n+\t\t\t// Always run `after.always` hooks.\n+\t\t\t.then(() => this.runHooks(this.tasks.afterAlways, contextRef))\n+\t\t\t.then(() => {\n+\t\t\t\tprocess.removeListener('beforeExit', beforeExitHandler);\n+\t\t\t\t// `ended` is always resolved with `undefined`.\n+\t\t\t\treturn undefined;\n+\t\t\t});\n+\n+\t\tthis.emit('start', {\n+\t\t\tended,\n+\t\t\tskippedTests,\n+\t\t\tstats: this.stats,\n+\t\t\ttodoTitles\n+\t\t});\n+\t}\n+\n+\tinterrupt() {\n+\t\tthis.interrupted = true;\n \t}\n }\n "
      },
      {
        "sha": "1e5960a98cb471b42f2c840ba30f4e56e344fb11",
        "filename": "lib/sequence.js",
        "status": "removed",
        "additions": 0,
        "deletions": 94,
        "changes": 94,
        "blob_url": "https://github.com/avajs/ava/blob/51a0ff02d4c4dcb9036e7f56c0860dfee330e238/lib%2Fsequence.js",
        "raw_url": "https://github.com/avajs/ava/raw/51a0ff02d4c4dcb9036e7f56c0860dfee330e238/lib%2Fsequence.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fsequence.js?ref=51a0ff02d4c4dcb9036e7f56c0860dfee330e238",
        "patch": "@@ -1,94 +0,0 @@\n-'use strict';\n-\n-const beforeExitSubscribers = new Set();\n-const beforeExitHandler = () => {\n-\tfor (const subscriber of beforeExitSubscribers) {\n-\t\tsubscriber();\n-\t}\n-};\n-const onBeforeExit = subscriber => {\n-\tif (beforeExitSubscribers.size === 0) {\n-\t\t// Only listen for the event once, no matter how many Sequences are run\n-\t\t// concurrently.\n-\t\tprocess.on('beforeExit', beforeExitHandler);\n-\t}\n-\n-\tbeforeExitSubscribers.add(subscriber);\n-\treturn {\n-\t\tdispose() {\n-\t\t\tbeforeExitSubscribers.delete(subscriber);\n-\t\t\tif (beforeExitSubscribers.size === 0) {\n-\t\t\t\tprocess.removeListener('beforeExit', beforeExitHandler);\n-\t\t\t}\n-\t\t}\n-\t};\n-};\n-\n-class Sequence {\n-\tconstructor(runnables, bail) {\n-\t\tif (!Array.isArray(runnables)) {\n-\t\t\tthrow new TypeError('Expected an array of runnables');\n-\t\t}\n-\n-\t\tthis.runnables = runnables;\n-\t\tthis.bail = bail || false;\n-\t}\n-\n-\trun() {\n-\t\tconst iterator = this.runnables[Symbol.iterator]();\n-\n-\t\tlet activeRunnable;\n-\t\tconst beforeExit = onBeforeExit(() => {\n-\t\t\tif (activeRunnable.finishDueToInactivity) {\n-\t\t\t\tactiveRunnable.finishDueToInactivity();\n-\t\t\t}\n-\t\t});\n-\n-\t\tlet allPassed = true;\n-\t\tconst finish = () => {\n-\t\t\tbeforeExit.dispose();\n-\t\t\treturn allPassed;\n-\t\t};\n-\n-\t\tconst runNext = () => {\n-\t\t\tlet promise;\n-\n-\t\t\tfor (let next = iterator.next(); !next.done; next = iterator.next()) {\n-\t\t\t\tactiveRunnable = next.value;\n-\t\t\t\tconst passedOrPromise = activeRunnable.run();\n-\t\t\t\tif (!passedOrPromise) {\n-\t\t\t\t\tallPassed = false;\n-\n-\t\t\t\t\tif (this.bail) {\n-\t\t\t\t\t\t// Stop if the test failed and bail mode is on.\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t} else if (passedOrPromise !== true) {\n-\t\t\t\t\tpromise = passedOrPromise;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (!promise) {\n-\t\t\t\treturn finish();\n-\t\t\t}\n-\n-\t\t\treturn promise.then(passed => {\n-\t\t\t\tif (!passed) {\n-\t\t\t\t\tallPassed = false;\n-\n-\t\t\t\t\tif (this.bail) {\n-\t\t\t\t\t\t// Stop if the test failed and bail mode is on.\n-\t\t\t\t\t\treturn finish();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\treturn runNext();\n-\t\t\t});\n-\t\t};\n-\n-\t\treturn runNext();\n-\t}\n-}\n-\n-module.exports = Sequence;"
      },
      {
        "sha": "969f78e0217ec387237004daf37c398499f0e755",
        "filename": "lib/serialize-error.js",
        "status": "modified",
        "additions": 13,
        "deletions": 1,
        "changes": 14,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Fserialize-error.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Fserialize-error.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fserialize-error.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -90,7 +90,19 @@ module.exports = error => {\n \t}\n \n \tif (typeof error.stack === 'string') {\n-\t\tretval.summary = error.stack.split('\\n')[0];\n+\t\tconst lines = error.stack.split('\\n');\n+\t\tif (error.name === 'SyntaxError' && !lines[0].startsWith('SyntaxError')) {\n+\t\t\tretval.summary = '';\n+\t\t\tfor (const line of lines) {\n+\t\t\t\tretval.summary += line + '\\n';\n+\t\t\t\tif (line.startsWith('SyntaxError')) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tretval.summary = retval.summary.trim();\n+\t\t} else {\n+\t\t\tretval.summary = lines[0];\n+\t\t}\n \t} else {\n \t\tretval.summary = JSON.stringify(error);\n \t}"
      },
      {
        "sha": "0569e88e67f11b70d46908021aaab1252ec007d8",
        "filename": "lib/test-collection.js",
        "status": "removed",
        "additions": 0,
        "deletions": 250,
        "changes": 250,
        "blob_url": "https://github.com/avajs/ava/blob/51a0ff02d4c4dcb9036e7f56c0860dfee330e238/lib%2Ftest-collection.js",
        "raw_url": "https://github.com/avajs/ava/raw/51a0ff02d4c4dcb9036e7f56c0860dfee330e238/lib%2Ftest-collection.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Ftest-collection.js?ref=51a0ff02d4c4dcb9036e7f56c0860dfee330e238",
        "patch": "@@ -1,250 +0,0 @@\n-'use strict';\n-const EventEmitter = require('events');\n-const clone = require('lodash.clone');\n-const Concurrent = require('./concurrent');\n-const Sequence = require('./sequence');\n-const Test = require('./test');\n-\n-class ContextRef {\n-\tconstructor() {\n-\t\tthis.value = {};\n-\t}\n-\n-\tget() {\n-\t\treturn this.value;\n-\t}\n-\n-\tset(newValue) {\n-\t\tthis.value = newValue;\n-\t}\n-\n-\tcopy() {\n-\t\treturn new LateBinding(this); // eslint-disable-line no-use-before-define\n-\t}\n-}\n-\n-class LateBinding extends ContextRef {\n-\tconstructor(ref) {\n-\t\tsuper();\n-\t\tthis.ref = ref;\n-\t\tthis.bound = false;\n-\t}\n-\n-\tget() {\n-\t\tif (!this.bound) {\n-\t\t\tthis.set(clone(this.ref.get()));\n-\t\t}\n-\t\treturn super.get();\n-\t}\n-\n-\tset(newValue) {\n-\t\tthis.bound = true;\n-\t\tsuper.set(newValue);\n-\t}\n-}\n-\n-class TestCollection extends EventEmitter {\n-\tconstructor(options) {\n-\t\tsuper();\n-\n-\t\tthis.bail = options.bail;\n-\t\tthis.failWithoutAssertions = options.failWithoutAssertions;\n-\t\tthis.compareTestSnapshot = options.compareTestSnapshot;\n-\t\tthis.hasExclusive = false;\n-\t\tthis.testCount = 0;\n-\n-\t\tthis.tests = {\n-\t\t\tconcurrent: [],\n-\t\t\tserial: []\n-\t\t};\n-\n-\t\tthis.hooks = {\n-\t\t\tbefore: [],\n-\t\t\tbeforeEach: [],\n-\t\t\tafter: [],\n-\t\t\tafterAlways: [],\n-\t\t\tafterEach: [],\n-\t\t\tafterEachAlways: []\n-\t\t};\n-\n-\t\tthis.pendingTestInstances = new Set();\n-\t\tthis.uniqueTestTitles = new Set();\n-\n-\t\tthis._emitTestResult = this._emitTestResult.bind(this);\n-\t}\n-\n-\tadd(test) {\n-\t\tconst metadata = test.metadata;\n-\t\tconst type = metadata.type;\n-\n-\t\tif (test.title === '' || typeof test.title !== 'string') {\n-\t\t\tif (type === 'test') {\n-\t\t\t\tthrow new TypeError('Tests must have a title');\n-\t\t\t} else {\n-\t\t\t\ttest.title = `${type} hook`;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (type === 'test') {\n-\t\t\tif (this.uniqueTestTitles.has(test.title)) {\n-\t\t\t\tthrow new Error(`Duplicate test title: ${test.title}`);\n-\t\t\t} else {\n-\t\t\t\tthis.uniqueTestTitles.add(test.title);\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Add a hook\n-\t\tif (type !== 'test') {\n-\t\t\tthis.hooks[type + (metadata.always ? 'Always' : '')].push(test);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tthis.testCount++;\n-\n-\t\t// Add `.only()` tests if `.only()` was used previously\n-\t\tif (this.hasExclusive && !metadata.exclusive) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (metadata.exclusive && !this.hasExclusive) {\n-\t\t\tthis.tests.concurrent = [];\n-\t\t\tthis.tests.serial = [];\n-\t\t\tthis.hasExclusive = true;\n-\t\t}\n-\n-\t\tif (metadata.serial) {\n-\t\t\tthis.tests.serial.push(test);\n-\t\t} else {\n-\t\t\tthis.tests.concurrent.push(test);\n-\t\t}\n-\t}\n-\n-\t_skippedTest(test) {\n-\t\treturn {\n-\t\t\trun: () => {\n-\t\t\t\tthis._emitTestResult({\n-\t\t\t\t\tpassed: true,\n-\t\t\t\t\tresult: test\n-\t\t\t\t});\n-\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t};\n-\t}\n-\n-\t_emitTestResult(result) {\n-\t\tthis.pendingTestInstances.delete(result.result);\n-\t\tthis.emit('test', result);\n-\t}\n-\n-\t_buildHooks(hooks, testTitle, contextRef) {\n-\t\treturn hooks.map(hook => {\n-\t\t\tconst test = this._buildHook(hook, testTitle, contextRef);\n-\n-\t\t\tif (hook.metadata.skipped || hook.metadata.todo) {\n-\t\t\t\treturn this._skippedTest(test);\n-\t\t\t}\n-\n-\t\t\treturn test;\n-\t\t});\n-\t}\n-\n-\t_buildHook(hook, testTitle, contextRef) {\n-\t\tlet title = hook.title;\n-\n-\t\tif (testTitle) {\n-\t\t\ttitle += ` for ${testTitle}`;\n-\t\t}\n-\n-\t\tconst test = new Test({\n-\t\t\tcontextRef,\n-\t\t\tfailWithoutAssertions: false,\n-\t\t\tfn: hook.fn,\n-\t\t\tcompareTestSnapshot: this.compareTestSnapshot,\n-\t\t\tmetadata: hook.metadata,\n-\t\t\tonResult: this._emitTestResult,\n-\t\t\ttitle\n-\t\t});\n-\t\tthis.pendingTestInstances.add(test);\n-\t\treturn test;\n-\t}\n-\n-\t_buildTest(test, contextRef) {\n-\t\ttest = new Test({\n-\t\t\tcontextRef,\n-\t\t\tfailWithoutAssertions: this.failWithoutAssertions,\n-\t\t\tfn: test.fn,\n-\t\t\tcompareTestSnapshot: this.compareTestSnapshot,\n-\t\t\tmetadata: test.metadata,\n-\t\t\tonResult: this._emitTestResult,\n-\t\t\ttitle: test.title\n-\t\t});\n-\t\tthis.pendingTestInstances.add(test);\n-\t\treturn test;\n-\t}\n-\n-\t_buildTestWithHooks(test, contextRef) {\n-\t\tif (test.metadata.skipped || test.metadata.todo) {\n-\t\t\treturn new Sequence([this._skippedTest(this._buildTest(test))], true);\n-\t\t}\n-\n-\t\tconst copiedRef = contextRef.copy();\n-\n-\t\tconst beforeHooks = this._buildHooks(this.hooks.beforeEach, test.title, copiedRef);\n-\t\tconst afterHooks = this._buildHooks(this.hooks.afterEach, test.title, copiedRef);\n-\n-\t\tlet sequence = new Sequence([].concat(beforeHooks, this._buildTest(test, copiedRef), afterHooks), true);\n-\t\tif (this.hooks.afterEachAlways.length > 0) {\n-\t\t\tconst afterAlwaysHooks = new Sequence(this._buildHooks(this.hooks.afterEachAlways, test.title, copiedRef));\n-\t\t\tsequence = new Sequence([sequence, afterAlwaysHooks], false);\n-\t\t}\n-\t\treturn sequence;\n-\t}\n-\n-\t_buildTests(tests, contextRef) {\n-\t\treturn tests.map(test => this._buildTestWithHooks(test, contextRef));\n-\t}\n-\n-\t_hasUnskippedTests() {\n-\t\treturn this.tests.serial.concat(this.tests.concurrent)\n-\t\t\t.some(test => {\n-\t\t\t\treturn !(test.metadata && test.metadata.skipped === true);\n-\t\t\t});\n-\t}\n-\n-\tbuild() {\n-\t\tconst contextRef = new ContextRef();\n-\n-\t\tconst serialTests = new Sequence(this._buildTests(this.tests.serial, contextRef), this.bail);\n-\t\tconst concurrentTests = new Concurrent(this._buildTests(this.tests.concurrent, contextRef), this.bail);\n-\t\tconst allTests = new Sequence([serialTests, concurrentTests]);\n-\n-\t\tlet finalTests;\n-\t\t// Only run before and after hooks when there are unskipped tests\n-\t\tif (this._hasUnskippedTests()) {\n-\t\t\tconst beforeHooks = new Sequence(this._buildHooks(this.hooks.before, null, contextRef));\n-\t\t\tconst afterHooks = new Sequence(this._buildHooks(this.hooks.after, null, contextRef));\n-\t\t\tfinalTests = new Sequence([beforeHooks, allTests, afterHooks], true);\n-\t\t} else {\n-\t\t\tfinalTests = new Sequence([allTests], true);\n-\t\t}\n-\n-\t\tif (this.hooks.afterAlways.length > 0) {\n-\t\t\tconst afterAlwaysHooks = new Sequence(this._buildHooks(this.hooks.afterAlways, null, contextRef));\n-\t\t\tfinalTests = new Sequence([finalTests, afterAlwaysHooks], false);\n-\t\t}\n-\n-\t\treturn finalTests;\n-\t}\n-\n-\tattributeLeakedError(err) {\n-\t\tfor (const test of this.pendingTestInstances) {\n-\t\t\tif (test.attributeLeakedError(err)) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n-}\n-\n-module.exports = TestCollection;"
      },
      {
        "sha": "ff93e5ad052d56b3a0fc8f3cd0a9e733c770c5de",
        "filename": "lib/test-worker.js",
        "status": "modified",
        "additions": 147,
        "deletions": 38,
        "changes": 185,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Ftest-worker.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Ftest-worker.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Ftest-worker.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -20,35 +20,40 @@ const currentlyUnhandled = require('currently-unhandled')();\n const isObj = require('is-obj');\n \n const adapter = require('./process-adapter');\n-const globals = require('./globals');\n-\n-const opts = adapter.opts;\n-globals.options = opts;\n-\n const serializeError = require('./serialize-error');\n+const opts = require('./worker-options').get();\n \n-// Install before processing opts.require, so if helpers are added to the\n-// require configuration the *compiled* helper will be loaded.\n-adapter.installSourceMapSupport();\n-adapter.installPrecompilerHook();\n-\n-(opts.require || []).forEach(x => {\n-\tif (/[/\\\\]@std[/\\\\]esm[/\\\\]index\\.js$/.test(x)) {\n-\t\trequire = require(x)(module); // eslint-disable-line no-global-assign\n-\t} else {\n-\t\trequire(x);\n-\t}\n-});\n-\n-const testPath = opts.file;\n-\n+// Store details about the test run, to be sent to the parent process later.\n const dependencies = new Set();\n-adapter.installDependencyTracking(dependencies, testPath);\n-\n const touchedFiles = new Set();\n \n // Set when main.js is required (since test files should have `require('ava')`).\n let runner = null;\n+\n+// Track when exiting begins, to avoid repeatedly sending stats, or sending\n+// individual test results once stats have been sent. This is necessary since\n+// exit() can be invoked from the worker process and over IPC.\n+let exiting = false;\n+function exit() {\n+\tif (exiting) {\n+\t\treturn;\n+\t}\n+\texiting = true;\n+\n+\t// Reference the IPC channel so the exit sequence can be completed.\n+\tadapter.forceRefChannel();\n+\n+\tconst stats = {\n+\t\tfailCount: runner.stats.failCount + runner.stats.failedHookCount,\n+\t\tknownFailureCount: runner.stats.knownFailureCount,\n+\t\tpassCount: runner.stats.passCount,\n+\t\tskipCount: runner.stats.skipCount,\n+\t\ttestCount: runner.stats.testCount,\n+\t\ttodoCount: runner.stats.todoCount\n+\t};\n+\tadapter.send('results', {stats});\n+}\n+\n exports.setRunner = newRunner => {\n \trunner = newRunner;\n \trunner.on('dependency', file => {\n@@ -59,14 +64,69 @@ exports.setRunner = newRunner => {\n \t\t\ttouchedFiles.add(file);\n \t\t}\n \t});\n-};\n+\trunner.on('start', started => {\n+\t\tadapter.send('stats', {\n+\t\t\ttestCount: started.stats.testCount,\n+\t\t\thasExclusive: started.stats.hasExclusive\n+\t\t});\n \n-require(testPath);\n+\t\tfor (const partial of started.skippedTests) {\n+\t\t\tadapter.send('test', {\n+\t\t\t\tduration: null,\n+\t\t\t\terror: null,\n+\t\t\t\tfailing: partial.failing,\n+\t\t\t\tlogs: [],\n+\t\t\t\tskip: true,\n+\t\t\t\ttitle: partial.title,\n+\t\t\t\ttodo: false,\n+\t\t\t\ttype: 'test'\n+\t\t\t});\n+\t\t}\n+\t\tfor (const title of started.todoTitles) {\n+\t\t\tadapter.send('test', {\n+\t\t\t\tduration: null,\n+\t\t\t\terror: null,\n+\t\t\t\tfailing: false,\n+\t\t\t\tlogs: [],\n+\t\t\t\tskip: true,\n+\t\t\t\ttitle,\n+\t\t\t\ttodo: true,\n+\t\t\t\ttype: 'test'\n+\t\t\t});\n+\t\t}\n \n-// If AVA was not required, show an error\n-if (!runner) {\n-\tadapter.send('no-tests', {avaRequired: false});\n-}\n+\t\tstarted.ended.then(() => {\n+\t\t\trunner.saveSnapshotState();\n+\t\t\treturn exit();\n+\t\t}).catch(err => {\n+\t\t\thandleUncaughtException(err);\n+\t\t});\n+\t});\n+\trunner.on('hook-failed', result => {\n+\t\tadapter.send('test', {\n+\t\t\tduration: result.duration,\n+\t\t\terror: serializeError(result.error),\n+\t\t\tfailing: result.metadata.failing,\n+\t\t\tlogs: result.logs,\n+\t\t\tskip: result.metadata.skip,\n+\t\t\ttitle: result.title,\n+\t\t\ttodo: result.metadata.todo,\n+\t\t\ttype: result.metadata.type\n+\t\t});\n+\t});\n+\trunner.on('test', result => {\n+\t\tadapter.send('test', {\n+\t\t\tduration: result.duration,\n+\t\t\terror: result.passed ? null : serializeError(result.error),\n+\t\t\tfailing: result.metadata.failing,\n+\t\t\tlogs: result.logs,\n+\t\t\tskip: result.metadata.skip,\n+\t\t\ttitle: result.title,\n+\t\t\ttodo: result.metadata.todo,\n+\t\t\ttype: result.metadata.type\n+\t\t});\n+\t});\n+};\n \n function attributeLeakedError(err) {\n \tif (!runner) {\n@@ -76,14 +136,7 @@ function attributeLeakedError(err) {\n \treturn runner.attributeLeakedError(err);\n }\n \n-const attributedRejections = new Set();\n-process.on('unhandledRejection', (reason, promise) => {\n-\tif (attributeLeakedError(reason)) {\n-\t\tattributedRejections.add(promise);\n-\t}\n-});\n-\n-process.on('uncaughtException', exception => {\n+function handleUncaughtException(exception) {\n \tif (attributeLeakedError(exception)) {\n \t\treturn;\n \t}\n@@ -102,13 +155,22 @@ process.on('uncaughtException', exception => {\n \t\t};\n \t}\n \n-\t// Ensure the IPC channel is refereced. The uncaught exception will kick off\n+\t// Ensure the IPC channel is referenced. The uncaught exception will kick off\n \t// the teardown sequence, for which the messages must be received.\n-\tadapter.ipcChannel.ref();\n+\tadapter.forceRefChannel();\n \n \tadapter.send('uncaughtException', {exception: serialized});\n+}\n+\n+const attributedRejections = new Set();\n+process.on('unhandledRejection', (reason, promise) => {\n+\tif (attributeLeakedError(reason)) {\n+\t\tattributedRejections.add(promise);\n+\t}\n });\n \n+process.on('uncaughtException', handleUncaughtException);\n+\n let tearingDown = false;\n process.on('ava-teardown', () => {\n \t// AVA-teardown can be sent more than once\n@@ -117,6 +179,9 @@ process.on('ava-teardown', () => {\n \t}\n \ttearingDown = true;\n \n+\t// Reference the IPC channel so the teardown sequence can be completed.\n+\tadapter.forceRefChannel();\n+\n \tlet rejections = currentlyUnhandled()\n \t\t.filter(rejection => !attributedRejections.has(rejection.promise));\n \n@@ -147,3 +212,47 @@ process.on('ava-teardown', () => {\n process.on('ava-exit', () => {\n \tprocess.exit(0); // eslint-disable-line xo/no-process-exit\n });\n+\n+process.on('ava-init-exit', () => {\n+\texit();\n+});\n+\n+process.on('ava-peer-failed', () => {\n+\tif (runner) {\n+\t\trunner.interrupt();\n+\t}\n+});\n+\n+// Store value in case to prevent required modules from modifying it.\n+const testPath = opts.file;\n+\n+// Install before processing opts.require, so if helpers are added to the\n+// require configuration the *compiled* helper will be loaded.\n+adapter.installDependencyTracking(dependencies, testPath);\n+adapter.installSourceMapSupport();\n+adapter.installPrecompilerHook();\n+\n+try {\n+\t(opts.require || []).forEach(x => {\n+\t\tif (/[/\\\\]@std[/\\\\]esm[/\\\\]index\\.js$/.test(x)) {\n+\t\t\trequire = require(x)(module); // eslint-disable-line no-global-assign\n+\t\t} else {\n+\t\t\trequire(x);\n+\t\t}\n+\t});\n+\n+\trequire(testPath);\n+} catch (err) {\n+\thandleUncaughtException(err);\n+} finally {\n+\tadapter.send('loaded-file', {avaRequired: Boolean(runner)});\n+\n+\tif (runner) {\n+\t\t// Unreference the IPC channel if the test file required AVA. This stops it\n+\t\t// from keeping the event loop busy, which means the `beforeExit` event can be\n+\t\t// used to detect when tests stall.\n+\t\t// If AVA was not required then the parent process will initiated a teardown\n+\t\t// sequence, for which this process ought to stay active.\n+\t\tadapter.unrefChannel();\n+\t}\n+}"
      },
      {
        "sha": "115b02106d33c4c861019097e3b15aa00deba5e8",
        "filename": "lib/test.js",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Ftest.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -7,7 +7,7 @@ const isPromise = require('is-promise');\n const isObservable = require('is-observable');\n const plur = require('plur');\n const assert = require('./assert');\n-const globals = require('./globals');\n+const nowAndTimers = require('./now-and-timers');\n const concordanceOptions = require('./concordance-options').default;\n \n function formatErrorValue(label, error) {\n@@ -103,7 +103,6 @@ class Test {\n \t\tthis.failWithoutAssertions = options.failWithoutAssertions;\n \t\tthis.fn = isGeneratorFn(options.fn) ? co.wrap(options.fn) : options.fn;\n \t\tthis.metadata = options.metadata;\n-\t\tthis.onResult = options.onResult;\n \t\tthis.title = options.title;\n \t\tthis.logs = [];\n \n@@ -278,7 +277,7 @@ class Test {\n \n \t\t\t// Wait up to a second to see if an error can be attributed to the\n \t\t\t// pending assertion.\n-\t\t\tglobals.setTimeout(() => this.finishDueToInactivity(), 1000).unref();\n+\t\t\tnowAndTimers.setTimeout(() => this.finishDueToInactivity(), 1000).unref();\n \t\t});\n \t}\n \n@@ -306,7 +305,7 @@ class Test {\n \t}\n \n \trun() {\n-\t\tthis.startedAt = globals.now();\n+\t\tthis.startedAt = nowAndTimers.now();\n \n \t\tconst result = this.callFn();\n \t\tif (!result.ok) {\n@@ -317,7 +316,7 @@ class Test {\n \t\t\t\t\tvalues: [formatErrorValue('Error thrown in test:', result.error)]\n \t\t\t\t}));\n \t\t\t}\n-\t\t\treturn this.finish();\n+\t\t\treturn this.finishPromised();\n \t\t}\n \n \t\tconst returnedObservable = isObservable(result.retval);\n@@ -335,11 +334,11 @@ class Test {\n \t\t\tif (returnedObservable || returnedPromise) {\n \t\t\t\tconst asyncType = returnedObservable ? 'observables' : 'promises';\n \t\t\t\tthis.saveFirstError(new Error(`Do not return ${asyncType} from tests declared via \\`test.cb(...)\\`, if you want to return a promise simply declare the test via \\`test(...)\\``));\n-\t\t\t\treturn this.finish();\n+\t\t\t\treturn this.finishPromised();\n \t\t\t}\n \n \t\t\tif (this.calledEnd) {\n-\t\t\t\treturn this.finish();\n+\t\t\t\treturn this.finishPromised();\n \t\t\t}\n \n \t\t\treturn new Promise(resolve => {\n@@ -386,7 +385,7 @@ class Test {\n \t\t\t});\n \t\t}\n \n-\t\treturn this.finish();\n+\t\treturn this.finishPromised();\n \t}\n \n \tfinish() {\n@@ -399,28 +398,29 @@ class Test {\n \t\tthis.verifyPlan();\n \t\tthis.verifyAssertions();\n \n-\t\tthis.duration = globals.now() - this.startedAt;\n+\t\tthis.duration = nowAndTimers.now() - this.startedAt;\n \n-\t\tlet reason = this.assertError;\n-\t\tlet passed = !reason;\n+\t\tlet error = this.assertError;\n+\t\tlet passed = !error;\n \n \t\tif (this.metadata.failing) {\n \t\t\tpassed = !passed;\n \n \t\t\tif (passed) {\n-\t\t\t\treason = undefined;\n+\t\t\t\terror = null;\n \t\t\t} else {\n-\t\t\t\treason = new Error('Test was expected to fail, but succeeded, you should stop marking the test as failing');\n+\t\t\t\terror = new Error('Test was expected to fail, but succeeded, you should stop marking the test as failing');\n \t\t\t}\n \t\t}\n \n-\t\tthis.onResult({\n+\t\treturn {\n+\t\t\tduration: this.duration,\n+\t\t\terror,\n+\t\t\tlogs: this.logs,\n+\t\t\tmetadata: this.metadata,\n \t\t\tpassed,\n-\t\t\tresult: this,\n-\t\t\treason\n-\t\t});\n-\n-\t\treturn passed;\n+\t\t\ttitle: this.title\n+\t\t};\n \t}\n \n \tfinishPromised() {"
      },
      {
        "sha": "8258a5990a48b3aabdd43e98dc39a99ae1aca417",
        "filename": "lib/validate-test.js",
        "status": "removed",
        "additions": 0,
        "deletions": 48,
        "changes": 48,
        "blob_url": "https://github.com/avajs/ava/blob/51a0ff02d4c4dcb9036e7f56c0860dfee330e238/lib%2Fvalidate-test.js",
        "raw_url": "https://github.com/avajs/ava/raw/51a0ff02d4c4dcb9036e7f56c0860dfee330e238/lib%2Fvalidate-test.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fvalidate-test.js?ref=51a0ff02d4c4dcb9036e7f56c0860dfee330e238",
        "patch": "@@ -1,48 +0,0 @@\n-'use strict';\n-\n-function validate(title, fn, metadata) {\n-\tif (metadata.type !== 'test') {\n-\t\tif (metadata.exclusive) {\n-\t\t\treturn '`only` is only for tests and cannot be used with hooks';\n-\t\t}\n-\n-\t\tif (metadata.failing) {\n-\t\t\treturn '`failing` is only for tests and cannot be used with hooks';\n-\t\t}\n-\n-\t\tif (metadata.todo) {\n-\t\t\treturn '`todo` is only for documentation of future tests and cannot be used with hooks';\n-\t\t}\n-\t}\n-\n-\tif (metadata.todo) {\n-\t\tif (typeof fn === 'function') {\n-\t\t\treturn '`todo` tests are not allowed to have an implementation. Use ' +\n-\t\t\t'`test.skip()` for tests with an implementation.';\n-\t\t}\n-\n-\t\tif (typeof title !== 'string') {\n-\t\t\treturn '`todo` tests require a title';\n-\t\t}\n-\n-\t\tif (metadata.skipped || metadata.failing || metadata.exclusive) {\n-\t\t\treturn '`todo` tests are just for documentation and cannot be used with `skip`, `only`, or `failing`';\n-\t\t}\n-\t} else if (typeof fn !== 'function') {\n-\t\treturn 'Expected an implementation. Use `test.todo()` for tests without an implementation.';\n-\t}\n-\n-\tif (metadata.always) {\n-\t\tif (!(metadata.type === 'after' || metadata.type === 'afterEach')) {\n-\t\t\treturn '`always` can only be used with `after` and `afterEach`';\n-\t\t}\n-\t}\n-\n-\tif (metadata.skipped && metadata.exclusive) {\n-\t\treturn '`only` tests cannot be skipped';\n-\t}\n-\n-\treturn null;\n-}\n-\n-module.exports = validate;"
      },
      {
        "sha": "65a7c1756e9ee97e7430e057ae36b8481fdef6a6",
        "filename": "lib/worker-options.js",
        "status": "added",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Fworker-options.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/lib%2Fworker-options.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fworker-options.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -0,0 +1,14 @@\n+'use strict';\n+let options = null;\n+exports.get = () => {\n+\tif (!options) {\n+\t\tthrow new Error('Options have not yet been set');\n+\t}\n+\treturn options;\n+};\n+exports.set = newOptions => {\n+\tif (options) {\n+\t\tthrow new Error('Options have already been set');\n+\t}\n+\toptions = newOptions;\n+};"
      },
      {
        "sha": "44282634655109d3f89e47f4162c3fdb24a5b6dc",
        "filename": "package-lock.json",
        "status": "modified",
        "additions": 2,
        "deletions": 21,
        "changes": 23,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/package-lock.json",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/package-lock.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/package-lock.json?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -2002,7 +2002,8 @@\n     \"commondir\": {\n       \"version\": \"1.0.1\",\n       \"resolved\": \"https://registry.npmjs.org/commondir/-/commondir-1.0.1.tgz\",\n-      \"integrity\": \"sha1-3dgA2gxmEnOTzKWVDqloo6rxJTs=\"\n+      \"integrity\": \"sha1-3dgA2gxmEnOTzKWVDqloo6rxJTs=\",\n+      \"dev\": true\n     },\n     \"component-emitter\": {\n       \"version\": \"1.2.1\",\n@@ -3270,26 +3271,6 @@\n         \"repeat-string\": \"1.6.1\"\n       }\n     },\n-    \"find-cache-dir\": {\n-      \"version\": \"1.0.0\",\n-      \"resolved\": \"https://registry.npmjs.org/find-cache-dir/-/find-cache-dir-1.0.0.tgz\",\n-      \"integrity\": \"sha1-kojj6ePMN0hxfTnq3hfPcfww7m8=\",\n-      \"requires\": {\n-        \"commondir\": \"1.0.1\",\n-        \"make-dir\": \"1.1.0\",\n-        \"pkg-dir\": \"2.0.0\"\n-      },\n-      \"dependencies\": {\n-        \"pkg-dir\": {\n-          \"version\": \"2.0.0\",\n-          \"resolved\": \"https://registry.npmjs.org/pkg-dir/-/pkg-dir-2.0.0.tgz\",\n-          \"integrity\": \"sha1-9tXREJ4Z1j7fQo4L1X4Sd3YVM0s=\",\n-          \"requires\": {\n-            \"find-up\": \"2.1.0\"\n-          }\n-        }\n-      }\n-    },\n     \"find-up\": {\n       \"version\": \"2.1.0\",\n       \"resolved\": \"https://registry.npmjs.org/find-up/-/find-up-2.1.0.tgz\","
      },
      {
        "sha": "1a6e099df471d3fab427d95121854326ec42fbfa",
        "filename": "package.json",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/package.json",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/package.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/package.json?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -97,7 +97,6 @@\n \t\t\"empower-core\": \"^0.6.1\",\n \t\t\"equal-length\": \"^1.0.0\",\n \t\t\"figures\": \"^2.0.0\",\n-\t\t\"find-cache-dir\": \"^1.0.0\",\n \t\t\"get-port\": \"^3.2.0\",\n \t\t\"globby\": \"^7.1.1\",\n \t\t\"hullabaloo-config-manager\": \"^2.0.0-beta.2\","
      },
      {
        "sha": "35acdce8005b0e5e7fda6e95245f3c8ffbde3ecf",
        "filename": "profile.js",
        "status": "modified",
        "additions": 13,
        "deletions": 11,
        "changes": 24,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/profile.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/profile.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/profile.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -9,13 +9,11 @@ const EventEmitter = require('events');\n const meow = require('meow');\n const Promise = require('bluebird');\n const pkgConf = require('pkg-conf');\n-const findCacheDir = require('find-cache-dir');\n const uniqueTempDir = require('unique-temp-dir');\n const arrify = require('arrify');\n const resolveCwd = require('resolve-cwd');\n const babelConfigHelper = require('./lib/babel-config');\n const CachingPrecompiler = require('./lib/caching-precompiler');\n-const globals = require('./lib/globals');\n \n function resolveModules(modules) {\n \treturn arrify(modules).map(name => {\n@@ -29,10 +27,6 @@ function resolveModules(modules) {\n \t});\n }\n \n-// Chrome gets upset when the `this` value is non-null for these functions\n-globals.setTimeout = setTimeout.bind(null);\n-globals.clearTimeout = clearTimeout.bind(null);\n-\n Promise.longStackTraces();\n \n const conf = pkgConf.sync('ava', {\n@@ -44,6 +38,9 @@ const conf = pkgConf.sync('ava', {\n \t}\n });\n \n+const filepath = pkgConf.filepath(conf);\n+const projectDir = filepath === null ? process.cwd() : path.dirname(filepath);\n+\n // Define a minimal set of options from the main CLI\n const cli = meow(`\n \tUsage\n@@ -74,10 +71,7 @@ if (cli.input.length === 0) {\n }\n \n const file = path.resolve(cli.input[0]);\n-const cacheDir = findCacheDir({\n-\tname: 'ava',\n-\tfiles: [file]\n-}) || uniqueTempDir();\n+const cacheDir = conf.cacheEnabled === false ? uniqueTempDir() : path.join(projectDir, 'node_modules', '.cache', 'ava');\n \n babelConfigHelper.build(process.cwd(), cacheDir, babelConfigHelper.validate(conf.babel), conf.compileEnhancements === true)\n \t.then(result => {\n@@ -103,6 +97,9 @@ babelConfigHelper.build(process.cwd(), cacheDir, babelConfigHelper.validate(conf\n \t\t};\n \n \t\tconst events = new EventEmitter();\n+\t\tevents.on('loaded-file', () => {});\n+\n+\t\tlet failCount = 0;\n \t\tlet uncaughtExceptionCount = 0;\n \n \t\t// Mock the behavior of a parent process\n@@ -134,8 +131,13 @@ babelConfigHelper.build(process.cwd(), cacheDir, babelConfigHelper.validate(conf\n \n \t\t\tconsole.log('RESULTS:', data.stats);\n \n+\t\t\tfailCount = data.stats.failCount;\n+\t\t\tsetImmediate(() => process.emit('ava-teardown'));\n+\t\t});\n+\n+\t\tevents.on('teardown', () => {\n \t\t\tif (process.exit) {\n-\t\t\t\tprocess.exit(data.stats.failCount + uncaughtExceptionCount); // eslint-disable-line unicorn/no-process-exit\n+\t\t\t\tprocess.exit(failCount + uncaughtExceptionCount); // eslint-disable-line unicorn/no-process-exit\n \t\t\t}\n \t\t});\n "
      },
      {
        "sha": "5004a2b21fc92c0fdaf36d65a039c2d068bda3c2",
        "filename": "readme.md",
        "status": "modified",
        "additions": 20,
        "deletions": 16,
        "changes": 36,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/readme.md",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/readme.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/readme.md?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -524,25 +524,31 @@ test.failing('demonstrate some bug', t => {\n \n AVA lets you register hooks that are run before and after your tests. This allows you to run setup and/or teardown code.\n \n-`test.before()` registers a hook to be run before the first test in your test file. Similarly `test.after()` registers a hook to be run after the last test. Use `test.after.always()` to register a hook that will **always** run once your tests and other hooks complete. `.always()` hooks run regardless of whether there were earlier failures or if all tests were skipped, so they are ideal for cleanup tasks. There are two exceptions to this however. If you use `--fail-fast` AVA will stop testing as soon as a failure occurs, and it won't run any hooks including the `.always()` hooks. Uncaught exceptions will crash your tests, possibly preventing `.always()` hooks from running.\n+`test.before()` registers a hook to be run before the first test in your test file. Similarly `test.after()` registers a hook to be run after the last test. Use `test.after.always()` to register a hook that will **always** run once your tests and other hooks complete. `.always()` hooks run regardless of whether there were earlier failures, so they are ideal for cleanup tasks. Note however that uncaught exceptions, unhandled rejections or timeouts will crash your tests, possibly preventing `.always()` hooks from running.\n \n-`test.beforeEach()` registers a hook to be run before each test in your test file. Similarly `test.afterEach()` a hook to be run after each test. Use `test.afterEach.always()` to register an after hook that is called even if other test hooks, or the test itself, fail. `.always()` hooks are ideal for cleanup tasks.\n+`test.beforeEach()` registers a hook to be run before each test in your test file. Similarly `test.afterEach()` a hook to be run after each test. Use `test.afterEach.always()` to register an after hook that is called even if other test hooks, or the test itself, fail.\n \n-If a test is skipped with the `.skip` modifier, the respective `.beforeEach()` and `.afterEach()` hooks are not run. Likewise, if all tests in a test file are skipped `.before()` and `.after()` hooks for the file are not run. Hooks modified with `.always()` will always run, even if all tests are skipped.\n+If a test is skipped with the `.skip` modifier, the respective `.beforeEach()`, `.afterEach()` and `.afterEach.always()` hooks are not run. Likewise, if all tests in a test file are skipped `.before()`, `.after()` and `.after.always()` hooks for the file are not run.\n \n-**Note**: If the `--fail-fast` flag is specified, AVA will stop after the first test failure and the `.always` hook will **not** run.\n+Like `test()` these methods take an optional title and an implementation function. The title is shown if your hook fails to execute. The implementation is called with an [execution object](#t). You can use assertions in your hooks. You can also pass a [macro function](#test-macros) and additional arguments.\n \n-Like `test()` these methods take an optional title and a callback function. The title is shown if your hook fails to execute. The callback is called with an [execution object](#t).\n-\n-`before` hooks execute before `beforeEach` hooks. `afterEach` hooks execute before `after` hooks. Within their category the hooks execute in the order they were defined.\n+`.before()` hooks execute before `.beforeEach()` hooks. `.afterEach()` hooks execute before `.after()` hooks. Within their category the hooks execute in the order they were defined. By default hooks execute concurrently, but you can use `test.serial` to ensure only that single hook is run at a time. Unlike with tests, serial hooks are *not* run before other hooks:\n \n ```js\n test.before(t => {\n \t// This runs before all tests\n });\n \n test.before(t => {\n-\t// This runs after the above, but before tests\n+\t// This runs concurrently with the above\n+});\n+\n+test.serial.before(t => {\n+\t// This runs after the above\n+});\n+\n+test.serial.before(t => {\n+\t// This too runs after the above, and before tests\n });\n \n test.after('cleanup', t => {\n@@ -590,13 +596,13 @@ test.afterEach.cb(t => {\n });\n ```\n \n-Keep in mind that the `beforeEach` and `afterEach` hooks run just before and after a test is run, and that by default tests run concurrently. If you need to set up global state for each test (like spying on `console.log` [for example](https://github.com/avajs/ava/issues/560)), you'll need to make sure the tests are [run serially](#running-tests-serially).\n+Keep in mind that the `.beforeEach()` and `.afterEach()` hooks run just before and after a test is run, and that by default tests run concurrently. This means each multiple `.beforeEach()` hooks may run concurrently. Using `test.serial.beforeEach()` does not change this. If you need to set up global state for each test (like spying on `console.log` [for example](https://github.com/avajs/ava/issues/560)), you'll need to make sure the tests themselves are [run serially](#running-tests-serially).\n \n-Remember that AVA runs each test file in its own process. You may not have to clean up global state in a `after`-hook since that's only called right before the process exits.\n+Remember that AVA runs each test file in its own process. You may not have to clean up global state in a `.after()`-hook since that's only called right before the process exits.\n \n #### Test context\n \n-The `beforeEach` & `afterEach` hooks can share context with the test:\n+The `.beforeEach()` & `.afterEach()` hooks can share context with the test:\n \n ```js\n test.beforeEach(t => {\n@@ -620,7 +626,7 @@ test('context is unicorn', t => {\n });\n ```\n \n-Context sharing is *not* available to `before` and `after` hooks.\n+Context sharing is *not* available to `.before()` and `.after()` hooks.\n \n ### Test macros\n \n@@ -781,9 +787,7 @@ test.cb('data.txt can be read', t => {\n \n ### Global timeout\n \n-A global timeout can be set via the `--timeout` option.\n-Timeout in AVA behaves differently than in other test frameworks.\n-AVA resets a timer after each test, forcing tests to quit if no new test results were received within the specified timeout.\n+A global timeout can be set via the `--timeout` option. Timeout in AVA behaves differently than in other test frameworks. AVA resets a timer after each test, forcing tests to quit if no new test results were received within the specified timeout. This can be used to handle stalled tests.\n \n You can set timeouts in a human-readable way:\n \n@@ -823,7 +827,7 @@ Should contain the actual test.\n \n Type: `object`\n \n-The execution object of a particular test. Each test implementation receives a different object. Contains the [assertions](#assertions) as well as `.plan(count)` and `.end()` methods. `t.context` can contain shared state from `beforeEach` hooks. `t.title` returns the test's title.\n+The execution object of a particular test. Each test implementation receives a different object. Contains the [assertions](#assertions) as well as `.plan(count)` and `.end()` methods. `t.context` can contain shared state from `.beforeEach()` hooks. `t.title` returns the test's title.\n \n ###### `t.plan(count)`\n "
      },
      {
        "sha": "8ee4e32ed787e6cbf0811e0d50129c569a19c502",
        "filename": "test/api.js",
        "status": "modified",
        "additions": 896,
        "deletions": 752,
        "changes": 1648,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Fapi.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Fapi.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fapi.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -13,6 +13,7 @@ const ROOT_DIR = path.join(__dirname, '..');\n function apiCreator(options) {\n \toptions = options || {};\n \toptions.babelConfig = options.babelConfig || {testOptions: {}};\n+\toptions.concurrency = 2;\n \toptions.projectDir = options.projectDir || ROOT_DIR;\n \toptions.resolveTestsFrom = options.resolveTestsFrom || options.projectDir;\n \tconst instance = new Api(options);\n@@ -22,1023 +23,1166 @@ function apiCreator(options) {\n \treturn instance;\n }\n \n-generateTests('With Pool:', options => {\n-\toptions = options || {};\n-\toptions.concurrency = 2;\n-\treturn apiCreator(options);\n-});\n+test('ES2015 support', t => {\n+\tconst api = apiCreator();\n \n-function generateTests(prefix, apiCreator) {\n-\ttest(`${prefix} ES2015 support`, t => {\n-\t\tconst api = apiCreator();\n+\treturn api.run([path.join(__dirname, 'fixture/es2015.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n+\t\t});\n+});\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/es2015.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t});\n+test('precompile helpers', t => {\n+\tconst api = apiCreator({\n+\t\tprecompileHelpers: true,\n+\t\tresolveTestsFrom: path.join(__dirname, 'fixture/precompile-helpers')\n \t});\n \n-\ttest(`${prefix} precompile helpers`, t => {\n-\t\tconst api = apiCreator({\n-\t\t\tprecompileHelpers: true,\n-\t\t\tresolveTestsFrom: path.join(__dirname, 'fixture/precompile-helpers')\n+\treturn api.run()\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n+});\n \n-\t\treturn api.run()\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t});\n-\t});\n+test('generators support', t => {\n+\tconst api = apiCreator();\n \n-\ttest(`${prefix} generators support`, t => {\n-\t\tconst api = apiCreator();\n+\treturn api.run([path.join(__dirname, 'fixture/generators.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n+\t\t});\n+});\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/generators.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t});\n-\t});\n+test('async/await support', t => {\n+\tconst api = apiCreator();\n \n-\ttest(`${prefix} async/await support`, t => {\n-\t\tconst api = apiCreator();\n+\treturn api.run([path.join(__dirname, 'fixture/async-await.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 2);\n+\t\t});\n+});\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/async-await.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 2);\n-\t\t\t});\n+test('test title prefixes — multiple files', t => {\n+\tt.plan(5);\n+\n+\tconst separator = ` ${figures.pointerSmall} `;\n+\tconst files = [\n+\t\tpath.join(__dirname, 'fixture/async-await.js'),\n+\t\tpath.join(__dirname, 'fixture/generators.js'),\n+\t\tpath.join(__dirname, 'fixture/subdir/in-a-subdir.js')\n+\t];\n+\tconst expected = [\n+\t\t['async-await', 'async function'].join(separator),\n+\t\t['async-await', 'arrow async function'].join(separator),\n+\t\t['generators', 'generator function'].join(separator),\n+\t\t['subdir', 'in-a-subdir', 'subdir'].join(separator)\n+\t];\n+\tlet index;\n+\n+\tconst api = apiCreator();\n+\n+\tapi.run(files)\n+\t\t.then(() => {\n+\t\t\t// If all lines were removed from expected output\n+\t\t\t// actual output matches expected output\n+\t\t\tt.is(expected.length, 0);\n+\t\t});\n+\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('test', a => {\n+\t\t\tindex = expected.indexOf(a.title);\n+\n+\t\t\tt.true(index >= 0);\n+\n+\t\t\t// Remove line from expected output\n+\t\t\texpected.splice(index, 1);\n+\t\t});\n \t});\n+});\n \n-\ttest(`${prefix} test title prefixes — multiple files`, t => {\n-\t\tt.plan(5);\n-\n-\t\tconst separator = ` ${figures.pointerSmall} `;\n-\t\tconst files = [\n-\t\t\tpath.join(__dirname, 'fixture/async-await.js'),\n-\t\t\tpath.join(__dirname, 'fixture/generators.js'),\n-\t\t\tpath.join(__dirname, 'fixture/subdir/in-a-subdir.js')\n-\t\t];\n-\t\tconst expected = [\n-\t\t\t['async-await', 'async function'].join(separator),\n-\t\t\t['async-await', 'arrow async function'].join(separator),\n-\t\t\t['generators', 'generator function'].join(separator),\n-\t\t\t['subdir', 'in-a-subdir', 'subdir'].join(separator)\n-\t\t];\n-\t\tlet index;\n-\n-\t\tconst api = apiCreator();\n-\n-\t\tapi.run(files)\n-\t\t\t.then(() => {\n-\t\t\t\t// If all lines were removed from expected output\n-\t\t\t\t// actual output matches expected output\n-\t\t\t\tt.is(expected.length, 0);\n-\t\t\t});\n+test('test title prefixes — single file', t => {\n+\tt.plan(2);\n+\n+\tconst separator = ` ${figures.pointerSmall} `;\n+\tconst files = [\n+\t\tpath.join(__dirname, 'fixture/generators.js')\n+\t];\n+\tconst expected = [\n+\t\t['generator function'].join(separator)\n+\t];\n+\tlet index;\n+\n+\tconst api = apiCreator();\n+\n+\tapi.run(files)\n+\t\t.then(() => {\n+\t\t\t// If all lines were removed from expected output\n+\t\t\t// actual output matches expected output\n+\t\t\tt.is(expected.length, 0);\n+\t\t});\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('test', a => {\n-\t\t\t\tindex = expected.indexOf(a.title);\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('test', a => {\n+\t\t\tindex = expected.indexOf(a.title);\n \n-\t\t\t\tt.true(index >= 0);\n+\t\t\tt.true(index >= 0);\n \n-\t\t\t\t// Remove line from expected output\n-\t\t\t\texpected.splice(index, 1);\n-\t\t\t});\n+\t\t\t// Remove line from expected output\n+\t\t\texpected.splice(index, 1);\n \t\t});\n \t});\n+});\n \n-\ttest(`${prefix} test title prefixes — single file`, t => {\n-\t\tt.plan(2);\n+test('test title prefixes — single file (explicit)', t => {\n+\tt.plan(2);\n \n-\t\tconst separator = ` ${figures.pointerSmall} `;\n-\t\tconst files = [\n-\t\t\tpath.join(__dirname, 'fixture/generators.js')\n-\t\t];\n-\t\tconst expected = [\n-\t\t\t['generator function'].join(separator)\n-\t\t];\n-\t\tlet index;\n+\tconst separator = ` ${figures.pointerSmall} `;\n+\tconst files = [\n+\t\tpath.join(__dirname, 'fixture/generators.js')\n+\t];\n+\tconst expected = [\n+\t\t['generators', 'generator function'].join(separator)\n+\t];\n+\tlet index;\n \n-\t\tconst api = apiCreator();\n+\tconst api = apiCreator({\n+\t\texplicitTitles: true\n+\t});\n \n-\t\tapi.run(files)\n-\t\t\t.then(() => {\n-\t\t\t\t// If all lines were removed from expected output\n-\t\t\t\t// actual output matches expected output\n-\t\t\t\tt.is(expected.length, 0);\n-\t\t\t});\n+\tapi.run(files)\n+\t\t.then(() => {\n+\t\t\t// If all lines were removed from expected output\n+\t\t\t// actual output matches expected output\n+\t\t\tt.is(expected.length, 0);\n+\t\t});\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('test', a => {\n-\t\t\t\tindex = expected.indexOf(a.title);\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('test', a => {\n+\t\t\tindex = expected.indexOf(a.title);\n \n-\t\t\t\tt.true(index >= 0);\n+\t\t\tt.true(index >= 0);\n \n-\t\t\t\t// Remove line from expected output\n-\t\t\t\texpected.splice(index, 1);\n-\t\t\t});\n+\t\t\t// Remove line from expected output\n+\t\t\texpected.splice(index, 1);\n \t\t});\n \t});\n+});\n \n-\ttest(`${prefix} test title prefixes — single file (explicit)`, t => {\n-\t\tt.plan(2);\n+test('display filename prefixes for failed test stack traces', t => {\n+\tconst files = [\n+\t\tpath.join(__dirname, 'fixture/es2015.js'),\n+\t\tpath.join(__dirname, 'fixture/one-pass-one-fail.js')\n+\t];\n \n-\t\tconst separator = ` ${figures.pointerSmall} `;\n-\t\tconst files = [\n-\t\t\tpath.join(__dirname, 'fixture/generators.js')\n-\t\t];\n-\t\tconst expected = [\n-\t\t\t['generators', 'generator function'].join(separator)\n-\t\t];\n-\t\tlet index;\n+\tconst api = apiCreator();\n \n-\t\tconst api = apiCreator({\n-\t\t\texplicitTitles: true\n+\treturn api.run(files)\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 2);\n+\t\t\tt.is(result.failCount, 1);\n+\t\t\tt.match(result.errors[0].title, /one-pass-one-fail \\S this is a failing test/);\n \t\t});\n+});\n \n-\t\tapi.run(files)\n-\t\t\t.then(() => {\n-\t\t\t\t// If all lines were removed from expected output\n-\t\t\t\t// actual output matches expected output\n-\t\t\t\tt.is(expected.length, 0);\n-\t\t\t});\n-\n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('test', a => {\n-\t\t\t\tindex = expected.indexOf(a.title);\n+// This is a seperate test because we can't ensure the order of the errors (to match them), and this is easier than\n+// sorting.\n+test('display filename prefixes for failed test stack traces in subdirs', t => {\n+\tconst files = [\n+\t\tpath.join(__dirname, 'fixture/es2015.js'),\n+\t\tpath.join(__dirname, 'fixture/subdir/failing-subdir.js')\n+\t];\n \n-\t\t\t\tt.true(index >= 0);\n+\tconst api = apiCreator();\n \n-\t\t\t\t// Remove line from expected output\n-\t\t\t\texpected.splice(index, 1);\n-\t\t\t});\n+\treturn api.run(files)\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n+\t\t\tt.is(result.failCount, 1);\n+\t\t\tt.match(result.errors[0].title, /subdir \\S failing-subdir \\S subdir fail/);\n \t\t});\n-\t});\n+});\n \n-\ttest(`${prefix} display filename prefixes for failed test stack traces`, t => {\n-\t\tconst files = [\n-\t\t\tpath.join(__dirname, 'fixture/es2015.js'),\n-\t\t\tpath.join(__dirname, 'fixture/one-pass-one-fail.js')\n-\t\t];\n+test('fail-fast mode - single file & serial', t => {\n+\tconst api = apiCreator({\n+\t\tfailFast: true\n+\t});\n \n-\t\tconst api = apiCreator();\n+\tconst tests = [];\n \n-\t\treturn api.run(files)\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 2);\n-\t\t\t\tt.is(result.failCount, 1);\n-\t\t\t\tt.match(result.errors[0].title, /one-pass-one-fail \\S this is a failing test/);\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('test', test => {\n+\t\t\ttests.push({\n+\t\t\t\tok: !test.error,\n+\t\t\t\ttitle: test.title\n \t\t\t});\n+\t\t});\n \t});\n \n-\t// This is a seperate test because we can't ensure the order of the errors (to match them), and this is easier than\n-\t// sorting.\n-\ttest(`${prefix} display filename prefixes for failed test stack traces in subdirs`, t => {\n-\t\tconst files = [\n-\t\t\tpath.join(__dirname, 'fixture/es2015.js'),\n-\t\t\tpath.join(__dirname, 'fixture/subdir/failing-subdir.js')\n-\t\t];\n+\treturn api.run([path.join(__dirname, 'fixture/fail-fast/single-file/test.js')])\n+\t\t.then(result => {\n+\t\t\tt.ok(api.options.failFast);\n+\t\t\tt.strictDeepEqual(tests, [{\n+\t\t\t\tok: true,\n+\t\t\t\ttitle: 'first pass'\n+\t\t\t}, {\n+\t\t\t\tok: false,\n+\t\t\t\ttitle: 'second fail'\n+\t\t\t}, {\n+\t\t\t\tok: true,\n+\t\t\t\ttitle: 'third pass'\n+\t\t\t}]);\n+\t\t\tt.is(result.passCount, 2);\n+\t\t\tt.is(result.failCount, 1);\n+\t\t});\n+});\n+\n+test('fail-fast mode - multiple files & serial', t => {\n+\tconst api = apiCreator({\n+\t\tfailFast: true,\n+\t\tserial: true\n+\t});\n \n-\t\tconst api = apiCreator();\n+\tconst tests = [];\n \n-\t\treturn api.run(files)\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t\tt.is(result.failCount, 1);\n-\t\t\t\tt.match(result.errors[0].title, /subdir \\S failing-subdir \\S subdir fail/);\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('test', test => {\n+\t\t\ttests.push({\n+\t\t\t\tok: !test.error,\n+\t\t\t\ttitle: test.title\n \t\t\t});\n+\t\t});\n \t});\n \n-\ttest(`${prefix} fail-fast mode`, t => {\n-\t\tconst api = apiCreator({\n-\t\t\tfailFast: true\n+\treturn api.run([\n+\t\tpath.join(__dirname, 'fixture/fail-fast/multiple-files/fails.js'),\n+\t\tpath.join(__dirname, 'fixture/fail-fast/multiple-files/passes.js')\n+\t])\n+\t\t.then(result => {\n+\t\t\tt.ok(api.options.failFast);\n+\t\t\tt.strictDeepEqual(tests, [{\n+\t\t\t\tok: true,\n+\t\t\t\ttitle: `fails ${figures.pointerSmall} first pass`\n+\t\t\t}, {\n+\t\t\t\tok: false,\n+\t\t\t\ttitle: `fails ${figures.pointerSmall} second fail`\n+\t\t\t}]);\n+\t\t\tt.is(result.passCount, 1);\n+\t\t\tt.is(result.failCount, 1);\n \t\t});\n+});\n \n-\t\tconst tests = [];\n+test('fail-fast mode - multiple files & interrupt', t => {\n+\tconst api = apiCreator({\n+\t\tfailFast: true,\n+\t\tconcurrency: 2\n+\t});\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('test', test => {\n-\t\t\t\ttests.push({\n-\t\t\t\t\tok: !test.error,\n-\t\t\t\t\ttitle: test.title\n-\t\t\t\t});\n-\t\t\t});\n-\t\t});\n+\tconst tests = [];\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/fail-fast.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.ok(api.options.failFast);\n-\t\t\t\tt.strictDeepEqual(tests, [{\n-\t\t\t\t\tok: true,\n-\t\t\t\t\ttitle: 'first pass'\n-\t\t\t\t}, {\n-\t\t\t\t\tok: false,\n-\t\t\t\t\ttitle: 'second fail'\n-\t\t\t\t}]);\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t\tt.is(result.failCount, 1);\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('test', test => {\n+\t\t\ttests.push({\n+\t\t\t\tok: !test.error,\n+\t\t\t\ttitle: test.title\n \t\t\t});\n+\t\t});\n \t});\n \n-\ttest(`${prefix} serial execution mode`, t => {\n-\t\tconst api = apiCreator({\n-\t\t\tserial: true\n+\treturn api.run([\n+\t\tpath.join(__dirname, 'fixture/fail-fast/multiple-files/fails.js'),\n+\t\tpath.join(__dirname, 'fixture/fail-fast/multiple-files/passes-slow.js')\n+\t])\n+\t\t.then(result => {\n+\t\t\tt.ok(api.options.failFast);\n+\t\t\tt.strictDeepEqual(tests, [{\n+\t\t\t\tok: true,\n+\t\t\t\ttitle: `fails ${figures.pointerSmall} first pass`\n+\t\t\t}, {\n+\t\t\t\tok: false,\n+\t\t\t\ttitle: `fails ${figures.pointerSmall} second fail`\n+\t\t\t}, {\n+\t\t\t\tok: true,\n+\t\t\t\ttitle: `fails ${figures.pointerSmall} third pass`\n+\t\t\t}, {\n+\t\t\t\tok: true,\n+\t\t\t\ttitle: `passes-slow ${figures.pointerSmall} first pass`\n+\t\t\t}]);\n+\t\t\tt.is(result.passCount, 3);\n+\t\t\tt.is(result.failCount, 1);\n \t\t});\n+});\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/serial.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.ok(api.options.serial);\n-\t\t\t\tt.is(result.passCount, 3);\n-\t\t\t\tt.is(result.failCount, 0);\n-\t\t\t});\n+test('fail-fast mode - crash & serial', t => {\n+\tconst api = apiCreator({\n+\t\tfailFast: true,\n+\t\tserial: true\n \t});\n \n-\ttest(`${prefix} circular references on assertions do not break process.send`, t => {\n-\t\tconst api = apiCreator();\n+\tconst tests = [];\n+\tconst errors = [];\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/circular-reference-on-assertion.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.failCount, 1);\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('test', test => {\n+\t\t\ttests.push({\n+\t\t\t\tok: !test.error,\n+\t\t\t\ttitle: test.title\n \t\t\t});\n+\t\t});\n+\t\trunStatus.on('error', err => {\n+\t\t\terrors.push(err);\n+\t\t});\n \t});\n \n-\ttest(`${prefix} run from package.json folder by default`, t => {\n-\t\tconst api = apiCreator();\n+\treturn api.run([\n+\t\tpath.join(__dirname, 'fixture/fail-fast/crash/crashes.js'),\n+\t\tpath.join(__dirname, 'fixture/fail-fast/crash/passes.js')\n+\t])\n+\t\t.then(result => {\n+\t\t\tt.ok(api.options.failFast);\n+\t\t\tt.strictDeepEqual(tests, []);\n+\t\t\tt.is(errors.length, 1);\n+\t\t\tt.is(errors[0].name, 'AvaError');\n+\t\t\tt.is(errors[0].message, `${path.join('test', 'fixture', 'fail-fast', 'crash', 'crashes.js')} exited with a non-zero exit code: 1`);\n+\t\t\tt.is(result.passCount, 0);\n+\t\t\tt.is(result.failCount, 0);\n+\t\t});\n+});\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/process-cwd-default.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t});\n+test('fail-fast mode - timeout & serial', t => {\n+\tconst api = apiCreator({\n+\t\tfailFast: true,\n+\t\tserial: true,\n+\t\ttimeout: '100ms'\n \t});\n \n-\ttest(`${prefix} control worker's process.cwd() with projectDir option`, t => {\n-\t\tconst fullPath = path.join(__dirname, 'fixture/process-cwd-pkgdir.js');\n-\t\tconst api = apiCreator({projectDir: path.dirname(fullPath)});\n+\tconst tests = [];\n+\tconst errors = [];\n \n-\t\treturn api.run([fullPath])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('test', test => {\n+\t\t\ttests.push({\n+\t\t\t\tok: !test.error,\n+\t\t\t\ttitle: test.title\n \t\t\t});\n+\t\t});\n+\t\trunStatus.on('error', err => {\n+\t\t\terrors.push(err);\n+\t\t});\n \t});\n \n-\ttest(`${prefix} unhandled promises will throw an error`, t => {\n-\t\tt.plan(3);\n+\treturn api.run([\n+\t\tpath.join(__dirname, 'fixture/fail-fast/timeout/fails.js'),\n+\t\tpath.join(__dirname, 'fixture/fail-fast/timeout/passes.js')\n+\t])\n+\t\t.then(result => {\n+\t\t\tt.ok(api.options.failFast);\n+\t\t\tt.strictDeepEqual(tests, []);\n+\t\t\tt.is(errors.length, 1);\n+\t\t\tt.is(errors[0].name, 'AvaError');\n+\t\t\tt.is(errors[0].message, 'Exited because no new tests completed within the last 100ms of inactivity');\n+\t\t\tt.is(result.passCount, 0);\n+\t\t\tt.is(result.failCount, 0);\n+\t\t});\n+});\n \n-\t\tconst api = apiCreator();\n+test('serial execution mode', t => {\n+\tconst api = apiCreator({\n+\t\tserial: true\n+\t});\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('error', data => {\n-\t\t\t\tt.is(data.name, 'Error');\n-\t\t\t\tt.match(data.message, /You can't handle this!/);\n-\t\t\t});\n+\treturn api.run([path.join(__dirname, 'fixture/serial.js')])\n+\t\t.then(result => {\n+\t\t\tt.ok(api.options.serial);\n+\t\t\tt.is(result.passCount, 3);\n+\t\t\tt.is(result.failCount, 0);\n \t\t});\n+});\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/loud-rejection.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t});\n-\t});\n+test('circular references on assertions do not break process.send', t => {\n+\tconst api = apiCreator();\n \n-\ttest(`${prefix} uncaught exception will throw an error`, t => {\n-\t\tt.plan(3);\n+\treturn api.run([path.join(__dirname, 'fixture/circular-reference-on-assertion.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.failCount, 1);\n+\t\t});\n+});\n \n-\t\tconst api = apiCreator();\n+test('run from package.json folder by default', t => {\n+\tconst api = apiCreator();\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('error', data => {\n-\t\t\t\tt.is(data.name, 'Error');\n-\t\t\t\tt.match(data.message, /Can't catch me!/);\n-\t\t\t});\n+\treturn api.run([path.join(__dirname, 'fixture/process-cwd-default.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n+});\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/uncaught-exception.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t});\n-\t});\n+test('control worker\\'s process.cwd() with projectDir option', t => {\n+\tconst fullPath = path.join(__dirname, 'fixture/process-cwd-pkgdir.js');\n+\tconst api = apiCreator({projectDir: path.dirname(fullPath)});\n \n-\ttest(`${prefix} errors can occur without messages`, t => {\n-\t\tconst api = apiCreator();\n+\treturn api.run([fullPath])\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n+\t\t});\n+});\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/error-without-message.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.failCount, 1);\n-\t\t\t\tt.is(result.errors.length, 1);\n-\t\t\t});\n-\t});\n+test('unhandled promises will throw an error', t => {\n+\tt.plan(3);\n \n-\ttest(`${prefix} stack traces for exceptions are corrected using a source map file`, t => {\n-\t\tt.plan(4);\n+\tconst api = apiCreator();\n \n-\t\tconst api = apiCreator({\n-\t\t\tcacheEnabled: true\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('error', data => {\n+\t\t\tt.is(data.name, 'Error');\n+\t\t\tt.match(data.message, /You can't handle this!/);\n \t\t});\n+\t});\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('error', data => {\n-\t\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n-\t\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n-\t\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-file.js:4.*$/m);\n-\t\t\t});\n+\treturn api.run([path.join(__dirname, 'fixture/loud-rejection.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n+});\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/source-map-file.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t});\n-\t});\n+test('uncaught exception will throw an error', t => {\n+\tt.plan(3);\n \n-\ttest(`${prefix} stack traces for exceptions are corrected using a source map file in what looks like a browser env`, t => {\n-\t\tt.plan(4);\n+\tconst api = apiCreator();\n \n-\t\tconst api = apiCreator({\n-\t\t\tcacheEnabled: true\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('error', data => {\n+\t\t\tt.is(data.name, 'Error');\n+\t\t\tt.match(data.message, /Can't catch me!/);\n \t\t});\n+\t});\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('error', data => {\n-\t\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n-\t\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n-\t\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-file-browser-env.js:7.*$/m);\n-\t\t\t});\n+\treturn api.run([path.join(__dirname, 'fixture/uncaught-exception.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n+});\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/source-map-file-browser-env.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t});\n-\t});\n+test('errors can occur without messages', t => {\n+\tconst api = apiCreator();\n \n-\ttest(`${prefix} enhanced assertion formatting necessary whitespace and empty strings`, t => {\n-\t\tconst expected = [\n-\t\t\t[\n-\t\t\t\t/foo === \"\" && \"\" === foo/,\n-\t\t\t\t/foo === \"\"/,\n-\t\t\t\t/foo/\n-\t\t\t],\n-\t\t\t[\n-\t\t\t\t/new Object\\(foo\\) instanceof Object/,\n-\t\t\t\t/Object/,\n-\t\t\t\t/new Object\\(foo\\)/,\n-\t\t\t\t/foo/\n-\t\t\t],\n-\t\t\t[\n-\t\t\t\t/\\[foo].filter\\(item => {\\n\\s+return item === \"bar\";\\n}\\).length > 0/,\n-\t\t\t\t/\\[foo].filter\\(item => {\\n\\s+return item === \"bar\";\\n}\\).length/,\n-\t\t\t\t/\\[foo].filter\\(item => {\\n\\s+return item === \"bar\";\\n}\\)/,\n-\t\t\t\t/\\[foo]/,\n-\t\t\t\t/foo/\n-\t\t\t]\n-\t\t];\n-\n-\t\tt.plan(14);\n-\t\tconst api = apiCreator();\n-\t\treturn api.run([path.join(__dirname, 'fixture/enhanced-assertion-formatting.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.errors.length, 3);\n-\t\t\t\tt.is(result.passCount, 0);\n+\treturn api.run([path.join(__dirname, 'fixture/error-without-message.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.failCount, 1);\n+\t\t\tt.is(result.errors.length, 1);\n+\t\t});\n+});\n \n-\t\t\t\tresult.errors.forEach((error, errorIndex) => {\n-\t\t\t\t\terror.error.statements.forEach((statement, statementIndex) => {\n-\t\t\t\t\t\tt.match(statement[0], expected[errorIndex][statementIndex]);\n-\t\t\t\t\t});\n-\t\t\t\t});\n-\t\t\t});\n-\t});\n+test('stack traces for exceptions are corrected using a source map file', t => {\n+\tt.plan(4);\n \n-\ttest(`${prefix} stack traces for exceptions are corrected using a source map file (cache off)`, t => {\n-\t\tt.plan(4);\n+\tconst api = apiCreator({\n+\t\tcacheEnabled: true\n+\t});\n \n-\t\tconst api = apiCreator({\n-\t\t\tcacheEnabled: false\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('error', data => {\n+\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n+\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n+\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-file.js:4.*$/m);\n \t\t});\n+\t});\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('error', data => {\n-\t\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n-\t\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n-\t\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-file.js:4.*$/m);\n-\t\t\t});\n+\treturn api.run([path.join(__dirname, 'fixture/source-map-file.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n+});\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/source-map-file.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t});\n+test('stack traces for exceptions are corrected using a source map file in what looks like a browser env', t => {\n+\tt.plan(4);\n+\n+\tconst api = apiCreator({\n+\t\tcacheEnabled: true\n \t});\n \n-\ttest(`${prefix} stack traces for exceptions are corrected using a source map, taking an initial source map for the test file into account (cache on)`, t => {\n-\t\tt.plan(4);\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('error', data => {\n+\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n+\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n+\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-file-browser-env.js:7.*$/m);\n+\t\t});\n+\t});\n \n-\t\tconst api = apiCreator({\n-\t\t\tcacheEnabled: true\n+\treturn api.run([path.join(__dirname, 'fixture/source-map-file-browser-env.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n+});\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('error', data => {\n-\t\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n-\t\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n-\t\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-initial-input.js:14.*$/m);\n+test('enhanced assertion formatting necessary whitespace and empty strings', t => {\n+\tconst expected = [\n+\t\t[\n+\t\t\t/foo === \"\" && \"\" === foo/,\n+\t\t\t/foo === \"\"/,\n+\t\t\t/foo/\n+\t\t],\n+\t\t[\n+\t\t\t/new Object\\(foo\\) instanceof Object/,\n+\t\t\t/Object/,\n+\t\t\t/new Object\\(foo\\)/,\n+\t\t\t/foo/\n+\t\t],\n+\t\t[\n+\t\t\t/\\[foo].filter\\(item => {\\n\\s+return item === \"bar\";\\n}\\).length > 0/,\n+\t\t\t/\\[foo].filter\\(item => {\\n\\s+return item === \"bar\";\\n}\\).length/,\n+\t\t\t/\\[foo].filter\\(item => {\\n\\s+return item === \"bar\";\\n}\\)/,\n+\t\t\t/\\[foo]/,\n+\t\t\t/foo/\n+\t\t]\n+\t];\n+\n+\tt.plan(14);\n+\tconst api = apiCreator();\n+\treturn api.run([path.join(__dirname, 'fixture/enhanced-assertion-formatting.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.errors.length, 3);\n+\t\t\tt.is(result.passCount, 0);\n+\n+\t\t\tresult.errors.forEach((error, errorIndex) => {\n+\t\t\t\terror.error.statements.forEach((statement, statementIndex) => {\n+\t\t\t\t\tt.match(statement[0], expected[errorIndex][statementIndex]);\n+\t\t\t\t});\n \t\t\t});\n \t\t});\n+});\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/source-map-initial.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t});\n-\t});\n+test('stack traces for exceptions are corrected using a source map file (cache off)', t => {\n+\tt.plan(4);\n \n-\ttest(`${prefix} stack traces for exceptions are corrected using a source map, taking an initial source map for the test file into account (cache off)`, t => {\n-\t\tt.plan(4);\n+\tconst api = apiCreator({\n+\t\tcacheEnabled: false\n+\t});\n \n-\t\tconst api = apiCreator({\n-\t\t\tcacheEnabled: false\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('error', data => {\n+\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n+\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n+\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-file.js:4.*$/m);\n \t\t});\n+\t});\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('error', data => {\n-\t\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n-\t\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n-\t\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-initial-input.js:14.*$/m);\n-\t\t\t});\n+\treturn api.run([path.join(__dirname, 'fixture/source-map-file.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n+});\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/source-map-initial.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t});\n-\t});\n-\n-\ttest(`${prefix} absolute paths`, t => {\n-\t\tconst api = apiCreator();\n+test('stack traces for exceptions are corrected using a source map, taking an initial source map for the test file into account (cache on)', t => {\n+\tt.plan(4);\n \n-\t\treturn api.run([path.resolve('test/fixture/es2015.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t});\n+\tconst api = apiCreator({\n+\t\tcacheEnabled: true\n \t});\n \n-\ttest(`${prefix} symlink to directory containing test files`, t => {\n-\t\tconst api = apiCreator();\n-\n-\t\treturn api.run([path.join(__dirname, 'fixture/symlink')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t});\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('error', data => {\n+\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n+\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n+\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-initial-input.js:14.*$/m);\n+\t\t});\n \t});\n \n-\ttest(`${prefix} symlink to test file directly`, t => {\n-\t\tconst api = apiCreator();\n-\n-\t\treturn api.run([path.join(__dirname, 'fixture/symlinkfile.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t});\n-\t});\n+\treturn api.run([path.join(__dirname, 'fixture/source-map-initial.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n+\t\t});\n+});\n \n-\ttest(`${prefix} search directories recursively for files`, t => {\n-\t\tconst api = apiCreator();\n+test('stack traces for exceptions are corrected using a source map, taking an initial source map for the test file into account (cache off)', t => {\n+\tt.plan(4);\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/subdir')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 2);\n-\t\t\t\tt.is(result.failCount, 1);\n-\t\t\t});\n+\tconst api = apiCreator({\n+\t\tcacheEnabled: false\n \t});\n \n-\ttest(`${prefix} titles of both passing and failing tests and AssertionErrors are returned`, t => {\n-\t\tconst api = apiCreator();\n-\n-\t\treturn api.run([path.join(__dirname, 'fixture/one-pass-one-fail.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.match(result.errors[0].title, /this is a failing test/);\n-\t\t\t\tt.match(result.tests[0].title, /this is a passing test/);\n-\t\t\t\tt.match(result.errors[0].error.name, /AssertionError/);\n-\t\t\t});\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('error', data => {\n+\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n+\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n+\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-initial-input.js:14.*$/m);\n+\t\t});\n \t});\n \n-\ttest(`${prefix} empty test files cause an AvaError to be emitted`, t => {\n-\t\tt.plan(2);\n+\treturn api.run([path.join(__dirname, 'fixture/source-map-initial.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n+\t\t});\n+});\n \n-\t\tconst api = apiCreator();\n+test('absolute paths', t => {\n+\tconst api = apiCreator();\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('error', err => {\n-\t\t\t\tt.is(err.name, 'AvaError');\n-\t\t\t\tt.match(err.message, /No tests found.*?import \"ava\"/);\n-\t\t\t});\n+\treturn api.run([path.resolve('test/fixture/es2015.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n+});\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/empty.js')]);\n-\t});\n+test('symlink to directory containing test files', t => {\n+\tconst api = apiCreator();\n \n-\ttest(`${prefix} test file with no tests causes an AvaError to be emitted`, t => {\n-\t\tt.plan(2);\n+\treturn api.run([path.join(__dirname, 'fixture/symlink')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n+\t\t});\n+});\n \n-\t\tconst api = apiCreator();\n+test('symlink to test file directly', t => {\n+\tconst api = apiCreator();\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('error', err => {\n-\t\t\t\tt.is(err.name, 'AvaError');\n-\t\t\t\tt.match(err.message, /No tests/);\n-\t\t\t});\n+\treturn api.run([path.join(__dirname, 'fixture/symlinkfile.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n+});\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/no-tests.js')]);\n-\t});\n+test('search directories recursively for files', t => {\n+\tconst api = apiCreator();\n \n-\ttest(`${prefix} test file that immediately exits with 0 exit code`, t => {\n-\t\tt.plan(2);\n+\treturn api.run([path.join(__dirname, 'fixture/subdir')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 2);\n+\t\t\tt.is(result.failCount, 1);\n+\t\t});\n+});\n \n-\t\tconst api = apiCreator();\n+test('titles of both passing and failing tests and AssertionErrors are returned', t => {\n+\tconst api = apiCreator();\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('error', err => {\n-\t\t\t\tt.is(err.name, 'AvaError');\n-\t\t\t\tt.match(err.message, /Test results were not received from/);\n-\t\t\t});\n+\treturn api.run([path.join(__dirname, 'fixture/one-pass-one-fail.js')])\n+\t\t.then(result => {\n+\t\t\tt.match(result.errors[0].title, /this is a failing test/);\n+\t\t\tt.match(result.tests[0].title, /this is a passing test/);\n+\t\t\tt.match(result.errors[0].error.name, /AssertionError/);\n \t\t});\n+});\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/immediate-0-exit.js')]);\n-\t});\n-\n-\ttest(`${prefix} test file that immediately exits with 3 exit code`, t => {\n-\t\tt.plan(3);\n+test('empty test files cause an AvaError to be emitted', t => {\n+\tt.plan(2);\n \n-\t\tconst api = apiCreator();\n+\tconst api = apiCreator();\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('error', err => {\n-\t\t\t\tt.is(err.name, 'AvaError');\n-\t\t\t\tt.is(err.file, path.join('test', 'fixture', 'immediate-3-exit.js'));\n-\t\t\t\tt.match(err.message, /exited with a non-zero exit code: 3/);\n-\t\t\t});\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('error', err => {\n+\t\t\tt.is(err.name, 'AvaError');\n+\t\t\tt.match(err.message, /No tests found.*?import \"ava\"/);\n \t\t});\n-\n-\t\treturn api.run([path.join(__dirname, 'fixture/immediate-3-exit.js')]);\n \t});\n \n-\ttest(`${prefix} testing nonexistent files causes an AvaError to be emitted`, t => {\n-\t\tt.plan(2);\n+\treturn api.run([path.join(__dirname, 'fixture/empty.js')]);\n+});\n \n-\t\tconst api = apiCreator();\n+test('test file with no tests causes an AvaError to be emitted', t => {\n+\tt.plan(2);\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('error', err => {\n-\t\t\t\tt.is(err.name, 'AvaError');\n-\t\t\t\tt.match(err.message, /Couldn't find any files to test/);\n-\t\t\t});\n-\t\t});\n+\tconst api = apiCreator();\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/broken.js')]);\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('error', err => {\n+\t\t\tt.is(err.name, 'AvaError');\n+\t\t\tt.match(err.message, /No tests/);\n+\t\t});\n \t});\n \n-\ttest(`${prefix} test file in node_modules is ignored`, t => {\n-\t\tt.plan(2);\n+\treturn api.run([path.join(__dirname, 'fixture/no-tests.js')]);\n+});\n \n-\t\tconst api = apiCreator();\n+test('test file that immediately exits with 0 exit code', t => {\n+\tt.plan(2);\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('error', err => {\n-\t\t\t\tt.is(err.name, 'AvaError');\n-\t\t\t\tt.match(err.message, /Couldn't find any files to test/);\n-\t\t\t});\n-\t\t});\n+\tconst api = apiCreator();\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/ignored-dirs/node_modules/test.js')]);\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('error', err => {\n+\t\t\tt.is(err.name, 'AvaError');\n+\t\t\tt.match(err.message, /Test results were not received from/);\n+\t\t});\n \t});\n \n-\ttest(`${prefix} test file in fixtures is ignored`, t => {\n-\t\tt.plan(2);\n+\treturn api.run([path.join(__dirname, 'fixture/immediate-0-exit.js')]);\n+});\n \n-\t\tconst api = apiCreator();\n+test('test file that immediately exits with 3 exit code', t => {\n+\tt.plan(3);\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('error', err => {\n-\t\t\t\tt.is(err.name, 'AvaError');\n-\t\t\t\tt.match(err.message, /Couldn't find any files to test/);\n-\t\t\t});\n-\t\t});\n+\tconst api = apiCreator();\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/ignored-dirs/fixtures/test.js')]);\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('error', err => {\n+\t\t\tt.is(err.name, 'AvaError');\n+\t\t\tt.is(err.file, path.join('test', 'fixture', 'immediate-3-exit.js'));\n+\t\t\tt.match(err.message, /exited with a non-zero exit code: 3/);\n+\t\t});\n \t});\n \n-\ttest(`${prefix} test file in helpers is ignored`, t => {\n-\t\tt.plan(2);\n+\treturn api.run([path.join(__dirname, 'fixture/immediate-3-exit.js')]);\n+});\n \n-\t\tconst api = apiCreator();\n+test('testing nonexistent files causes an AvaError to be emitted', t => {\n+\tt.plan(2);\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('error', err => {\n-\t\t\t\tt.is(err.name, 'AvaError');\n-\t\t\t\tt.match(err.message, /Couldn't find any files to test/);\n-\t\t\t});\n-\t\t});\n+\tconst api = apiCreator();\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/ignored-dirs/helpers/test.js')]);\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('error', err => {\n+\t\t\tt.is(err.name, 'AvaError');\n+\t\t\tt.match(err.message, /Couldn't find any files to test/);\n+\t\t});\n \t});\n \n-\ttest(`${prefix} Node.js-style --require CLI argument`, t => {\n-\t\tconst requirePath = './' + path.relative('.', path.join(__dirname, 'fixture/install-global.js')).replace(/\\\\/g, '/');\n+\treturn api.run([path.join(__dirname, 'fixture/broken.js')]);\n+});\n \n-\t\tconst api = apiCreator({\n-\t\t\trequire: [requirePath]\n-\t\t});\n+test('test file in node_modules is ignored', t => {\n+\tt.plan(2);\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/validate-installed-global.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t});\n-\t});\n+\tconst api = apiCreator();\n \n-\ttest(`${prefix} Node.js-style --require CLI argument module not found`, t => {\n-\t\tt.throws(() => {\n-\t\t\t/* eslint no-new: 0 */\n-\t\t\tapiCreator({require: ['foo-bar']});\n-\t\t}, /^Could not resolve required module 'foo-bar'$/);\n-\t\tt.end();\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('error', err => {\n+\t\t\tt.is(err.name, 'AvaError');\n+\t\t\tt.match(err.message, /Couldn't find any files to test/);\n+\t\t});\n \t});\n \n-\ttest(`${prefix} caching is enabled by default`, t => {\n-\t\tdel.sync(path.join(__dirname, 'fixture/caching/node_modules'));\n+\treturn api.run([path.join(__dirname, 'fixture/ignored-dirs/node_modules/test.js')]);\n+});\n+\n+test('test file in fixtures is ignored', t => {\n+\tt.plan(2);\n+\n+\tconst api = apiCreator();\n \n-\t\tconst api = apiCreator({\n-\t\t\tresolveTestsFrom: path.join(__dirname, 'fixture/caching')\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('error', err => {\n+\t\t\tt.is(err.name, 'AvaError');\n+\t\t\tt.match(err.message, /Couldn't find any files to test/);\n \t\t});\n+\t});\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/caching/test.js')])\n-\t\t\t.then(() => {\n-\t\t\t\tconst files = fs.readdirSync(path.join(__dirname, 'fixture/caching/node_modules/.cache/ava'));\n-\t\t\t\tt.ok(files.length, 4);\n-\t\t\t\tt.is(files.filter(x => endsWithBin(x)).length, 1);\n-\t\t\t\tt.is(files.filter(x => endsWithJs(x)).length, 2);\n-\t\t\t\tt.is(files.filter(x => endsWithMap(x)).length, 1);\n-\t\t\t});\n+\treturn api.run([path.join(__dirname, 'fixture/ignored-dirs/fixtures/test.js')]);\n+});\n \n-\t\tfunction endsWithBin(filename) {\n-\t\t\treturn /\\.bin$/.test(filename);\n-\t\t}\n+test('test file in helpers is ignored', t => {\n+\tt.plan(2);\n \n-\t\tfunction endsWithJs(filename) {\n-\t\t\treturn /\\.js$/.test(filename);\n-\t\t}\n+\tconst api = apiCreator();\n \n-\t\tfunction endsWithMap(filename) {\n-\t\t\treturn /\\.map$/.test(filename);\n-\t\t}\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('error', err => {\n+\t\t\tt.is(err.name, 'AvaError');\n+\t\t\tt.match(err.message, /Couldn't find any files to test/);\n+\t\t});\n \t});\n \n-\ttest(`${prefix} caching can be disabled`, t => {\n-\t\tdel.sync(path.join(__dirname, 'fixture/caching/node_modules'));\n+\treturn api.run([path.join(__dirname, 'fixture/ignored-dirs/helpers/test.js')]);\n+});\n \n-\t\tconst api = apiCreator({\n-\t\t\tresolveTestsFrom: path.join(__dirname, 'fixture/caching'),\n-\t\t\tcacheEnabled: false\n-\t\t});\n+test('Node.js-style --require CLI argument', t => {\n+\tconst requirePath = './' + path.relative('.', path.join(__dirname, 'fixture/install-global.js')).replace(/\\\\/g, '/');\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/caching/test.js')])\n-\t\t\t.then(() => {\n-\t\t\t\tt.false(fs.existsSync(path.join(__dirname, 'fixture/caching/node_modules/.cache/ava')));\n-\t\t\t});\n+\tconst api = apiCreator({\n+\t\trequire: [requirePath]\n \t});\n \n-\ttest(`${prefix} test file with only skipped tests does not create a failure`, t => {\n-\t\tconst api = apiCreator();\n+\treturn api.run([path.join(__dirname, 'fixture/validate-installed-global.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n+\t\t});\n+});\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/skip-only.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.tests.length, 1);\n-\t\t\t\tt.true(result.tests[0].skip);\n-\t\t\t});\n-\t});\n+test('Node.js-style --require CLI argument module not found', t => {\n+\tt.throws(() => {\n+\t\t/* eslint no-new: 0 */\n+\t\tapiCreator({require: ['foo-bar']});\n+\t}, /^Could not resolve required module 'foo-bar'$/);\n+\tt.end();\n+});\n \n-\ttest(`${prefix} test file with only skipped tests does not run hooks`, t => {\n-\t\tconst api = apiCreator();\n+test('caching is enabled by default', t => {\n+\tdel.sync(path.join(__dirname, 'fixture/caching/node_modules'));\n \n-\t\treturn api.run([path.join(__dirname, 'fixture/hooks-skipped.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.tests.length, 1);\n-\t\t\t\tt.is(result.skipCount, 1);\n-\t\t\t\tt.is(result.passCount, 0);\n-\t\t\t\tt.is(result.failCount, 0);\n-\t\t\t});\n+\tconst api = apiCreator({\n+\t\tprojectDir: path.join(__dirname, 'fixture/caching')\n \t});\n \n-\ttest(`${prefix} resets state before running`, t => {\n-\t\tconst api = apiCreator();\n-\n-\t\treturn api.run([path.resolve('test/fixture/es2015.js')]).then(result => {\n-\t\t\tt.is(result.passCount, 1);\n-\t\t\treturn api.run([path.resolve('test/fixture/es2015.js')]);\n-\t\t}).then(result => {\n-\t\t\tt.is(result.passCount, 1);\n+\treturn api.run([path.join(__dirname, 'fixture/caching/test.js')])\n+\t\t.then(() => {\n+\t\t\tconst files = fs.readdirSync(path.join(__dirname, 'fixture/caching/node_modules/.cache/ava'));\n+\t\t\tt.ok(files.length, 4);\n+\t\t\tt.is(files.filter(x => endsWithBin(x)).length, 1);\n+\t\t\tt.is(files.filter(x => endsWithJs(x)).length, 2);\n+\t\t\tt.is(files.filter(x => endsWithMap(x)).length, 1);\n \t\t});\n-\t});\n \n-\ttest(`${prefix} emits dependencies for test files`, t => {\n-\t\tt.plan(8);\n+\tfunction endsWithBin(filename) {\n+\t\treturn /\\.bin$/.test(filename);\n+\t}\n \n-\t\tconst api = apiCreator({\n-\t\t\trequire: [path.resolve('test/fixture/with-dependencies/require-custom.js')]\n-\t\t});\n+\tfunction endsWithJs(filename) {\n+\t\treturn /\\.js$/.test(filename);\n+\t}\n \n-\t\tconst testFiles = [\n-\t\t\tpath.normalize('test/fixture/with-dependencies/no-tests.js'),\n-\t\t\tpath.normalize('test/fixture/with-dependencies/test.js'),\n-\t\t\tpath.normalize('test/fixture/with-dependencies/test-failure.js'),\n-\t\t\tpath.normalize('test/fixture/with-dependencies/test-uncaught-exception.js')\n-\t\t];\n+\tfunction endsWithMap(filename) {\n+\t\treturn /\\.map$/.test(filename);\n+\t}\n+});\n \n-\t\tconst sourceFiles = [\n-\t\t\tpath.resolve('test/fixture/with-dependencies/dep-1.js'),\n-\t\t\tpath.resolve('test/fixture/with-dependencies/dep-2.js'),\n-\t\t\tpath.resolve('test/fixture/with-dependencies/dep-3.custom')\n-\t\t];\n+test('caching can be disabled', t => {\n+\tdel.sync(path.join(__dirname, 'fixture/caching/node_modules'));\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('dependencies', (file, dependencies) => {\n-\t\t\t\tt.notEqual(testFiles.indexOf(file), -1);\n-\t\t\t\tt.strictDeepEqual(dependencies.slice(-3), sourceFiles);\n-\t\t\t});\n+\tconst api = apiCreator({\n+\t\tresolveTestsFrom: path.join(__dirname, 'fixture/caching'),\n+\t\tcacheEnabled: false\n+\t});\n \n-\t\t\t// The test files are designed to cause errors so ignore them here.\n-\t\t\trunStatus.on('error', () => {});\n+\treturn api.run([path.join(__dirname, 'fixture/caching/test.js')])\n+\t\t.then(() => {\n+\t\t\tt.false(fs.existsSync(path.join(__dirname, 'fixture/caching/node_modules/.cache/ava')));\n \t\t});\n+});\n \n-\t\tconst result = api.run(['test/fixture/with-dependencies/*test*.js']);\n+test('test file with only skipped tests does not create a failure', t => {\n+\tconst api = apiCreator();\n \n-\t\treturn result.catch(() => {});\n-\t});\n+\treturn api.run([path.join(__dirname, 'fixture/skip-only.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.tests.length, 1);\n+\t\t\tt.true(result.tests[0].skip);\n+\t\t});\n+});\n \n-\ttest(`${prefix} emits stats for test files`, t => {\n-\t\tt.plan(2);\n+test('test file with only skipped tests does not run hooks', t => {\n+\tconst api = apiCreator();\n \n-\t\tconst api = apiCreator();\n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('stats', stats => {\n-\t\t\t\tif (stats.file === path.normalize('test/fixture/exclusive.js')) {\n-\t\t\t\t\tt.is(stats.hasExclusive, true);\n-\t\t\t\t} else if (stats.file === path.normalize('test/fixture/generators.js')) {\n-\t\t\t\t\tt.is(stats.hasExclusive, false);\n-\t\t\t\t} else {\n-\t\t\t\t\tt.ok(false);\n-\t\t\t\t}\n-\t\t\t});\n+\treturn api.run([path.join(__dirname, 'fixture/hooks-skipped.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.tests.length, 1);\n+\t\t\tt.is(result.skipCount, 1);\n+\t\t\tt.is(result.passCount, 0);\n+\t\t\tt.is(result.failCount, 0);\n \t\t});\n+});\n \n-\t\treturn api.run([\n-\t\t\t'test/fixture/exclusive.js',\n-\t\t\t'test/fixture/generators.js'\n-\t\t]);\n+test('resets state before running', t => {\n+\tconst api = apiCreator();\n+\n+\treturn api.run([path.resolve('test/fixture/es2015.js')]).then(result => {\n+\t\tt.is(result.passCount, 1);\n+\t\treturn api.run([path.resolve('test/fixture/es2015.js')]);\n+\t}).then(result => {\n+\t\tt.is(result.passCount, 1);\n \t});\n+});\n \n-\ttest(`${prefix} verify test count`, t => {\n-\t\tt.plan(8);\n+test('emits dependencies for test files', t => {\n+\tt.plan(8);\n \n-\t\tconst api = apiCreator();\n+\tconst api = apiCreator({\n+\t\trequire: [path.resolve('test/fixture/with-dependencies/require-custom.js')]\n+\t});\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\tt.is(runStatus.passCount, 0);\n-\t\t\tt.is(runStatus.failCount, 0);\n-\t\t\tt.is(runStatus.skipCount, 0);\n-\t\t\tt.is(runStatus.todoCount, 0);\n+\tconst testFiles = [\n+\t\tpath.normalize('test/fixture/with-dependencies/no-tests.js'),\n+\t\tpath.normalize('test/fixture/with-dependencies/test.js'),\n+\t\tpath.normalize('test/fixture/with-dependencies/test-failure.js'),\n+\t\tpath.normalize('test/fixture/with-dependencies/test-uncaught-exception.js')\n+\t];\n+\n+\tconst sourceFiles = [\n+\t\tpath.resolve('test/fixture/with-dependencies/dep-1.js'),\n+\t\tpath.resolve('test/fixture/with-dependencies/dep-2.js'),\n+\t\tpath.resolve('test/fixture/with-dependencies/dep-3.custom')\n+\t];\n+\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('dependencies', (file, dependencies) => {\n+\t\t\tt.notEqual(testFiles.indexOf(file), -1);\n+\t\t\tt.strictDeepEqual(dependencies.slice(-3), sourceFiles);\n \t\t});\n \n-\t\treturn api.run([\n-\t\t\tpath.join(__dirname, 'fixture/test-count.js'),\n-\t\t\tpath.join(__dirname, 'fixture/test-count-2.js'),\n-\t\t\tpath.join(__dirname, 'fixture/test-count-3.js')\n-\t\t]).then(result => {\n-\t\t\tt.is(result.passCount, 4, 'pass count');\n-\t\t\tt.is(result.failCount, 3, 'fail count');\n-\t\t\tt.is(result.skipCount, 3, 'skip count');\n-\t\t\tt.is(result.todoCount, 3, 'todo count');\n-\t\t});\n+\t\t// The test files are designed to cause errors so ignore them here.\n+\t\trunStatus.on('error', () => {});\n \t});\n \n-\ttest(`${prefix} babel.testOptions with a custom plugin`, t => {\n-\t\tt.plan(2);\n+\tconst result = api.run(['test/fixture/with-dependencies/*test*.js']);\n \n-\t\tconst api = apiCreator({\n-\t\t\tbabelConfig: {\n-\t\t\t\ttestOptions: {\n-\t\t\t\t\tplugins: [testCapitalizerPlugin]\n-\t\t\t\t}\n-\t\t\t},\n-\t\t\tcacheEnabled: false,\n-\t\t\tprojectDir: __dirname\n-\t\t});\n+\treturn result.catch(() => {});\n+});\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('test', data => {\n-\t\t\t\tt.is(data.title, 'FOO');\n-\t\t\t});\n+test('emits stats for test files', t => {\n+\tt.plan(2);\n+\n+\tconst api = apiCreator();\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('stats', stats => {\n+\t\t\tif (stats.file === path.normalize('test/fixture/exclusive.js')) {\n+\t\t\t\tt.is(stats.hasExclusive, true);\n+\t\t\t} else if (stats.file === path.normalize('test/fixture/generators.js')) {\n+\t\t\t\tt.is(stats.hasExclusive, false);\n+\t\t\t} else {\n+\t\t\t\tt.ok(false);\n+\t\t\t}\n \t\t});\n-\n-\t\treturn api.run([path.join(__dirname, 'fixture/babelrc/test.js')])\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t}, t.threw);\n \t});\n \n-\ttest(`${prefix} babel.testOptions.babelrc effectively defaults to true`, t => {\n-\t\tt.plan(3);\n+\treturn api.run([\n+\t\t'test/fixture/exclusive.js',\n+\t\t'test/fixture/generators.js'\n+\t]);\n+});\n \n-\t\tconst api = apiCreator({\n-\t\t\tprojectDir: path.join(__dirname, 'fixture/babelrc')\n-\t\t});\n+test('verify test count', t => {\n+\tt.plan(8);\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('test', data => {\n-\t\t\t\tt.ok((data.title === 'foo') || (data.title === 'repeated test: foo'));\n-\t\t\t});\n-\t\t});\n+\tconst api = apiCreator();\n \n-\t\treturn api.run()\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 2);\n-\t\t\t});\n+\tapi.on('test-run', runStatus => {\n+\t\tt.is(runStatus.passCount, 0);\n+\t\tt.is(runStatus.failCount, 0);\n+\t\tt.is(runStatus.skipCount, 0);\n+\t\tt.is(runStatus.todoCount, 0);\n \t});\n \n-\ttest(`${prefix} babel.testOptions.babelrc can explicitly be true`, t => {\n-\t\tt.plan(3);\n+\treturn api.run([\n+\t\tpath.join(__dirname, 'fixture/test-count.js'),\n+\t\tpath.join(__dirname, 'fixture/test-count-2.js'),\n+\t\tpath.join(__dirname, 'fixture/test-count-3.js')\n+\t]).then(result => {\n+\t\tt.is(result.passCount, 4, 'pass count');\n+\t\tt.is(result.failCount, 3, 'fail count');\n+\t\tt.is(result.skipCount, 3, 'skip count');\n+\t\tt.is(result.todoCount, 3, 'todo count');\n+\t});\n+});\n \n-\t\tconst api = apiCreator({\n-\t\t\tbabelConfig: {\n-\t\t\t\ttestOptions: {babelrc: true}\n-\t\t\t},\n-\t\t\tcacheEnabled: false,\n-\t\t\tprojectDir: path.join(__dirname, 'fixture/babelrc')\n-\t\t});\n+test('babel.testOptions with a custom plugin', t => {\n+\tt.plan(2);\n+\n+\tconst api = apiCreator({\n+\t\tbabelConfig: {\n+\t\t\ttestOptions: {\n+\t\t\t\tplugins: [testCapitalizerPlugin]\n+\t\t\t}\n+\t\t},\n+\t\tcacheEnabled: false,\n+\t\tprojectDir: __dirname\n+\t});\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('test', data => {\n-\t\t\t\tt.ok(data.title === 'foo' || data.title === 'repeated test: foo');\n-\t\t\t});\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('test', data => {\n+\t\t\tt.is(data.title, 'FOO');\n \t\t});\n-\n-\t\treturn api.run()\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 2);\n-\t\t\t});\n \t});\n \n-\ttest(`${prefix} babel.testOptions.babelrc can explicitly be false`, t => {\n-\t\tt.plan(2);\n+\treturn api.run([path.join(__dirname, 'fixture/babelrc/test.js')])\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n+\t\t}, t.threw);\n+});\n+\n+test('babel.testOptions.babelrc effectively defaults to true', t => {\n+\tt.plan(3);\n+\n+\tconst api = apiCreator({\n+\t\tprojectDir: path.join(__dirname, 'fixture/babelrc')\n+\t});\n \n-\t\tconst api = apiCreator({\n-\t\t\tbabelConfig: {\n-\t\t\t\ttestOptions: {babelrc: false}\n-\t\t\t},\n-\t\t\tcacheEnabled: false,\n-\t\t\tprojectDir: path.join(__dirname, 'fixture/babelrc')\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('test', data => {\n+\t\t\tt.ok((data.title === 'foo') || (data.title === 'repeated test: foo'));\n \t\t});\n+\t});\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('test', data => {\n-\t\t\t\tt.is(data.title, 'foo');\n-\t\t\t});\n+\treturn api.run()\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 2);\n \t\t});\n+});\n \n-\t\treturn api.run()\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 1);\n-\t\t\t});\n-\t});\n+test('babel.testOptions.babelrc can explicitly be true', t => {\n+\tt.plan(3);\n \n-\ttest(`${prefix} babelConfig.testOptions merges plugins with .babelrc`, t => {\n-\t\tt.plan(3);\n+\tconst api = apiCreator({\n+\t\tbabelConfig: {\n+\t\t\ttestOptions: {babelrc: true}\n+\t\t},\n+\t\tcacheEnabled: false,\n+\t\tprojectDir: path.join(__dirname, 'fixture/babelrc')\n+\t});\n \n-\t\tconst api = apiCreator({\n-\t\t\tbabelConfig: {\n-\t\t\t\ttestOptions: {\n-\t\t\t\t\tbabelrc: true,\n-\t\t\t\t\tplugins: [testCapitalizerPlugin]\n-\t\t\t\t}\n-\t\t\t},\n-\t\t\tcacheEnabled: false,\n-\t\t\tprojectDir: path.join(__dirname, 'fixture/babelrc')\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('test', data => {\n+\t\t\tt.ok(data.title === 'foo' || data.title === 'repeated test: foo');\n \t\t});\n+\t});\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('test', data => {\n-\t\t\t\tt.ok(data.title === 'FOO' || data.title === 'repeated test: foo');\n-\t\t\t});\n+\treturn api.run()\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 2);\n \t\t});\n+});\n \n-\t\treturn api.run()\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 2);\n-\t\t\t});\n-\t});\n+test('babel.testOptions.babelrc can explicitly be false', t => {\n+\tt.plan(2);\n \n-\ttest(`${prefix} babelConfig.testOptions with extends still merges plugins with .babelrc`, t => {\n-\t\tt.plan(3);\n+\tconst api = apiCreator({\n+\t\tbabelConfig: {\n+\t\t\ttestOptions: {babelrc: false}\n+\t\t},\n+\t\tcacheEnabled: false,\n+\t\tprojectDir: path.join(__dirname, 'fixture/babelrc')\n+\t});\n \n-\t\tconst api = apiCreator({\n-\t\t\tbabelConfig: {\n-\t\t\t\ttestOptions: {\n-\t\t\t\t\tplugins: [testCapitalizerPlugin],\n-\t\t\t\t\textends: path.join(__dirname, 'fixture/babelrc/.alt-babelrc')\n-\t\t\t\t}\n-\t\t\t},\n-\t\t\tcacheEnabled: false,\n-\t\t\tprojectDir: path.join(__dirname, 'fixture/babelrc')\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('test', data => {\n+\t\t\tt.is(data.title, 'foo');\n \t\t});\n+\t});\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('test', data => {\n-\t\t\t\tt.ok(data.title === 'BAR' || data.title === 'repeated test: bar');\n-\t\t\t});\n+\treturn api.run()\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n+});\n \n-\t\treturn api.run()\n-\t\t\t.then(result => {\n-\t\t\t\tt.is(result.passCount, 2);\n-\t\t\t});\n+test('babelConfig.testOptions merges plugins with .babelrc', t => {\n+\tt.plan(3);\n+\n+\tconst api = apiCreator({\n+\t\tbabelConfig: {\n+\t\t\ttestOptions: {\n+\t\t\t\tbabelrc: true,\n+\t\t\t\tplugins: [testCapitalizerPlugin]\n+\t\t\t}\n+\t\t},\n+\t\tcacheEnabled: false,\n+\t\tprojectDir: path.join(__dirname, 'fixture/babelrc')\n \t});\n \n-\ttest(`${prefix} using --match with no matching tests causes an AvaError to be emitted`, t => {\n-\t\tt.plan(2);\n-\n-\t\tconst api = apiCreator({\n-\t\t\tmatch: ['can\\'t match this']\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('test', data => {\n+\t\t\tt.ok(data.title === 'FOO' || data.title === 'repeated test: foo');\n \t\t});\n+\t});\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('test', data => {\n-\t\t\t\tt.fail(`Unexpected test run: ${data.title}`);\n-\t\t\t});\n-\t\t\trunStatus.on('error', err => {\n-\t\t\t\tt.is(err.name, 'AvaError');\n-\t\t\t\tt.match(err.message, /Couldn't find any matching tests/);\n-\t\t\t});\n+\treturn api.run()\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 2);\n \t\t});\n+});\n \n-\t\treturn api.run([\n-\t\t\tpath.join(__dirname, 'fixture/match-no-match.js'),\n-\t\t\tpath.join(__dirname, 'fixture/match-no-match-2.js'),\n-\t\t\tpath.join(__dirname, 'fixture/test-count.js')\n-\t\t]);\n+test('babelConfig.testOptions with extends still merges plugins with .babelrc', t => {\n+\tt.plan(3);\n+\n+\tconst api = apiCreator({\n+\t\tbabelConfig: {\n+\t\t\ttestOptions: {\n+\t\t\t\tplugins: [testCapitalizerPlugin],\n+\t\t\t\textends: path.join(__dirname, 'fixture/babelrc/.alt-babelrc')\n+\t\t\t}\n+\t\t},\n+\t\tcacheEnabled: false,\n+\t\tprojectDir: path.join(__dirname, 'fixture/babelrc')\n \t});\n \n-\ttest(`${prefix} using --match with matching tests will only report those passing tests`, t => {\n-\t\tt.plan(2);\n-\n-\t\tconst api = apiCreator({\n-\t\t\tmatch: ['this test will match']\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('test', data => {\n+\t\t\tt.ok(data.title === 'BAR' || data.title === 'repeated test: bar');\n \t\t});\n+\t});\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('test', data => {\n-\t\t\t\tt.match(data.title, /^match-no-match-2 .+ this test will match$/);\n-\t\t\t});\n-\t\t\trunStatus.on('error', err => {\n-\t\t\t\tt.fail(`Unexpected failure: ${err}`);\n-\t\t\t});\n+\treturn api.run()\n+\t\t.then(result => {\n+\t\t\tt.is(result.passCount, 2);\n \t\t});\n+});\n \n-\t\treturn api.run([\n-\t\t\tpath.join(__dirname, 'fixture/match-no-match.js'),\n-\t\t\tpath.join(__dirname, 'fixture/match-no-match-2.js'),\n-\t\t\tpath.join(__dirname, 'fixture/test-count.js')\n-\t\t]).then(result => {\n-\t\t\tt.is(result.passCount, 1);\n-\t\t}).catch(() => {\n-\t\t\tt.fail();\n+test('using --match with no matching tests causes an AvaError to be emitted', t => {\n+\tt.plan(2);\n+\n+\tconst api = apiCreator({\n+\t\tmatch: ['can\\'t match this']\n+\t});\n+\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('test', data => {\n+\t\t\tt.fail(`Unexpected test run: ${data.title}`);\n+\t\t});\n+\t\trunStatus.on('error', err => {\n+\t\t\tt.is(err.name, 'AvaError');\n+\t\t\tt.match(err.message, /Couldn't find any matching tests/);\n \t\t});\n \t});\n \n-\ttest(`${prefix} errors thrown when running files are emitted`, t => {\n-\t\tt.plan(3);\n+\treturn api.run([\n+\t\tpath.join(__dirname, 'fixture/match-no-match.js'),\n+\t\tpath.join(__dirname, 'fixture/match-no-match-2.js'),\n+\t\tpath.join(__dirname, 'fixture/test-count.js')\n+\t]);\n+});\n \n-\t\tconst api = apiCreator();\n+test('using --match with matching tests will only report those passing tests', t => {\n+\tt.plan(2);\n \n-\t\tapi.on('test-run', runStatus => {\n-\t\t\trunStatus.on('error', err => {\n-\t\t\t\tt.is(err.name, 'SyntaxError');\n-\t\t\t\tt.is(err.file, path.join('test', 'fixture', 'syntax-error.js'));\n-\t\t\t\tt.match(err.message, /Unexpected token/);\n-\t\t\t});\n+\tconst api = apiCreator({\n+\t\tmatch: ['this test will match']\n+\t});\n+\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('test', data => {\n+\t\t\tt.match(data.title, /^match-no-match-2 .+ this test will match$/);\n+\t\t});\n+\t\trunStatus.on('error', err => {\n+\t\t\tt.fail(`Unexpected failure: ${err}`);\n \t\t});\n+\t});\n \n-\t\treturn api.run([\n-\t\t\tpath.join(__dirname, 'fixture/es2015.js'),\n-\t\t\tpath.join(__dirname, 'fixture/syntax-error.js')\n-\t\t]);\n+\treturn api.run([\n+\t\tpath.join(__dirname, 'fixture/match-no-match.js'),\n+\t\tpath.join(__dirname, 'fixture/match-no-match-2.js'),\n+\t\tpath.join(__dirname, 'fixture/test-count.js')\n+\t]).then(result => {\n+\t\tt.is(result.passCount, 1);\n+\t}).catch(() => {\n+\t\tt.fail();\n \t});\n-}\n+});\n+\n+test('errors thrown when running files are emitted', t => {\n+\tt.plan(3);\n+\n+\tconst api = apiCreator();\n+\n+\tapi.on('test-run', runStatus => {\n+\t\trunStatus.on('error', err => {\n+\t\t\tt.is(err.name, 'SyntaxError');\n+\t\t\tt.is(err.file, path.join('test', 'fixture', 'syntax-error.js'));\n+\t\t\tt.match(err.message, /Unexpected token/);\n+\t\t});\n+\t});\n+\n+\treturn api.run([\n+\t\tpath.join(__dirname, 'fixture/es2015.js'),\n+\t\tpath.join(__dirname, 'fixture/syntax-error.js')\n+\t]);\n+});\n \n function generatePassDebugTests(execArgv, expectedInspectIndex) {\n \ttest(`pass ${execArgv.join(' ')} to fork`, t => {\n \t\tconst api = apiCreator({testOnlyExecArgv: execArgv});\n-\t\treturn api._computeForkExecArgs(['foo.js'])\n+\t\treturn api._computeForkExecArgv()\n \t\t\t.then(result => {\n-\t\t\t\tt.true(result.length === 1);\n+\t\t\t\tt.true(result.length === execArgv.length);\n \t\t\t\tif (expectedInspectIndex === -1) {\n-\t\t\t\t\tt.true(result[0].length === 1);\n-\t\t\t\t\tt.true(/--debug=\\d+/.test(result[0][0]));\n+\t\t\t\t\tt.true(/--debug=\\d+/.test(result[0]));\n \t\t\t\t} else {\n-\t\t\t\t\tt.true(/--inspect=\\d+/.test(result[0][expectedInspectIndex]));\n+\t\t\t\t\tt.true(/--inspect=\\d+/.test(result[expectedInspectIndex]));\n \t\t\t\t}\n \t\t\t});\n \t});"
      },
      {
        "sha": "4336ff67b242b85670ccff1a414f2f612dbc086b",
        "filename": "test/assert.js",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Fassert.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Fassert.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fassert.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -1,5 +1,5 @@\n 'use strict';\n-require('../lib/globals').options.color = false;\n+require('../lib/worker-options').set({color: false});\n \n const path = require('path');\n const stripAnsi = require('strip-ansi');"
      },
      {
        "sha": "d23ac0186c712fba0cc56fd583ad6128b36b138b",
        "filename": "test/beautify-stack.js",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Fbeautify-stack.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Fbeautify-stack.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fbeautify-stack.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -1,7 +1,9 @@\n 'use strict';\n+require('../lib/worker-options').set({});\n+\n const proxyquire = require('proxyquire').noPreserveCache();\n const test = require('tap').test;\n-const Sequence = require('../lib/sequence');\n+const Runner = require('../lib/runner');\n \n const beautifyStack = proxyquire('../lib/beautify-stack', {\n \tdebug() {\n@@ -56,20 +58,20 @@ test('returns empty string without any arguments', t => {\n \n test('beautify stack - removes uninteresting lines', t => {\n \ttry {\n-\t\tconst seq = new Sequence([{\n+\t\tconst runner = new Runner();\n+\t\trunner.runSingle({\n \t\t\trun() {\n \t\t\t\tfooFunc();\n \t\t\t}\n-\t\t}]);\n-\t\tseq.run();\n+\t\t});\n \t} catch (err) {\n \t\tconst stack = beautifyStack(err.stack);\n \t\tt.match(stack, /fooFunc/);\n \t\tt.match(stack, /barFunc/);\n-\t\t// The runNext line is introduced by Sequence. It's internal so it should\n+\t\t// The runSingle line is introduced by Runner. It's internal so it should\n \t\t// be stripped.\n-\t\tt.match(err.stack, /runNext/);\n-\t\tt.notMatch(stack, /runNext/);\n+\t\tt.match(err.stack, /runSingle/);\n+\t\tt.notMatch(stack, /runSingle/);\n \t\tt.end();\n \t}\n });"
      },
      {
        "sha": "07652fc397e19e293143726fc59b9d9bc54a2f1b",
        "filename": "test/cli.js",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Fcli.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Fcli.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fcli.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -199,7 +199,7 @@ test('improper use of t.throws, even if caught and then rethrown too slowly, wil\n \t});\n });\n \n-test('babel require hook only does not apply to source files', t => {\n+test('precompiler require hook does not apply to source files', t => {\n \tt.plan(3);\n \n \texecCli('fixture/babel-hook.js', (err, stdout, stderr) => {"
      },
      {
        "sha": "78edd31786e50a2ebca455ad5140eaba1bee75a8",
        "filename": "test/concurrent.js",
        "status": "removed",
        "additions": 0,
        "deletions": 790,
        "changes": 790,
        "blob_url": "https://github.com/avajs/ava/blob/51a0ff02d4c4dcb9036e7f56c0860dfee330e238/test%2Fconcurrent.js",
        "raw_url": "https://github.com/avajs/ava/raw/51a0ff02d4c4dcb9036e7f56c0860dfee330e238/test%2Fconcurrent.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fconcurrent.js?ref=51a0ff02d4c4dcb9036e7f56c0860dfee330e238",
        "patch": "@@ -1,790 +0,0 @@\n-'use strict';\n-const tap = require('tap');\n-const isPromise = require('is-promise');\n-const Concurrent = require('../lib/concurrent');\n-\n-let results = [];\n-const test = (name, fn) => {\n-\ttap.test(name, t => {\n-\t\tresults = [];\n-\t\treturn fn(t);\n-\t});\n-};\n-function collect(result) {\n-\tif (isPromise(result)) {\n-\t\treturn result.then(collect);\n-\t}\n-\n-\tresults.push(result);\n-\treturn result.passed;\n-}\n-\n-function pass(val) {\n-\treturn {\n-\t\trun() {\n-\t\t\treturn collect({\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: val\n-\t\t\t});\n-\t\t}\n-\t};\n-}\n-\n-function fail(val) {\n-\treturn {\n-\t\trun() {\n-\t\t\treturn collect({\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: val\n-\t\t\t});\n-\t\t}\n-\t};\n-}\n-\n-function failWithTypeError() {\n-\treturn {\n-\t\trun() {\n-\t\t\tthrow new TypeError('Unexpected Error');\n-\t\t}\n-\t};\n-}\n-\n-function passAsync(val) {\n-\treturn {\n-\t\trun() {\n-\t\t\treturn collect(Promise.resolve({\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: val\n-\t\t\t}));\n-\t\t}\n-\t};\n-}\n-\n-function failAsync(err) {\n-\treturn {\n-\t\trun() {\n-\t\t\treturn collect(Promise.resolve({\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: err\n-\t\t\t}));\n-\t\t}\n-\t};\n-}\n-\n-function reject(err) {\n-\treturn {\n-\t\trun() {\n-\t\t\treturn Promise.reject(err);\n-\t\t}\n-\t};\n-}\n-\n-test('all sync - all pass - no bail', t => {\n-\tconst passed = new Concurrent(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpass('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\tfalse\n-\t).run();\n-\n-\tt.equal(passed, true);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'a'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'b'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'c'\n-\t\t}\n-\t]);\n-\tt.end();\n-});\n-\n-test('all sync - no failure - bail', t => {\n-\tconst passed = new Concurrent(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpass('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\ttrue\n-\t).run();\n-\n-\tt.equal(passed, true);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'a'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'b'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'c'\n-\t\t}\n-\t]);\n-\tt.end();\n-});\n-\n-test('all sync - begin failure - no bail', t => {\n-\tconst passed = new Concurrent(\n-\t\t[\n-\t\t\tfail('a'),\n-\t\t\tpass('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\tfalse\n-\t).run();\n-\n-\tt.equal(passed, false);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: false,\n-\t\t\treason: 'a'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'b'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'c'\n-\t\t}\n-\t]);\n-\tt.end();\n-});\n-\n-test('all sync - mid failure - no bail', t => {\n-\tconst passed = new Concurrent(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tfail('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\tfalse\n-\t).run();\n-\n-\tt.equal(passed, false);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'a'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: false,\n-\t\t\treason: 'b'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'c'\n-\t\t}\n-\t]);\n-\tt.end();\n-});\n-\n-test('all sync - end failure - no bail', t => {\n-\tconst passed = new Concurrent(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpass('b'),\n-\t\t\tfail('c')\n-\t\t],\n-\t\tfalse\n-\t).run();\n-\n-\tt.equal(passed, false);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'a'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'b'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: false,\n-\t\t\treason: 'c'\n-\t\t}\n-\t]);\n-\tt.end();\n-});\n-\n-test('all sync - multiple failure - no bail', t => {\n-\tconst passed = new Concurrent(\n-\t\t[\n-\t\t\tfail('a'),\n-\t\t\tpass('b'),\n-\t\t\tfail('c')\n-\t\t],\n-\t\tfalse\n-\t).run();\n-\n-\tt.equal(passed, false);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: false,\n-\t\t\treason: 'a'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'b'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: false,\n-\t\t\treason: 'c'\n-\t\t}\n-\t]);\n-\tt.end();\n-});\n-\n-test('all sync - begin failure - bail', t => {\n-\tconst passed = new Concurrent(\n-\t\t[\n-\t\t\tfail('a'),\n-\t\t\tpass('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\ttrue\n-\t).run();\n-\n-\tt.equal(passed, false);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: false,\n-\t\t\treason: 'a'\n-\t\t}\n-\t]);\n-\tt.end();\n-});\n-\n-test('all sync - mid failure - bail', t => {\n-\tconst passed = new Concurrent(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tfail('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\ttrue\n-\t).run();\n-\n-\tt.equal(passed, false);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'a'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: false,\n-\t\t\treason: 'b'\n-\t\t}\n-\t]);\n-\tt.end();\n-});\n-\n-test('all sync - end failure - bail', t => {\n-\tconst passed = new Concurrent(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpass('b'),\n-\t\t\tfail('c')\n-\t\t],\n-\t\ttrue\n-\t).run();\n-\n-\tt.equal(passed, false);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'a'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'b'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: false,\n-\t\t\treason: 'c'\n-\t\t}\n-\t]);\n-\tt.end();\n-});\n-\n-test('all async - no failure - no bail', t => {\n-\treturn new Concurrent(\n-\t\t[\n-\t\t\tpassAsync('a'),\n-\t\t\tpassAsync('b'),\n-\t\t\tpassAsync('c')\n-\t\t],\n-\t\tfalse\n-\t).run().then(passed => {\n-\t\tt.equal(passed, true);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t}\n-\t\t]);\n-\t});\n-});\n-\n-test('all async - no failure - bail', t => {\n-\treturn new Concurrent(\n-\t\t[\n-\t\t\tpassAsync('a'),\n-\t\t\tpassAsync('b'),\n-\t\t\tpassAsync('c')\n-\t\t],\n-\t\ttrue\n-\t).run().then(passed => {\n-\t\tt.equal(passed, true);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t}\n-\t\t]);\n-\t});\n-});\n-\n-test('last async - no failure - no bail', t => {\n-\treturn new Concurrent(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpass('b'),\n-\t\t\tpassAsync('c')\n-\t\t],\n-\t\tfalse\n-\t).run().then(passed => {\n-\t\tt.equal(passed, true);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t}\n-\t\t]);\n-\t});\n-});\n-\n-test('mid async - no failure - no bail', t => {\n-\treturn new Concurrent(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpassAsync('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\tfalse\n-\t).run().then(passed => {\n-\t\tt.equal(passed, true);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t}\n-\t\t]);\n-\t});\n-});\n-\n-test('first async - no failure - no bail', t => {\n-\treturn new Concurrent(\n-\t\t[\n-\t\t\tpassAsync('a'),\n-\t\t\tpass('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\tfalse\n-\t).run().then(passed => {\n-\t\tt.equal(passed, true);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t}\n-\t\t]);\n-\t});\n-});\n-\n-test('last async - no failure - bail', t => {\n-\treturn new Concurrent(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpass('b'),\n-\t\t\tpassAsync('c')\n-\t\t],\n-\t\ttrue\n-\t).run().then(passed => {\n-\t\tt.equal(passed, true);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t}\n-\t\t]);\n-\t});\n-});\n-\n-test('mid async - no failure - bail', t => {\n-\treturn new Concurrent(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpassAsync('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\ttrue\n-\t).run().then(passed => {\n-\t\tt.equal(passed, true);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t}\n-\t\t]);\n-\t});\n-});\n-\n-test('first async - no failure - bail', t => {\n-\treturn new Concurrent(\n-\t\t[\n-\t\t\tpassAsync('a'),\n-\t\t\tpass('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\ttrue\n-\t).run().then(passed => {\n-\t\tt.equal(passed, true);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t}\n-\t\t]);\n-\t});\n-});\n-\n-test('all async - begin failure - bail', t => {\n-\treturn new Concurrent(\n-\t\t[\n-\t\t\tfailAsync('a'),\n-\t\t\tpassAsync('b'),\n-\t\t\tpassAsync('c')\n-\t\t],\n-\t\ttrue\n-\t).run().then(passed => {\n-\t\tt.equal(passed, false);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t}\n-\t\t]);\n-\t});\n-});\n-\n-test('all async - mid failure - bail', t => {\n-\treturn new Concurrent(\n-\t\t[\n-\t\t\tpassAsync('a'),\n-\t\t\tfailAsync('b'),\n-\t\t\tpassAsync('c')\n-\t\t],\n-\t\ttrue\n-\t).run().then(passed => {\n-\t\tt.equal(passed, false);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t}\n-\t\t]);\n-\t});\n-});\n-\n-test('all async - end failure - bail', t => {\n-\treturn new Concurrent(\n-\t\t[\n-\t\t\tpassAsync('a'),\n-\t\t\tpassAsync('b'),\n-\t\t\tfailAsync('c')\n-\t\t],\n-\t\ttrue\n-\t).run().then(passed => {\n-\t\tt.equal(passed, false);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: 'c'\n-\t\t\t}\n-\t\t]);\n-\t});\n-});\n-\n-test('all async - begin failure - no bail', t => {\n-\treturn new Concurrent(\n-\t\t[\n-\t\t\tfailAsync('a'),\n-\t\t\tpassAsync('b'),\n-\t\t\tpassAsync('c')\n-\t\t],\n-\t\tfalse\n-\t).run().then(passed => {\n-\t\tt.equal(passed, false);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t}\n-\t\t]);\n-\t});\n-});\n-\n-test('all async - mid failure - no bail', t => {\n-\treturn new Concurrent(\n-\t\t[\n-\t\t\tpassAsync('a'),\n-\t\t\tfailAsync('b'),\n-\t\t\tpassAsync('c')\n-\t\t],\n-\t\tfalse\n-\t).run().then(passed => {\n-\t\tt.equal(passed, false);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t}\n-\t\t]);\n-\t});\n-});\n-\n-test('all async - end failure - no bail', t => {\n-\treturn new Concurrent(\n-\t\t[\n-\t\t\tpassAsync('a'),\n-\t\t\tpassAsync('b'),\n-\t\t\tfailAsync('c')\n-\t\t],\n-\t\tfalse\n-\t).run().then(passed => {\n-\t\tt.equal(passed, false);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: 'c'\n-\t\t\t}\n-\t\t]);\n-\t});\n-});\n-\n-test('all async - multiple failure - no bail', t => {\n-\treturn new Concurrent(\n-\t\t[\n-\t\t\tfailAsync('a'),\n-\t\t\tpassAsync('b'),\n-\t\t\tfailAsync('c')\n-\t\t],\n-\t\tfalse\n-\t).run().then(passed => {\n-\t\tt.equal(passed, false);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: 'c'\n-\t\t\t}\n-\t\t]);\n-\t});\n-});\n-\n-test('rejections are just passed through - no bail', t => {\n-\treturn new Concurrent(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpass('b'),\n-\t\t\treject('foo')\n-\t\t],\n-\t\tfalse\n-\t).run().catch(err => {\n-\t\tt.is(err, 'foo');\n-\t});\n-});\n-\n-test('rejections are just passed through - bail', t => {\n-\treturn new Concurrent(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpass('b'),\n-\t\t\treject('foo')\n-\t\t],\n-\t\ttrue\n-\t).run().catch(err => {\n-\t\tt.is(err, 'foo');\n-\t});\n-});\n-\n-test('sequences of sequences', t => {\n-\tconst passed = new Concurrent([\n-\t\tnew Concurrent([pass('a'), pass('b')]),\n-\t\tnew Concurrent([pass('c')])\n-\t]).run();\n-\n-\tt.equal(passed, true);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'a'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'b'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'c'\n-\t\t}\n-\t]);\n-\n-\tt.end();\n-});\n-\n-test('must be called with array of runnables', t => {\n-\tt.throws(() => {\n-\t\tnew Concurrent(pass('a')).run();\n-\t}, {message: 'Expected an array of runnables'});\n-\tt.end();\n-});\n-\n-test('should throw an error then test.run() fails with not AvaError', t => {\n-\tt.throws(() => {\n-\t\tnew Concurrent([failWithTypeError()]).run();\n-\t}, {message: 'Unexpected Error'});\n-\tt.end();\n-});"
      },
      {
        "sha": "fe046b460749aabdfe04e077fee18b3da3f2a0da",
        "filename": "test/fixture/fail-fast/crash/crashes.js",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ffixture%2Ffail-fast%2Fcrash%2Fcrashes.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ffixture%2Ffail-fast%2Fcrash%2Fcrashes.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Ffail-fast%2Fcrash%2Fcrashes.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -0,0 +1,3 @@\n+import '../../../../'; // eslint-disable-line import/no-unassigned-import\n+\n+process.exit(1); // eslint-disable-line unicorn/no-process-exit"
      },
      {
        "sha": "fe55dc3d0fe994c1a79793965040df7f9e93cde5",
        "filename": "test/fixture/fail-fast/crash/passes.js",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ffixture%2Ffail-fast%2Fcrash%2Fpasses.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ffixture%2Ffail-fast%2Fcrash%2Fpasses.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Ffail-fast%2Fcrash%2Fpasses.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -0,0 +1,5 @@\n+import test from '../../../../';\n+\n+test('first pass', t => {\n+\tt.pass();\n+});"
      },
      {
        "sha": "83c8bc219cfc4c6cd98cffbd8f40f9367e380b9b",
        "filename": "test/fixture/fail-fast/multiple-files/fails.js",
        "status": "renamed",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ffixture%2Ffail-fast%2Fmultiple-files%2Ffails.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ffixture%2Ffail-fast%2Fmultiple-files%2Ffails.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Ffail-fast%2Fmultiple-files%2Ffails.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -1,4 +1,4 @@\n-import test from '../../';\n+import test from '../../../../';\n \n test('first pass', t => {\n \tt.pass();",
        "previous_filename": "test/fixture/fail-fast.js"
      },
      {
        "sha": "3464a4216c05189da5960a781d1fb52d9472057e",
        "filename": "test/fixture/fail-fast/multiple-files/passes-slow.js",
        "status": "added",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ffixture%2Ffail-fast%2Fmultiple-files%2Fpasses-slow.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ffixture%2Ffail-fast%2Fmultiple-files%2Fpasses-slow.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Ffail-fast%2Fmultiple-files%2Fpasses-slow.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -0,0 +1,14 @@\n+import test from '../../../../';\n+\n+test.serial('first pass', async t => {\n+\tt.pass();\n+\treturn new Promise(resolve => setTimeout(resolve, 3000));\n+});\n+\n+test.serial('second pass', t => {\n+\tt.pass();\n+});\n+\n+test('third pass', t => {\n+\tt.pass();\n+});"
      },
      {
        "sha": "fe55dc3d0fe994c1a79793965040df7f9e93cde5",
        "filename": "test/fixture/fail-fast/multiple-files/passes.js",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ffixture%2Ffail-fast%2Fmultiple-files%2Fpasses.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ffixture%2Ffail-fast%2Fmultiple-files%2Fpasses.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Ffail-fast%2Fmultiple-files%2Fpasses.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -0,0 +1,5 @@\n+import test from '../../../../';\n+\n+test('first pass', t => {\n+\tt.pass();\n+});"
      },
      {
        "sha": "83c8bc219cfc4c6cd98cffbd8f40f9367e380b9b",
        "filename": "test/fixture/fail-fast/single-file/test.js",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ffixture%2Ffail-fast%2Fsingle-file%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ffixture%2Ffail-fast%2Fsingle-file%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Ffail-fast%2Fsingle-file%2Ftest.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -0,0 +1,13 @@\n+import test from '../../../../';\n+\n+test('first pass', t => {\n+\tt.pass();\n+});\n+\n+test('second fail', t => {\n+\tt.fail();\n+});\n+\n+test('third pass', t => {\n+\tt.pass();\n+});"
      },
      {
        "sha": "cd9545d57f08b67732b395cb127bf2dedcd3190b",
        "filename": "test/fixture/fail-fast/timeout/fails.js",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ffixture%2Ffail-fast%2Ftimeout%2Ffails.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ffixture%2Ffail-fast%2Ftimeout%2Ffails.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Ffail-fast%2Ftimeout%2Ffails.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -0,0 +1,5 @@\n+import test from '../../../../';\n+\n+test.cb('slow pass', t => {\n+\tsetTimeout(t.end, 1000);\n+});"
      },
      {
        "sha": "fe55dc3d0fe994c1a79793965040df7f9e93cde5",
        "filename": "test/fixture/fail-fast/timeout/passes.js",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ffixture%2Ffail-fast%2Ftimeout%2Fpasses.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ffixture%2Ffail-fast%2Ftimeout%2Fpasses.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffixture%2Ffail-fast%2Ftimeout%2Fpasses.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -0,0 +1,5 @@\n+import test from '../../../../';\n+\n+test('first pass', t => {\n+\tt.pass();\n+});"
      },
      {
        "sha": "c0e7e339f825ea5bce5f30e1f8a3e4e72c896779",
        "filename": "test/fork.js",
        "status": "modified",
        "additions": 3,
        "deletions": 21,
        "changes": 24,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ffork.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ffork.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ffork.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -35,7 +35,6 @@ test('emits test event', t => {\n \tt.plan(1);\n \n \tfork(fixture('generators.js'))\n-\t\t.run({})\n \t\t.on('test', tt => {\n \t\t\tt.is(tt.title, 'generator function');\n \t\t\tt.end();\n@@ -48,7 +47,6 @@ test('resolves promise with tests info', t => {\n \tconst file = fixture('generators.js');\n \n \treturn fork(file)\n-\t\t.run({})\n \t\t.then(info => {\n \t\t\tt.is(info.stats.passCount, 1);\n \t\t\tt.is(info.tests.length, 1);\n@@ -64,7 +62,6 @@ test('exit after tests are finished', t => {\n \tlet cleanupCompleted = false;\n \n \tfork(fixture('slow-exit.js'))\n-\t\t.run({})\n \t\t.on('exit', () => {\n \t\t\tt.true(Date.now() - start < 10000, 'test waited for a pending setTimeout');\n \t\t\tt.true(cleanupCompleted, 'cleanup did not complete');\n@@ -104,7 +101,6 @@ test('rejects promise if the process is killed', t => {\n \n test('fake timers do not break duration', t => {\n \treturn fork(fixture('fake-timers.js'))\n-\t\t.run({})\n \t\t.then(info => {\n \t\t\tconst duration = info.tests[0].duration;\n \t\t\tt.true(duration < 1000, `${duration} < 1000`);\n@@ -114,21 +110,8 @@ test('fake timers do not break duration', t => {\n \t\t});\n });\n \n-/* ignore\n-test('destructuring of `t` is allowed', t => {\n-\tfork(fixture('destructuring-public-api.js'))\n-\t\t.run({})\n-\t\t.then(info => {\n-\t\t\tt.is(info.stats.failCount, 0);\n-\t\t\tt.is(info.stats.passCount, 3);\n-\t\t\tt.end();\n-\t\t});\n-});\n-*/\n-\n test('babelrc is ignored', t => {\n \treturn fork(fixture('babelrc/test.js'))\n-\t\t.run({})\n \t\t.then(info => {\n \t\t\tt.is(info.stats.passCount, 1);\n \t\t\tt.end();\n@@ -139,7 +122,6 @@ test('@std/esm support', t => {\n \treturn fork(fixture('std-esm/test.js'), {\n \t\trequire: [require.resolve('@std/esm')]\n \t})\n-\t\t.run({})\n \t\t.then(info => {\n \t\t\tt.is(info.stats.passCount, 1);\n \t\t\tt.end();\n@@ -151,9 +133,9 @@ test('color support is initialized correctly', t => {\n \tt.plan(1);\n \n \treturn Promise.all([\n-\t\tfork(fixture('chalk-enabled.js'), {color: true}).run({}),\n-\t\tfork(fixture('chalk-disabled.js'), {color: false}).run({}),\n-\t\tfork(fixture('chalk-disabled.js'), {}).run({})\n+\t\tfork(fixture('chalk-enabled.js'), {color: true}),\n+\t\tfork(fixture('chalk-disabled.js'), {color: false}),\n+\t\tfork(fixture('chalk-disabled.js'), {})\n \t]).then(infos => {\n \t\tfor (const info of infos) {\n \t\t\tif (info.stats.failCount > 0) {"
      },
      {
        "sha": "78229f77cd48f27432d8886e2bd0d2ce7da5a39c",
        "filename": "test/hooks.js",
        "status": "modified",
        "additions": 253,
        "deletions": 308,
        "changes": 561,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Fhooks.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Fhooks.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fhooks.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -1,4 +1,6 @@\n 'use strict';\n+require('../lib/worker-options').set({});\n+\n const path = require('path');\n const test = require('tap').test;\n const Runner = require('../lib/runner');\n@@ -28,516 +30,459 @@ function fork(testPath) {\n \t});\n }\n \n+const promiseEnd = (runner, next) => {\n+\treturn new Promise(resolve => {\n+\t\trunner.on('start', data => resolve(data.ended));\n+\t\tnext(runner);\n+\t}).then(() => runner);\n+};\n+\n test('before', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner();\n \tconst arr = [];\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.before(() => {\n+\t\t\tarr.push('a');\n+\t\t});\n \n-\trunner.chain.before(() => {\n-\t\tarr.push('a');\n-\t});\n-\n-\trunner.chain('test', a => {\n-\t\ta.pass();\n-\t\tarr.push('b');\n-\t});\n-\n-\treturn runner.run({}).then(() => {\n+\t\trunner.chain('test', a => {\n+\t\t\ta.pass();\n+\t\t\tarr.push('b');\n+\t\t});\n+\t}).then(() => {\n \t\tt.strictDeepEqual(arr, ['a', 'b']);\n \t});\n });\n \n test('after', t => {\n \tt.plan(3);\n \n-\tconst runner = new Runner();\n \tconst arr = [];\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.after(() => {\n+\t\t\tarr.push('b');\n+\t\t});\n \n-\trunner.chain.after(() => {\n-\t\tarr.push('b');\n-\t});\n-\n-\trunner.chain('test', a => {\n-\t\ta.pass();\n-\t\tarr.push('a');\n-\t});\n-\n-\treturn runner.run({}).then(() => {\n-\t\tconst stats = runner.buildStats();\n-\t\tt.is(stats.passCount, 1);\n-\t\tt.is(stats.failCount, 0);\n+\t\trunner.chain('test', a => {\n+\t\t\ta.pass();\n+\t\t\tarr.push('a');\n+\t\t});\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.passCount, 1);\n+\t\tt.is(runner.stats.failCount, 0);\n \t\tt.strictDeepEqual(arr, ['a', 'b']);\n-\t\tt.end();\n \t});\n });\n \n test('after not run if test failed', t => {\n \tt.plan(3);\n \n-\tconst runner = new Runner();\n \tconst arr = [];\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.after(() => {\n+\t\t\tarr.push('a');\n+\t\t});\n \n-\trunner.chain.after(() => {\n-\t\tarr.push('a');\n-\t});\n-\n-\trunner.chain('test', () => {\n-\t\tthrow new Error('something went wrong');\n-\t});\n-\treturn runner.run({}).then(() => {\n-\t\tconst stats = runner.buildStats();\n-\t\tt.is(stats.passCount, 0);\n-\t\tt.is(stats.failCount, 1);\n+\t\trunner.chain('test', () => {\n+\t\t\tthrow new Error('something went wrong');\n+\t\t});\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.passCount, 0);\n+\t\tt.is(runner.stats.failCount, 1);\n \t\tt.strictDeepEqual(arr, []);\n-\t\tt.end();\n \t});\n });\n \n test('after.always run even if test failed', t => {\n \tt.plan(3);\n \n-\tconst runner = new Runner();\n \tconst arr = [];\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.after.always(() => {\n+\t\t\tarr.push('a');\n+\t\t});\n \n-\trunner.chain.after.always(() => {\n-\t\tarr.push('a');\n-\t});\n-\n-\trunner.chain('test', () => {\n-\t\tthrow new Error('something went wrong');\n-\t});\n-\treturn runner.run({}).then(() => {\n-\t\tconst stats = runner.buildStats();\n-\t\tt.is(stats.passCount, 0);\n-\t\tt.is(stats.failCount, 1);\n+\t\trunner.chain('test', () => {\n+\t\t\tthrow new Error('something went wrong');\n+\t\t});\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.passCount, 0);\n+\t\tt.is(runner.stats.failCount, 1);\n \t\tt.strictDeepEqual(arr, ['a']);\n-\t\tt.end();\n \t});\n });\n \n test('after.always run even if before failed', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner();\n \tconst arr = [];\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.before(() => {\n+\t\t\tthrow new Error('something went wrong');\n+\t\t});\n \n-\trunner.chain.before(() => {\n-\t\tthrow new Error('something went wrong');\n-\t});\n-\n-\trunner.chain.after.always(() => {\n-\t\tarr.push('a');\n-\t});\n+\t\trunner.chain('test', a => a.pass());\n \n-\treturn runner.run({}).then(() => {\n+\t\trunner.chain.after.always(() => {\n+\t\t\tarr.push('a');\n+\t\t});\n+\t}).then(() => {\n \t\tt.strictDeepEqual(arr, ['a']);\n-\t\tt.end();\n \t});\n });\n \n test('stop if before hooks failed', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner();\n \tconst arr = [];\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.before(() => {\n+\t\t\tarr.push('a');\n+\t\t});\n \n-\trunner.chain.before(() => {\n-\t\tarr.push('a');\n-\t});\n-\n-\trunner.chain.before(() => {\n-\t\tthrow new Error('something went wrong');\n-\t});\n-\n-\trunner.chain('test', a => {\n-\t\ta.pass();\n-\t\tarr.push('b');\n-\t\ta.end();\n-\t});\n+\t\trunner.chain.before(() => {\n+\t\t\tthrow new Error('something went wrong');\n+\t\t});\n \n-\treturn runner.run({}).then(() => {\n+\t\trunner.chain('test', a => {\n+\t\t\ta.pass();\n+\t\t\tarr.push('b');\n+\t\t\ta.end();\n+\t\t});\n+\t}).then(() => {\n \t\tt.strictDeepEqual(arr, ['a']);\n-\t\tt.end();\n \t});\n });\n \n test('before each with concurrent tests', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner();\n \tconst arr = [[], []];\n-\tlet i = 0;\n-\tlet k = 0;\n-\n-\trunner.chain.beforeEach(() => {\n-\t\tarr[i++].push('a');\n-\t});\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\tlet i = 0;\n+\t\tlet k = 0;\n \n-\trunner.chain.beforeEach(() => {\n-\t\tarr[k++].push('b');\n-\t});\n+\t\trunner.chain.beforeEach(() => {\n+\t\t\tarr[i++].push('a');\n+\t\t});\n \n-\trunner.chain('c', a => {\n-\t\ta.pass();\n-\t\tarr[0].push('c');\n-\t});\n+\t\trunner.chain.beforeEach(() => {\n+\t\t\tarr[k++].push('b');\n+\t\t});\n \n-\trunner.chain('d', a => {\n-\t\ta.pass();\n-\t\tarr[1].push('d');\n-\t});\n+\t\trunner.chain('c', a => {\n+\t\t\ta.pass();\n+\t\t\tarr[0].push('c');\n+\t\t});\n \n-\treturn runner.run({}).then(() => {\n+\t\trunner.chain('d', a => {\n+\t\t\ta.pass();\n+\t\t\tarr[1].push('d');\n+\t\t});\n+\t}).then(() => {\n \t\tt.strictDeepEqual(arr, [['a', 'b', 'c'], ['a', 'b', 'd']]);\n-\t\tt.end();\n \t});\n });\n \n test('before each with serial tests', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner();\n \tconst arr = [];\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.beforeEach(() => {\n+\t\t\tarr.push('a');\n+\t\t});\n \n-\trunner.chain.beforeEach(() => {\n-\t\tarr.push('a');\n-\t});\n-\n-\trunner.chain.beforeEach(() => {\n-\t\tarr.push('b');\n-\t});\n-\n-\trunner.chain.serial('c', a => {\n-\t\ta.pass();\n-\t\tarr.push('c');\n-\t});\n+\t\trunner.chain.beforeEach(() => {\n+\t\t\tarr.push('b');\n+\t\t});\n \n-\trunner.chain.serial('d', a => {\n-\t\ta.pass();\n-\t\tarr.push('d');\n-\t});\n+\t\trunner.chain.serial('c', a => {\n+\t\t\ta.pass();\n+\t\t\tarr.push('c');\n+\t\t});\n \n-\treturn runner.run({}).then(() => {\n+\t\trunner.chain.serial('d', a => {\n+\t\t\ta.pass();\n+\t\t\tarr.push('d');\n+\t\t});\n+\t}).then(() => {\n \t\tt.strictDeepEqual(arr, ['a', 'b', 'c', 'a', 'b', 'd']);\n-\t\tt.end();\n \t});\n });\n \n test('fail if beforeEach hook fails', t => {\n \tt.plan(2);\n \n-\tconst runner = new Runner();\n \tconst arr = [];\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.beforeEach(a => {\n+\t\t\tarr.push('a');\n+\t\t\ta.fail();\n+\t\t});\n \n-\trunner.chain.beforeEach(a => {\n-\t\tarr.push('a');\n-\t\ta.fail();\n-\t});\n-\n-\trunner.chain('test', a => {\n-\t\tarr.push('b');\n-\t\ta.pass();\n-\t});\n-\n-\treturn runner.run({}).then(() => {\n-\t\tconst stats = runner.buildStats();\n-\t\tt.is(stats.failCount, 1);\n+\t\trunner.chain('test', a => {\n+\t\t\tarr.push('b');\n+\t\t\ta.pass();\n+\t\t});\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.failedHookCount, 1);\n \t\tt.strictDeepEqual(arr, ['a']);\n-\t\tt.end();\n \t});\n });\n \n test('after each with concurrent tests', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner();\n \tconst arr = [[], []];\n-\tlet i = 0;\n-\tlet k = 0;\n-\n-\trunner.chain.afterEach(() => {\n-\t\tarr[i++].push('a');\n-\t});\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\tlet i = 0;\n+\t\tlet k = 0;\n \n-\trunner.chain.afterEach(() => {\n-\t\tarr[k++].push('b');\n-\t});\n+\t\trunner.chain.afterEach(() => {\n+\t\t\tarr[i++].push('a');\n+\t\t});\n \n-\trunner.chain('c', a => {\n-\t\ta.pass();\n-\t\tarr[0].push('c');\n-\t});\n+\t\trunner.chain.afterEach(() => {\n+\t\t\tarr[k++].push('b');\n+\t\t});\n \n-\trunner.chain('d', a => {\n-\t\ta.pass();\n-\t\tarr[1].push('d');\n-\t});\n+\t\trunner.chain('c', a => {\n+\t\t\ta.pass();\n+\t\t\tarr[0].push('c');\n+\t\t});\n \n-\treturn runner.run({}).then(() => {\n+\t\trunner.chain('d', a => {\n+\t\t\ta.pass();\n+\t\t\tarr[1].push('d');\n+\t\t});\n+\t}).then(() => {\n \t\tt.strictDeepEqual(arr, [['c', 'a', 'b'], ['d', 'a', 'b']]);\n-\t\tt.end();\n \t});\n });\n \n test('after each with serial tests', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner();\n \tconst arr = [];\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.afterEach(() => {\n+\t\t\tarr.push('a');\n+\t\t});\n \n-\trunner.chain.afterEach(() => {\n-\t\tarr.push('a');\n-\t});\n-\n-\trunner.chain.afterEach(() => {\n-\t\tarr.push('b');\n-\t});\n-\n-\trunner.chain.serial('c', a => {\n-\t\ta.pass();\n-\t\tarr.push('c');\n-\t});\n+\t\trunner.chain.afterEach(() => {\n+\t\t\tarr.push('b');\n+\t\t});\n \n-\trunner.chain.serial('d', a => {\n-\t\ta.pass();\n-\t\tarr.push('d');\n-\t});\n+\t\trunner.chain.serial('c', a => {\n+\t\t\ta.pass();\n+\t\t\tarr.push('c');\n+\t\t});\n \n-\treturn runner.run({}).then(() => {\n+\t\trunner.chain.serial('d', a => {\n+\t\t\ta.pass();\n+\t\t\tarr.push('d');\n+\t\t});\n+\t}).then(() => {\n \t\tt.strictDeepEqual(arr, ['c', 'a', 'b', 'd', 'a', 'b']);\n-\t\tt.end();\n \t});\n });\n \n test('afterEach not run if concurrent tests failed', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner();\n \tconst arr = [];\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.afterEach(() => {\n+\t\t\tarr.push('a');\n+\t\t});\n \n-\trunner.chain.afterEach(() => {\n-\t\tarr.push('a');\n-\t});\n-\n-\trunner.chain('test', () => {\n-\t\tthrow new Error('something went wrong');\n-\t});\n-\n-\treturn runner.run({}).then(() => {\n+\t\trunner.chain('test', () => {\n+\t\t\tthrow new Error('something went wrong');\n+\t\t});\n+\t}).then(() => {\n \t\tt.strictDeepEqual(arr, []);\n-\t\tt.end();\n \t});\n });\n \n test('afterEach not run if serial tests failed', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner();\n \tconst arr = [];\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.afterEach(() => {\n+\t\t\tarr.push('a');\n+\t\t});\n \n-\trunner.chain.afterEach(() => {\n-\t\tarr.push('a');\n-\t});\n-\n-\trunner.chain.serial('test', () => {\n-\t\tthrow new Error('something went wrong');\n-\t});\n-\n-\treturn runner.run({}).then(() => {\n+\t\trunner.chain.serial('test', () => {\n+\t\t\tthrow new Error('something went wrong');\n+\t\t});\n+\t}).then(() => {\n \t\tt.strictDeepEqual(arr, []);\n-\t\tt.end();\n \t});\n });\n \n test('afterEach.always run even if concurrent tests failed', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner();\n \tconst arr = [];\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.afterEach.always(() => {\n+\t\t\tarr.push('a');\n+\t\t});\n \n-\trunner.chain.afterEach.always(() => {\n-\t\tarr.push('a');\n-\t});\n-\n-\trunner.chain('test', () => {\n-\t\tthrow new Error('something went wrong');\n-\t});\n-\n-\treturn runner.run({}).then(() => {\n+\t\trunner.chain('test', () => {\n+\t\t\tthrow new Error('something went wrong');\n+\t\t});\n+\t}).then(() => {\n \t\tt.strictDeepEqual(arr, ['a']);\n-\t\tt.end();\n \t});\n });\n \n test('afterEach.always run even if serial tests failed', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner();\n \tconst arr = [];\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.afterEach.always(() => {\n+\t\t\tarr.push('a');\n+\t\t});\n \n-\trunner.chain.afterEach.always(() => {\n-\t\tarr.push('a');\n-\t});\n-\n-\trunner.chain.serial('test', () => {\n-\t\tthrow new Error('something went wrong');\n-\t});\n-\n-\treturn runner.run({}).then(() => {\n+\t\trunner.chain.serial('test', () => {\n+\t\t\tthrow new Error('something went wrong');\n+\t\t});\n+\t}).then(() => {\n \t\tt.strictDeepEqual(arr, ['a']);\n-\t\tt.end();\n \t});\n });\n \n test('afterEach.always run even if beforeEach failed', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner();\n \tconst arr = [];\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.beforeEach(() => {\n+\t\t\tthrow new Error('something went wrong');\n+\t\t});\n \n-\trunner.chain.beforeEach(() => {\n-\t\tthrow new Error('something went wrong');\n-\t});\n-\n-\trunner.chain('test', a => {\n-\t\ta.pass();\n-\t\tarr.push('a');\n-\t});\n-\n-\trunner.chain.afterEach.always(() => {\n-\t\tarr.push('b');\n-\t});\n+\t\trunner.chain('test', a => {\n+\t\t\ta.pass();\n+\t\t\tarr.push('a');\n+\t\t});\n \n-\treturn runner.run({}).then(() => {\n+\t\trunner.chain.afterEach.always(() => {\n+\t\t\tarr.push('b');\n+\t\t});\n+\t}).then(() => {\n \t\tt.strictDeepEqual(arr, ['b']);\n-\t\tt.end();\n \t});\n });\n \n test('ensure hooks run only around tests', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner();\n \tconst arr = [];\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.beforeEach(() => {\n+\t\t\tarr.push('beforeEach');\n+\t\t});\n \n-\trunner.chain.beforeEach(() => {\n-\t\tarr.push('beforeEach');\n-\t});\n-\n-\trunner.chain.before(() => {\n-\t\tarr.push('before');\n-\t});\n-\n-\trunner.chain.afterEach(() => {\n-\t\tarr.push('afterEach');\n-\t});\n+\t\trunner.chain.before(() => {\n+\t\t\tarr.push('before');\n+\t\t});\n \n-\trunner.chain.after(() => {\n-\t\tarr.push('after');\n-\t});\n+\t\trunner.chain.afterEach(() => {\n+\t\t\tarr.push('afterEach');\n+\t\t});\n \n-\trunner.chain('test', a => {\n-\t\ta.pass();\n-\t\tarr.push('test');\n-\t});\n+\t\trunner.chain.after(() => {\n+\t\t\tarr.push('after');\n+\t\t});\n \n-\treturn runner.run({}).then(() => {\n+\t\trunner.chain('test', a => {\n+\t\t\ta.pass();\n+\t\t\tarr.push('test');\n+\t\t});\n+\t}).then(() => {\n \t\tt.strictDeepEqual(arr, ['before', 'beforeEach', 'test', 'afterEach', 'after']);\n-\t\tt.end();\n \t});\n });\n \n test('shared context', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner();\n-\n-\trunner.chain.before(a => {\n-\t\ta.deepEqual(a.context, {});\n-\t\ta.context.arr = ['a'];\n-\t\ta.context.prop = 'before';\n-\t});\n-\n-\trunner.chain.after(a => {\n-\t\ta.deepEqual(a.context.arr, ['a', 'b', 'c', 'd']);\n-\t\ta.is(a.context.prop, 'before');\n-\t});\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.before(a => {\n+\t\t\ta.deepEqual(a.context, {});\n+\t\t\ta.context.arr = ['a'];\n+\t\t\ta.context.prop = 'before';\n+\t\t});\n \n-\trunner.chain.beforeEach(a => {\n-\t\ta.deepEqual(a.context.arr, ['a']);\n-\t\ta.context.arr.push('b');\n-\t\ta.is(a.context.prop, 'before');\n-\t\ta.context.prop = 'beforeEach';\n-\t});\n+\t\trunner.chain.after(a => {\n+\t\t\ta.deepEqual(a.context.arr, ['a', 'b', 'c', 'd']);\n+\t\t\ta.is(a.context.prop, 'before');\n+\t\t});\n \n-\trunner.chain('test', a => {\n-\t\ta.pass();\n-\t\ta.deepEqual(a.context.arr, ['a', 'b']);\n-\t\ta.context.arr.push('c');\n-\t\ta.is(a.context.prop, 'beforeEach');\n-\t\ta.context.prop = 'test';\n-\t});\n+\t\trunner.chain.beforeEach(a => {\n+\t\t\ta.deepEqual(a.context.arr, ['a']);\n+\t\t\ta.context.arr.push('b');\n+\t\t\ta.is(a.context.prop, 'before');\n+\t\t\ta.context.prop = 'beforeEach';\n+\t\t});\n \n-\trunner.chain.afterEach(a => {\n-\t\ta.deepEqual(a.context.arr, ['a', 'b', 'c']);\n-\t\ta.context.arr.push('d');\n-\t\ta.is(a.context.prop, 'test');\n-\t\ta.context.prop = 'afterEach';\n-\t});\n+\t\trunner.chain('test', a => {\n+\t\t\ta.pass();\n+\t\t\ta.deepEqual(a.context.arr, ['a', 'b']);\n+\t\t\ta.context.arr.push('c');\n+\t\t\ta.is(a.context.prop, 'beforeEach');\n+\t\t\ta.context.prop = 'test';\n+\t\t});\n \n-\treturn runner.run({}).then(() => {\n-\t\tconst stats = runner.buildStats();\n-\t\tt.is(stats.failCount, 0);\n-\t\tt.end();\n+\t\trunner.chain.afterEach(a => {\n+\t\t\ta.deepEqual(a.context.arr, ['a', 'b', 'c']);\n+\t\t\ta.context.arr.push('d');\n+\t\t\ta.is(a.context.prop, 'test');\n+\t\t\ta.context.prop = 'afterEach';\n+\t\t});\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.failCount, 0);\n \t});\n });\n \n test('shared context of any type', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner();\n-\n-\trunner.chain.beforeEach(a => {\n-\t\ta.context = 'foo';\n-\t});\n-\n-\trunner.chain('test', a => {\n-\t\ta.pass();\n-\t\ta.is(a.context, 'foo');\n-\t});\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.beforeEach(a => {\n+\t\t\ta.context = 'foo';\n+\t\t});\n \n-\treturn runner.run({}).then(() => {\n-\t\tconst stats = runner.buildStats();\n-\t\tt.is(stats.failCount, 0);\n-\t\tt.end();\n+\t\trunner.chain('test', a => {\n+\t\t\ta.pass();\n+\t\t\ta.is(a.context, 'foo');\n+\t\t});\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.failCount, 0);\n \t});\n });\n \n test('don\\'t display hook title if it did not fail', t => {\n \tt.plan(2);\n \n \treturn fork(path.join(__dirname, 'fixture/hooks-passing.js'))\n-\t\t.run({})\n \t\t.on('test', test => {\n \t\t\tt.strictDeepEqual(test.error, null);\n \t\t\tt.is(test.title, 'pass');\n-\t\t})\n-\t\t.then(() => {\n-\t\t\tt.end();\n \t\t});\n });\n \n test('display hook title if it failed', t => {\n \tt.plan(2);\n \n \treturn fork(path.join(__dirname, 'fixture/hooks-failing.js'))\n-\t\t.run({})\n \t\t.on('test', test => {\n \t\t\tt.is(test.error.name, 'AssertionError');\n \t\t\tt.is(test.title, 'beforeEach hook for pass');\n-\t\t})\n-\t\t.then(() => {\n-\t\t\tt.end();\n \t\t});\n });"
      },
      {
        "sha": "819fd4f59f8b3a1064212cbe3b992e93dd4486fe",
        "filename": "test/observable.js",
        "status": "modified",
        "additions": 59,
        "deletions": 101,
        "changes": 160,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Fobservable.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Fobservable.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fobservable.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -1,33 +1,32 @@\n 'use strict';\n+require('../lib/worker-options').set({});\n+\n const test = require('tap').test;\n const Test = require('../lib/test');\n const Observable = require('zen-observable'); // eslint-disable-line import/order\n \n-function ava(fn, onResult) {\n+function ava(fn) {\n \treturn new Test({\n \t\tcontextRef: null,\n \t\tfailWithoutAssertions: true,\n \t\tfn,\n \t\tmetadata: {type: 'test', callback: false},\n-\t\tonResult,\n \t\ttitle: '[anonymous]'\n \t});\n }\n \n-ava.cb = function (fn, onResult) {\n+ava.cb = function (fn) {\n \treturn new Test({\n \t\tcontextRef: null,\n \t\tfailWithoutAssertions: true,\n \t\tfn,\n \t\tmetadata: {type: 'test', callback: true},\n-\t\tonResult,\n \t\ttitle: '[anonymous]'\n \t});\n };\n \n test('returning an observable from a legacy async fn is an error', t => {\n-\tlet result;\n-\tconst passed = ava.cb(a => {\n+\treturn ava.cb(a => {\n \t\ta.plan(2);\n \n \t\tconst observable = Observable.of();\n@@ -39,56 +38,46 @@ test('returning an observable from a legacy async fn is an error', t => {\n \t\t});\n \n \t\treturn observable;\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.match(result.reason.message, /Do not return observables/);\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.match(result.error.message, /Do not return observables/);\n+\t});\n });\n \n test('handle throws with erroring observable', t => {\n-\tlet result;\n-\tava(a => {\n+\tconst instance = ava(a => {\n \t\ta.plan(1);\n \n \t\tconst observable = new Observable(observer => {\n \t\t\tobserver.error(new Error());\n \t\t});\n \n \t\treturn a.throws(observable);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.assertCount, 1);\n-\t\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n \t});\n });\n \n test('handle throws with erroring observable returned by function', t => {\n-\tlet result;\n-\tava(a => {\n+\tconst instance = ava(a => {\n \t\ta.plan(1);\n \n \t\tconst observable = new Observable(observer => {\n \t\t\tobserver.error(new Error());\n \t\t});\n \n \t\treturn a.throws(() => observable);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.assertCount, 1);\n-\t\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n \t});\n });\n \n test('handle throws with long running erroring observable', t => {\n-\tlet result;\n-\tava(a => {\n+\tconst instance = ava(a => {\n \t\ta.plan(1);\n \n \t\tconst observable = new Observable(observer => {\n@@ -98,88 +87,71 @@ test('handle throws with long running erroring observable', t => {\n \t\t});\n \n \t\treturn a.throws(observable, /abc/);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.assertCount, 1);\n-\t\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n \t});\n });\n \n test('handle throws with completed observable', t => {\n-\tlet result;\n-\tava(a => {\n+\treturn ava(a => {\n \t\ta.plan(1);\n \n \t\tconst observable = Observable.of();\n \t\treturn a.throws(observable);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.name, 'AssertionError');\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n \t});\n });\n \n test('handle throws with completed observable returned by function', t => {\n-\tlet result;\n-\tava(a => {\n+\treturn ava(a => {\n \t\ta.plan(1);\n \n \t\tconst observable = Observable.of();\n \t\treturn a.throws(() => observable);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.name, 'AssertionError');\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n \t});\n });\n \n test('handle throws with regex', t => {\n-\tlet result;\n-\tava(a => {\n+\tconst instance = ava(a => {\n \t\ta.plan(1);\n \n \t\tconst observable = new Observable(observer => {\n \t\t\tobserver.error(new Error('abc'));\n \t\t});\n \n \t\treturn a.throws(observable, /abc/);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.assertCount, 1);\n-\t\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n \t});\n });\n \n test('handle throws with string', t => {\n-\tlet result;\n-\tava(a => {\n+\tconst instance = ava(a => {\n \t\ta.plan(1);\n \n \t\tconst observable = new Observable(observer => {\n \t\t\tobserver.error(new Error('abc'));\n \t\t});\n \n \t\treturn a.throws(observable, 'abc');\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.assertCount, 1);\n-\t\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n \t});\n });\n \n test('handle throws with false-positive observable', t => {\n-\tlet result;\n-\tava(a => {\n+\treturn ava(a => {\n \t\ta.plan(1);\n \n \t\tconst observable = new Observable(observer => {\n@@ -188,65 +160,51 @@ test('handle throws with false-positive observable', t => {\n \t\t});\n \n \t\treturn a.throws(observable);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.name, 'AssertionError');\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n \t});\n });\n \n test('handle notThrows with completed observable', t => {\n-\tlet result;\n-\tava(a => {\n+\tconst instance = ava(a => {\n \t\ta.plan(1);\n \n \t\tconst observable = Observable.of();\n \t\treturn a.notThrows(observable);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.assertCount, 1);\n-\t\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n \t});\n });\n \n test('handle notThrows with thrown observable', t => {\n-\tlet result;\n-\tava(a => {\n+\treturn ava(a => {\n \t\ta.plan(1);\n \n \t\tconst observable = new Observable(observer => {\n \t\t\tobserver.error(new Error());\n \t\t});\n \n \t\treturn a.notThrows(observable);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.name, 'AssertionError');\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n \t});\n });\n \n test('handle notThrows with erroring observable returned by function', t => {\n-\tlet result;\n-\tava(a => {\n+\treturn ava(a => {\n \t\ta.plan(1);\n \n \t\tconst observable = new Observable(observer => {\n \t\t\tobserver.error(new Error());\n \t\t});\n \n \t\treturn a.notThrows(() => observable);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.name, 'AssertionError');\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n \t});\n });"
      },
      {
        "sha": "7ad06bc5914eab8d3bd18fe274f14ff99c69def6",
        "filename": "test/promise.js",
        "status": "modified",
        "additions": 115,
        "deletions": 201,
        "changes": 316,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Fpromise.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Fpromise.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fpromise.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -1,28 +1,26 @@\n 'use strict';\n-require('../lib/globals').options.color = false;\n+require('../lib/worker-options').set({color: false});\n \n const Promise = require('bluebird');\n const test = require('tap').test;\n const Test = require('../lib/test');\n \n-function ava(fn, onResult) {\n+function ava(fn) {\n \treturn new Test({\n \t\tcontextRef: null,\n \t\tfailWithoutAssertions: true,\n \t\tfn,\n \t\tmetadata: {type: 'test', callback: false},\n-\t\tonResult,\n \t\ttitle: '[anonymous]'\n \t});\n }\n \n-ava.cb = function (fn, onResult) {\n+ava.cb = function (fn) {\n \treturn new Test({\n \t\tcontextRef: null,\n \t\tfailWithoutAssertions: true,\n \t\tfn,\n \t\tmetadata: {type: 'test', callback: true},\n-\t\tonResult,\n \t\ttitle: '[anonymous]'\n \t});\n };\n@@ -42,27 +40,22 @@ function fail() {\n }\n \n test('returning a promise from a legacy async fn is an error', t => {\n-\tlet result;\n-\tconst passed = ava.cb(a => {\n+\treturn ava.cb(a => {\n \t\ta.plan(1);\n \n \t\treturn Promise.resolve(true).then(() => {\n \t\t\ta.pass();\n \t\t\ta.end();\n \t\t});\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.match(result.reason.message, /Do not return promises/);\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.match(result.error.message, /Do not return promises/);\n+\t});\n });\n \n test('assertion plan is tested after returned promise resolves', t => {\n-\tlet result;\n \tconst start = Date.now();\n-\tava(a => {\n+\tconst instance = ava(a => {\n \t\ta.plan(2);\n \n \t\tconst defer = Promise.defer();\n@@ -75,20 +68,17 @@ test('assertion plan is tested after returned promise resolves', t => {\n \t\ta.pass();\n \n \t\treturn defer.promise;\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.planCount, 2);\n-\t\tt.is(result.result.assertCount, 2);\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.planCount, 2);\n+\t\tt.is(instance.assertCount, 2);\n \t\tt.true(Date.now() - start >= 500);\n-\t\tt.end();\n \t});\n });\n \n test('missing assertion will fail the test', t => {\n-\tlet result;\n-\tava(a => {\n+\treturn ava(a => {\n \t\ta.plan(2);\n \n \t\tconst defer = Promise.defer();\n@@ -99,18 +89,14 @@ test('missing assertion will fail the test', t => {\n \t\t}, 200);\n \n \t\treturn defer.promise;\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.assertion, 'plan');\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.assertion, 'plan');\n \t});\n });\n \n test('extra assertion will fail the test', t => {\n-\tlet result;\n-\tava(a => {\n+\treturn ava(a => {\n \t\ta.plan(2);\n \n \t\tconst defer = Promise.defer();\n@@ -126,51 +112,41 @@ test('extra assertion will fail the test', t => {\n \t\t}, 500);\n \n \t\treturn defer.promise;\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.assertion, 'plan');\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.assertion, 'plan');\n \t});\n });\n \n test('handle throws with rejected promise', t => {\n-\tlet result;\n-\tava(a => {\n+\tconst instance = ava(a => {\n \t\ta.plan(1);\n \n \t\tconst promise = Promise.reject(new Error());\n \t\treturn a.throws(promise);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.assertCount, 1);\n-\t\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n \t});\n });\n \n test('handle throws with rejected promise returned by function', t => {\n-\tlet result;\n-\tava(a => {\n+\tconst instance = ava(a => {\n \t\ta.plan(1);\n \n \t\tconst promise = Promise.reject(new Error());\n \t\treturn a.throws(() => promise);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.assertCount, 1);\n-\t\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n \t});\n });\n \n // TODO(team): This is a very slow test, and I can't figure out why we need it - James\n test('handle throws with long running rejected promise', t => {\n-\tlet result;\n-\tava(a => {\n+\tconst instance = ava(a => {\n \t\ta.plan(1);\n \n \t\tconst promise = new Promise((resolve, reject) => {\n@@ -180,270 +156,208 @@ test('handle throws with long running rejected promise', t => {\n \t\t});\n \n \t\treturn a.throws(promise, /abc/);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.assertCount, 1);\n-\t\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n \t});\n });\n \n test('handle throws with resolved promise', t => {\n-\tlet result;\n-\tava(a => {\n+\treturn ava(a => {\n \t\ta.plan(1);\n \n \t\tconst promise = Promise.resolve();\n \t\treturn a.throws(promise);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.name, 'AssertionError');\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n \t});\n });\n \n test('handle throws with resolved promise returned by function', t => {\n-\tlet result;\n-\tava(a => {\n+\treturn ava(a => {\n \t\ta.plan(1);\n \n \t\tconst promise = Promise.resolve();\n \t\treturn a.throws(() => promise);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.name, 'AssertionError');\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n \t});\n });\n \n test('handle throws with regex', t => {\n-\tlet result;\n-\tava(a => {\n+\tconst instance = ava(a => {\n \t\ta.plan(1);\n \n \t\tconst promise = Promise.reject(new Error('abc'));\n \t\treturn a.throws(promise, /abc/);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.assertCount, 1);\n-\t\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n \t});\n });\n \n test('throws with regex will fail if error message does not match', t => {\n-\tlet result;\n-\tava(a => {\n+\treturn ava(a => {\n \t\ta.plan(1);\n \n \t\tconst promise = Promise.reject(new Error('abc'));\n \t\treturn a.throws(promise, /def/);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.name, 'AssertionError');\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n \t});\n });\n \n test('handle throws with string', t => {\n-\tlet result;\n-\tava(a => {\n+\tconst instance = ava(a => {\n \t\ta.plan(1);\n \n \t\tconst promise = Promise.reject(new Error('abc'));\n \t\treturn a.throws(promise, 'abc');\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.assertCount, 1);\n-\t\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n \t});\n });\n \n test('throws with string argument will reject if message does not match', t => {\n-\tlet result;\n-\tava(a => {\n+\treturn ava(a => {\n \t\ta.plan(1);\n \n \t\tconst promise = Promise.reject(new Error('abc'));\n \t\treturn a.throws(promise, 'def');\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.name, 'AssertionError');\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n \t});\n });\n \n test('does not handle throws with string reject', t => {\n-\tlet result;\n-\tava(a => {\n+\treturn ava(a => {\n \t\ta.plan(1);\n \n \t\tconst promise = Promise.reject('abc'); // eslint-disable-line prefer-promise-reject-errors\n \t\treturn a.throws(promise, 'abc');\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.name, 'AssertionError');\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n \t});\n });\n \n test('handle throws with false-positive promise', t => {\n-\tlet result;\n-\tava(a => {\n+\treturn ava(a => {\n \t\ta.plan(1);\n \n \t\tconst promise = Promise.resolve(new Error());\n \t\treturn a.throws(promise);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.name, 'AssertionError');\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n \t});\n });\n \n test('handle notThrows with resolved promise', t => {\n-\tlet result;\n-\tava(a => {\n+\tconst instance = ava(a => {\n \t\ta.plan(1);\n \n \t\tconst promise = Promise.resolve();\n \t\treturn a.notThrows(promise);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.assertCount, 1);\n-\t\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n \t});\n });\n \n test('handle notThrows with rejected promise', t => {\n-\tlet result;\n-\tava(a => {\n+\treturn ava(a => {\n \t\ta.plan(1);\n \n \t\tconst promise = Promise.reject(new Error());\n \t\treturn a.notThrows(promise);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.name, 'AssertionError');\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n \t});\n });\n \n test('handle notThrows with resolved promise returned by function', t => {\n-\tlet result;\n-\tava(a => {\n+\tconst instance = ava(a => {\n \t\ta.plan(1);\n \n \t\tconst promise = Promise.resolve();\n \t\treturn a.notThrows(() => promise);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.assertCount, 1);\n-\t\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n \t});\n });\n \n test('handle notThrows with rejected promise returned by function', t => {\n-\tlet result;\n-\tava(a => {\n+\treturn ava(a => {\n \t\ta.plan(1);\n \n \t\tconst promise = Promise.reject(new Error());\n \t\treturn a.notThrows(() => promise);\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.name, 'AssertionError');\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n \t});\n });\n \n test('assert pass', t => {\n-\tlet result;\n-\tava(a => {\n+\tconst instance = ava(a => {\n \t\treturn pass().then(() => {\n \t\t\ta.pass();\n \t\t});\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.assertCount, 1);\n-\t\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n \t});\n });\n \n test('assert fail', t => {\n-\tlet result;\n-\tava(a => {\n+\treturn ava(a => {\n \t\treturn pass().then(() => {\n \t\t\ta.fail();\n \t\t});\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.name, 'AssertionError');\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n \t});\n });\n \n test('reject', t => {\n-\tlet result;\n-\tava(a => {\n+\treturn ava(a => {\n \t\treturn fail().then(() => {\n \t\t\ta.pass();\n \t\t});\n-\t}, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.name, 'AssertionError');\n-\t\tt.is(result.reason.message, 'Rejected promise returned by test');\n-\t\tt.is(result.reason.values.length, 1);\n-\t\tt.is(result.reason.values[0].label, 'Rejected promise returned by test. Reason:');\n-\t\tt.match(result.reason.values[0].formatted, /.*Error.*\\n.*message: 'unicorn'/);\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n+\t\tt.is(result.error.message, 'Rejected promise returned by test');\n+\t\tt.is(result.error.values.length, 1);\n+\t\tt.is(result.error.values[0].label, 'Rejected promise returned by test. Reason:');\n+\t\tt.match(result.error.values[0].formatted, /.*Error.*\\n.*message: 'unicorn'/);\n \t});\n });\n \n test('reject with non-Error', t => {\n-\tlet result;\n-\tava(\n-\t\t() => Promise.reject('failure'), // eslint-disable-line prefer-promise-reject-errors\n-\t\tr => {\n-\t\t\tresult = r;\n-\t\t}\n-\t).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.name, 'AssertionError');\n-\t\tt.is(result.reason.message, 'Rejected promise returned by test');\n-\t\tt.is(result.reason.values.length, 1);\n-\t\tt.is(result.reason.values[0].label, 'Rejected promise returned by test. Reason:');\n-\t\tt.match(result.reason.values[0].formatted, /failure/);\n-\t\tt.end();\n+\treturn ava(() => {\n+\t\treturn Promise.reject('failure'); // eslint-disable-line prefer-promise-reject-errors\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n+\t\tt.is(result.error.message, 'Rejected promise returned by test');\n+\t\tt.is(result.error.values.length, 1);\n+\t\tt.is(result.error.values[0].label, 'Rejected promise returned by test. Reason:');\n+\t\tt.match(result.error.values[0].formatted, /failure/);\n \t});\n });"
      },
      {
        "sha": "3d62a1d2e5eff505e5e6e456f329057e3b7d782c",
        "filename": "test/reporters/mini.js",
        "status": "modified",
        "additions": 90,
        "deletions": 14,
        "changes": 104,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Freporters%2Fmini.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Freporters%2Fmini.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Freporters%2Fmini.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -1,4 +1,5 @@\n 'use strict';\n+require('../../lib/worker-options').set({});\n \n // These tests are run as a sub-process of the `tap` module, so the standard\n // output stream will not be recognized as a text terminal. AVA internals are\n@@ -296,8 +297,12 @@ test('results with passing tests and rejections', t => {\n \treporter.passCount = 1;\n \treporter.rejectionCount = 1;\n \n-\tconst err1 = errorFromWorker(new Error('failure one'), {type: 'rejection'});\n+\tconst err1 = errorFromWorker(new Error('failure one'), {\n+\t\tfile: 'test.js',\n+\t\ttype: 'rejection'\n+\t});\n \tconst err2 = errorFromWorker(new Error('failure two'), {\n+\t\tfile: 'test.js',\n \t\ttype: 'rejection',\n \t\tstack: 'Error: failure two\\n    at trailingWhitespace (test.js:1:1)\\r\\n'\n \t});\n@@ -312,12 +317,12 @@ test('results with passing tests and rejections', t => {\n \t\t'  ' + colors.green('1 passed'),\n \t\t'  ' + colors.red('1 rejection'),\n \t\t'',\n-\t\t'  ' + colors.boldWhite('Unhandled Rejection'),\n+\t\t'  ' + colors.boldWhite('Unhandled rejection in test.js'),\n \t\t/Error: failure one/,\n \t\t/test\\/reporters\\/mini\\.js/,\n \t\tcompareLineOutput.SKIP_UNTIL_EMPTY_LINE,\n \t\t'',\n-\t\t'  ' + colors.boldWhite('Unhandled Rejection'),\n+\t\t'  ' + colors.boldWhite('Unhandled rejection in test.js'),\n \t\t/Error: failure two/,\n \t\t/trailingWhitespace/,\n \t\t''\n@@ -330,9 +335,15 @@ test('results with passing tests and exceptions', t => {\n \treporter.passCount = 1;\n \treporter.exceptionCount = 2;\n \n-\tconst err = errorFromWorker(new Error('failure'), {type: 'exception'});\n+\tconst err = errorFromWorker(new Error('failure'), {\n+\t\tfile: 'test.js',\n+\t\ttype: 'exception'\n+\t});\n \n-\tconst avaErr = errorFromWorker(new AvaError('A futuristic test runner'), {type: 'exception'});\n+\tconst avaErr = errorFromWorker(new AvaError('A futuristic test runner'), {\n+\t\tfile: 'test.js',\n+\t\ttype: 'exception'\n+\t});\n \n \tconst runStatus = {\n \t\terrors: [err, avaErr]\n@@ -344,7 +355,7 @@ test('results with passing tests and exceptions', t => {\n \t\t'  ' + colors.green('1 passed'),\n \t\t'  ' + colors.red('2 exceptions'),\n \t\t'',\n-\t\t'  ' + colors.boldWhite('Uncaught Exception'),\n+\t\t'  ' + colors.boldWhite('Uncaught exception in test.js'),\n \t\t/Error: failure/,\n \t\t/test\\/reporters\\/mini\\.js/,\n \t\tcompareLineOutput.SKIP_UNTIL_EMPTY_LINE,\n@@ -638,7 +649,9 @@ test('results when fail-fast is enabled', t => {\n \tconst runStatus = {\n \t\tremainingCount: 1,\n \t\tfailCount: 1,\n-\t\tfailFastEnabled: true\n+\t\tfailFastEnabled: true,\n+\t\tfileCount: 1,\n+\t\tobservationCount: 1\n \t};\n \n \tconst output = reporter.finish(runStatus);\n@@ -655,7 +668,9 @@ test('results when fail-fast is enabled with multiple skipped tests', t => {\n \tconst runStatus = {\n \t\tremainingCount: 2,\n \t\tfailCount: 1,\n-\t\tfailFastEnabled: true\n+\t\tfailFastEnabled: true,\n+\t\tfileCount: 1,\n+\t\tobservationCount: 1\n \t};\n \n \tconst output = reporter.finish(runStatus);\n@@ -667,12 +682,71 @@ test('results when fail-fast is enabled with multiple skipped tests', t => {\n \tt.end();\n });\n \n+test('results when fail-fast is enabled with skipped test file', t => {\n+\tconst reporter = miniReporter();\n+\tconst runStatus = {\n+\t\tremainingCount: 0,\n+\t\tfailCount: 1,\n+\t\tfailFastEnabled: true,\n+\t\tfileCount: 2,\n+\t\tobservationCount: 1\n+\t};\n+\n+\tconst output = reporter.finish(runStatus);\n+\tcompareLineOutput(t, output, [\n+\t\t'',\n+\t\t'  ' + colors.magenta('`--fail-fast` is on. 1 test file was skipped.'),\n+\t\t''\n+\t]);\n+\tt.end();\n+});\n+\n+test('results when fail-fast is enabled with multiple skipped test files', t => {\n+\tconst reporter = miniReporter();\n+\tconst runStatus = {\n+\t\tremainingCount: 0,\n+\t\tfailCount: 1,\n+\t\tfailFastEnabled: true,\n+\t\tfileCount: 3,\n+\t\tobservationCount: 1\n+\t};\n+\n+\tconst output = reporter.finish(runStatus);\n+\tcompareLineOutput(t, output, [\n+\t\t'',\n+\t\t'  ' + colors.magenta('`--fail-fast` is on. 2 test files were skipped.'),\n+\t\t''\n+\t]);\n+\tt.end();\n+});\n+\n+test('results when fail-fast is enabled with skipped tests and files', t => {\n+\tconst reporter = miniReporter();\n+\tconst runStatus = {\n+\t\tremainingCount: 1,\n+\t\tfailCount: 1,\n+\t\tfailFastEnabled: true,\n+\t\tfileCount: 3,\n+\t\tobservationCount: 1\n+\t};\n+\n+\tconst output = reporter.finish(runStatus);\n+\tcompareLineOutput(t, output, [\n+\t\t'',\n+\t\t'  ' + colors.magenta('`--fail-fast` is on. At least 1 test was skipped, as well as 2 test files.'),\n+\t\t''\n+\t]);\n+\tt.end();\n+});\n+\n test('results without fail-fast if no failing tests', t => {\n \tconst reporter = miniReporter();\n \tconst runStatus = {\n \t\tremainingCount: 1,\n \t\tfailCount: 0,\n-\t\tfailFastEnabled: true\n+\t\tfailFastEnabled: true,\n+\t\tfileCount: 1,\n+\t\tobservationCount: 1\n \t};\n \n \tconst output = reporter.finish(runStatus);\n@@ -685,7 +759,9 @@ test('results without fail-fast if no skipped tests', t => {\n \tconst runStatus = {\n \t\tremainingCount: 0,\n \t\tfailCount: 1,\n-\t\tfailFastEnabled: true\n+\t\tfailFastEnabled: true,\n+\t\tfileCount: 1,\n+\t\tobservationCount: 1\n \t};\n \n \tconst output = reporter.finish(runStatus);\n@@ -820,7 +896,7 @@ test('returns description based on error itself if no stack available', t => {\n \tconst reporter = miniReporter();\n \treporter.exceptionCount = 1;\n \tconst thrownValue = {message: 'failure one'};\n-\tconst err1 = errorFromWorker(thrownValue);\n+\tconst err1 = errorFromWorker(thrownValue, {file: 'test.js'});\n \tconst runStatus = {\n \t\terrors: [err1]\n \t};\n@@ -829,7 +905,7 @@ test('returns description based on error itself if no stack available', t => {\n \tconst expectedOutput = [\n \t\t'\\n  ' + colors.red('1 exception'),\n \t\t'\\n',\n-\t\t'\\n  ' + colors.boldWhite('Uncaught Exception'),\n+\t\t'\\n  ' + colors.boldWhite('Uncaught exception in test.js'),\n \t\t'\\n  Threw non-error: ' + JSON.stringify(thrownValue),\n \t\t'\\n'\n \t].join('');\n@@ -840,15 +916,15 @@ test('returns description based on error itself if no stack available', t => {\n test('shows \"non-error\" hint for invalid throws', t => {\n \tconst reporter = miniReporter();\n \treporter.exceptionCount = 1;\n-\tconst err = errorFromWorker({type: 'exception', message: 'function fooFn() {}', stack: 'function fooFn() {}'});\n+\tconst err = errorFromWorker({type: 'exception', message: 'function fooFn() {}', stack: 'function fooFn() {}'}, {file: 'test.js'});\n \tconst runStatus = {\n \t\terrors: [err]\n \t};\n \tconst actualOutput = reporter.finish(runStatus);\n \tconst expectedOutput = [\n \t\t'\\n  ' + colors.red('1 exception'),\n \t\t'\\n',\n-\t\t'\\n  ' + colors.boldWhite('Uncaught Exception'),\n+\t\t'\\n  ' + colors.boldWhite('Uncaught exception in test.js'),\n \t\t'\\n  Threw non-error: function fooFn() {}',\n \t\t'\\n'\n \t].join('');"
      },
      {
        "sha": "c12073060100cab8de55af2a359bbde2ad8a9137",
        "filename": "test/reporters/verbose.js",
        "status": "modified",
        "additions": 91,
        "deletions": 21,
        "changes": 112,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Freporters%2Fverbose.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Freporters%2Fverbose.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Freporters%2Fverbose.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -1,4 +1,5 @@\n 'use strict';\n+require('../../lib/worker-options').set({});\n \n // These tests are run as a sub-process of the `tap` module, so the standard\n // output stream will not be recognized as a text terminal. AVA internals are\n@@ -69,7 +70,7 @@ test('passing test and duration less than threshold', t => {\n \tconst actualOutput = reporter.test({\n \t\ttitle: 'passed',\n \t\tduration: 90\n-\t}, createRunStatus());\n+\t});\n \n \tconst expectedOutput = '  ' + colors.green(figures.tick) + ' passed';\n \n@@ -83,32 +84,21 @@ test('passing test and duration greater than threshold', t => {\n \tconst actualOutput = reporter.test({\n \t\ttitle: 'passed',\n \t\tduration: 150\n-\t}, createRunStatus());\n+\t});\n \n \tconst expectedOutput = '  ' + colors.green(figures.tick) + ' passed' + colors.dimGray(' (150ms)');\n \n \tt.is(actualOutput, expectedOutput);\n \tt.end();\n });\n \n-test('don\\'t display test title if there is only one anonymous test', t => {\n-\tconst reporter = createReporter();\n-\n-\tconst output = reporter.test({\n-\t\ttitle: '[anonymous]'\n-\t}, createRunStatus());\n-\n-\tt.is(output, undefined);\n-\tt.end();\n-});\n-\n test('known failure test', t => {\n \tconst reporter = createReporter();\n \n \tconst actualOutput = reporter.test({\n \t\ttitle: 'known failure',\n \t\tfailing: true\n-\t}, createRunStatus());\n+\t});\n \n \tconst expectedOutput = '  ' + colors.red(figures.tick) + ' ' + colors.red('known failure');\n \n@@ -124,7 +114,7 @@ test('failing test', t => {\n \t\terror: {\n \t\t\tmessage: 'assertion failed'\n \t\t}\n-\t}, createRunStatus());\n+\t});\n \n \tconst expectedOutput = '  ' + colors.red(figures.cross) + ' failed ' + colors.red('assertion failed');\n \n@@ -138,7 +128,7 @@ test('skipped test', t => {\n \tconst actualOutput = reporter.test({\n \t\ttitle: 'skipped',\n \t\tskip: true\n-\t}, createRunStatus());\n+\t});\n \n \tconst expectedOutput = '  ' + colors.yellow('- skipped');\n \n@@ -153,7 +143,7 @@ test('todo test', t => {\n \t\ttitle: 'todo',\n \t\tskip: true,\n \t\ttodo: true\n-\t}, createRunStatus());\n+\t});\n \n \tconst expectedOutput = '  ' + colors.blue('- todo');\n \n@@ -171,7 +161,7 @@ test('uncaught exception', t => {\n \n \tconst output = reporter.unhandledError(error, createRunStatus()).split('\\n');\n \n-\tt.is(output[0], colors.red('Uncaught Exception: test.js'));\n+\tt.is(output[0].trim(), colors.boldWhite('Uncaught exception in test.js'));\n \tt.match(output[1], /Error: Unexpected token/);\n \tt.match(output[2], /test\\/reporters\\/verbose\\.js/);\n \tt.end();\n@@ -201,7 +191,7 @@ test('unhandled rejection', t => {\n \n \tconst output = reporter.unhandledError(error, createRunStatus()).split('\\n');\n \n-\tt.is(output[0], colors.red('Unhandled Rejection: test.js'));\n+\tt.is(output[0].trim(), colors.boldWhite('Unhandled rejection in test.js'));\n \tt.match(output[1], /Error: Unexpected token/);\n \tt.match(output[2], /test\\/reporters\\/verbose\\.js/);\n \tt.end();\n@@ -217,8 +207,8 @@ test('unhandled error without stack', t => {\n \n \tconst output = reporter.unhandledError(err, createRunStatus()).split('\\n');\n \n-\tt.is(output[0], colors.red('Uncaught Exception: test.js'));\n-\tt.is(output[1], '  ' + colors.red(JSON.stringify(err)));\n+\tt.is(output[0].trim(), colors.boldWhite('Uncaught exception in test.js'));\n+\tt.is(output[1], '  Threw non-error: ' + JSON.stringify({message: 'test'}));\n \tt.end();\n });\n \n@@ -604,6 +594,8 @@ test('results when fail-fast is enabled', t => {\n \trunStatus.remainingCount = 1;\n \trunStatus.failCount = 1;\n \trunStatus.failFastEnabled = true;\n+\trunStatus.fileCount = 1;\n+\trunStatus.observationCount = 1;\n \trunStatus.tests = [{\n \t\ttitle: 'failed test'\n \t}];\n@@ -626,6 +618,8 @@ test('results when fail-fast is enabled with multiple skipped tests', t => {\n \trunStatus.remainingCount = 2;\n \trunStatus.failCount = 1;\n \trunStatus.failFastEnabled = true;\n+\trunStatus.fileCount = 1;\n+\trunStatus.observationCount = 1;\n \trunStatus.tests = [{\n \t\ttitle: 'failed test'\n \t}];\n@@ -642,13 +636,87 @@ test('results when fail-fast is enabled with multiple skipped tests', t => {\n \tt.end();\n });\n \n+test('results when fail-fast is enabled with skipped test file', t => {\n+\tconst reporter = createReporter();\n+\tconst runStatus = createRunStatus();\n+\trunStatus.remainingCount = 0;\n+\trunStatus.failCount = 1;\n+\trunStatus.failFastEnabled = true;\n+\trunStatus.fileCount = 2;\n+\trunStatus.observationCount = 1;\n+\trunStatus.tests = [{\n+\t\ttitle: 'failed test'\n+\t}];\n+\n+\tconst output = reporter.finish(runStatus);\n+\tconst expectedOutput = [\n+\t\t'\\n  ' + colors.red('1 test failed'),\n+\t\t'\\n',\n+\t\t'\\n  ' + colors.magenta('`--fail-fast` is on. 1 test file was skipped.'),\n+\t\t'\\n'\n+\t].join('');\n+\n+\tt.is(output, expectedOutput);\n+\tt.end();\n+});\n+\n+test('results when fail-fast is enabled with multiple skipped test files', t => {\n+\tconst reporter = createReporter();\n+\tconst runStatus = createRunStatus();\n+\trunStatus.remainingCount = 0;\n+\trunStatus.failCount = 1;\n+\trunStatus.failFastEnabled = true;\n+\trunStatus.fileCount = 3;\n+\trunStatus.observationCount = 1;\n+\trunStatus.tests = [{\n+\t\ttitle: 'failed test'\n+\t}];\n+\n+\tconst output = reporter.finish(runStatus);\n+\tconst expectedOutput = [\n+\t\t'\\n  ' + colors.red('1 test failed'),\n+\t\t'\\n',\n+\t\t'\\n  ' + colors.magenta('`--fail-fast` is on. 2 test files were skipped.'),\n+\t\t'\\n'\n+\t].join('');\n+\n+\tt.is(output, expectedOutput);\n+\tt.end();\n+});\n+\n+test('results when fail-fast is enabled with skipped tests and files', t => {\n+\tconst reporter = createReporter();\n+\tconst runStatus = createRunStatus();\n+\trunStatus.remainingCount = 1;\n+\trunStatus.failCount = 1;\n+\trunStatus.failFastEnabled = true;\n+\trunStatus.fileCount = 3;\n+\trunStatus.observationCount = 1;\n+\trunStatus.tests = [{\n+\t\ttitle: 'failed test'\n+\t}];\n+\n+\tconst output = reporter.finish(runStatus);\n+\tconst expectedOutput = [\n+\t\t'\\n  ' + colors.red('1 test failed'),\n+\t\t'\\n',\n+\t\t'\\n  ' + colors.magenta('`--fail-fast` is on. At least 1 test was skipped, as well as 2 test files.'),\n+\t\t'\\n'\n+\t].join('');\n+\n+\tt.is(output, expectedOutput);\n+\tt.end();\n+});\n+\n test('results without fail-fast if no failing tests', t => {\n \tconst reporter = createReporter();\n \tconst runStatus = createRunStatus();\n \trunStatus.remainingCount = 1;\n \trunStatus.failCount = 0;\n \trunStatus.passCount = 1;\n \trunStatus.failFastEnabled = true;\n+\trunStatus.fileCount = 1;\n+\trunStatus.observationCount = 1;\n \n \tconst output = reporter.finish(runStatus);\n \tconst expectedOutput = [\n@@ -667,6 +735,8 @@ test('results without fail-fast if no skipped tests', t => {\n \trunStatus.remainingCount = 0;\n \trunStatus.failCount = 1;\n \trunStatus.failFastEnabled = true;\n+\trunStatus.fileCount = 1;\n+\trunStatus.observationCount = 1;\n \trunStatus.tests = [{\n \t\ttitle: 'failed test'\n \t}];"
      },
      {
        "sha": "4ed269dd0f94997eafb26c9d410b71f5783d2c63",
        "filename": "test/runner.js",
        "status": "modified",
        "additions": 539,
        "deletions": 452,
        "changes": 991,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Frunner.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Frunner.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Frunner.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -1,118 +1,112 @@\n 'use strict';\n+require('../lib/worker-options').set({});\n+\n const test = require('tap').test;\n const Runner = require('../lib/runner');\n \n const slice = Array.prototype.slice;\n const noop = () => {};\n \n+const promiseEnd = (runner, next) => {\n+\treturn new Promise(resolve => {\n+\t\trunner.on('start', data => resolve(data.ended));\n+\t\tnext(runner);\n+\t}).then(() => runner);\n+};\n+\n test('nested tests and hooks aren\\'t allowed', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner();\n-\n-\trunner.chain('test', a => {\n-\t\tt.throws(() => {\n-\t\t\trunner.chain(noop);\n-\t\t}, {message: 'All tests and hooks must be declared synchronously in your test file, and cannot be nested within other tests or hooks.'});\n-\t\ta.pass();\n-\t});\n-\n-\trunner.run({}).then(() => {\n-\t\tt.end();\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain('test', a => {\n+\t\t\tt.throws(() => {\n+\t\t\t\trunner.chain(noop);\n+\t\t\t}, {message: 'All tests and hooks must be declared synchronously in your test file, and cannot be nested within other tests or hooks.'});\n+\t\t\ta.pass();\n+\t\t});\n \t});\n });\n \n test('tests must be declared synchronously', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner();\n-\n-\trunner.chain('test', a => {\n-\t\ta.pass();\n-\t\treturn Promise.resolve();\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain('test', a => {\n+\t\t\ta.pass();\n+\t\t\treturn Promise.resolve();\n+\t\t});\n+\t}).then(runner => {\n+\t\tt.throws(() => {\n+\t\t\trunner.chain(noop);\n+\t\t}, {message: 'All tests and hooks must be declared synchronously in your test file, and cannot be nested within other tests or hooks.'});\n \t});\n-\n-\trunner.run({});\n-\n-\tt.throws(() => {\n-\t\trunner.chain(noop);\n-\t}, {message: 'All tests and hooks must be declared synchronously in your test file, and cannot be nested within other tests or hooks.'});\n-\n-\tt.end();\n });\n \n test('runner emits a \"test\" event', t => {\n \tconst runner = new Runner();\n \n-\trunner.chain('foo', a => {\n-\t\ta.pass();\n-\t});\n-\n \trunner.on('test', props => {\n \t\tt.ifError(props.error);\n \t\tt.is(props.title, 'foo');\n \t\tt.not(props.duration, undefined);\n \t\tt.end();\n \t});\n \n-\trunner.run({});\n+\trunner.chain('foo', a => {\n+\t\ta.pass();\n+\t});\n });\n \n test('run serial tests before concurrent ones', t => {\n-\tconst runner = new Runner();\n \tconst arr = [];\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain('test', a => {\n+\t\t\tarr.push('c');\n+\t\t\ta.end();\n+\t\t});\n \n-\trunner.chain('test', a => {\n-\t\tarr.push('c');\n-\t\ta.end();\n-\t});\n-\n-\trunner.chain.serial('serial', a => {\n-\t\tarr.push('a');\n-\t\ta.end();\n-\t});\n-\n-\trunner.chain.serial('serial 2', a => {\n-\t\tarr.push('b');\n-\t\ta.end();\n-\t});\n+\t\trunner.chain.serial('serial', a => {\n+\t\t\tarr.push('a');\n+\t\t\ta.end();\n+\t\t});\n \n-\trunner.run({}).then(() => {\n+\t\trunner.chain.serial('serial 2', a => {\n+\t\t\tarr.push('b');\n+\t\t\ta.end();\n+\t\t});\n+\t}).then(() => {\n \t\tt.strictDeepEqual(arr, ['a', 'b', 'c']);\n-\t\tt.end();\n \t});\n });\n \n test('anything can be skipped', t => {\n-\tconst runner = new Runner();\n \tconst arr = [];\n-\n \tfunction pusher(title) {\n \t\treturn a => {\n \t\t\tarr.push(title);\n \t\t\ta.pass();\n \t\t};\n \t}\n \n-\trunner.chain.after(pusher('after'));\n-\trunner.chain.after.skip(pusher('after.skip'));\n-\n-\trunner.chain.afterEach(pusher('afterEach'));\n-\trunner.chain.afterEach.skip(pusher('afterEach.skip'));\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.after(pusher('after'));\n+\t\trunner.chain.after.skip(pusher('after.skip'));\n \n-\trunner.chain.before(pusher('before'));\n-\trunner.chain.before.skip(pusher('before.skip'));\n+\t\trunner.chain.afterEach(pusher('afterEach'));\n+\t\trunner.chain.afterEach.skip(pusher('afterEach.skip'));\n \n-\trunner.chain.beforeEach(pusher('beforeEach'));\n-\trunner.chain.beforeEach.skip(pusher('beforeEach.skip'));\n+\t\trunner.chain.before(pusher('before'));\n+\t\trunner.chain.before.skip(pusher('before.skip'));\n \n-\trunner.chain('concurrent', pusher('concurrent'));\n-\trunner.chain.skip('concurrent.skip', pusher('concurrent.skip'));\n+\t\trunner.chain.beforeEach(pusher('beforeEach'));\n+\t\trunner.chain.beforeEach.skip(pusher('beforeEach.skip'));\n \n-\trunner.chain.serial('serial', pusher('serial'));\n-\trunner.chain.serial.skip('serial.skip', pusher('serial.skip'));\n+\t\trunner.chain('concurrent', pusher('concurrent'));\n+\t\trunner.chain.skip('concurrent.skip', pusher('concurrent.skip'));\n \n-\trunner.run({}).then(() => {\n+\t\trunner.chain.serial('serial', pusher('serial'));\n+\t\trunner.chain.serial.skip('serial.skip', pusher('serial.skip'));\n+\t}).then(() => {\n \t\t// Note that afterEach and beforeEach run twice because there are two actual tests - \"serial\" and \"concurrent\"\n \t\tt.strictDeepEqual(arr, [\n \t\t\t'before',\n@@ -124,471 +118,469 @@ test('anything can be skipped', t => {\n \t\t\t'afterEach',\n \t\t\t'after'\n \t\t]);\n-\t\tt.end();\n \t});\n });\n \n-test('include skipped tests in results', t => {\n-\tconst runner = new Runner();\n-\n-\trunner.chain.before('before', noop);\n-\trunner.chain.before.skip('before.skip', noop);\n-\n-\trunner.chain.beforeEach('beforeEach', noop);\n-\trunner.chain.beforeEach.skip('beforeEach.skip', noop);\n+test('emit skipped tests at start', t => {\n+\tt.plan(1);\n \n-\trunner.chain.serial('test', a => a.pass());\n-\trunner.chain.serial.skip('test.skip', noop);\n+\tconst runner = new Runner();\n+\trunner.on('start', data => {\n+\t\tt.strictDeepEqual(data.skippedTests, [\n+\t\t\t{failing: false, title: 'test.serial.skip'},\n+\t\t\t{failing: true, title: 'test.failing.skip'}\n+\t\t]);\n+\t});\n \n-\trunner.chain.after('after', noop);\n-\trunner.chain.after.skip('after.skip', noop);\n+\treturn promiseEnd(runner, () => {\n+\t\trunner.chain.before('before', noop);\n+\t\trunner.chain.before.skip('before.skip', noop);\n \n-\trunner.chain.afterEach('afterEach', noop);\n-\trunner.chain.afterEach.skip('afterEach.skip', noop);\n+\t\trunner.chain.beforeEach('beforeEach', noop);\n+\t\trunner.chain.beforeEach.skip('beforeEach.skip', noop);\n \n-\tconst titles = [];\n+\t\trunner.chain.serial('test.serial', a => a.pass());\n+\t\trunner.chain.serial.skip('test.serial.skip', noop);\n \n-\trunner.on('test', test => {\n-\t\ttitles.push(test.title);\n-\t});\n+\t\trunner.chain.failing('test.failing', a => a.fail());\n+\t\trunner.chain.failing.skip('test.failing.skip', noop);\n \n-\trunner.run({}).then(() => {\n-\t\tt.strictDeepEqual(titles, [\n-\t\t\t'before',\n-\t\t\t'before.skip',\n-\t\t\t'beforeEach for test',\n-\t\t\t'beforeEach.skip for test',\n-\t\t\t'test',\n-\t\t\t'afterEach for test',\n-\t\t\t'afterEach.skip for test',\n-\t\t\t'test.skip',\n-\t\t\t'after',\n-\t\t\t'after.skip'\n-\t\t]);\n+\t\trunner.chain.after('after', noop);\n+\t\trunner.chain.after.skip('after.skip', noop);\n \n-\t\tt.end();\n+\t\trunner.chain.afterEach('afterEach', noop);\n+\t\trunner.chain.afterEach.skip('afterEach.skip', noop);\n \t});\n });\n \n test('test types and titles', t => {\n-\tt.plan(10);\n-\n-\tconst fn = a => {\n-\t\ta.pass();\n-\t};\n-\n-\tfunction named(a) {\n-\t\ta.pass();\n-\t}\n+\tt.plan(20);\n \n-\tconst runner = new Runner();\n-\trunner.chain.before(named);\n-\trunner.chain.beforeEach(fn);\n-\trunner.chain.after(fn);\n-\trunner.chain.afterEach(named);\n-\trunner.chain('test', fn);\n-\n-\tconst tests = [\n-\t\t{\n-\t\t\ttype: 'before',\n-\t\t\ttitle: 'before hook'\n-\t\t},\n-\t\t{\n-\t\t\ttype: 'beforeEach',\n-\t\t\ttitle: 'beforeEach hook for test'\n-\t\t},\n-\t\t{\n-\t\t\ttype: 'test',\n-\t\t\ttitle: 'test'\n-\t\t},\n-\t\t{\n-\t\t\ttype: 'afterEach',\n-\t\t\ttitle: 'afterEach hook for test'\n-\t\t},\n-\t\t{\n-\t\t\ttype: 'after',\n-\t\t\ttitle: 'after hook'\n-\t\t}\n-\t];\n+\tconst fail = a => a.fail();\n+\tconst pass = a => a.pass();\n \n-\trunner.on('test', props => {\n-\t\tconst test = tests.shift();\n-\t\tt.is(props.title, test.title);\n-\t\tt.is(props.type, test.type);\n-\t});\n+\tconst check = (setup, expect) => {\n+\t\tconst runner = new Runner();\n+\t\tconst assert = data => {\n+\t\t\tconst expected = expect.shift();\n+\t\t\tt.is(data.title, expected.title);\n+\t\t\tt.is(data.metadata.type, expected.type);\n+\t\t};\n+\t\trunner.on('hook-failed', assert);\n+\t\trunner.on('test', assert);\n+\t\treturn promiseEnd(runner, () => setup(runner.chain));\n+\t};\n \n-\trunner.run({}).then(t.end);\n+\treturn Promise.all([\n+\t\tcheck(chain => {\n+\t\t\tchain.before(fail);\n+\t\t\tchain('test', pass);\n+\t\t}, [\n+\t\t\t{type: 'before', title: 'before hook'}\n+\t\t]),\n+\t\tcheck(chain => {\n+\t\t\tchain('test', pass);\n+\t\t\tchain.after(fail);\n+\t\t}, [\n+\t\t\t{type: 'test', title: 'test'},\n+\t\t\t{type: 'after', title: 'after hook'}\n+\t\t]),\n+\t\tcheck(chain => {\n+\t\t\tchain('test', pass);\n+\t\t\tchain.after.always(fail);\n+\t\t}, [\n+\t\t\t{type: 'test', title: 'test'},\n+\t\t\t{type: 'after', title: 'after.always hook'}\n+\t\t]),\n+\t\tcheck(chain => {\n+\t\t\tchain.beforeEach(fail);\n+\t\t\tchain('test', fail);\n+\t\t}, [\n+\t\t\t{type: 'beforeEach', title: 'beforeEach hook for test'}\n+\t\t]),\n+\t\tcheck(chain => {\n+\t\t\tchain('test', pass);\n+\t\t\tchain.afterEach(fail);\n+\t\t}, [\n+\t\t\t{type: 'test', title: 'test'},\n+\t\t\t{type: 'afterEach', title: 'afterEach hook for test'}\n+\t\t]),\n+\t\tcheck(chain => {\n+\t\t\tchain('test', pass);\n+\t\t\tchain.afterEach.always(fail);\n+\t\t}, [\n+\t\t\t{type: 'test', title: 'test'},\n+\t\t\t{type: 'afterEach', title: 'afterEach.always hook for test'}\n+\t\t])\n+\t]);\n });\n \n test('skip test', t => {\n-\tt.plan(5);\n+\tt.plan(4);\n \n-\tconst runner = new Runner();\n \tconst arr = [];\n-\n-\trunner.chain('test', a => {\n-\t\tarr.push('a');\n-\t\ta.pass();\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain('test', a => {\n+\t\t\tarr.push('a');\n+\t\t\ta.pass();\n+\t\t});\n+\n+\t\trunner.chain.skip('skip', () => {\n+\t\t\tarr.push('b');\n+\t\t});\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.testCount, 2);\n+\t\tt.is(runner.stats.passCount, 1);\n+\t\tt.is(runner.stats.skipCount, 1);\n+\t\tt.strictDeepEqual(arr, ['a']);\n \t});\n+});\n+\n+test('tests must have a non-empty title)', t => {\n+\tt.plan(1);\n \n-\trunner.chain.skip('skip', () => {\n-\t\tarr.push('b');\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\tt.throws(() => {\n+\t\t\trunner.chain('', t => t.pass());\n+\t\t}, new TypeError('Tests must have a title'));\n \t});\n+});\n \n-\tt.throws(() => {\n-\t\trunner.chain.skip('should be a todo');\n-\t}, new TypeError('Expected an implementation. Use `test.todo()` for tests without an implementation.'));\n+test('test titles must be unique', t => {\n+\tt.plan(1);\n \n-\trunner.run({}).then(() => {\n-\t\tconst stats = runner.buildStats();\n-\t\tt.is(stats.testCount, 2);\n-\t\tt.is(stats.passCount, 1);\n-\t\tt.is(stats.skipCount, 1);\n-\t\tt.strictDeepEqual(arr, ['a']);\n-\t\tt.end();\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain('title', t => t.pass());\n+\n+\t\tt.throws(() => {\n+\t\t\trunner.chain('title', t => t.pass());\n+\t\t}, new Error('Duplicate test title: title'));\n \t});\n });\n \n-test('test throws when given no function', t => {\n+test('tests must have an implementation', t => {\n \tt.plan(1);\n \n \tconst runner = new Runner();\n \n \tt.throws(() => {\n-\t\trunner.chain();\n+\t\trunner.chain('title');\n \t}, new TypeError('Expected an implementation. Use `test.todo()` for tests without an implementation.'));\n });\n \n test('todo test', t => {\n-\tt.plan(6);\n+\tt.plan(4);\n \n-\tconst runner = new Runner();\n \tconst arr = [];\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain('test', a => {\n+\t\t\tarr.push('a');\n+\t\t\ta.pass();\n+\t\t});\n \n-\trunner.chain('test', a => {\n-\t\tarr.push('a');\n-\t\ta.pass();\n-\t});\n-\n-\trunner.chain.todo('todo');\n-\n-\tt.throws(() => {\n-\t\trunner.chain.todo('todo', () => {});\n-\t}, new TypeError('`todo` tests are not allowed to have an implementation. Use `test.skip()` for tests with an implementation.'));\n-\n-\tt.throws(() => {\n-\t\trunner.chain.todo();\n-\t}, new TypeError('`todo` tests require a title'));\n-\n-\trunner.run({}).then(() => {\n-\t\tconst stats = runner.buildStats();\n-\t\tt.is(stats.testCount, 2);\n-\t\tt.is(stats.passCount, 1);\n-\t\tt.is(stats.todoCount, 1);\n+\t\trunner.chain.todo('todo');\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.testCount, 2);\n+\t\tt.is(runner.stats.passCount, 1);\n+\t\tt.is(runner.stats.todoCount, 1);\n \t\tt.strictDeepEqual(arr, ['a']);\n-\t\tt.end();\n \t});\n });\n \n-test('only test', t => {\n-\tt.plan(3);\n-\n-\tconst runner = new Runner();\n-\tconst arr = [];\n-\n-\trunner.chain('test', a => {\n-\t\tarr.push('a');\n-\t\ta.pass();\n-\t});\n-\n-\trunner.chain.only('only', a => {\n-\t\tarr.push('b');\n-\t\ta.pass();\n-\t});\n+test('todo tests must not have an implementation', t => {\n+\tt.plan(1);\n \n-\trunner.run({}).then(() => {\n-\t\tconst stats = runner.buildStats();\n-\t\tt.is(stats.testCount, 1);\n-\t\tt.is(stats.passCount, 1);\n-\t\tt.strictDeepEqual(arr, ['b']);\n-\t\tt.end();\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\tt.throws(() => {\n+\t\t\trunner.chain.todo('todo', () => {});\n+\t\t}, new TypeError('`todo` tests are not allowed to have an implementation. Use `test.skip()` for tests with an implementation.'));\n \t});\n });\n \n-test('throws if you give a function to todo', t => {\n-\tconst runner = new Runner();\n-\n-\tt.throws(() => {\n-\t\trunner.chain.todo('todo with function', noop);\n-\t}, new TypeError('`todo` tests are not allowed to have an implementation. Use ' +\n-\t'`test.skip()` for tests with an implementation.'));\n+test('todo tests must have a title', t => {\n+\tt.plan(1);\n \n-\tt.end();\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\tt.throws(() => {\n+\t\t\trunner.chain.todo();\n+\t\t}, new TypeError('`todo` tests require a title'));\n+\t});\n });\n \n-test('throws if todo has no title', t => {\n-\tconst runner = new Runner();\n+test('todo test titles must be unique', t => {\n+\tt.plan(1);\n \n-\tt.throws(() => {\n-\t\trunner.chain.todo();\n-\t}, new TypeError('`todo` tests require a title'));\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain('title', t => t.pass());\n \n-\tt.end();\n+\t\tt.throws(() => {\n+\t\t\trunner.chain.todo('title');\n+\t\t}, new Error('Duplicate test title: title'));\n+\t});\n });\n \n-test('validate accepts skipping failing tests', t => {\n-\tt.plan(2);\n-\n-\tconst runner = new Runner();\n+test('only test', t => {\n+\tt.plan(3);\n \n-\trunner.chain.failing.skip('skip failing', noop);\n+\tconst arr = [];\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain('test', a => {\n+\t\t\tarr.push('a');\n+\t\t\ta.pass();\n+\t\t});\n \n-\trunner.run({}).then(() => {\n-\t\tconst stats = runner.buildStats();\n-\t\tt.is(stats.testCount, 1);\n-\t\tt.is(stats.skipCount, 1);\n-\t\tt.end();\n+\t\trunner.chain.only('only', a => {\n+\t\t\tarr.push('b');\n+\t\t\ta.pass();\n+\t\t});\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.testCount, 1);\n+\t\tt.is(runner.stats.passCount, 1);\n+\t\tt.strictDeepEqual(arr, ['b']);\n \t});\n });\n \n-test('runOnlyExclusive option test', t => {\n+test('options.runOnlyExclusive means only exclusive tests are run', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner();\n-\tconst options = {runOnlyExclusive: true};\n-\tconst arr = [];\n-\n-\trunner.chain('test', () => {\n-\t\tarr.push('a');\n-\t});\n+\treturn promiseEnd(new Runner({runOnlyExclusive: true}), runner => {\n+\t\trunner.chain('test', () => {\n+\t\t\tt.fail();\n+\t\t});\n \n-\trunner.run(options).then(stats => {\n-\t\tt.is(stats, null);\n-\t\tt.end();\n+\t\trunner.chain.only('test 2', () => {\n+\t\t\tt.pass();\n+\t\t});\n \t});\n });\n \n test('options.serial forces all tests to be serial', t => {\n \tt.plan(1);\n \n-\tconst runner = new Runner({serial: true});\n \tconst arr = [];\n+\treturn promiseEnd(new Runner({serial: true}), runner => {\n+\t\trunner.chain.cb('cb', a => {\n+\t\t\tsetTimeout(() => {\n+\t\t\t\tarr.push(1);\n+\t\t\t\ta.end();\n+\t\t\t}, 200);\n+\t\t\ta.pass();\n+\t\t});\n \n-\trunner.chain.cb('cb', a => {\n-\t\tsetTimeout(() => {\n-\t\t\tarr.push(1);\n-\t\t\ta.end();\n-\t\t}, 200);\n-\t\ta.pass();\n-\t});\n-\n-\trunner.chain.cb('cb 2', a => {\n-\t\tsetTimeout(() => {\n-\t\t\tarr.push(2);\n-\t\t\ta.end();\n-\t\t}, 100);\n-\t\ta.pass();\n-\t});\n+\t\trunner.chain.cb('cb 2', a => {\n+\t\t\tsetTimeout(() => {\n+\t\t\t\tarr.push(2);\n+\t\t\t\ta.end();\n+\t\t\t}, 100);\n+\t\t\ta.pass();\n+\t\t});\n \n-\trunner.chain('test', a => {\n-\t\ta.pass();\n-\t\tt.strictDeepEqual(arr, [1, 2]);\n-\t\tt.end();\n+\t\trunner.chain('test', a => {\n+\t\t\ta.pass();\n+\t\t\tt.strictDeepEqual(arr, [1, 2]);\n+\t\t});\n \t});\n-\n-\trunner.run({});\n });\n \n-test('options.bail will bail out', t => {\n-\tt.plan(1);\n-\n-\tconst runner = new Runner({bail: true});\n-\n-\trunner.chain('test', a => {\n-\t\tt.pass();\n-\t\ta.fail();\n-\t});\n+test('options.failFast does not stop concurrent tests from running', t => {\n+\tconst expected = ['first', 'second'];\n+\tt.plan(expected.length);\n+\n+\tpromiseEnd(new Runner({failFast: true}), runner => {\n+\t\tlet block;\n+\t\tlet resume;\n+\t\trunner.chain.beforeEach(() => {\n+\t\t\tif (block) {\n+\t\t\t\treturn block;\n+\t\t\t}\n+\n+\t\t\tblock = new Promise(resolve => {\n+\t\t\t\tresume = resolve;\n+\t\t\t});\n+\t\t});\n+\n+\t\trunner.chain('first', a => {\n+\t\t\tresume();\n+\t\t\ta.fail();\n+\t\t});\n \n-\trunner.chain('test 2', () => {\n-\t\tt.fail();\n-\t});\n+\t\trunner.chain('second', a => {\n+\t\t\ta.pass();\n+\t\t});\n \n-\trunner.run({}).then(() => {\n-\t\tt.end();\n+\t\trunner.on('test', data => {\n+\t\t\tt.is(data.title, expected.shift());\n+\t\t});\n \t});\n });\n \n-test('options.bail will bail out (async)', t => {\n-\tt.plan(2);\n-\n-\tconst runner = new Runner({bail: true});\n-\tconst tests = [];\n-\n-\trunner.chain.cb('cb', a => {\n-\t\tsetTimeout(() => {\n-\t\t\ttests.push(1);\n+test('options.failFast && options.serial stops subsequent tests from running ', t => {\n+\tconst expected = ['first'];\n+\tt.plan(expected.length);\n+\n+\tpromiseEnd(new Runner({failFast: true, serial: true}), runner => {\n+\t\tlet block;\n+\t\tlet resume;\n+\t\trunner.chain.beforeEach(() => {\n+\t\t\tif (block) {\n+\t\t\t\treturn block;\n+\t\t\t}\n+\n+\t\t\tblock = new Promise(resolve => {\n+\t\t\t\tresume = resolve;\n+\t\t\t});\n+\t\t});\n+\n+\t\trunner.chain('first', a => {\n+\t\t\tresume();\n \t\t\ta.fail();\n-\t\t\ta.end();\n-\t\t}, 100);\n-\t\ta.pass();\n-\t});\n+\t\t});\n \n-\trunner.chain.cb('cb 2', a => {\n-\t\tsetTimeout(() => {\n-\t\t\ttests.push(2);\n-\t\t\ta.end();\n-\t\t}, 300);\n-\t\ta.pass();\n-\t});\n+\t\trunner.chain('second', a => {\n+\t\t\ta.pass();\n+\t\t});\n \n-\trunner.run({}).then(() => {\n-\t\tt.strictDeepEqual(tests, [1]);\n-\t\t// With concurrent tests there is no stopping the second `setTimeout` callback from happening.\n-\t\t// See the `bail + serial` test below for comparison\n-\t\tsetTimeout(() => {\n-\t\t\tt.strictDeepEqual(tests, [1, 2]);\n-\t\t\tt.end();\n-\t\t}, 250);\n+\t\trunner.on('test', data => {\n+\t\t\tt.is(data.title, expected.shift());\n+\t\t});\n \t});\n });\n \n-test('options.bail + serial - tests will never happen (async)', t => {\n-\tt.plan(2);\n-\n-\tconst runner = new Runner({\n-\t\tbail: true,\n-\t\tserial: true\n-\t});\n-\tconst tests = [];\n-\n-\trunner.chain.cb('cb', a => {\n-\t\tsetTimeout(() => {\n-\t\t\ttests.push(1);\n+test('options.failFast & failing serial test stops subsequent tests from running ', t => {\n+\tconst expected = ['first'];\n+\tt.plan(expected.length);\n+\n+\tpromiseEnd(new Runner({failFast: true, serial: true}), runner => {\n+\t\tlet block;\n+\t\tlet resume;\n+\t\trunner.chain.beforeEach(() => {\n+\t\t\tif (block) {\n+\t\t\t\treturn block;\n+\t\t\t}\n+\n+\t\t\tblock = new Promise(resolve => {\n+\t\t\t\tresume = resolve;\n+\t\t\t});\n+\t\t});\n+\n+\t\trunner.chain.serial('first', a => {\n+\t\t\tresume();\n \t\t\ta.fail();\n-\t\t\ta.end();\n-\t\t}, 100);\n-\t});\n+\t\t});\n \n-\trunner.chain.cb('cb 2', a => {\n-\t\tsetTimeout(() => {\n-\t\t\ttests.push(2);\n-\t\t\ta.end();\n-\t\t}, 300);\n-\t});\n+\t\trunner.chain.serial('second', a => {\n+\t\t\ta.pass();\n+\t\t});\n+\n+\t\trunner.chain('third', a => {\n+\t\t\ta.pass();\n+\t\t});\n \n-\trunner.run({}).then(() => {\n-\t\tt.strictDeepEqual(tests, [1]);\n-\t\tsetTimeout(() => {\n-\t\t\tt.strictDeepEqual(tests, [1]);\n-\t\t\tt.end();\n-\t\t}, 250);\n+\t\trunner.on('test', data => {\n+\t\t\tt.is(data.title, expected.shift());\n+\t\t});\n \t});\n });\n \n test('options.match will not run tests with non-matching titles', t => {\n \tt.plan(5);\n \n-\tconst runner = new Runner({\n-\t\tmatch: ['*oo', '!foo']\n-\t});\n-\n-\trunner.chain('mhm. grass tasty. moo', a => {\n-\t\tt.pass();\n-\t\ta.pass();\n-\t});\n-\n-\trunner.chain('juggaloo', a => {\n-\t\tt.pass();\n-\t\ta.pass();\n-\t});\n+\treturn promiseEnd(new Runner({match: ['*oo', '!foo']}), runner => {\n+\t\trunner.chain('mhm. grass tasty. moo', a => {\n+\t\t\tt.pass();\n+\t\t\ta.pass();\n+\t\t});\n \n-\trunner.chain('foo', a => {\n-\t\tt.fail();\n-\t\ta.pass();\n-\t});\n+\t\trunner.chain('juggaloo', a => {\n+\t\t\tt.pass();\n+\t\t\ta.pass();\n+\t\t});\n \n-\trunner.chain('test', a => {\n-\t\tt.fail();\n-\t\ta.pass();\n-\t});\n+\t\trunner.chain('foo', a => {\n+\t\t\tt.fail();\n+\t\t\ta.pass();\n+\t\t});\n \n-\trunner.run({}).then(() => {\n-\t\tconst stats = runner.buildStats();\n-\t\tt.is(stats.skipCount, 0);\n-\t\tt.is(stats.passCount, 2);\n-\t\tt.is(stats.testCount, 2);\n-\t\tt.end();\n+\t\trunner.chain('test', a => {\n+\t\t\tt.fail();\n+\t\t\ta.pass();\n+\t\t});\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.skipCount, 0);\n+\t\tt.is(runner.stats.passCount, 2);\n+\t\tt.is(runner.stats.testCount, 2);\n \t});\n });\n \n test('options.match hold no effect on hooks with titles', t => {\n \tt.plan(4);\n \n-\tconst runner = new Runner({\n-\t\tmatch: ['!before*']\n-\t});\n-\n-\tlet actual;\n+\treturn promiseEnd(new Runner({match: ['!before*']}), runner => {\n+\t\tlet actual;\n \n-\trunner.chain.before('before hook with title', () => {\n-\t\tactual = 'foo';\n-\t});\n-\n-\trunner.chain('after', a => {\n-\t\tt.is(actual, 'foo');\n-\t\ta.pass();\n-\t});\n+\t\trunner.chain.before('before hook with title', () => {\n+\t\t\tactual = 'foo';\n+\t\t});\n \n-\trunner.run({}).then(() => {\n-\t\tconst stats = runner.buildStats();\n-\t\tt.is(stats.skipCount, 0);\n-\t\tt.is(stats.passCount, 1);\n-\t\tt.is(stats.testCount, 1);\n-\t\tt.end();\n+\t\trunner.chain('after', a => {\n+\t\t\tt.is(actual, 'foo');\n+\t\t\ta.pass();\n+\t\t});\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.skipCount, 0);\n+\t\tt.is(runner.stats.passCount, 1);\n+\t\tt.is(runner.stats.testCount, 1);\n \t});\n });\n \n test('options.match overrides .only', t => {\n \tt.plan(5);\n \n-\tconst runner = new Runner({\n-\t\tmatch: ['*oo']\n-\t});\n+\treturn promiseEnd(new Runner({match: ['*oo']}), runner => {\n+\t\trunner.chain('moo', a => {\n+\t\t\tt.pass();\n+\t\t\ta.pass();\n+\t\t});\n \n-\trunner.chain('moo', a => {\n-\t\tt.pass();\n-\t\ta.pass();\n+\t\trunner.chain.only('boo', a => {\n+\t\t\tt.pass();\n+\t\t\ta.pass();\n+\t\t});\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.skipCount, 0);\n+\t\tt.is(runner.stats.passCount, 2);\n+\t\tt.is(runner.stats.testCount, 2);\n \t});\n+});\n \n-\trunner.chain.only('boo', a => {\n-\t\tt.pass();\n-\t\ta.pass();\n-\t});\n+test('options.match matches todo tests', t => {\n+\tt.plan(2);\n \n-\trunner.run({}).then(() => {\n-\t\tconst stats = runner.buildStats();\n-\t\tt.is(stats.skipCount, 0);\n-\t\tt.is(stats.passCount, 2);\n-\t\tt.is(stats.testCount, 2);\n-\t\tt.end();\n+\treturn promiseEnd(new Runner({match: ['*oo']}), runner => {\n+\t\trunner.chain.todo('moo');\n+\t\trunner.chain.todo('oom');\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.testCount, 1);\n+\t\tt.is(runner.stats.todoCount, 1);\n \t});\n });\n \n test('macros: Additional args will be spread as additional args on implementation function', t => {\n-\tt.plan(3);\n-\n-\tconst runner = new Runner();\n+\tt.plan(4);\n \n-\trunner.chain('test1', function (a) {\n-\t\tt.deepEqual(slice.call(arguments, 1), ['foo', 'bar']);\n-\t\ta.pass();\n-\t}, 'foo', 'bar');\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain.before(function (a) {\n+\t\t\tt.deepEqual(slice.call(arguments, 1), ['foo', 'bar']);\n+\t\t\ta.pass();\n+\t\t}, 'foo', 'bar');\n \n-\trunner.run({}).then(() => {\n-\t\tconst stats = runner.buildStats();\n-\t\tt.is(stats.passCount, 1);\n-\t\tt.is(stats.testCount, 1);\n-\t\tt.end();\n+\t\trunner.chain('test1', function (a) {\n+\t\t\tt.deepEqual(slice.call(arguments, 1), ['foo', 'bar']);\n+\t\t\ta.pass();\n+\t\t}, 'foo', 'bar');\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.passCount, 1);\n+\t\tt.is(runner.stats.testCount, 1);\n \t});\n });\n \n@@ -614,21 +606,41 @@ test('macros: Customize test names attaching a `title` function', t => {\n \n \tmacroFn.title = (title, firstArg) => (title || 'default') + firstArg;\n \n-\tconst runner = new Runner();\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.on('test', props => {\n+\t\t\tt.is(props.title, expectedTitles.shift());\n+\t\t});\n \n-\trunner.on('test', props => {\n-\t\tt.is(props.title, expectedTitles.shift());\n+\t\trunner.chain(macroFn, 'A');\n+\t\trunner.chain('supplied', macroFn, 'B');\n+\t\trunner.chain(macroFn, 'C');\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.passCount, 3);\n+\t\tt.is(runner.stats.testCount, 3);\n \t});\n+});\n \n-\trunner.chain(macroFn, 'A');\n-\trunner.chain('supplied', macroFn, 'B');\n-\trunner.chain(macroFn, 'C');\n+test('macros: test titles must be strings', t => {\n+\tt.plan(1);\n \n-\trunner.run({}).then(() => {\n-\t\tconst stats = runner.buildStats();\n-\t\tt.is(stats.passCount, 3);\n-\t\tt.is(stats.testCount, 3);\n-\t\tt.end();\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\tt.throws(() => {\n+\t\t\tconst macro = t => t.pass();\n+\t\t\tmacro.title = () => [];\n+\t\t\trunner.chain(macro);\n+\t\t}, new TypeError('Test & hook titles must be strings'));\n+\t});\n+});\n+\n+test('macros: hook titles must be strings', t => {\n+\tt.plan(1);\n+\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\tt.throws(() => {\n+\t\t\tconst macro = t => t.pass();\n+\t\t\tmacro.title = () => [];\n+\t\t\trunner.chain.before(macro);\n+\t\t}, new TypeError('Test & hook titles must be strings'));\n \t});\n });\n \n@@ -641,22 +653,16 @@ test('match applies to macros', t => {\n \n \tmacroFn.title = (title, firstArg) => `${firstArg}bar`;\n \n-\tconst runner = new Runner({\n-\t\tmatch: ['foobar']\n-\t});\n-\n-\trunner.on('test', props => {\n-\t\tt.is(props.title, 'foobar');\n-\t});\n-\n-\trunner.chain(macroFn, 'foo');\n-\trunner.chain(macroFn, 'bar');\n+\treturn promiseEnd(new Runner({match: ['foobar']}), runner => {\n+\t\trunner.on('test', props => {\n+\t\t\tt.is(props.title, 'foobar');\n+\t\t});\n \n-\trunner.run({}).then(() => {\n-\t\tconst stats = runner.buildStats();\n-\t\tt.is(stats.passCount, 1);\n-\t\tt.is(stats.testCount, 1);\n-\t\tt.end();\n+\t\trunner.chain(macroFn, 'foo');\n+\t\trunner.chain(macroFn, 'bar');\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.passCount, 1);\n+\t\tt.is(runner.stats.testCount, 1);\n \t});\n });\n \n@@ -685,20 +691,16 @@ test('arrays of macros', t => {\n \t}\n \tmacroFnB.title = prefix => `${prefix}.B`;\n \n-\tconst runner = new Runner();\n-\n-\trunner.chain('A', [macroFnA, macroFnB], 'A');\n-\trunner.chain('B', [macroFnA, macroFnB], 'B');\n-\trunner.chain('C', macroFnA, 'C');\n-\trunner.chain('D', macroFnB, 'D');\n-\n-\trunner.run({}).then(() => {\n-\t\tconst stats = runner.buildStats();\n-\t\tt.is(stats.passCount, 6);\n-\t\tt.is(stats.testCount, 6);\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain('A', [macroFnA, macroFnB], 'A');\n+\t\trunner.chain('B', [macroFnA, macroFnB], 'B');\n+\t\trunner.chain('C', macroFnA, 'C');\n+\t\trunner.chain('D', macroFnB, 'D');\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.passCount, 6);\n+\t\tt.is(runner.stats.testCount, 6);\n \t\tt.is(expectedArgsA.length, 0);\n \t\tt.is(expectedArgsB.length, 0);\n-\t\tt.end();\n \t});\n });\n \n@@ -723,21 +725,106 @@ test('match applies to arrays of macros', t => {\n \t}\n \tbazMacro.title = (title, firstArg) => `${firstArg}baz`;\n \n-\tconst runner = new Runner({\n-\t\tmatch: ['foobar']\n+\treturn promiseEnd(new Runner({match: ['foobar']}), runner => {\n+\t\trunner.on('test', props => {\n+\t\t\tt.is(props.title, 'foobar');\n+\t\t});\n+\n+\t\trunner.chain([fooMacro, barMacro, bazMacro], 'foo');\n+\t\trunner.chain([fooMacro, barMacro, bazMacro], 'bar');\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.passCount, 1);\n+\t\tt.is(runner.stats.testCount, 1);\n \t});\n+});\n \n-\trunner.on('test', props => {\n-\t\tt.is(props.title, 'foobar');\n+test('silently skips other tests when .only is used', t => {\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain('skip me', a => a.pass());\n+\t\trunner.chain.serial('skip me too', a => a.pass());\n+\t\trunner.chain.only('only me', a => a.pass());\n+\t}).then(runner => {\n+\t\tt.is(runner.stats.passCount, 1);\n+\t\tt.is(runner.stats.skipCount, 0);\n \t});\n+});\n \n-\trunner.chain([fooMacro, barMacro, bazMacro], 'foo');\n-\trunner.chain([fooMacro, barMacro, bazMacro], 'bar');\n+test('subsequent always hooks are run even if earlier always hooks fail', t => {\n+\tt.plan(3);\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain('test', a => a.pass());\n+\t\trunner.chain.serial.after.always(a => {\n+\t\t\tt.pass();\n+\t\t\ta.fail();\n+\t\t});\n+\t\trunner.chain.serial.after.always(a => {\n+\t\t\tt.pass();\n+\t\t\ta.fail();\n+\t\t});\n+\t\trunner.chain.after.always(a => {\n+\t\t\tt.pass();\n+\t\t\ta.fail();\n+\t\t});\n+\t});\n+});\n \n-\trunner.run({}).then(() => {\n-\t\tconst stats = runner.buildStats();\n-\t\tt.is(stats.passCount, 1);\n-\t\tt.is(stats.testCount, 1);\n-\t\tt.end();\n+test('hooks run concurrently, but can be serialized', t => {\n+\tt.plan(7);\n+\n+\tlet activeCount = 0;\n+\treturn promiseEnd(new Runner(), runner => {\n+\t\trunner.chain('test', a => a.pass());\n+\n+\t\trunner.chain.before(() => {\n+\t\t\tt.is(activeCount, 0);\n+\t\t\tactiveCount++;\n+\t\t\treturn new Promise(resolve => setTimeout(resolve, 20)).then(() => {\n+\t\t\t\tactiveCount--;\n+\t\t\t});\n+\t\t});\n+\n+\t\trunner.chain.before(() => {\n+\t\t\tt.is(activeCount, 1);\n+\t\t\tactiveCount++;\n+\t\t\treturn new Promise(resolve => setTimeout(resolve, 10)).then(() => {\n+\t\t\t\tactiveCount--;\n+\t\t\t});\n+\t\t});\n+\n+\t\trunner.chain.serial.before(() => {\n+\t\t\tt.is(activeCount, 0);\n+\t\t\tactiveCount++;\n+\t\t\treturn new Promise(resolve => setTimeout(resolve, 10)).then(() => {\n+\t\t\t\tactiveCount--;\n+\t\t\t});\n+\t\t});\n+\n+\t\trunner.chain.before(() => {\n+\t\t\tt.is(activeCount, 0);\n+\t\t\tactiveCount++;\n+\t\t\treturn new Promise(resolve => setTimeout(resolve, 20)).then(() => {\n+\t\t\t\tactiveCount--;\n+\t\t\t});\n+\t\t});\n+\n+\t\trunner.chain.before(() => {\n+\t\t\tt.is(activeCount, 1);\n+\t\t\tactiveCount++;\n+\t\t\treturn new Promise(resolve => setTimeout(resolve, 10)).then(() => {\n+\t\t\t\tactiveCount--;\n+\t\t\t});\n+\t\t});\n+\n+\t\trunner.chain.serial.before(() => {\n+\t\t\tt.is(activeCount, 0);\n+\t\t\tactiveCount++;\n+\t\t\treturn new Promise(resolve => setTimeout(resolve, 10)).then(() => {\n+\t\t\t\tactiveCount--;\n+\t\t\t});\n+\t\t});\n+\n+\t\trunner.chain.serial.before(() => {\n+\t\t\tt.is(activeCount, 0);\n+\t\t});\n \t});\n });"
      },
      {
        "sha": "555fba97ec38c773cedb7af7e9bf6fd771516c4b",
        "filename": "test/sequence.js",
        "status": "removed",
        "additions": 0,
        "deletions": 780,
        "changes": 780,
        "blob_url": "https://github.com/avajs/ava/blob/51a0ff02d4c4dcb9036e7f56c0860dfee330e238/test%2Fsequence.js",
        "raw_url": "https://github.com/avajs/ava/raw/51a0ff02d4c4dcb9036e7f56c0860dfee330e238/test%2Fsequence.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fsequence.js?ref=51a0ff02d4c4dcb9036e7f56c0860dfee330e238",
        "patch": "@@ -1,780 +0,0 @@\n-'use strict';\n-const tap = require('tap');\n-const Promise = require('bluebird');\n-const isPromise = require('is-promise');\n-const Sequence = require('../lib/sequence');\n-\n-let results = [];\n-const test = (name, fn) => {\n-\ttap.test(name, t => {\n-\t\tresults = [];\n-\t\treturn fn(t);\n-\t});\n-};\n-function collect(result) {\n-\tif (isPromise(result)) {\n-\t\treturn result.then(collect);\n-\t}\n-\n-\tresults.push(result);\n-\treturn result.passed;\n-}\n-\n-function pass(val) {\n-\treturn {\n-\t\trun() {\n-\t\t\treturn collect({\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: val\n-\t\t\t});\n-\t\t}\n-\t};\n-}\n-\n-function fail(val) {\n-\treturn {\n-\t\trun() {\n-\t\t\treturn collect({\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: val\n-\t\t\t});\n-\t\t}\n-\t};\n-}\n-\n-function passAsync(val) {\n-\treturn {\n-\t\trun() {\n-\t\t\treturn collect(Promise.resolve({\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: val\n-\t\t\t}));\n-\t\t}\n-\t};\n-}\n-\n-function failAsync(err) {\n-\treturn {\n-\t\trun() {\n-\t\t\treturn collect(Promise.resolve({\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: err\n-\t\t\t}));\n-\t\t}\n-\t};\n-}\n-\n-function reject(err) {\n-\treturn {\n-\t\trun() {\n-\t\t\treturn Promise.reject(err);\n-\t\t}\n-\t};\n-}\n-\n-test('all sync - no failure - no bail', t => {\n-\tconst passed = new Sequence(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpass('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\tfalse\n-\t).run();\n-\n-\tt.equal(passed, true);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'a'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'b'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'c'\n-\t\t}\n-\t]);\n-\tt.end();\n-});\n-\n-test('all sync - no failure - bail', t => {\n-\tconst passed = new Sequence(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpass('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\ttrue\n-\t).run();\n-\n-\tt.equal(passed, true);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'a'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'b'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'c'\n-\t\t}\n-\t]);\n-\tt.end();\n-});\n-\n-test('all sync - begin failure - no bail', t => {\n-\tconst passed = new Sequence(\n-\t\t[\n-\t\t\tfail('a'),\n-\t\t\tpass('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\tfalse\n-\t).run();\n-\n-\tt.equal(passed, false);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: false,\n-\t\t\treason: 'a'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'b'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'c'\n-\t\t}\n-\t]);\n-\tt.end();\n-});\n-\n-test('all sync - mid failure - no bail', t => {\n-\tconst passed = new Sequence(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tfail('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\tfalse\n-\t).run();\n-\n-\tt.equal(passed, false);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'a'},\n-\t\t{\n-\t\t\tpassed: false,\n-\t\t\treason: 'b'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'c'\n-\t\t}\n-\t]);\n-\tt.end();\n-});\n-\n-test('all sync - end failure - no bail', t => {\n-\tconst passed = new Sequence(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpass('b'),\n-\t\t\tfail('c')\n-\t\t],\n-\t\tfalse\n-\t).run();\n-\n-\tt.equal(passed, false);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'a'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'b'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: false,\n-\t\t\treason: 'c'\n-\t\t}\n-\t]);\n-\tt.end();\n-});\n-\n-test('all sync - multiple failure - no bail', t => {\n-\tconst passed = new Sequence(\n-\t\t[\n-\t\t\tfail('a'),\n-\t\t\tpass('b'),\n-\t\t\tfail('c')\n-\t\t],\n-\t\tfalse\n-\t).run();\n-\n-\tt.equal(passed, false);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: false,\n-\t\t\treason: 'a'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'b'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: false,\n-\t\t\treason: 'c'\n-\t\t}\n-\t]);\n-\tt.end();\n-});\n-\n-test('all sync - begin failure - bail', t => {\n-\tconst passed = new Sequence(\n-\t\t[\n-\t\t\tfail('a'),\n-\t\t\tpass('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\ttrue\n-\t).run();\n-\n-\tt.equal(passed, false);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: false,\n-\t\t\treason: 'a'\n-\t\t}\n-\t]);\n-\tt.end();\n-});\n-\n-test('all sync - mid failure - bail', t => {\n-\tconst passed = new Sequence(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tfail('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\ttrue\n-\t).run();\n-\n-\tt.equal(passed, false);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'a'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: false,\n-\t\t\treason: 'b'\n-\t\t}\n-\t]);\n-\tt.end();\n-});\n-\n-test('all sync - end failure - bail', t => {\n-\tconst passed = new Sequence(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpass('b'),\n-\t\t\tfail('c')\n-\t\t],\n-\t\ttrue\n-\t).run();\n-\n-\tt.equal(passed, false);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'a'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'b'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: false,\n-\t\t\treason: 'c'\n-\t\t}\n-\t]);\n-\tt.end();\n-});\n-\n-test('all async - no failure - no bail', t => {\n-\tnew Sequence(\n-\t\t[\n-\t\t\tpassAsync('a'),\n-\t\t\tpassAsync('b'),\n-\t\t\tpassAsync('c')\n-\t\t],\n-\t\tfalse\n-\t).run().then(passed => {\n-\t\tt.equal(passed, true);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t}\n-\t\t]);\n-\t\tt.end();\n-\t});\n-});\n-\n-test('all async - no failure - bail', t => {\n-\tnew Sequence(\n-\t\t[\n-\t\t\tpassAsync('a'),\n-\t\t\tpassAsync('b'),\n-\t\t\tpassAsync('c')\n-\t\t],\n-\t\ttrue\n-\t).run().then(passed => {\n-\t\tt.equal(passed, true);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t}\n-\t\t]);\n-\t\tt.end();\n-\t});\n-});\n-\n-test('last async - no failure - no bail', t => {\n-\tnew Sequence(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpass('b'),\n-\t\t\tpassAsync('c')\n-\t\t],\n-\t\tfalse\n-\t).run().then(passed => {\n-\t\tt.equal(passed, true);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t}\n-\t\t]);\n-\t\tt.end();\n-\t});\n-});\n-\n-test('mid async - no failure - no bail', t => {\n-\tnew Sequence(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpassAsync('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\tfalse\n-\t).run().then(passed => {\n-\t\tt.equal(passed, true);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t}\n-\t\t]);\n-\t\tt.end();\n-\t});\n-});\n-\n-test('first async - no failure - no bail', t => {\n-\tnew Sequence(\n-\t\t[\n-\t\t\tpassAsync('a'),\n-\t\t\tpass('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\tfalse\n-\t).run().then(passed => {\n-\t\tt.equal(passed, true);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t}\n-\t\t]);\n-\t\tt.end();\n-\t});\n-});\n-\n-test('last async - no failure - bail', t => {\n-\tnew Sequence(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpass('b'),\n-\t\t\tpassAsync('c')\n-\t\t],\n-\t\ttrue\n-\t).run().then(passed => {\n-\t\tt.equal(passed, true);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t}\n-\t\t]);\n-\t\tt.end();\n-\t});\n-});\n-\n-test('mid async - no failure - bail', t => {\n-\tnew Sequence(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpassAsync('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\ttrue\n-\t).run().then(passed => {\n-\t\tt.equal(passed, true);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t}\n-\t\t]);\n-\t\tt.end();\n-\t});\n-});\n-\n-test('first async - no failure - bail', t => {\n-\tnew Sequence(\n-\t\t[\n-\t\t\tpassAsync('a'),\n-\t\t\tpass('b'),\n-\t\t\tpass('c')\n-\t\t],\n-\t\ttrue\n-\t).run().then(passed => {\n-\t\tt.equal(passed, true);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t}\n-\t\t]);\n-\t\tt.end();\n-\t});\n-});\n-\n-test('all async - begin failure - bail', t => {\n-\tnew Sequence(\n-\t\t[\n-\t\t\tfailAsync('a'),\n-\t\t\tpassAsync('b'),\n-\t\t\tpassAsync('c')\n-\t\t],\n-\t\ttrue\n-\t).run().then(passed => {\n-\t\tt.equal(passed, false);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: 'a'\n-\t\t\t}\n-\t\t]);\n-\t\tt.end();\n-\t});\n-});\n-\n-test('all async - mid failure - bail', t => {\n-\tnew Sequence(\n-\t\t[\n-\t\t\tpassAsync('a'),\n-\t\t\tfailAsync('b'),\n-\t\t\tpassAsync('c')\n-\t\t],\n-\t\ttrue\n-\t).run().then(passed => {\n-\t\tt.equal(passed, false);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: 'b'\n-\t\t\t}\n-\t\t]);\n-\t\tt.end();\n-\t});\n-});\n-\n-test('all async - end failure - bail', t => {\n-\tnew Sequence(\n-\t\t[\n-\t\t\tpassAsync('a'),\n-\t\t\tpassAsync('b'),\n-\t\t\tfailAsync('c')\n-\t\t],\n-\t\ttrue\n-\t).run().then(passed => {\n-\t\tt.equal(passed, false);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: 'c'\n-\t\t\t}\n-\t\t]);\n-\t\tt.end();\n-\t});\n-});\n-\n-test('all async - begin failure - no bail', t => {\n-\tnew Sequence(\n-\t\t[\n-\t\t\tfailAsync('a'),\n-\t\t\tpassAsync('b'),\n-\t\t\tpassAsync('c')\n-\t\t],\n-\t\tfalse\n-\t).run().then(passed => {\n-\t\tt.equal(passed, false);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t}\n-\t\t]);\n-\t\tt.end();\n-\t});\n-});\n-\n-test('all async - mid failure - no bail', t => {\n-\tnew Sequence(\n-\t\t[\n-\t\t\tpassAsync('a'),\n-\t\t\tfailAsync('b'),\n-\t\t\tpassAsync('c')\n-\t\t],\n-\t\tfalse\n-\t).run().then(passed => {\n-\t\tt.equal(passed, false);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'c'\n-\t\t\t}\n-\t\t]);\n-\t\tt.end();\n-\t});\n-});\n-\n-test('all async - end failure - no bail', t => {\n-\tnew Sequence(\n-\t\t[\n-\t\t\tpassAsync('a'),\n-\t\t\tpassAsync('b'),\n-\t\t\tfailAsync('c')\n-\t\t],\n-\t\tfalse\n-\t).run().then(passed => {\n-\t\tt.equal(passed, false);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: 'c'\n-\t\t\t}\n-\t\t]);\n-\t\tt.end();\n-\t});\n-});\n-\n-test('all async - multiple failure - no bail', t => {\n-\tnew Sequence(\n-\t\t[\n-\t\t\tfailAsync('a'),\n-\t\t\tpassAsync('b'),\n-\t\t\tfailAsync('c')\n-\t\t],\n-\t\tfalse\n-\t).run().then(passed => {\n-\t\tt.equal(passed, false);\n-\t\tt.strictDeepEqual(results, [\n-\t\t\t{\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: 'a'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: true,\n-\t\t\t\tresult: 'b'\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tpassed: false,\n-\t\t\t\treason: 'c'\n-\t\t\t}\n-\t\t]);\n-\t\tt.end();\n-\t});\n-});\n-\n-test('rejections are just passed through - no bail', t => {\n-\tnew Sequence(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpass('b'),\n-\t\t\treject('foo')\n-\t\t],\n-\t\tfalse\n-\t).run().catch(err => {\n-\t\tt.is(err, 'foo');\n-\t\tt.end();\n-\t});\n-});\n-\n-test('rejections are just passed through - bail', t => {\n-\tnew Sequence(\n-\t\t[\n-\t\t\tpass('a'),\n-\t\t\tpass('b'),\n-\t\t\treject('foo')\n-\t\t],\n-\t\ttrue\n-\t).run().catch(err => {\n-\t\tt.is(err, 'foo');\n-\t\tt.end();\n-\t});\n-});\n-\n-test('needs at least one sequence runnable', t => {\n-\tt.throws(() => {\n-\t\tnew Sequence().run();\n-\t}, {message: 'Expected an array of runnables'});\n-\tt.end();\n-});\n-\n-test('sequences of sequences', t => {\n-\tconst passed = new Sequence([\n-\t\tnew Sequence([pass('a'), pass('b')]),\n-\t\tnew Sequence([pass('c')])\n-\t]).run();\n-\n-\tt.equal(passed, true);\n-\tt.strictDeepEqual(results, [\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'a'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'b'\n-\t\t},\n-\t\t{\n-\t\t\tpassed: true,\n-\t\t\tresult: 'c'\n-\t\t}\n-\t]);\n-\n-\tt.end();\n-});"
      },
      {
        "sha": "6fc4efcb068ac71cbf7bda8b9830d08cd2f72d43",
        "filename": "test/serialize-error.js",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Fserialize-error.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Fserialize-error.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fserialize-error.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -1,4 +1,5 @@\n 'use strict';\n+require('../lib/worker-options').set({});\n \n const fs = require('fs');\n const path = require('path');\n@@ -160,3 +161,14 @@ test('remove non-string error properties', t => {\n \tt.is(serializedErr.stack, undefined);\n \tt.end();\n });\n+\n+test('creates multiline summaries for syntax errors', t => {\n+\tconst err = {\n+\t\tname: 'SyntaxError',\n+\t\tstack: 'Hello\\nThere\\nSyntaxError here\\nIgnore me'\n+\t};\n+\tconst serializedErr = serialize(err);\n+\tt.is(serializedErr.name, 'SyntaxError');\n+\tt.is(serializedErr.summary, 'Hello\\nThere\\nSyntaxError here');\n+\tt.end();\n+});"
      },
      {
        "sha": "995e19290dc982e050cef6b06b327d1a53373c22",
        "filename": "test/test-collection.js",
        "status": "removed",
        "additions": 0,
        "deletions": 379,
        "changes": 379,
        "blob_url": "https://github.com/avajs/ava/blob/51a0ff02d4c4dcb9036e7f56c0860dfee330e238/test%2Ftest-collection.js",
        "raw_url": "https://github.com/avajs/ava/raw/51a0ff02d4c4dcb9036e7f56c0860dfee330e238/test%2Ftest-collection.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ftest-collection.js?ref=51a0ff02d4c4dcb9036e7f56c0860dfee330e238",
        "patch": "@@ -1,379 +0,0 @@\n-'use strict';\n-const test = require('tap').test;\n-const TestCollection = require('../lib/test-collection');\n-\n-function defaults() {\n-\treturn {\n-\t\ttype: 'test',\n-\t\tserial: false,\n-\t\texclusive: false,\n-\t\tskipped: false,\n-\t\tcallback: false,\n-\t\talways: false\n-\t};\n-}\n-\n-function metadata(opts) {\n-\treturn Object.assign(defaults(), opts);\n-}\n-\n-function mockTest(opts, title) {\n-\treturn {\n-\t\ttitle,\n-\t\tmetadata: metadata(opts)\n-\t};\n-}\n-\n-function titles(tests) {\n-\tif (!tests) {\n-\t\ttests = [];\n-\t}\n-\n-\treturn tests.map(test => test.title);\n-}\n-\n-function removeEmptyProps(obj) {\n-\tif (Array.isArray(obj) && obj.length === 0) {\n-\t\treturn null;\n-\t}\n-\n-\tif (obj.constructor !== Object) {\n-\t\treturn obj;\n-\t}\n-\n-\tlet cleanObj = null;\n-\n-\tObject.keys(obj).forEach(key => {\n-\t\tconst value = removeEmptyProps(obj[key]);\n-\n-\t\tif (value) {\n-\t\t\tif (!cleanObj) {\n-\t\t\t\tcleanObj = {};\n-\t\t\t}\n-\n-\t\t\tcleanObj[key] = value;\n-\t\t}\n-\t});\n-\n-\treturn cleanObj;\n-}\n-\n-function serialize(collection) {\n-\tconst serialized = {\n-\t\ttests: {\n-\t\t\tconcurrent: titles(collection.tests.concurrent),\n-\t\t\tserial: titles(collection.tests.serial)\n-\t\t},\n-\t\thooks: {\n-\t\t\tbefore: titles(collection.hooks.before),\n-\t\t\tbeforeEach: titles(collection.hooks.beforeEach),\n-\t\t\tafter: titles(collection.hooks.after),\n-\t\t\tafterAlways: titles(collection.hooks.afterAlways),\n-\t\t\tafterEach: titles(collection.hooks.afterEach),\n-\t\t\tafterEachAlways: titles(collection.hooks.afterEachAlways)\n-\t\t}\n-\t};\n-\n-\treturn removeEmptyProps(serialized);\n-}\n-\n-test('hasExclusive is set when an exclusive test is added', t => {\n-\tconst collection = new TestCollection({});\n-\tt.false(collection.hasExclusive);\n-\tcollection.add(mockTest({exclusive: true}, 'foo'));\n-\tt.true(collection.hasExclusive);\n-\tt.end();\n-});\n-\n-test('adding a concurrent test', t => {\n-\tconst collection = new TestCollection({});\n-\tcollection.add(mockTest({}, 'foo'));\n-\tt.strictDeepEqual(serialize(collection), {\n-\t\ttests: {\n-\t\t\tconcurrent: ['foo']\n-\t\t}\n-\t});\n-\tt.end();\n-});\n-\n-test('adding a serial test', t => {\n-\tconst collection = new TestCollection({});\n-\tcollection.add(mockTest({serial: true}, 'bar'));\n-\tt.strictDeepEqual(serialize(collection), {\n-\t\ttests: {\n-\t\t\tserial: ['bar']\n-\t\t}\n-\t});\n-\tt.end();\n-});\n-\n-test('adding a before test', t => {\n-\tconst collection = new TestCollection({});\n-\tcollection.add(mockTest({type: 'before'}, 'baz'));\n-\tt.strictDeepEqual(serialize(collection), {\n-\t\thooks: {\n-\t\t\tbefore: ['baz']\n-\t\t}\n-\t});\n-\tt.end();\n-});\n-\n-test('adding a beforeEach test', t => {\n-\tconst collection = new TestCollection({});\n-\tcollection.add(mockTest({type: 'beforeEach'}, 'foo'));\n-\tt.strictDeepEqual(serialize(collection), {\n-\t\thooks: {\n-\t\t\tbeforeEach: ['foo']\n-\t\t}\n-\t});\n-\tt.end();\n-});\n-\n-test('adding a after test', t => {\n-\tconst collection = new TestCollection({});\n-\tcollection.add(mockTest({type: 'after'}, 'bar'));\n-\tt.strictDeepEqual(serialize(collection), {\n-\t\thooks: {\n-\t\t\tafter: ['bar']\n-\t\t}\n-\t});\n-\tt.end();\n-});\n-\n-test('adding a after.always test', t => {\n-\tconst collection = new TestCollection({});\n-\tcollection.add(mockTest({\n-\t\ttype: 'after',\n-\t\talways: true\n-\t}, 'bar'));\n-\tt.strictDeepEqual(serialize(collection), {\n-\t\thooks: {\n-\t\t\tafterAlways: ['bar']\n-\t\t}\n-\t});\n-\tt.end();\n-});\n-\n-test('adding a afterEach test', t => {\n-\tconst collection = new TestCollection({});\n-\tcollection.add(mockTest({type: 'afterEach'}, 'baz'));\n-\tt.strictDeepEqual(serialize(collection), {\n-\t\thooks: {\n-\t\t\tafterEach: ['baz']\n-\t\t}\n-\t});\n-\tt.end();\n-});\n-\n-test('adding a afterEach.always test', t => {\n-\tconst collection = new TestCollection({});\n-\tcollection.add(mockTest({\n-\t\ttype: 'afterEach',\n-\t\talways: true\n-\t}, 'baz'));\n-\tt.strictDeepEqual(serialize(collection), {\n-\t\thooks: {\n-\t\t\tafterEachAlways: ['baz']\n-\t\t}\n-\t});\n-\tt.end();\n-});\n-\n-test('adding a bunch of different types', t => {\n-\tconst collection = new TestCollection({});\n-\tcollection.add(mockTest({}, 'a'));\n-\tcollection.add(mockTest({}, 'b'));\n-\tcollection.add(mockTest({serial: true}, 'c'));\n-\tcollection.add(mockTest({serial: true}, 'd'));\n-\tcollection.add(mockTest({type: 'before'}, 'e'));\n-\tt.strictDeepEqual(serialize(collection), {\n-\t\ttests: {\n-\t\t\tconcurrent: ['a', 'b'],\n-\t\t\tserial: ['c', 'd']\n-\t\t},\n-\t\thooks: {\n-\t\t\tbefore: ['e']\n-\t\t}\n-\t});\n-\tt.end();\n-});\n-\n-test('skips before and after hooks when all tests are skipped', t => {\n-\tt.plan(5);\n-\n-\tconst collection = new TestCollection({});\n-\tcollection.add({\n-\t\tmetadata: metadata({type: 'before'}),\n-\t\tfn: a => a.fail()\n-\t});\n-\tcollection.add({\n-\t\tmetadata: metadata({type: 'after'}),\n-\t\tfn: a => a.fail()\n-\t});\n-\tcollection.add({\n-\t\ttitle: 'some serial test',\n-\t\tmetadata: metadata({skipped: true, serial: true}),\n-\t\tfn: a => a.fail()\n-\t});\n-\tcollection.add({\n-\t\ttitle: 'some concurrent test',\n-\t\tmetadata: metadata({skipped: true}),\n-\t\tfn: a => a.fail()\n-\t});\n-\n-\tconst log = [];\n-\tcollection.on('test', result => {\n-\t\tt.is(result.result.metadata.skipped, true);\n-\t\tt.is(result.result.metadata.type, 'test');\n-\t\tlog.push(result.result.title);\n-\t});\n-\n-\tcollection.build().run();\n-\n-\tt.strictDeepEqual(log, [\n-\t\t'some serial test',\n-\t\t'some concurrent test'\n-\t]);\n-\n-\tt.end();\n-});\n-\n-test('runs after.always hook, even if all tests are skipped', t => {\n-\tt.plan(6);\n-\n-\tconst collection = new TestCollection({});\n-\tcollection.add({\n-\t\ttitle: 'some serial test',\n-\t\tmetadata: metadata({skipped: true, serial: true}),\n-\t\tfn: a => a.fail()\n-\t});\n-\tcollection.add({\n-\t\ttitle: 'some concurrent test',\n-\t\tmetadata: metadata({skipped: true}),\n-\t\tfn: a => a.fail()\n-\t});\n-\tcollection.add({\n-\t\ttitle: 'after always',\n-\t\tmetadata: metadata({type: 'after', always: true}),\n-\t\tfn: a => a.pass()\n-\t});\n-\n-\tconst log = [];\n-\tcollection.on('test', result => {\n-\t\tif (result.result.metadata.type === 'after') {\n-\t\t\tt.is(result.result.metadata.skipped, false);\n-\t\t} else {\n-\t\t\tt.is(result.result.metadata.skipped, true);\n-\t\t\tt.is(result.result.metadata.type, 'test');\n-\t\t}\n-\t\tlog.push(result.result.title);\n-\t});\n-\n-\tcollection.build().run();\n-\n-\tt.strictDeepEqual(log, [\n-\t\t'some serial test',\n-\t\t'some concurrent test',\n-\t\t'after always'\n-\t]);\n-\n-\tt.end();\n-});\n-\n-test('skips beforeEach and afterEach hooks when test is skipped', t => {\n-\tt.plan(3);\n-\n-\tconst collection = new TestCollection({});\n-\tcollection.add({\n-\t\tmetadata: metadata({type: 'beforeEach'}),\n-\t\tfn: a => a.fail()\n-\t});\n-\tcollection.add({\n-\t\tmetadata: metadata({type: 'afterEach'}),\n-\t\tfn: a => a.fail()\n-\t});\n-\tcollection.add({\n-\t\ttitle: 'some test',\n-\t\tmetadata: metadata({skipped: true}),\n-\t\tfn: a => a.fail()\n-\t});\n-\n-\tconst log = [];\n-\tcollection.on('test', result => {\n-\t\tt.is(result.result.metadata.skipped, true);\n-\t\tt.is(result.result.metadata.type, 'test');\n-\t\tlog.push(result.result.title);\n-\t});\n-\n-\tcollection.build().run();\n-\n-\tt.strictDeepEqual(log, [\n-\t\t'some test'\n-\t]);\n-\n-\tt.end();\n-});\n-\n-test('foo', t => {\n-\tconst collection = new TestCollection({});\n-\tconst log = [];\n-\n-\tfunction logger(result) {\n-\t\tt.is(result.passed, true);\n-\t\tlog.push(result.result.title);\n-\t}\n-\n-\tfunction add(title, opts) {\n-\t\tcollection.add({\n-\t\t\ttitle,\n-\t\t\tmetadata: metadata(opts),\n-\t\t\tfn: a => a.pass()\n-\t\t});\n-\t}\n-\n-\tadd('after1', {type: 'after'});\n-\tadd('after.always', {\n-\t\ttype: 'after',\n-\t\talways: true\n-\t});\n-\tadd('beforeEach1', {type: 'beforeEach'});\n-\tadd('before1', {type: 'before'});\n-\tadd('beforeEach2', {type: 'beforeEach'});\n-\tadd('afterEach1', {type: 'afterEach'});\n-\tadd('afterEach.always', {\n-\t\ttype: 'afterEach',\n-\t\talways: true\n-\t});\n-\tadd('test1', {});\n-\tadd('afterEach2', {type: 'afterEach'});\n-\tadd('test2', {});\n-\tadd('after2', {type: 'after'});\n-\tadd('before2', {type: 'before'});\n-\n-\tcollection.on('test', logger);\n-\n-\tconst passed = collection.build().run();\n-\tt.is(passed, true);\n-\n-\tt.strictDeepEqual(log, [\n-\t\t'before1',\n-\t\t'before2',\n-\t\t'beforeEach1 for test1',\n-\t\t'beforeEach2 for test1',\n-\t\t'test1',\n-\t\t'afterEach1 for test1',\n-\t\t'afterEach2 for test1',\n-\t\t'afterEach.always for test1',\n-\t\t'beforeEach1 for test2',\n-\t\t'beforeEach2 for test2',\n-\t\t'test2',\n-\t\t'afterEach1 for test2',\n-\t\t'afterEach2 for test2',\n-\t\t'afterEach.always for test2',\n-\t\t'after1',\n-\t\t'after2',\n-\t\t'after.always'\n-\t]);\n-\n-\tt.end();\n-});"
      },
      {
        "sha": "0bd63d4d7dbdc4a639e13024647bd59119c0c604",
        "filename": "test/test.js",
        "status": "modified",
        "additions": 260,
        "deletions": 403,
        "changes": 663,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ftest.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -1,12 +1,11 @@\n 'use strict';\n-require('../lib/globals').options.color = false;\n+require('../lib/worker-options').set({color: false});\n \n const test = require('tap').test;\n const delay = require('delay');\n const Test = require('../lib/test');\n \n const failingTestHint = 'Test was expected to fail, but succeeded, you should stop marking the test as failing';\n-const noop = () => {};\n \n class ContextRef {\n \tconstructor() {\n@@ -20,274 +19,228 @@ class ContextRef {\n \t}\n }\n \n-function ava(fn, contextRef, onResult) {\n+function ava(fn, contextRef) {\n \treturn new Test({\n \t\tcontextRef: contextRef || new ContextRef(),\n \t\tfailWithoutAssertions: true,\n \t\tfn,\n \t\tmetadata: {type: 'test', callback: false},\n-\t\tonResult: onResult || noop,\n-\t\ttitle: '[anonymous]'\n+\t\ttitle: 'test'\n \t});\n }\n \n-ava.failing = (fn, contextRef, onResult) => {\n+ava.failing = (fn, contextRef) => {\n \treturn new Test({\n \t\tcontextRef: contextRef || new ContextRef(),\n \t\tfailWithoutAssertions: true,\n \t\tfn,\n \t\tmetadata: {type: 'test', callback: false, failing: true},\n-\t\tonResult: onResult || noop,\n-\t\ttitle: '[anonymous]'\n+\t\ttitle: 'test.failing'\n \t});\n };\n \n-ava.cb = (fn, contextRef, onResult) => {\n+ava.cb = (fn, contextRef) => {\n \treturn new Test({\n \t\tcontextRef: contextRef || new ContextRef(),\n \t\tfailWithoutAssertions: true,\n \t\tfn,\n \t\tmetadata: {type: 'test', callback: true},\n-\t\tonResult: onResult || noop,\n-\t\ttitle: '[anonymous]'\n+\t\ttitle: 'test.cb'\n \t});\n };\n \n-ava.cb.failing = (fn, contextRef, onResult) => {\n+ava.cb.failing = (fn, contextRef) => {\n \treturn new Test({\n \t\tcontextRef: contextRef || new ContextRef(),\n \t\tfailWithoutAssertions: true,\n \t\tfn,\n \t\tmetadata: {type: 'test', callback: true, failing: true},\n-\t\tonResult: onResult || noop,\n-\t\ttitle: '[anonymous]'\n+\t\ttitle: 'test.cb.failing'\n \t});\n };\n \n test('run test', t => {\n-\tconst passed = ava(a => {\n+\treturn ava(a => {\n \t\ta.fail();\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t});\n });\n \n test('multiple asserts', t => {\n-\tlet result;\n-\tconst passed = ava(a => {\n+\tconst instance = ava(a => {\n \t\ta.pass();\n \t\ta.pass();\n \t\ta.pass();\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, true);\n-\tt.is(result.result.assertCount, 3);\n-\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 3);\n+\t});\n });\n \n test('plan assertions', t => {\n-\tlet result;\n-\tconst passed = ava(a => {\n+\tconst instance = ava(a => {\n \t\ta.plan(2);\n \t\ta.pass();\n \t\ta.pass();\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\tt.is(passed, true);\n-\tt.is(result.result.planCount, 2);\n-\tt.is(result.result.assertCount, 2);\n-\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.planCount, 2);\n+\t\tt.is(instance.assertCount, 2);\n+\t});\n });\n \n test('run more assertions than planned', t => {\n-\tlet result;\n-\tconst passed = ava(a => {\n+\treturn ava(a => {\n \t\ta.plan(2);\n \t\ta.pass();\n \t\ta.pass();\n \t\ta.pass();\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.ok(result.reason);\n-\tt.match(result.reason.message, /Planned for 2 assertions, but got 3\\./);\n-\tt.is(result.reason.name, 'AssertionError');\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.ok(result.error);\n+\t\tt.match(result.error.message, /Planned for 2 assertions, but got 3\\./);\n+\t\tt.is(result.error.name, 'AssertionError');\n+\t});\n });\n \n test('fails if no assertions are run', t => {\n-\tlet result;\n-\tconst passed = ava(() => {}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.ok(result.reason);\n-\tt.is(result.reason.name, 'Error');\n-\tt.match(result.reason.message, /Test finished without running any assertions/);\n-\tt.end();\n+\treturn ava(() => {}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.ok(result.error);\n+\t\tt.is(result.error.name, 'Error');\n+\t\tt.match(result.error.message, /Test finished without running any assertions/);\n+\t});\n });\n \n test('fails if no assertions are run, unless so planned', t => {\n-\tconst passed = ava(a => a.plan(0)).run();\n-\tt.is(passed, true);\n-\tt.end();\n+\treturn ava(a => a.plan(0)).run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t});\n });\n \n test('fails if no assertions are run, unless an ended callback test', t => {\n-\tconst passed = ava.cb(a => a.end()).run();\n-\tt.is(passed, true);\n-\tt.end();\n+\treturn ava.cb(a => a.end()).run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t});\n });\n \n test('wrap non-assertion errors', t => {\n \tconst err = new Error();\n-\tlet result;\n-\tconst passed = ava(() => {\n+\treturn ava(() => {\n \t\tthrow err;\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.is(result.reason.message, 'Error thrown in test');\n-\tt.is(result.reason.name, 'AssertionError');\n-\tt.is(result.reason.values.length, 1);\n-\tt.is(result.reason.values[0].label, 'Error thrown in test:');\n-\tt.match(result.reason.values[0].formatted, /Error/);\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.message, 'Error thrown in test');\n+\t\tt.is(result.error.name, 'AssertionError');\n+\t\tt.is(result.error.values.length, 1);\n+\t\tt.is(result.error.values[0].label, 'Error thrown in test:');\n+\t\tt.match(result.error.values[0].formatted, /Error/);\n+\t});\n });\n \n test('end can be used as callback without maintaining thisArg', t => {\n-\tava.cb(a => {\n+\treturn ava.cb(a => {\n \t\ta.pass();\n \t\tsetTimeout(a.end);\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, true);\n \t});\n });\n \n test('end can be used as callback with error', t => {\n \tconst err = new Error('failed');\n-\tlet result;\n-\tconst passed = ava.cb(a => {\n+\treturn ava.cb(a => {\n \t\ta.end(err);\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.is(result.reason.message, 'Callback called with an error');\n-\tt.is(result.reason.name, 'AssertionError');\n-\tt.is(result.reason.values.length, 1);\n-\tt.is(result.reason.values[0].label, 'Callback called with an error:');\n-\tt.match(result.reason.values[0].formatted, /.*Error.*\\n.*message: 'failed'/);\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.message, 'Callback called with an error');\n+\t\tt.is(result.error.name, 'AssertionError');\n+\t\tt.is(result.error.values.length, 1);\n+\t\tt.is(result.error.values[0].label, 'Callback called with an error:');\n+\t\tt.match(result.error.values[0].formatted, /.*Error.*\\n.*message: 'failed'/);\n+\t});\n });\n \n test('end can be used as callback with a non-error as its error argument', t => {\n \tconst nonError = {foo: 'bar'};\n-\tlet result;\n-\tconst passed = ava.cb(a => {\n+\treturn ava.cb(a => {\n \t\ta.end(nonError);\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.ok(result.reason);\n-\tt.is(result.reason.message, 'Callback called with an error');\n-\tt.is(result.reason.name, 'AssertionError');\n-\tt.is(result.reason.values.length, 1);\n-\tt.is(result.reason.values[0].label, 'Callback called with an error:');\n-\tt.match(result.reason.values[0].formatted, /.*\\{.*\\n.*foo: 'bar'/);\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.ok(result.error);\n+\t\tt.is(result.error.message, 'Callback called with an error');\n+\t\tt.is(result.error.name, 'AssertionError');\n+\t\tt.is(result.error.values.length, 1);\n+\t\tt.is(result.error.values[0].label, 'Callback called with an error:');\n+\t\tt.match(result.error.values[0].formatted, /.*\\{.*\\n.*foo: 'bar'/);\n+\t});\n });\n \n test('title returns the test title', t => {\n \tt.plan(1);\n-\tnew Test({\n+\treturn new Test({\n \t\tfn(a) {\n \t\t\tt.is(a.title, 'foo');\n \t\t\ta.pass();\n \t\t},\n \t\tmetadata: {type: 'test', callback: false},\n-\t\tonResult: noop,\n \t\ttitle: 'foo'\n \t}).run();\n });\n \n test('handle non-assertion errors even when planned', t => {\n \tconst err = new Error('bar');\n-\tlet result;\n-\tconst passed = ava(a => {\n+\treturn ava(a => {\n \t\ta.plan(1);\n \t\tthrow err;\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.is(result.reason.name, 'AssertionError');\n-\tt.is(result.reason.message, 'Error thrown in test');\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n+\t\tt.is(result.error.message, 'Error thrown in test');\n+\t});\n });\n \n test('handle testing of arrays', t => {\n-\tlet result;\n-\tconst passed = ava(a => {\n+\tconst instance = ava(a => {\n \t\ta.deepEqual(['foo', 'bar'], ['foo', 'bar']);\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, true);\n-\tt.is(result.result.assertCount, 1);\n-\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n+\t});\n });\n \n test('handle falsy testing of arrays', t => {\n-\tlet result;\n-\tconst passed = ava(a => {\n+\tconst instance = ava(a => {\n \t\ta.notDeepEqual(['foo', 'bar'], ['foo', 'bar', 'cat']);\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, true);\n-\tt.is(result.result.assertCount, 1);\n-\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n+\t});\n });\n \n test('handle testing of objects', t => {\n-\tlet result;\n-\tconst passed = ava(a => {\n+\tconst instance = ava(a => {\n \t\ta.deepEqual({\n \t\t\tfoo: 'foo',\n \t\t\tbar: 'bar'\n \t\t}, {\n \t\t\tfoo: 'foo',\n \t\t\tbar: 'bar'\n \t\t});\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, true);\n-\tt.is(result.result.assertCount, 1);\n-\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n+\t});\n });\n \n test('handle falsy testing of objects', t => {\n-\tlet result;\n-\tconst passed = ava(a => {\n+\tconst instance = ava(a => {\n \t\ta.notDeepEqual({\n \t\t\tfoo: 'foo',\n \t\t\tbar: 'bar'\n@@ -296,245 +249,190 @@ test('handle falsy testing of objects', t => {\n \t\t\tbar: 'bar',\n \t\t\tcat: 'cake'\n \t\t});\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, true);\n-\tt.is(result.result.assertCount, 1);\n-\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n+\t});\n });\n \n test('planned async assertion', t => {\n-\tlet result;\n-\tava.cb(a => {\n+\tconst instance = ava.cb(a => {\n \t\ta.plan(1);\n \n \t\tsetTimeout(() => {\n \t\t\ta.pass();\n \t\t\ta.end();\n \t\t}, 100);\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.assertCount, 1);\n-\t\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n \t});\n });\n \n test('async assertion with `.end()`', t => {\n-\tlet result;\n-\tava.cb(a => {\n+\tconst instance = ava.cb(a => {\n \t\tsetTimeout(() => {\n \t\t\ta.pass();\n \t\t\ta.end();\n \t\t}, 100);\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.assertCount, 1);\n-\t\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.assertCount, 1);\n \t});\n });\n \n test('more assertions than planned should emit an assertion error', t => {\n-\tlet result;\n-\tconst passed = ava(a => {\n+\treturn ava(a => {\n \t\ta.plan(1);\n \t\ta.pass();\n \t\ta.pass();\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.is(result.reason.name, 'AssertionError');\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n+\t});\n });\n \n test('record test duration', t => {\n-\tlet result;\n-\tava.cb(a => {\n+\treturn ava.cb(a => {\n \t\ta.plan(1);\n \n \t\tsetTimeout(() => {\n \t\t\ta.true(true);\n \t\t\ta.end();\n \t\t}, 1234);\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.true(result.result.duration >= 1000);\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.true(result.duration >= 1000);\n \t});\n });\n \n test('wait for test to end', t => {\n-\tlet avaTest;\n-\n-\tlet result;\n-\tava.cb(a => {\n+\tconst instance = ava.cb(a => {\n \t\ta.plan(1);\n-\n-\t\tavaTest = a;\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.planCount, 1);\n-\t\tt.is(result.result.assertCount, 1);\n-\t\tt.true(result.result.duration >= 1000);\n-\t\tt.end();\n+\t\tsetTimeout(() => {\n+\t\t\ta.pass();\n+\t\t\ta.end();\n+\t\t}, 1234);\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.planCount, 1);\n+\t\tt.is(instance.assertCount, 1);\n+\t\tt.true(result.duration >= 1000);\n \t});\n-\n-\tsetTimeout(() => {\n-\t\tavaTest.pass();\n-\t\tavaTest.end();\n-\t}, 1234);\n });\n \n test('fails with the first assertError', t => {\n-\tlet result;\n-\tconst passed = ava(a => {\n+\treturn ava(a => {\n \t\ta.plan(2);\n \t\ta.is(1, 2);\n \t\ta.is(3, 4);\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.is(result.reason.name, 'AssertionError');\n-\tt.is(result.reason.values.length, 1);\n-\tt.is(result.reason.values[0].label, 'Difference:');\n-\tt.match(result.reason.values[0].formatted, /- 1\\n\\+ 2/);\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'AssertionError');\n+\t\tt.is(result.error.values.length, 1);\n+\t\tt.is(result.error.values[0].label, 'Difference:');\n+\t\tt.match(result.error.values[0].formatted, /- 1\\n\\+ 2/);\n+\t});\n });\n \n test('failing pending assertion causes test to fail, not promise rejection', t => {\n-\tlet result;\n \treturn ava(a => {\n-\t\treturn a.throws(Promise.resolve())\n-\t\t\t.then(() => {\n-\t\t\t\tthrow new Error('Should be ignored');\n-\t\t\t});\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.notMatch(result.reason.message, /Rejected promise returned by test/);\n+\t\treturn a.throws(Promise.resolve()).then(() => {\n+\t\t\tthrow new Error('Should be ignored');\n+\t\t});\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.notMatch(result.error.message, /Rejected promise returned by test/);\n \t});\n });\n \n test('fails with thrown falsy value', t => {\n-\tlet result;\n-\tconst passed = ava(() => {\n+\treturn ava(() => {\n \t\tthrow 0; // eslint-disable-line no-throw-literal\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.is(result.reason.message, 'Error thrown in test');\n-\tt.is(result.reason.name, 'AssertionError');\n-\tt.is(result.reason.values.length, 1);\n-\tt.is(result.reason.values[0].label, 'Error thrown in test:');\n-\tt.match(result.reason.values[0].formatted, /0/);\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.message, 'Error thrown in test');\n+\t\tt.is(result.error.name, 'AssertionError');\n+\t\tt.is(result.error.values.length, 1);\n+\t\tt.is(result.error.values[0].label, 'Error thrown in test:');\n+\t\tt.match(result.error.values[0].formatted, /0/);\n+\t});\n });\n \n test('fails with thrown non-error object', t => {\n \tconst obj = {foo: 'bar'};\n-\tlet result;\n-\tconst passed = ava(() => {\n+\treturn ava(() => {\n \t\tthrow obj;\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.is(result.reason.message, 'Error thrown in test');\n-\tt.is(result.reason.name, 'AssertionError');\n-\tt.is(result.reason.values.length, 1);\n-\tt.is(result.reason.values[0].label, 'Error thrown in test:');\n-\tt.match(result.reason.values[0].formatted, /.*\\{.*\\n.*foo: 'bar'/);\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.message, 'Error thrown in test');\n+\t\tt.is(result.error.name, 'AssertionError');\n+\t\tt.is(result.error.values.length, 1);\n+\t\tt.is(result.error.values[0].label, 'Error thrown in test:');\n+\t\tt.match(result.error.values[0].formatted, /.*\\{.*\\n.*foo: 'bar'/);\n+\t});\n });\n \n test('skipped assertions count towards the plan', t => {\n-\tlet result;\n-\tconst passed = ava(a => {\n+\tconst instance = ava(a => {\n \t\ta.plan(2);\n \t\ta.pass();\n \t\ta.skip.fail();\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, true);\n-\tt.is(result.result.planCount, 2);\n-\tt.is(result.result.assertCount, 2);\n-\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.planCount, 2);\n+\t\tt.is(instance.assertCount, 2);\n+\t});\n });\n \n test('throws and notThrows work with promises', t => {\n \tlet asyncCalled = false;\n-\tlet result;\n-\tava(a => {\n+\tconst instance = ava(a => {\n \t\ta.plan(2);\n \t\treturn Promise.all([\n \t\t\ta.throws(delay.reject(10, new Error('foo')), 'foo'),\n \t\t\ta.notThrows(delay(20).then(() => {\n \t\t\t\tasyncCalled = true;\n \t\t\t}))\n \t\t]);\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.planCount, 2);\n-\t\tt.is(result.result.assertCount, 2);\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.planCount, 2);\n+\t\tt.is(instance.assertCount, 2);\n \t\tt.is(asyncCalled, true);\n-\t\tt.end();\n \t});\n });\n \n test('end should not be called multiple times', t => {\n-\tlet result;\n-\tconst passed = ava.cb(a => {\n+\treturn ava.cb(a => {\n \t\ta.pass();\n \t\ta.end();\n \t\ta.end();\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.is(result.reason.message, '`t.end()` called more than once');\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.message, '`t.end()` called more than once');\n+\t});\n });\n \n test('cb test that throws sync', t => {\n-\tlet result;\n \tconst err = new Error('foo');\n-\tconst passed = ava.cb(() => {\n+\treturn ava.cb(() => {\n \t\tthrow err;\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.is(result.reason.message, 'Error thrown in test');\n-\tt.is(result.reason.name, 'AssertionError');\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.message, 'Error thrown in test');\n+\t\tt.is(result.error.name, 'AssertionError');\n+\t});\n });\n \n test('multiple resolving and rejecting promises passed to t.throws/t.notThrows', t => {\n-\tlet result;\n-\tava(a => {\n+\tconst instance = ava(a => {\n \t\ta.plan(6);\n \t\tconst promises = [];\n \t\tfor (let i = 0; i < 3; i++) {\n@@ -544,57 +442,43 @@ test('multiple resolving and rejecting promises passed to t.throws/t.notThrows',\n \t\t\t);\n \t\t}\n \t\treturn Promise.all(promises);\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.is(result.result.planCount, 6);\n-\t\tt.is(result.result.assertCount, 6);\n-\t\tt.end();\n+\t});\n+\treturn instance.run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t\tt.is(instance.planCount, 6);\n+\t\tt.is(instance.assertCount, 6);\n \t});\n });\n \n test('fails if test ends while there are pending assertions', t => {\n-\tlet result;\n-\tconst passed = ava(a => {\n+\treturn ava(a => {\n \t\ta.throws(Promise.reject(new Error()));\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.is(result.reason.name, 'Error');\n-\tt.match(result.reason.message, /Test finished, but an assertion is still pending/);\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'Error');\n+\t\tt.match(result.error.message, /Test finished, but an assertion is still pending/);\n+\t});\n });\n \n test('fails if callback test ends while there are pending assertions', t => {\n-\tlet result;\n-\tconst passed = ava.cb(a => {\n+\treturn ava.cb(a => {\n \t\ta.throws(Promise.reject(new Error()));\n \t\ta.end();\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.is(result.reason.name, 'Error');\n-\tt.match(result.reason.message, /Test finished, but an assertion is still pending/);\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'Error');\n+\t\tt.match(result.error.message, /Test finished, but an assertion is still pending/);\n+\t});\n });\n \n test('fails if async test ends while there are pending assertions', t => {\n-\tlet result;\n-\tava(a => {\n+\treturn ava(a => {\n \t\ta.throws(Promise.reject(new Error()));\n \t\treturn Promise.resolve();\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.name, 'Error');\n-\t\tt.match(result.reason.message, /Test finished, but an assertion is still pending/);\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.name, 'Error');\n+\t\tt.match(result.error.message, /Test finished, but an assertion is still pending/);\n \t});\n });\n \n@@ -645,117 +529,90 @@ test('contextRef', t => {\n });\n \n test('failing tests should fail', t => {\n-\tconst passed = ava.failing('foo', a => {\n+\treturn ava.failing('foo', a => {\n \t\ta.fail();\n-\t}).run();\n-\n-\tt.is(passed, true);\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t});\n });\n \n test('failing callback tests should end without error', t => {\n \tconst err = new Error('failed');\n-\tconst passed = ava.cb.failing(a => {\n+\treturn ava.cb.failing(a => {\n \t\ta.end(err);\n-\t}).run();\n-\n-\tt.is(passed, true);\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, true);\n+\t});\n });\n \n test('failing tests must not pass', t => {\n-\tlet result;\n-\tconst passed = ava.failing(a => {\n+\treturn ava.failing(a => {\n \t\ta.pass();\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.is(result.reason.message, failingTestHint);\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.message, failingTestHint);\n+\t});\n });\n \n test('failing callback tests must not pass', t => {\n-\tconst passed = ava.cb.failing(a => {\n+\treturn ava.cb.failing(a => {\n \t\ta.pass();\n \t\ta.end();\n-\t}).run();\n-\n-\tt.is(passed, false);\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t});\n });\n \n test('failing tests must not return a fulfilled promise', t => {\n-\tlet result;\n-\tava.failing(a => {\n-\t\treturn Promise.resolve()\n-\t\t\t.then(() => {\n-\t\t\t\ta.pass();\n-\t\t\t});\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.message, failingTestHint);\n-\t\tt.end();\n+\treturn ava.failing(a => {\n+\t\treturn Promise.resolve().then(() => a.pass());\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.message, failingTestHint);\n \t});\n });\n \n test('failing tests pass when returning a rejected promise', t => {\n-\tava.failing(a => {\n+\treturn ava.failing(a => {\n \t\ta.plan(1);\n-\t\treturn a.notThrows(delay(10), 'foo')\n-\t\t\t.then(() => Promise.reject());\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.end();\n+\t\treturn a.notThrows(delay(10), 'foo').then(() => Promise.reject());\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, true);\n \t});\n });\n \n test('failing tests pass with `t.throws(nonThrowingPromise)`', t => {\n-\tava.failing(a => {\n+\treturn ava.failing(a => {\n \t\treturn a.throws(Promise.resolve(10));\n-\t}).run().then(passed => {\n-\t\tt.is(passed, true);\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, true);\n \t});\n });\n \n test('failing tests fail with `t.notThrows(throws)`', t => {\n-\tlet result;\n-\tava.failing(a => {\n+\treturn ava.failing(a => {\n \t\treturn a.notThrows(Promise.resolve('foo'));\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run().then(passed => {\n-\t\tt.is(passed, false);\n-\t\tt.is(result.reason.message, failingTestHint);\n-\t\tt.end();\n+\t}).run().then(result => {\n+\t\tt.is(result.passed, false);\n+\t\tt.is(result.error.message, failingTestHint);\n \t});\n });\n \n test('log from tests', t => {\n-\tlet result;\n-\n-\tava(a => {\n+\treturn ava(a => {\n \t\ta.log('a log message from a test');\n \t\tt.true(true);\n \t\ta.log('another log message from a test');\n \t\ta.log({b: 1, c: {d: 2}}, 'complex log', 5, 5.1);\n \t\ta.log();\n-\t}, null, r => {\n-\t\tresult = r;\n-\t}).run();\n-\n-\tt.deepEqual(\n-\t\tresult.result.logs,\n-\t\t[\n-\t\t\t'a log message from a test',\n-\t\t\t'another log message from a test',\n-\t\t\t'{\\n  b: 1,\\n  c: {\\n    d: 2,\\n  },\\n} complex log 5 5.1'\n-\t\t]\n-\t);\n-\n-\tt.end();\n+\t}).run().then(result => {\n+\t\tt.deepEqual(\n+\t\t\tresult.logs,\n+\t\t\t[\n+\t\t\t\t'a log message from a test',\n+\t\t\t\t'another log message from a test',\n+\t\t\t\t'{\\n  b: 1,\\n  c: {\\n    d: 2,\\n  },\\n} complex log 5 5.1'\n+\t\t\t]\n+\t\t);\n+\t});\n });"
      },
      {
        "sha": "7b3ae388bfbec41e92e826a9a83681b6db548271",
        "filename": "test/watcher.js",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Fwatcher.js",
        "raw_url": "https://github.com/avajs/ava/raw/788ec7fe2b98118ecd544213d3d67c6e144c6da5/test%2Fwatcher.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fwatcher.js?ref=788ec7fe2b98118ecd544213d3d67c6e144c6da5",
        "patch": "@@ -10,7 +10,7 @@ const sinon = require('sinon');\n const test = require('tap').test;\n const AvaFiles = require('../lib/ava-files');\n \n-const setImmediate = require('../lib/globals').setImmediate;\n+const setImmediate = require('../lib/now-and-timers').setImmediate;\n \n // Helper to make using beforeEach less arduous\n function makeGroup(test) {"
      }
    ]
  },
  {
    "url": "https://api.github.com/repos/avajs/ava/issues/1670",
    "repository_url": "https://api.github.com/repos/avajs/ava",
    "labels_url": "https://api.github.com/repos/avajs/ava/issues/1670/labels{/name}",
    "comments_url": "https://api.github.com/repos/avajs/ava/issues/1670/comments",
    "events_url": "https://api.github.com/repos/avajs/ava/issues/1670/events",
    "html_url": "https://github.com/avajs/ava/pull/1670",
    "id": 292506397,
    "node_id": "MDExOlB1bGxSZXF1ZXN0MTY1Nzc3NjYx",
    "number": 1670,
    "title": "Restrict modifier chaining",
    "user": {
      "login": "novemberborn",
      "id": 33538,
      "node_id": "MDQ6VXNlcjMzNTM4",
      "avatar_url": "https://avatars.githubusercontent.com/u/33538?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/novemberborn",
      "html_url": "https://github.com/novemberborn",
      "followers_url": "https://api.github.com/users/novemberborn/followers",
      "following_url": "https://api.github.com/users/novemberborn/following{/other_user}",
      "gists_url": "https://api.github.com/users/novemberborn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/novemberborn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/novemberborn/subscriptions",
      "organizations_url": "https://api.github.com/users/novemberborn/orgs",
      "repos_url": "https://api.github.com/users/novemberborn/repos",
      "events_url": "https://api.github.com/users/novemberborn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/novemberborn/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/avajs/ava/milestones/2",
      "html_url": "https://github.com/avajs/ava/milestone/2",
      "labels_url": "https://api.github.com/repos/avajs/ava/milestones/2/labels",
      "id": 3036701,
      "node_id": "MDk6TWlsZXN0b25lMzAzNjcwMQ==",
      "number": 2,
      "title": "1.0",
      "description": "",
      "creator": {
        "login": "novemberborn",
        "id": 33538,
        "node_id": "MDQ6VXNlcjMzNTM4",
        "avatar_url": "https://avatars.githubusercontent.com/u/33538?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/novemberborn",
        "html_url": "https://github.com/novemberborn",
        "followers_url": "https://api.github.com/users/novemberborn/followers",
        "following_url": "https://api.github.com/users/novemberborn/following{/other_user}",
        "gists_url": "https://api.github.com/users/novemberborn/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/novemberborn/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/novemberborn/subscriptions",
        "organizations_url": "https://api.github.com/users/novemberborn/orgs",
        "repos_url": "https://api.github.com/users/novemberborn/repos",
        "events_url": "https://api.github.com/users/novemberborn/events{/privacy}",
        "received_events_url": "https://api.github.com/users/novemberborn/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 0,
      "closed_issues": 40,
      "state": "closed",
      "created_at": "2018-01-15T16:32:53Z",
      "updated_at": "2019-01-27T17:16:24Z",
      "due_on": null,
      "closed_at": "2019-01-27T17:16:24Z"
    },
    "comments": 5,
    "created_at": "2018-01-29T18:08:57Z",
    "updated_at": "2018-02-04T18:06:31Z",
    "closed_at": "2018-02-04T17:57:21Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "draft": false,
    "pull_request": {
      "url": "https://api.github.com/repos/avajs/ava/pulls/1670",
      "html_url": "https://github.com/avajs/ava/pull/1670",
      "diff_url": "https://github.com/avajs/ava/pull/1670.diff",
      "patch_url": "https://github.com/avajs/ava/pull/1670.patch",
      "merged_at": "2018-02-04T17:57:21Z"
    },
    "body": "Explicitly specify allowable chains, with some ground rules in mind:\r\n\r\nTest chaining rules:\r\n\r\n* `serial` must come at the start\r\n* `only` and `skip` must come at the end\r\n* `failing` must come at the end, but can be followed by `only` and `skip`\r\n* `only` and `skip` cannot be chained together\r\n* no repeating\r\n\r\nHook chaining rules:\r\n\r\n* `always` comes immediately after \"after hooks\"\r\n* `skip` must come at the end\r\n* no `only`\r\n* no repeating\r\n\r\nAdditionally:\r\n\r\n* `todo` cannot be chained, except after `serial`\r\n* hooks are not available on `serial`\r\n\r\nThis commit also removes now unnecessary assertions from TestCollection.\r\n\r\nFixes #1182.\r\n\r\n---\r\n\r\nThis allows the TypeScript definition to be simplified. I've done an initial refactor. Note that I've not included any JSDoc comments. I think we can do a lot better than we what we had before but I didn't want to sort that out just yet. Will open a follow-up ticket. I have fixed `throws` / `notThrows` taking observables. Would be nice to get a better type definition for `Observable` though. Will ask more explicitly in a follow-up ticket.\r\n\r\n* [x] Create issue for `Observable` typing in TS and Flow\r\n* [x] Create issue for embedding documentation in the TS and Flow definitions\r\n* [x] Create issue in `eslint-plugin-ava` to check chains when linting",
    "reactions": {
      "url": "https://api.github.com/repos/avajs/ava/issues/1670/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/avajs/ava/issues/1670/timeline",
    "performed_via_github_app": null,
    "state_reason": null,
    "score": 1,
    "files": [
      {
        "sha": "7c2189e2ffc022924980ea39afe3048ad132c90a",
        "filename": "docs/recipes/flow.md",
        "status": "added",
        "additions": 83,
        "deletions": 0,
        "changes": 83,
        "blob_url": "https://github.com/avajs/ava/blob/d07fb0c5444318d27026d2c58bc511cba558a6a5/docs%2Frecipes%2Fflow.md",
        "raw_url": "https://github.com/avajs/ava/raw/d07fb0c5444318d27026d2c58bc511cba558a6a5/docs%2Frecipes%2Fflow.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/docs%2Frecipes%2Fflow.md?ref=d07fb0c5444318d27026d2c58bc511cba558a6a5",
        "patch": "@@ -0,0 +1,83 @@\n+# Flow\n+\n+AVA comes bundled with a Flow definition file. This allows developers to leverage Flow for writing tests.\n+\n+This guide assumes you've already set up Flow for your project. Note that AVA's definition as been tested with version 0.64.\n+\n+We recommend you use AVA's built-in Babel pipeline to strip Flow type annotations and declarations. AVA automatically applies your project's Babel configuration, so everything may just work without changes. Alternatively install [`@babel/plugin-transform-flow-strip-types`](https://www.npmjs.com/package/@babel/plugin-transform-flow-strip-types) and customize AVA's configuration in the `package.json` file as follows:\n+\n+```json\n+{\n+\t\"ava\": {\n+\t\t\"babel\": {\n+\t\t\t\"testOptions\": {\n+\t\t\t\t\"plugins\": [\"@babel/plugin-transform-flow-strip-types\"]\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+```\n+\n+See our [Babel documentation](babel.md) for more details.\n+\n+## Writing tests\n+\n+Create a `test.js` file.\n+\n+```js\n+// @flow\n+import test from 'ava';\n+\n+const fn = async () => Promise.resolve('foo');\n+\n+test(async (t) => {\n+\tt.is(await fn(), 'foo');\n+});\n+```\n+\n+## Typing [`t.context`](https://github.com/avajs/ava#test-context)\n+\n+By default, the type of `t.context` will be the empty object (`{}`). AVA exposes an interface `TestInterface<Context>` which you can use to apply your own type to `t.context`. This can help you catch errors at compile-time:\n+\n+```js\n+// @flow\n+import anyTest from 'ava';\n+import type {TestInterface} from 'ava';\n+\n+const test: TestInterface<{foo: string}> = (anyTest: any);\n+\n+test.beforeEach(t => {\n+\tt.context = {foo: 'bar'};\n+});\n+\n+test.beforeEach(t => {\n+\tt.context.foo = 123; // error:  Type '123' is not assignable to type 'string'\n+});\n+\n+test.serial.cb.failing('very long chains are properly typed', t => {\n+\tt.context.fooo = 'a value'; // error: Property 'fooo' does not exist on type ''\n+});\n+\n+test('an actual test', t => {\n+\tt.deepEqual(t.context.foo.map(c => c), ['b', 'a', 'r']); // error: Property 'map' does not exist on type 'string'\n+});\n+```\n+\n+Note that, despite the type cast above, when executing `t.context` is an empty object unless it's assigned.\n+\n+## Using `t.throws()` and `t.notThrows()`\n+\n+The `t.throws()` and `t.noThrows()` assertions can be called with a function that returns an observable or a promise. You may have to explicitly type functions:\n+\n+```ts\n+import test from 'ava';\n+\n+test('just throws', async t => {\n+\tconst expected = new Error();\n+\tconst err = t.throws((): void => { throw expected; });\n+\tt.is(err, expected);\n+\n+\tconst err2 = await t.throws((): Promise<*> => Promise.reject(expected));\n+\tt.is(err2, expected);\n+});\n+```"
      },
      {
        "sha": "f41b900926858c35219fc8e6a317a98708e082b8",
        "filename": "docs/recipes/typescript.md",
        "status": "modified",
        "additions": 51,
        "deletions": 44,
        "changes": 95,
        "blob_url": "https://github.com/avajs/ava/blob/d07fb0c5444318d27026d2c58bc511cba558a6a5/docs%2Frecipes%2Ftypescript.md",
        "raw_url": "https://github.com/avajs/ava/raw/d07fb0c5444318d27026d2c58bc511cba558a6a5/docs%2Frecipes%2Ftypescript.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/docs%2Frecipes%2Ftypescript.md?ref=d07fb0c5444318d27026d2c58bc511cba558a6a5",
        "patch": "@@ -4,26 +4,7 @@ Translations: [Español](https://github.com/avajs/ava-docs/blob/master/es_ES/doc\n \n AVA comes bundled with a TypeScript definition file. This allows developers to leverage TypeScript for writing tests.\n \n-\n-## Setup\n-\n-First install [TypeScript](https://github.com/Microsoft/TypeScript) (if you already have it installed, make sure you use version 2.1 or greater).\n-\n-```\n-$ npm install --save-dev typescript\n-```\n-\n-Create a [`tsconfig.json`](http://www.typescriptlang.org/docs/handbook/tsconfig-json.html) file. This file specifies the compiler options required to compile the project or the test file.\n-\n-```json\n-{\n-\t\"compilerOptions\": {\n-\t\t\"module\": \"commonjs\",\n-\t\t\"target\": \"es2015\",\n-\t\t\"sourceMap\": true\n-\t}\n-}\n-```\n+This guide assumes you've already set up TypeScript for your project. Note that AVA's definition has been tested with version 2.7.1.\n \n Add a `test` script in the `package.json` file. It will compile the project first and then run AVA.\n \n@@ -35,8 +16,9 @@ Add a `test` script in the `package.json` file. It will compile the project firs\n }\n ```\n \n+Make sure that AVA runs your built TypeScript files.\n \n-## Add tests\n+## Writing tests\n \n Create a `test.ts` file.\n \n@@ -50,57 +32,82 @@ test(async (t) => {\n });\n ```\n \n-## Working with [macros](https://github.com/avajs/ava#test-macros)\n+## Using [macros](https://github.com/avajs/ava#test-macros)\n \n-In order to be able to assign the `title` property to a macro:\n+In order to be able to assign the `title` property to a macro you need to type the function:\n \n ```ts\n-import test, { AssertContext, Macro } from 'ava';\n+import test, {Macro} from 'ava';\n \n-const macro: Macro<AssertContext> = (t, input, expected) => {\n+const macro: Macro = (t, input: string, expected: number) => {\n \tt.is(eval(input), expected);\n-}\n-\n-macro.title = (providedTitle, input, expected) => `${providedTitle} ${input} = ${expected}`.trim();\n+};\n+macro.title = (providedTitle: string, input: string, expected: number) => `${providedTitle} ${input} = ${expected}`.trim();\n \n test(macro, '2 + 2', 4);\n test(macro, '2 * 3', 6);\n test('providedTitle', macro, '3 * 3', 9);\n ```\n \n-## Working with [`context`](https://github.com/avajs/ava#test-context)\n-\n-By default, the type of `t.context` will be [`any`](https://www.typescriptlang.org/docs/handbook/basic-types.html#any). AVA exposes an interface `RegisterContextual<T>` which you can use to apply your own type to `t.context`. This can help you catch errors at compile-time:\n+You'll need a different type if you're expecting your macro to be used with a callback test:\n \n ```ts\n-import * as ava from 'ava';\n+import test, {CbMacro} from 'ava';\n \n-function contextualize<T>(getContext: () => T): ava.RegisterContextual<T> {\n-\tava.test.beforeEach(t => {\n-\t\tObject.assign(t.context, getContext());\n-\t});\n+const macro: CbMacro = t => {\n+\tt.pass();\n+\tsetTimeout(t.end, 100);\n+};\n \n-\treturn ava.test;\n-}\n+test.cb(macro);\n+```\n \n-const test = contextualize(() => ({ foo: 'bar' }));\n+## Typing [`t.context`](https://github.com/avajs/ava#test-context)\n+\n+By default, the type of `t.context` will be the empty object (`{}`). AVA exposes an interface `TestInterface<Context>` which you can use to apply your own type to `t.context`. This can help you catch errors at compile-time:\n+\n+```ts\n+import anyTest, {TestInterface} from 'ava';\n+\n+const test: TestInterface<{foo: string}> = anyTest;\n+\n+test.beforeEach(t => {\n+\tt.context = {foo: 'bar'};\n+});\n \n test.beforeEach(t => {\n \tt.context.foo = 123; // error:  Type '123' is not assignable to type 'string'\n });\n \n-test.after.always.failing.cb.serial('very long chains are properly typed', t => {\n-\tt.context.fooo = 'a value'; // error: Property 'fooo' does not exist on type '{ foo: string }'\n+test.serial.cb.failing('very long chains are properly typed', t => {\n+\tt.context.fooo = 'a value'; // error: Property 'fooo' does not exist on type ''\n });\n \n test('an actual test', t => {\n \tt.deepEqual(t.context.foo.map(c => c), ['b', 'a', 'r']); // error: Property 'map' does not exist on type 'string'\n });\n ```\n \n+You can also type the context when creating macros:\n \n-## Execute the tests\n+```ts\n+import anyTest, {Macro, TestInterface} from 'ava';\n \n+interface Context {\n+\tfoo: string\n+}\n+\n+const test: TestInterface<Context> = anyTest;\n+\n+const macro: Macro<Context> = (t, expected: string) => {\n+\tt.is(t.context.foo, expected);\n+};\n+\n+test.beforeEach(t => {\n+\tt.context = {foo: 'bar'};\n+});\n+\n+test('foo is bar', macro, 'bar');\n ```\n-$ npm test\n-```\n+\n+Note that, despite the type cast above, when executing `t.context` is an empty object unless it's assigned."
      },
      {
        "sha": "1d43ec91b94c0648e498e025cb7835745df0ba0c",
        "filename": "index.d.ts",
        "status": "added",
        "additions": 199,
        "deletions": 0,
        "changes": 199,
        "blob_url": "https://github.com/avajs/ava/blob/d07fb0c5444318d27026d2c58bc511cba558a6a5/index.d.ts",
        "raw_url": "https://github.com/avajs/ava/raw/d07fb0c5444318d27026d2c58bc511cba558a6a5/index.d.ts",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/index.d.ts?ref=d07fb0c5444318d27026d2c58bc511cba558a6a5",
        "patch": "@@ -0,0 +1,199 @@\n+export interface ObservableLike {\n+\tsubscribe(observer: (value: any) => void): void;\n+}\n+\n+export type ThrowsErrorValidator = (new (...args: Array<any>) => any) | RegExp | string | ((error: any) => boolean);\n+\n+export interface SnapshotOptions {\n+\tid?: string;\n+}\n+\n+export interface Assertions {\n+\tdeepEqual<ValueType = any>(actual: ValueType, expected: ValueType, message?: string): void;\n+\tfail(message?: string): void;\n+\tfalse(actual: any, message?: string): void;\n+\tfalsy(actual: any, message?: string): void;\n+\tifError(error: any, message?: string): void;\n+\tis<ValueType = any>(actual: ValueType, expected: ValueType, message?: string): void;\n+\tnot<ValueType = any>(actual: ValueType, expected: ValueType, message?: string): void;\n+\tnotDeepEqual<ValueType = any>(actual: ValueType, expected: ValueType, message?: string): void;\n+\tnotRegex(string: string, regex: RegExp, message?: string): void;\n+\tnotThrows(value: () => never, message?: string): void;\n+\tnotThrows(value: () => ObservableLike, message?: string): Promise<void>;\n+\tnotThrows(value: () => PromiseLike<any>, message?: string): Promise<void>;\n+\tnotThrows(value: () => any, message?: string): void;\n+\tnotThrows(value: ObservableLike, message?: string): Promise<void>;\n+\tnotThrows(value: PromiseLike<any>, message?: string): Promise<void>;\n+\tpass(message?: string): void;\n+\tregex(string: string, regex: RegExp, message?: string): void;\n+\tsnapshot(expected: any, message?: string): void;\n+\tsnapshot(expected: any, options: SnapshotOptions, message?: string): void;\n+\tthrows(value: () => never, error?: ThrowsErrorValidator, message?: string): any;\n+\tthrows(value: () => ObservableLike, error?: ThrowsErrorValidator, message?: string): Promise<any>;\n+\tthrows(value: () => PromiseLike<any>, error?: ThrowsErrorValidator, message?: string): Promise<any>;\n+\tthrows(value: () => any, error?: ThrowsErrorValidator, message?: string): any;\n+\tthrows(value: ObservableLike, error?: ThrowsErrorValidator, message?: string): Promise<any>;\n+\tthrows(value: PromiseLike<any>, error?: ThrowsErrorValidator, message?: string): Promise<any>;\n+\ttrue(actual: any, message?: string): void;\n+\ttruthy(actual: any, message?: string): void;\n+}\n+\n+export interface ExecutionContext<Context = {}> extends Assertions {\n+\tcontext: Context;\n+\tskip: Assertions;\n+\ttitle: string;\n+\tlog(...values: Array<any>): void;\n+\tplan(count: number): void;\n+}\n+\n+export interface CbExecutionContext<Context = {}> extends ExecutionContext<Context> {\n+\tend(): void;\n+}\n+\n+export type ImplementationResult = PromiseLike<void> | ObservableLike | Iterator<any> | void;\n+export type Implementation<Context = {}> = (t: ExecutionContext<Context>) => ImplementationResult;\n+export type CbImplementation<Context = {}> = (t: CbExecutionContext<Context>) => ImplementationResult;\n+\n+export interface Macro<Context = {}> {\n+\t(t: ExecutionContext<Context>, ...args: Array<any>): ImplementationResult;\n+\ttitle?: (providedTitle: string, ...args: Array<any>) => string;\n+}\n+\n+export interface CbMacro<Context = {}> {\n+\t(t: CbExecutionContext<Context>, ...args: Array<any>): ImplementationResult;\n+\ttitle?: (providedTitle: string, ...args: Array<any>) => string;\n+}\n+\n+export interface TestInterface<Context = {}> {\n+\t(title: string, implementation: Implementation<Context>): void;\n+\t(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\t(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\n+\tafter: AfterInterface<null>;\n+\tafterEach: AfterInterface<Context>;\n+\tbefore: BeforeInterface<null>;\n+\tbeforeEach: BeforeInterface<Context>;\n+\tcb: CbInterface<Context>;\n+\tfailing: FailingInterface<Context>;\n+\tonly: OnlyInterface<Context>;\n+\tserial: SerialInterface<Context>;\n+\tskip: SkipInterface<Context>;\n+\ttodo: TodoDeclaration;\n+}\n+\n+export interface AfterInterface<Context = {}> {\n+\t(title: string, implementation: Implementation<Context>): void;\n+\t(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\t(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\n+\talways: AlwaysInterface<Context>;\n+\tcb: HookCbInterface<Context>;\n+\tskip: SkipInterface<Context>;\n+}\n+\n+export interface AlwaysInterface<Context = {}> {\n+\t(title: string, implementation: Implementation<Context>): void;\n+\t(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\t(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\n+\tcb: HookCbInterface<Context>;\n+\tskip: SkipInterface<Context>;\n+}\n+\n+export interface BeforeInterface<Context = {}> {\n+\t(title: string, implementation: Implementation<Context>): void;\n+\t(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\t(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\n+\tcb: HookCbInterface<Context>;\n+\tskip: SkipInterface<Context>;\n+}\n+\n+export interface CbInterface<Context = {}> {\n+\t(title: string, implementation: CbImplementation<Context>): void;\n+\t(title: string, macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+\t(macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+\n+\tfailing: CbFailingInterface<Context>;\n+\tonly: CbOnlyInterface<Context>;\n+\tskip: CbSkipInterface<Context>;\n+}\n+\n+export interface CbFailingInterface<Context = {}> {\n+\t(title: string, implementation: CbImplementation<Context>): void;\n+\t(title: string, macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+\t(macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+\n+\tonly: CbOnlyInterface<Context>;\n+\tskip: CbSkipInterface<Context>;\n+}\n+\n+export interface CbOnlyInterface<Context = {}> {\n+\t(title: string, implementation: CbImplementation<Context>): void;\n+\t(title: string, macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+\t(macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+}\n+\n+export interface CbSkipInterface<Context = {}> {\n+\t(title: string, implementation: CbImplementation<Context>): void;\n+\t(title: string, macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+\t(macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+}\n+\n+export interface FailingInterface<Context = {}> {\n+\t(title: string, implementation: Implementation<Context>): void;\n+\t(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\t(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\n+\tonly: OnlyInterface<Context>;\n+\tskip: SkipInterface<Context>;\n+}\n+\n+export interface HookCbInterface<Context = {}> {\n+\t(title: string, implementation: CbImplementation<Context>): void;\n+\t(title: string, macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+\t(macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+\n+\tskip: CbSkipInterface<Context>;\n+}\n+\n+export interface OnlyInterface<Context = {}> {\n+\t(title: string, implementation: Implementation<Context>): void;\n+\t(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\t(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+}\n+\n+export interface SerialInterface<Context = {}> {\n+\t(title: string, implementation: Implementation<Context>): void;\n+\t(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\t(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\n+\tcb: CbInterface<Context>;\n+\tfailing: FailingInterface<Context>;\n+\tonly: OnlyInterface<Context>;\n+\tskip: SkipInterface<Context>;\n+\ttodo: TodoDeclaration;\n+}\n+\n+export interface SkipInterface<Context = {}> {\n+\t(title: string, implementation: Implementation<Context>): void;\n+\t(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\t(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+}\n+\n+export type TodoDeclaration = (title: string) => void;\n+\n+declare const test: TestInterface;\n+export default test;\n+\n+export {test};\n+export const after: AfterInterface<null>;\n+export const afterEach: AfterInterface;\n+export const before: BeforeInterface<null>;\n+export const beforeEach: BeforeInterface;\n+export const cb: CbInterface;\n+export const failing: FailingInterface;\n+export const only: OnlyInterface;\n+export const serial: SerialInterface;\n+export const skip: SkipInterface;\n+export const todo: TodoDeclaration;"
      },
      {
        "sha": "118307b294c518e9522cf3798d0cc986c97ab4cd",
        "filename": "index.js.flow",
        "status": "modified",
        "additions": 188,
        "deletions": 153,
        "changes": 341,
        "blob_url": "https://github.com/avajs/ava/blob/d07fb0c5444318d27026d2c58bc511cba558a6a5/index.js.flow",
        "raw_url": "https://github.com/avajs/ava/raw/d07fb0c5444318d27026d2c58bc511cba558a6a5/index.js.flow",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/index.js.flow?ref=d07fb0c5444318d27026d2c58bc511cba558a6a5",
        "patch": "@@ -1,166 +1,201 @@\n-/* @flow */\n-\n-/**\n- * Misc Setup Types\n- */\n-\n-type PromiseLike<R> = {\n-\tthen<U>(\n-\t\tonFulfill?: (value: R) => Promise<U> | U,\n-\t\tonReject?: (error: any) => Promise<U> | U\n-\t): Promise<U>;\n+// @flow\n+export interface PromiseLike<R> {\n+\tthen<U>(onFulfill?: (value: R) => Promise<U> | U, onReject?: (error: any) => Promise<U> | U): Promise<U>;\n }\n \n-type ObservableLike = {\n-\tsubscribe(observer: (value: {}) => void): void;\n-};\n-\n-type SpecialReturnTypes =\n-\t| PromiseLike<any>\n-\t| Iterator<any>\n-\t| ObservableLike;\n-\n-type Constructor = Class<{\n-\tconstructor(...args: Array<any>): any\n-}>;\n+export interface ObservableLike {\n+\tsubscribe(observer: (value: any) => void): void;\n+}\n \n-type ErrorValidator =\n-\t| Constructor\n-\t| RegExp\n-\t| string\n-\t| ((error: any) => boolean);\n+export type ThrowsErrorValidator = Class<{constructor(...args: Array<any>): any}> | RegExp | string | ((error: any) => boolean);\n \n-/**\n- * Assertion Types\n- */\n+export interface SnapshotOptions {\n+\tid?: string;\n+}\n \n-type AssertContext = {\n-\t// Passing assertion.\n-\tpass(message?: string): void;\n-\t// Failing assertion.\n+export interface Assertions {\n+\tdeepEqual(actual: any, expected: any, message?: string): void;\n \tfail(message?: string): void;\n-\t// Assert that value is truthy.\n-\ttruthy(value: mixed, message?: string): void;\n-\t// Assert that value is falsy.\n-\tfalsy(value: mixed, message?: string): void;\n-\t// Assert that value is true.\n-\ttrue(value: mixed, message?: string): void;\n-\t// Assert that value is false.\n-\tfalse(value: mixed, message?: string): void;\n-\t// Assert that value is equal to expected.\n-\tis<U>(value: U, expected: U, message?: string): void;\n-\t// Assert that value is not equal to expected.\n-\tnot<U>(value: U, expected: U, message?: string): void;\n-\t// Assert that value is deep equal to expected.\n-\tdeepEqual<U>(value: U, expected: U, message?: string): void;\n-\t// Assert that value is not deep equal to expected.\n-\tnotDeepEqual<U>(value: U, expected: U, message?: string): void;\n-\t// Assert that the promise rejects, or the function throws or returns a rejected promise.\n-\t// @param error Can be a constructor, regex, error message or validation function.\n-\tthrows: {\n-\t\t(value: PromiseLike<mixed>, error?: ErrorValidator, message?: string): Promise<any>;\n-\t\t(value: () => mixed, error?: ErrorValidator, message?: string): any;\n-\t};\n-\t// Assert that the promise resolves, or the function doesn't throw or return a resolved promise.\n-\tnotThrows: {\n-\t\t(value: PromiseLike<mixed>, message?: string): Promise<void>;\n-\t\t(value: () => mixed, message?: string): void;\n-\t};\n-\t// Assert that contents matches regex.\n-\tregex(contents: string, regex: RegExp, message?: string): void;\n-\t// Assert that contents matches a snapshot.\n-\tsnapshot: ((contents: any, message?: string) => void) & ((contents: any, options: {id: string}, message?: string) => void);\n-\t// Assert that contents does not match regex.\n-\tnotRegex(contents: string, regex: RegExp, message?: string): void;\n-\t// Assert that error is falsy.\n+\tfalse(actual: any, message?: string): void;\n+\tfalsy(actual: any, message?: string): void;\n \tifError(error: any, message?: string): void;\n-};\n-\n-/**\n- * Context Types\n- */\n+\tis(actual: any, expected: any, message?: string): void;\n+\tnot(actual: any, expected: any, message?: string): void;\n+\tnotDeepEqual(actual: any, expected: any, message?: string): void;\n+\tnotRegex(string: string, regex: RegExp, message?: string): void;\n+\tnotThrows(value: () => ObservableLike, message?: string): Promise<void>;\n+\tnotThrows(value: () => PromiseLike<any>, message?: string): Promise<void>;\n+\tnotThrows(value: () => any, message?: string): void;\n+\tnotThrows(value: ObservableLike, message?: string): Promise<void>;\n+\tnotThrows(value: PromiseLike<any>, message?: string): Promise<void>;\n+\tpass(message?: string): void;\n+\tregex(string: string, regex: RegExp, message?: string): void;\n+\tsnapshot(expected: any, message?: string): void;\n+\tsnapshot(expected: any, options: SnapshotOptions, message?: string): void;\n+\tthrows(value: () => ObservableLike, error?: ThrowsErrorValidator, message?: string): Promise<any>;\n+\tthrows(value: () => PromiseLike<any>, error?: ThrowsErrorValidator, message?: string): Promise<any>;\n+\tthrows(value: () => any, error?: ThrowsErrorValidator, message?: string): any;\n+\tthrows(value: ObservableLike, error?: ThrowsErrorValidator, message?: string): Promise<any>;\n+\tthrows(value: PromiseLike<any>, error?: ThrowsErrorValidator, message?: string): Promise<any>;\n+\ttrue(actual: any, message?: string): void;\n+\ttruthy(actual: any, message?: string): void;\n+}\n \n-type TestContext = AssertContext & {\n+export interface ExecutionContext<Context = {}> extends Assertions {\n+\tcontext: Context;\n+\tskip: Assertions;\n \ttitle: string;\n-\tplan(count: number): void;\n-\tskip: AssertContext;\n \tlog(...values: Array<any>): void;\n-};\n-type ContextualTestContext         = TestContext & { context: any; };\n-type ContextualCallbackTestContext = TestContext & { context: any; end(): void; };\n+\tplan(count: number): void;\n+}\n \n-/**\n- * Test Implementations\n- */\n+export interface CbExecutionContext<Context = {}> extends ExecutionContext<Context> {\n+\tend(): void;\n+}\n \n-type TestFunction<T, R> = {\n-\t(t: T, ...args: Array<any>): R;\n+export type ImplementationResult = PromiseLike<void> | ObservableLike | Iterator<any> | void;\n+export type Implementation<Context = {}> = {(t: ExecutionContext<Context>): ImplementationResult};\n+export type CbImplementation<Context = {}> = {(t: CbExecutionContext<Context>): ImplementationResult};\n+\n+export interface Macro<Context = {}> {\n+\t(t: ExecutionContext<Context>, ...args: Array<any>): ImplementationResult;\n+\ttitle?: (providedTitle: string, ...args: Array<any>) => string;\n+}\n+\n+export interface CbMacro<Context = {}> {\n+\t(t: CbExecutionContext<Context>, ...args: Array<any>): ImplementationResult;\n \ttitle?: (providedTitle: string, ...args: Array<any>) => string;\n-};\n-\n-type TestImplementation<T, R> =\n-\t| TestFunction<T, R>\n-\t| Array<TestFunction<T, R>>;\n-\n-type ContextualTest         = TestImplementation<ContextualTestContext, SpecialReturnTypes | void>;\n-type ContextualCallbackTest = TestImplementation<ContextualCallbackTestContext, void>;\n-\n-\n-/**\n- * Method Types\n- */\n-\n-type ContextualTestMethod = {\n-\t(               implementation: ContextualTest): void;\n-\t(title: string, implementation: ContextualTest): void;\n-\n-\tserial     : ContextualTestMethod;\n-\tbefore     : ContextualTestMethod;\n-\tafter      : ContextualTestMethod;\n-\tskip       : ContextualTestMethod;\n-\ttodo       : ContextualTestMethod;\n-\tfailing    : ContextualTestMethod;\n-\tonly       : ContextualTestMethod;\n-\tbeforeEach : ContextualTestMethod;\n-\tafterEach  : ContextualTestMethod;\n-\tcb         : ContextualCallbackTestMethod;\n-\talways     : ContextualTestMethod;\n-};\n-\n-type ContextualCallbackTestMethod = {\n-\t(               implementation: ContextualCallbackTest): void;\n-\t(title: string, implementation: ContextualCallbackTest): void;\n-\n-\tserial     : ContextualCallbackTestMethod;\n-\tbefore     : ContextualCallbackTestMethod;\n-\tafter      : ContextualCallbackTestMethod;\n-\tskip       : ContextualCallbackTestMethod;\n-\ttodo       : ContextualCallbackTestMethod;\n-\tfailing    : ContextualCallbackTestMethod;\n-\tonly       : ContextualCallbackTestMethod;\n-\tbeforeEach : ContextualCallbackTestMethod;\n-\tafterEach  : ContextualCallbackTestMethod;\n-\tcb         : ContextualCallbackTestMethod;\n-\talways     : ContextualCallbackTestMethod;\n-};\n-\n-/**\n- * Public API\n- */\n-\n-declare module.exports: {\n-\t(               run: ContextualTest, ...args: any): void;\n-\t(title: string, run: ContextualTest, ...args: any): void;\n-\n-\tbeforeEach : ContextualTestMethod;\n-\tafterEach  : ContextualTestMethod;\n-\tserial     : ContextualTestMethod;\n-\tbefore     : ContextualTestMethod;\n-\tafter      : ContextualTestMethod;\n-\tskip       : ContextualTestMethod;\n-\ttodo       : ContextualTestMethod;\n-\tfailing    : ContextualTestMethod;\n-\tonly       : ContextualTestMethod;\n-\tcb         : ContextualCallbackTestMethod;\n-\talways     : ContextualTestMethod;\n-};\n+}\n+\n+export interface TestInterface<Context = {}> {\n+\t(title: string, implementation: Implementation<Context> | Macro<Context>): void;\n+\t(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\t(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\n+\tafter: AfterInterface<null>;\n+\tafterEach: AfterInterface<Context>;\n+\tbefore: BeforeInterface<null>;\n+\tbeforeEach: BeforeInterface<Context>;\n+\tcb: CbInterface<Context>;\n+\tfailing: FailingInterface<Context>;\n+\tonly: OnlyInterface<Context>;\n+\tserial: SerialInterface<Context>;\n+\tskip: SkipInterface<Context>;\n+\ttodo: TodoDeclaration;\n+}\n+\n+export interface AfterInterface<Context = {}> {\n+\t(title: string, implementation: Implementation<Context> | Macro<Context>): void;\n+\t(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\t(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\n+\talways: AlwaysInterface<Context>;\n+\tcb: HookCbInterface<Context>;\n+\tskip: SkipInterface<Context>;\n+}\n+\n+export interface AlwaysInterface<Context = {}> {\n+\t(title: string, implementation: Implementation<Context> | Macro<Context>): void;\n+\t(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\t(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\n+\tcb: HookCbInterface<Context>;\n+\tskip: SkipInterface<Context>;\n+}\n+\n+export interface BeforeInterface<Context = {}> {\n+\t(title: string, implementation: Implementation<Context> | Macro<Context>): void;\n+\t(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\t(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\n+\tcb: HookCbInterface<Context>;\n+\tskip: SkipInterface<Context>;\n+}\n+\n+export interface CbInterface<Context = {}> {\n+\t(title: string, implementation: CbImplementation<Context> | CbMacro<Context>): void;\n+\t(title: string, macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+\t(macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+\n+\tfailing: CbFailingInterface<Context>;\n+\tonly: CbOnlyInterface<Context>;\n+\tskip: CbSkipInterface<Context>;\n+}\n+\n+export interface CbFailingInterface<Context = {}> {\n+\t(title: string, implementation: CbImplementation<Context> | CbMacro<Context>): void;\n+\t(title: string, macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+\t(macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+\n+\tonly: CbOnlyInterface<Context>;\n+\tskip: CbSkipInterface<Context>;\n+}\n+\n+export interface CbOnlyInterface<Context = {}> {\n+\t(title: string, implementation: CbImplementation<Context> | CbMacro<Context>): void;\n+\t(title: string, macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+\t(macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+}\n+\n+export interface CbSkipInterface<Context = {}> {\n+\t(title: string, implementation: CbImplementation<Context> | CbMacro<Context>): void;\n+\t(title: string, macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+\t(macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+}\n+\n+export interface FailingInterface<Context = {}> {\n+\t(title: string, implementation: Implementation<Context> | Macro<Context>): void;\n+\t(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\t(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\n+\tonly: OnlyInterface<Context>;\n+\tskip: SkipInterface<Context>;\n+}\n+\n+export interface HookCbInterface<Context = {}> {\n+\t(title: string, implementation: CbImplementation<Context> | CbMacro<Context>): void;\n+\t(title: string, macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+\t(macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;\n+\n+\tskip: CbSkipInterface<Context>;\n+}\n+\n+export interface OnlyInterface<Context = {}> {\n+\t(title: string, implementation: Implementation<Context> | Macro<Context>): void;\n+\t(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\t(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+}\n+\n+export interface SerialInterface<Context = {}> {\n+\t(title: string, implementation: Implementation<Context> | Macro<Context>): void;\n+\t(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\t(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\n+\tcb: CbInterface<Context>;\n+\tfailing: FailingInterface<Context>;\n+\tonly: OnlyInterface<Context>;\n+\tskip: SkipInterface<Context>;\n+\ttodo: TodoDeclaration;\n+}\n+\n+export interface SkipInterface<Context = {}> {\n+\t(title: string, implementation: Implementation<Context> | Macro<Context>): void;\n+\t(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+\t(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;\n+}\n+\n+export type TodoDeclaration = {(title: string): void};\n+\n+declare export default TestInterface<>;\n+\n+declare export var test: TestInterface<>;\n+declare export var after: AfterInterface<null>;\n+declare export var afterEach: AfterInterface<>;\n+declare export var before: BeforeInterface<null>;\n+declare export var beforeEach: BeforeInterface<>;\n+declare export var cb: CbInterface<>;\n+declare export var failing: FailingInterface<>;\n+declare export var only: OnlyInterface<>;\n+declare export var serial: SerialInterface<>;\n+declare export var skip: SkipInterface<>;\n+declare export var todo: TodoDeclaration;"
      },
      {
        "sha": "3ab8d5a97e1e4233fe210d1d67ffc2091900e8c2",
        "filename": "lib/main.js",
        "status": "modified",
        "additions": 18,
        "deletions": 6,
        "changes": 24,
        "blob_url": "https://github.com/avajs/ava/blob/d07fb0c5444318d27026d2c58bc511cba558a6a5/lib%2Fmain.js",
        "raw_url": "https://github.com/avajs/ava/raw/d07fb0c5444318d27026d2c58bc511cba558a6a5/lib%2Fmain.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fmain.js?ref=d07fb0c5444318d27026d2c58bc511cba558a6a5",
        "patch": "@@ -95,9 +95,21 @@ globals.setImmediate(() => {\n \t});\n });\n \n-module.exports = runner.chain;\n-\n-// TypeScript imports the `default` property for\n-// an ES2015 default import (`import test from 'ava'`)\n-// See: https://github.com/Microsoft/TypeScript/issues/2242#issuecomment-83694181\n-module.exports.default = runner.chain;\n+const makeCjsExport = () => {\n+\tfunction test() {\n+\t\treturn runner.chain.apply(null, arguments);\n+\t}\n+\treturn Object.assign(test, runner.chain);\n+};\n+\n+// Support CommonJS modules by exporting a test function that can be fully\n+// chained. Also support ES module loaders by exporting __esModule and a\n+// default. Support `import * as ava from 'ava'` use cases by exporting a\n+// `test` member. Do all this whilst preventing `test.test.test() or\n+// `test.default.test()` chains, though in CommonJS `test.test()` is\n+// unavoidable.\n+module.exports = Object.assign(makeCjsExport(), {\n+\t__esModule: true,\n+\tdefault: runner.chain,\n+\ttest: runner.chain\n+});"
      },
      {
        "sha": "d425a039989b7ccf4ec82c014a77529d0d6d5971",
        "filename": "lib/runner.js",
        "status": "modified",
        "additions": 109,
        "deletions": 27,
        "changes": 136,
        "blob_url": "https://github.com/avajs/ava/blob/d07fb0c5444318d27026d2c58bc511cba558a6a5/lib%2Frunner.js",
        "raw_url": "https://github.com/avajs/ava/raw/d07fb0c5444318d27026d2c58bc511cba558a6a5/lib%2Frunner.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Frunner.js?ref=d07fb0c5444318d27026d2c58bc511cba558a6a5",
        "patch": "@@ -2,38 +2,112 @@\n const EventEmitter = require('events');\n const path = require('path');\n const Bluebird = require('bluebird');\n-const optionChain = require('option-chain');\n const matcher = require('matcher');\n const snapshotManager = require('./snapshot-manager');\n const TestCollection = require('./test-collection');\n const validateTest = require('./validate-test');\n \n-const chainableMethods = {\n-\tdefaults: {\n-\t\ttype: 'test',\n-\t\tserial: false,\n-\t\texclusive: false,\n-\t\tskipped: false,\n-\t\ttodo: false,\n-\t\tfailing: false,\n-\t\tcallback: false,\n-\t\talways: false\n-\t},\n-\tchainableMethods: {\n-\t\ttest: {},\n-\t\tserial: {serial: true},\n-\t\tbefore: {type: 'before'},\n-\t\tafter: {type: 'after'},\n-\t\tskip: {skipped: true},\n-\t\ttodo: {todo: true},\n-\t\tfailing: {failing: true},\n-\t\tonly: {exclusive: true},\n-\t\tbeforeEach: {type: 'beforeEach'},\n-\t\tafterEach: {type: 'afterEach'},\n-\t\tcb: {callback: true},\n-\t\talways: {always: true}\n+const chainRegistry = new WeakMap();\n+\n+function startChain(name, call, defaults) {\n+\tconst fn = function () {\n+\t\tcall(Object.assign({}, defaults), Array.from(arguments));\n+\t};\n+\tObject.defineProperty(fn, 'name', {value: name});\n+\tchainRegistry.set(fn, {call, defaults, fullName: name});\n+\treturn fn;\n+}\n+\n+function extendChain(prev, name, flag) {\n+\tif (!flag) {\n+\t\tflag = name;\n \t}\n-};\n+\n+\tconst fn = function () {\n+\t\tcallWithFlag(prev, flag, Array.from(arguments));\n+\t};\n+\tconst fullName = `${chainRegistry.get(prev).fullName}.${name}`;\n+\tObject.defineProperty(fn, 'name', {value: fullName});\n+\tprev[name] = fn;\n+\n+\tchainRegistry.set(fn, {flag, fullName, prev});\n+\treturn fn;\n+}\n+\n+function callWithFlag(prev, flag, args) {\n+\tconst combinedFlags = {[flag]: true};\n+\tdo {\n+\t\tconst step = chainRegistry.get(prev);\n+\t\tif (step.call) {\n+\t\t\tstep.call(Object.assign({}, step.defaults, combinedFlags), args);\n+\t\t\tprev = null;\n+\t\t} else {\n+\t\t\tcombinedFlags[step.flag] = true;\n+\t\t\tprev = step.prev;\n+\t\t}\n+\t} while (prev);\n+}\n+\n+function createHookChain(hook, isAfterHook) {\n+\t// Hook chaining rules:\n+\t// * `always` comes immediately after \"after hooks\"\n+\t// * `skip` must come at the end\n+\t// * no `only`\n+\t// * no repeating\n+\textendChain(hook, 'cb', 'callback');\n+\textendChain(hook, 'skip', 'skipped');\n+\textendChain(hook.cb, 'skip', 'skipped');\n+\tif (isAfterHook) {\n+\t\textendChain(hook, 'always');\n+\t\textendChain(hook.always, 'cb', 'callback');\n+\t\textendChain(hook.always, 'skip', 'skipped');\n+\t\textendChain(hook.always.cb, 'skip', 'skipped');\n+\t}\n+\treturn hook;\n+}\n+\n+function createChain(fn, defaults) {\n+\t// Test chaining rules:\n+\t// * `serial` must come at the start\n+\t// * `only` and `skip` must come at the end\n+\t// * `failing` must come at the end, but can be followed by `only` and `skip`\n+\t// * `only` and `skip` cannot be chained together\n+\t// * no repeating\n+\tconst root = startChain('test', fn, Object.assign({}, defaults, {type: 'test'}));\n+\textendChain(root, 'cb', 'callback');\n+\textendChain(root, 'failing');\n+\textendChain(root, 'only', 'exclusive');\n+\textendChain(root, 'serial');\n+\textendChain(root, 'skip', 'skipped');\n+\textendChain(root.cb, 'failing');\n+\textendChain(root.cb, 'only', 'exclusive');\n+\textendChain(root.cb, 'skip', 'skipped');\n+\textendChain(root.cb.failing, 'only', 'exclusive');\n+\textendChain(root.cb.failing, 'skip', 'skipped');\n+\textendChain(root.failing, 'only', 'exclusive');\n+\textendChain(root.failing, 'skip', 'skipped');\n+\textendChain(root.serial, 'cb', 'callback');\n+\textendChain(root.serial, 'failing');\n+\textendChain(root.serial, 'only', 'exclusive');\n+\textendChain(root.serial, 'skip', 'skipped');\n+\textendChain(root.serial.cb, 'failing');\n+\textendChain(root.serial.cb, 'only', 'exclusive');\n+\textendChain(root.serial.cb, 'skip', 'skipped');\n+\textendChain(root.serial.cb.failing, 'only', 'exclusive');\n+\textendChain(root.serial.cb.failing, 'skip', 'skipped');\n+\n+\troot.after = createHookChain(startChain('test.after', fn, Object.assign({}, defaults, {type: 'after'})), true);\n+\troot.afterEach = createHookChain(startChain('test.afterEach', fn, Object.assign({}, defaults, {type: 'afterEach'})), true);\n+\troot.before = createHookChain(startChain('test.before', fn, Object.assign({}, defaults, {type: 'before'})), false);\n+\troot.beforeEach = createHookChain(startChain('test.beforeEach', fn, Object.assign({}, defaults, {type: 'beforeEach'})), false);\n+\n+\t// Todo tests cannot be chained. Allow todo tests to be flagged as needing to\n+\t// be serial.\n+\troot.todo = startChain('test.todo', fn, Object.assign({}, defaults, {type: 'test', todo: true}));\n+\troot.serial.todo = startChain('test.serial.todo', fn, Object.assign({}, defaults, {serial: true, type: 'test', todo: true}));\n+\n+\treturn root;\n+}\n \n function wrapFunction(fn, args) {\n \treturn function (t) {\n@@ -63,7 +137,7 @@ class Runner extends EventEmitter {\n \t\t\tcompareTestSnapshot: this.compareTestSnapshot.bind(this)\n \t\t});\n \n-\t\tthis.chain = optionChain(chainableMethods, (opts, args) => {\n+\t\tthis.chain = createChain((opts, args) => {\n \t\t\tlet title;\n \t\t\tlet fn;\n \t\t\tlet macroArgIndex;\n@@ -100,6 +174,14 @@ class Runner extends EventEmitter {\n \t\t\t} else {\n \t\t\t\tthis.addTest(title, opts, fn, args);\n \t\t\t}\n+\t\t}, {\n+\t\t\tserial: false,\n+\t\t\texclusive: false,\n+\t\t\tskipped: false,\n+\t\t\ttodo: false,\n+\t\t\tfailing: false,\n+\t\t\tcallback: false,\n+\t\t\talways: false\n \t\t});\n \t}\n "
      },
      {
        "sha": "46183d252093590674e62dbbc8aa13ba4a7f6470",
        "filename": "lib/test-collection.js",
        "status": "modified",
        "additions": 0,
        "deletions": 12,
        "changes": 12,
        "blob_url": "https://github.com/avajs/ava/blob/d07fb0c5444318d27026d2c58bc511cba558a6a5/lib%2Ftest-collection.js",
        "raw_url": "https://github.com/avajs/ava/raw/d07fb0c5444318d27026d2c58bc511cba558a6a5/lib%2Ftest-collection.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Ftest-collection.js?ref=d07fb0c5444318d27026d2c58bc511cba558a6a5",
        "patch": "@@ -38,10 +38,6 @@ class TestCollection extends EventEmitter {\n \t\tconst metadata = test.metadata;\n \t\tconst type = metadata.type;\n \n-\t\tif (!type) {\n-\t\t\tthrow new Error('Test type must be specified');\n-\t\t}\n-\n \t\tif (test.title === '' || typeof test.title !== 'string') {\n \t\t\tif (type === 'test') {\n \t\t\t\tthrow new TypeError('Tests must have a title');\n@@ -58,16 +54,8 @@ class TestCollection extends EventEmitter {\n \t\t\t}\n \t\t}\n \n-\t\tif (metadata.always && type !== 'after' && type !== 'afterEach') {\n-\t\t\tthrow new Error('\"always\" can only be used with after and afterEach hooks');\n-\t\t}\n-\n \t\t// Add a hook\n \t\tif (type !== 'test') {\n-\t\t\tif (metadata.exclusive) {\n-\t\t\t\tthrow new Error(`\"only\" cannot be used with a ${type} hook`);\n-\t\t\t}\n-\n \t\t\tthis.hooks[type + (metadata.always ? 'Always' : '')].push(test);\n \t\t\treturn;\n \t\t}"
      },
      {
        "sha": "18852f01c63b40bdd8e24e1ef7cc7bb3dabe8bc5",
        "filename": "package-lock.json",
        "status": "modified",
        "additions": 3,
        "deletions": 14,
        "changes": 17,
        "blob_url": "https://github.com/avajs/ava/blob/d07fb0c5444318d27026d2c58bc511cba558a6a5/package-lock.json",
        "raw_url": "https://github.com/avajs/ava/raw/d07fb0c5444318d27026d2c58bc511cba558a6a5/package-lock.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/package-lock.json?ref=d07fb0c5444318d27026d2c58bc511cba558a6a5",
        "patch": "@@ -4174,12 +4174,6 @@\n         }\n       }\n     },\n-    \"is-array-sorted\": {\n-      \"version\": \"1.0.0\",\n-      \"resolved\": \"https://registry.npmjs.org/is-array-sorted/-/is-array-sorted-1.0.0.tgz\",\n-      \"integrity\": \"sha1-fyQGt+kYStas6D0RpvzLHCyDeHM=\",\n-      \"dev\": true\n-    },\n     \"is-arrayish\": {\n       \"version\": \"0.2.1\",\n       \"resolved\": \"https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.2.1.tgz\",\n@@ -6143,11 +6137,6 @@\n         }\n       }\n     },\n-    \"option-chain\": {\n-      \"version\": \"1.0.0\",\n-      \"resolved\": \"https://registry.npmjs.org/option-chain/-/option-chain-1.0.0.tgz\",\n-      \"integrity\": \"sha1-k41zvU4Xg/lI00AjZEraI2aeMPI=\"\n-    },\n     \"optionator\": {\n       \"version\": \"0.8.2\",\n       \"resolved\": \"https://registry.npmjs.org/optionator/-/optionator-0.8.2.tgz\",\n@@ -8241,9 +8230,9 @@\n       \"dev\": true\n     },\n     \"typescript\": {\n-      \"version\": \"2.6.2\",\n-      \"resolved\": \"https://registry.npmjs.org/typescript/-/typescript-2.6.2.tgz\",\n-      \"integrity\": \"sha1-PFtv1/beCRQmkCfwPAlGdY92c6Q=\",\n+      \"version\": \"2.7.1\",\n+      \"resolved\": \"https://registry.npmjs.org/typescript/-/typescript-2.7.1.tgz\",\n+      \"integrity\": \"sha512-bqB1yS6o9TNA9ZC/MJxM0FZzPnZdtHj0xWK/IZ5khzVqdpGul/R/EIiHRgFXlwTD7PSIaYVnGKq1QgMCu2mnqw==\",\n       \"dev\": true\n     },\n     \"ua-parser-js\": {"
      },
      {
        "sha": "7f5d1d3d88cc8723ddf2ec78b417e6b48a272ed3",
        "filename": "package.json",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "blob_url": "https://github.com/avajs/ava/blob/d07fb0c5444318d27026d2c58bc511cba558a6a5/package.json",
        "raw_url": "https://github.com/avajs/ava/raw/d07fb0c5444318d27026d2c58bc511cba558a6a5/package.json",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/package.json?ref=d07fb0c5444318d27026d2c58bc511cba558a6a5",
        "patch": "@@ -13,15 +13,13 @@\n \t\t\"lint\": \"xo && (cd test/fixture && xo '**' '!{source-map-initial,syntax-error}.js' '!snapshots/test-sourcemaps/build/**') && lock-verify\",\n \t\t\"test\": \"npm run lint && flow check test/flow-types && tsc -p test/ts-types && nyc tap --no-cov --timeout=300 --jobs=4 test/*.js test/reporters/*.js\",\n \t\t\"test-win\": \"tap --no-cov --reporter=classic --timeout=300 --jobs=4 test/*.js test/reporters/*.js\",\n-\t\t\"visual\": \"node test/visual/run-visual-tests.js\",\n-\t\t\"prepare\": \"npm run make-ts\",\n-\t\t\"make-ts\": \"node types/make.js\"\n+\t\t\"visual\": \"node test/visual/run-visual-tests.js\"\n \t},\n \t\"files\": [\n \t\t\"lib\",\n \t\t\"*.js\",\n \t\t\"*.js.flow\",\n-\t\t\"types/generated.d.ts\"\n+\t\t\"index.d.ts\"\n \t],\n \t\"keywords\": [\n \t\t\"🦄\",\n@@ -124,7 +122,6 @@\n \t\t\"ms\": \"^2.1.1\",\n \t\t\"multimatch\": \"^2.1.0\",\n \t\t\"observable-to-promise\": \"^0.5.0\",\n-\t\t\"option-chain\": \"^1.0.0\",\n \t\t\"package-hash\": \"^2.0.0\",\n \t\t\"pkg-conf\": \"^2.1.0\",\n \t\t\"plur\": \"^2.0.0\",\n@@ -155,7 +152,6 @@\n \t\t\"git-branch\": \"^1.0.0\",\n \t\t\"has-ansi\": \"^3.0.0\",\n \t\t\"inquirer\": \"^5.0.1\",\n-\t\t\"is-array-sorted\": \"^1.0.0\",\n \t\t\"lock-verify\": \"^1.1.0\",\n \t\t\"lolex\": \"^2.3.1\",\n \t\t\"nyc\": \"^11.4.1\",\n@@ -168,11 +164,11 @@\n \t\t\"tap\": \"^11.0.1\",\n \t\t\"temp-write\": \"^3.4.0\",\n \t\t\"touch\": \"^3.1.0\",\n-\t\t\"typescript\": \"^2.6.2\",\n+\t\t\"typescript\": \"^2.7.1\",\n \t\t\"xo\": \"^0.18.2\",\n \t\t\"zen-observable\": \"^0.7.1\"\n \t},\n-\t\"typings\": \"types/generated.d.ts\",\n+\t\"typings\": \"index.d.ts\",\n \t\"xo\": {\n \t\t\"ignores\": [\n \t\t\t\"media/**\""
      },
      {
        "sha": "0c6fbadc884c4bd675f58192d54d94198da0a476",
        "filename": "readme.md",
        "status": "modified",
        "additions": 14,
        "deletions": 16,
        "changes": 30,
        "blob_url": "https://github.com/avajs/ava/blob/d07fb0c5444318d27026d2c58bc511cba558a6a5/readme.md",
        "raw_url": "https://github.com/avajs/ava/raw/d07fb0c5444318d27026d2c58bc511cba558a6a5/readme.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/readme.md?ref=d07fb0c5444318d27026d2c58bc511cba558a6a5",
        "patch": "@@ -385,6 +385,8 @@ test.serial('passes serially', t => {\n \n Note that this only applies to tests within a particular test file. AVA will still run multiple tests files at the same time unless you pass the [`--serial` CLI flag](#cli).\n \n+You can use the `.serial` modifier with all tests, hooks and even `.todo()`, but it's only available on the `test` function.\n+\n ### Running specific tests\n \n During development it can be helpful to only run a few specific tests. This can be accomplished using the `.only` modifier:\n@@ -399,6 +401,8 @@ test.only('will be run', t => {\n });\n ```\n \n+You can use the `.only` modifier with all tests. It cannot be used with hooks or `.todo()`.\n+\n *Note:* The `.only` modifier applies to the test file it's defined in, so if you run multiple test files, tests in other files will still run. If you want to only run the `test.only` test, provide just that test file to AVA.\n \n ### Running tests with matching titles\n@@ -485,7 +489,7 @@ test.skip('will not be run', t => {\n });\n ```\n \n-You must specify the implementation function.\n+You must specify the implementation function. You can use the `.skip` modifier with all tests and hooks, but not with `.todo()`. You can not apply further modifiers to `.skip`.\n \n ### Test placeholders (\"todo\")\n \n@@ -495,6 +499,12 @@ You can use the `.todo` modifier when you're planning to write a test. Like skip\n test.todo('will think about writing this later');\n ```\n \n+You can signal that you need to write a serial test:\n+\n+```js\n+test.serial.todo('will think about writing this later');\n+```\n+\n ### Failing tests\n \n You can use the `.failing` modifier to document issues with your code that need to be fixed. Failing tests are run just like normal ones, but they are expected to fail, and will not break your build when they do. If a test marked as failing actually passes, it will be reported as an error and fail the build with a helpful message instructing you to remove the `.failing` modifier.\n@@ -558,7 +568,7 @@ test('title', t => {\n });\n ```\n \n-Hooks can be synchronous or asynchronous, just like tests. To make a hook asynchronous return a promise or observable, use an async function, or enable callback mode via `test.cb.before()`, `test.cb.beforeEach()` etc.\n+Hooks can be synchronous or asynchronous, just like tests. To make a hook asynchronous return a promise or observable, use an async function, or enable callback mode via `test.before.cb()`, `test.beforeEach.cb()` etc.\n \n ```js\n test.before(async t => {\n@@ -569,7 +579,7 @@ test.after(t => {\n \treturn new Promise(/* ... */);\n });\n \n-test.cb.beforeEach(t => {\n+test.beforeEach.cb(t => {\n \tsetTimeout(t.end);\n });\n \n@@ -610,19 +620,6 @@ test('context is unicorn', t => {\n \n Context sharing is *not* available to `before` and `after` hooks.\n \n-### Chaining test modifiers\n-\n-You can use the `.serial`, `.only` and `.skip` modifiers in any order, with `test`, `before`, `after`, `beforeEach` and `afterEach`. For example:\n-\n-```js\n-test.before.skip(...);\n-test.skip.after(...);\n-test.serial.only(...);\n-test.only.serial(...);\n-```\n-\n-This means you can temporarily add `.skip` or `.only` at the end of a test or hook definition without having to make any other changes.\n-\n ### Test macros\n \n Additional arguments passed to the test declaration will be passed to the test implementation. This is useful for creating reusable test macros.\n@@ -1135,6 +1132,7 @@ It's the [Andromeda galaxy](https://simple.wikipedia.org/wiki/Andromeda_galaxy).\n - [When to use `t.plan()`](docs/recipes/when-to-use-plan.md)\n - [Browser testing](docs/recipes/browser-testing.md)\n - [TypeScript](docs/recipes/typescript.md)\n+- [Flow](docs/recipes/flow.md)\n - [Configuring Babel][Babel recipe]\n - [Testing React components](docs/recipes/react.md)\n - [Testing Vue.js components](docs/recipes/vue.md)"
      },
      {
        "sha": "83d6a064574f4ae2d8a2b680421f01c1bdf2cddc",
        "filename": "test/flow-types/log.js",
        "status": "renamed",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/avajs/ava/blob/d07fb0c5444318d27026d2c58bc511cba558a6a5/test%2Fflow-types%2Flog.js",
        "raw_url": "https://github.com/avajs/ava/raw/d07fb0c5444318d27026d2c58bc511cba558a6a5/test%2Fflow-types%2Flog.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fflow-types%2Flog.js?ref=d07fb0c5444318d27026d2c58bc511cba558a6a5",
        "patch": "@@ -1,8 +1,7 @@\n-/* @flow */\n-\n-const test = require('../../index.js.flow');\n+// @flow\n+import test from '../../index.js.flow';\n \n test('log', t => {\n \tt.pass();\n \tt.log({object: true}, 42, ['array'], false, new Date(), new Map());\n-})\n+});",
        "previous_filename": "test/flow-types/log.js.flow"
      },
      {
        "sha": "7459cae905e27efc3115c08672ba30b72f618c63",
        "filename": "test/flow-types/regression-1114.js",
        "status": "renamed",
        "additions": 6,
        "deletions": 13,
        "changes": 19,
        "blob_url": "https://github.com/avajs/ava/blob/d07fb0c5444318d27026d2c58bc511cba558a6a5/test%2Fflow-types%2Fregression-1114.js",
        "raw_url": "https://github.com/avajs/ava/raw/d07fb0c5444318d27026d2c58bc511cba558a6a5/test%2Fflow-types%2Fregression-1114.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fflow-types%2Fregression-1114.js?ref=d07fb0c5444318d27026d2c58bc511cba558a6a5",
        "patch": "@@ -1,12 +1,10 @@\n-/* @flow */\n-\n-const test = require('../../index.js.flow');\n+// @flow\n+import test from '../../index.js.flow';\n \n test('Named test', t => {\n \tt.pass('Success');\n \t// $ExpectError: Unknown method \"unknownAssertion\"\n \tt.unknownAssertion('Whoops');\n-\tconst context = t.context;\n \t// $ExpectError: Unknown method \"end\"\n \tt.end();\n });\n@@ -15,7 +13,6 @@ test('test', t => {\n \tt.pass('Success');\n \t// $ExpectError: Unknown method \"unknownAssertion\"\n \tt.unknownAssertion('Whoops');\n-\tconst context = t.context;\n \t// $ExpectError: Unknown method \"end\"\n \tt.end();\n });\n@@ -25,17 +22,13 @@ test.cb('test', t => {\n \tt.end();\n });\n \n-test.beforeEach(t => {\n-\tconst context = t.context;\n-})\n-\n function macro(t, input, expected) {\n-\tt.is(eval(input), expected);\n+\tt.is(eval(input), expected); // eslint-disable-line no-eval\n }\n-macro.title = (title, input, expected) => title || input;\n+macro.title = (title, input) => title || input;\n \n function macro2(t, input, expected) {\n-\tt.is(eval(input), expected);\n+\tt.is(eval(input), expected); // eslint-disable-line no-eval\n }\n \n test('2 + 2 === 4', macro, '2 + 2', 4);\n@@ -45,7 +38,7 @@ test('2 + 2 === 4', [macro, macro2], '2 + 2', 4);\n test([macro, macro2], '2 * 3', 6);\n \n function macroBadTitle(t, input, expected) {\n-\tt.is(eval(input), expected);\n+\tt.is(eval(input), expected); // eslint-disable-line no-eval\n }\n macroBadTitle.title = 'Not a function';\n // $ExpectError: Macro \"title\" is not a function",
        "previous_filename": "test/flow-types/regression-1114.js.flow"
      },
      {
        "sha": "915bda7653dcfa6b5c7b90b2ec63790afa52625d",
        "filename": "test/flow-types/regression-1148.js.flow",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/avajs/ava/blob/d07fb0c5444318d27026d2c58bc511cba558a6a5/test%2Fflow-types%2Fregression-1148.js.flow",
        "raw_url": "https://github.com/avajs/ava/raw/d07fb0c5444318d27026d2c58bc511cba558a6a5/test%2Fflow-types%2Fregression-1148.js.flow",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fflow-types%2Fregression-1148.js.flow?ref=d07fb0c5444318d27026d2c58bc511cba558a6a5",
        "patch": "@@ -1,19 +1,18 @@\n-/* @flow */\n-\n-const test = require('../../index.js.flow');\n+// @flow\n+import test from '../../index.js.flow';\n \n test('test', t => {\n-\tt.throws(() => { throw new Error(); });\n+\tt.throws((): void => { throw new Error(); });\n \tt.throws(Promise.reject(new Error()));\n \n-\tt.notThrows(() => { return; });\n+\tt.notThrows((): void => { return; });\n \tt.notThrows(Promise.resolve('Success'));\n \n-\tconst error = t.throws(() => { throw new Error(); });\n+\tconst error = t.throws((): void => { throw new Error(); });\n \tconst message: string = error.message;\n \n \tconst promise = t.throws(Promise.reject(new Error()));\n \tpromise.then(error => {\n \t\tconst message: string = error.message;\n-\t})\n+\t});\n });"
      },
      {
        "sha": "1d0a920196c3feadd611c167a3c5efbed3e862ce",
        "filename": "test/flow-types/regression-1500.js",
        "status": "added",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/avajs/ava/blob/d07fb0c5444318d27026d2c58bc511cba558a6a5/test%2Fflow-types%2Fregression-1500.js",
        "raw_url": "https://github.com/avajs/ava/raw/d07fb0c5444318d27026d2c58bc511cba558a6a5/test%2Fflow-types%2Fregression-1500.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fflow-types%2Fregression-1500.js?ref=d07fb0c5444318d27026d2c58bc511cba558a6a5",
        "patch": "@@ -0,0 +1,16 @@\n+// @flow\n+import test from '../../index.js.flow';\n+\n+test('test', t => {\n+\tt.snapshot({});\n+\tt.snapshot({}, 'a message');\n+\tt.snapshot({}, {id: 'snapshot-id'});\n+\tt.snapshot({}, {id: 'snapshot-id'}, 'a message');\n+\n+\t// $ExpectError Message should be a string\n+\tt.snapshot({}, 1);\n+\t// $ExpectError unknownOption is an unknown options attribute\n+\tt.snapshot({}, {unknownOption: true});\n+\t// $ExpectError Message should be a string\n+\tt.snapshot({}, {id: 'snapshot-id'}, 1);\n+});"
      },
      {
        "sha": "ca4f83d98e98876473a9dbcf4fc694d248d32424",
        "filename": "test/flow-types/regression-1500.js.flow",
        "status": "removed",
        "additions": 0,
        "deletions": 17,
        "changes": 17,
        "blob_url": "https://github.com/avajs/ava/blob/a28c89617ee2e73c639080ed4c5dcbfb66db9dd0/test%2Fflow-types%2Fregression-1500.js.flow",
        "raw_url": "https://github.com/avajs/ava/raw/a28c89617ee2e73c639080ed4c5dcbfb66db9dd0/test%2Fflow-types%2Fregression-1500.js.flow",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fflow-types%2Fregression-1500.js.flow?ref=a28c89617ee2e73c639080ed4c5dcbfb66db9dd0",
        "patch": "@@ -1,17 +0,0 @@\n-/* @flow */\n-\n-const test = require('../../index.js.flow');\n-\n-test('test', t => {\n-\tt.snapshot({});\n-\tt.snapshot({}, \"a message\");\n-\tt.snapshot({}, {id: \"snapshot-id\"});\n-\tt.snapshot({}, {id: \"snapshot-id\"}, \"a message\");\n-\n-\t// $ExpectError Message should be a string\n-\tt.snapshot({}, 1);\n-\t// $ExpectError unknownOption is an unknown options attribute\n-\tt.snapshot({}, { unknownOption: true });\n-\t// $ExpectError Message should be a string\n-\tt.snapshot({}, { id: \"snapshot-id\" }, 1);\n-});"
      },
      {
        "sha": "28c176732e599f2f9c9c90430303223f79b11075",
        "filename": "test/hooks.js",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/avajs/ava/blob/d07fb0c5444318d27026d2c58bc511cba558a6a5/test%2Fhooks.js",
        "raw_url": "https://github.com/avajs/ava/raw/d07fb0c5444318d27026d2c58bc511cba558a6a5/test%2Fhooks.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fhooks.js?ref=d07fb0c5444318d27026d2c58bc511cba558a6a5",
        "patch": "@@ -38,7 +38,7 @@ test('before', t => {\n \t\tarr.push('a');\n \t});\n \n-\trunner.chain.test('test', a => {\n+\trunner.chain('test', a => {\n \t\ta.pass();\n \t\tarr.push('b');\n \t});\n@@ -58,7 +58,7 @@ test('after', t => {\n \t\tarr.push('b');\n \t});\n \n-\trunner.chain.test('test', a => {\n+\trunner.chain('test', a => {\n \t\ta.pass();\n \t\tarr.push('a');\n \t});\n@@ -82,7 +82,7 @@ test('after not run if test failed', t => {\n \t\tarr.push('a');\n \t});\n \n-\trunner.chain.test('test', () => {\n+\trunner.chain('test', () => {\n \t\tthrow new Error('something went wrong');\n \t});\n \treturn runner.run({}).then(() => {\n@@ -104,7 +104,7 @@ test('after.always run even if test failed', t => {\n \t\tarr.push('a');\n \t});\n \n-\trunner.chain.test('test', () => {\n+\trunner.chain('test', () => {\n \t\tthrow new Error('something went wrong');\n \t});\n \treturn runner.run({}).then(() => {\n@@ -150,7 +150,7 @@ test('stop if before hooks failed', t => {\n \t\tthrow new Error('something went wrong');\n \t});\n \n-\trunner.chain.test('test', a => {\n+\trunner.chain('test', a => {\n \t\ta.pass();\n \t\tarr.push('b');\n \t\ta.end();\n@@ -178,12 +178,12 @@ test('before each with concurrent tests', t => {\n \t\tarr[k++].push('b');\n \t});\n \n-\trunner.chain.test('c', a => {\n+\trunner.chain('c', a => {\n \t\ta.pass();\n \t\tarr[0].push('c');\n \t});\n \n-\trunner.chain.test('d', a => {\n+\trunner.chain('d', a => {\n \t\ta.pass();\n \t\tarr[1].push('d');\n \t});\n@@ -235,7 +235,7 @@ test('fail if beforeEach hook fails', t => {\n \t\ta.fail();\n \t});\n \n-\trunner.chain.test('test', a => {\n+\trunner.chain('test', a => {\n \t\tarr.push('b');\n \t\ta.pass();\n \t});\n@@ -264,12 +264,12 @@ test('after each with concurrent tests', t => {\n \t\tarr[k++].push('b');\n \t});\n \n-\trunner.chain.test('c', a => {\n+\trunner.chain('c', a => {\n \t\ta.pass();\n \t\tarr[0].push('c');\n \t});\n \n-\trunner.chain.test('d', a => {\n+\trunner.chain('d', a => {\n \t\ta.pass();\n \t\tarr[1].push('d');\n \t});\n@@ -320,7 +320,7 @@ test('afterEach not run if concurrent tests failed', t => {\n \t\tarr.push('a');\n \t});\n \n-\trunner.chain.test('test', () => {\n+\trunner.chain('test', () => {\n \t\tthrow new Error('something went wrong');\n \t});\n \n@@ -360,7 +360,7 @@ test('afterEach.always run even if concurrent tests failed', t => {\n \t\tarr.push('a');\n \t});\n \n-\trunner.chain.test('test', () => {\n+\trunner.chain('test', () => {\n \t\tthrow new Error('something went wrong');\n \t});\n \n@@ -400,7 +400,7 @@ test('afterEach.always run even if beforeEach failed', t => {\n \t\tthrow new Error('something went wrong');\n \t});\n \n-\trunner.chain.test('test', a => {\n+\trunner.chain('test', a => {\n \t\ta.pass();\n \t\tarr.push('a');\n \t});\n@@ -437,7 +437,7 @@ test('ensure hooks run only around tests', t => {\n \t\tarr.push('after');\n \t});\n \n-\trunner.chain.test('test', a => {\n+\trunner.chain('test', a => {\n \t\ta.pass();\n \t\tarr.push('test');\n \t});\n@@ -465,7 +465,7 @@ test('shared context', t => {\n \t\ta.context.arr = ['a'];\n \t});\n \n-\trunner.chain.test('test', a => {\n+\trunner.chain('test', a => {\n \t\ta.pass();\n \t\ta.context.arr.push('b');\n \t\ta.deepEqual(a.context.arr, ['a', 'b']);\n@@ -492,7 +492,7 @@ test('shared context of any type', t => {\n \t\ta.context = 'foo';\n \t});\n \n-\trunner.chain.test('test', a => {\n+\trunner.chain('test', a => {\n \t\ta.pass();\n \t\ta.is(a.context, 'foo');\n \t});"
      },
      {
        "sha": "f8d85acb9ca9178a811313046fac8fb901514ca3",
        "filename": "test/runner.js",
        "status": "modified",
        "additions": 41,
        "deletions": 175,
        "changes": 216,
        "blob_url": "https://github.com/avajs/ava/blob/d07fb0c5444318d27026d2c58bc511cba558a6a5/test%2Frunner.js",
        "raw_url": "https://github.com/avajs/ava/raw/d07fb0c5444318d27026d2c58bc511cba558a6a5/test%2Frunner.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Frunner.js?ref=d07fb0c5444318d27026d2c58bc511cba558a6a5",
        "patch": "@@ -10,9 +10,9 @@ test('nested tests and hooks aren\\'t allowed', t => {\n \n \tconst runner = new Runner();\n \n-\trunner.chain.test('test', a => {\n+\trunner.chain('test', a => {\n \t\tt.throws(() => {\n-\t\t\trunner.chain.test(noop);\n+\t\t\trunner.chain(noop);\n \t\t}, {message: 'All tests and hooks must be declared synchronously in your test file, and cannot be nested within other tests or hooks.'});\n \t\ta.pass();\n \t});\n@@ -27,15 +27,15 @@ test('tests must be declared synchronously', t => {\n \n \tconst runner = new Runner();\n \n-\trunner.chain.test('test', a => {\n+\trunner.chain('test', a => {\n \t\ta.pass();\n \t\treturn Promise.resolve();\n \t});\n \n \trunner.run({});\n \n \tt.throws(() => {\n-\t\trunner.chain.test(noop);\n+\t\trunner.chain(noop);\n \t}, {message: 'All tests and hooks must be declared synchronously in your test file, and cannot be nested within other tests or hooks.'});\n \n \tt.end();\n@@ -44,7 +44,7 @@ test('tests must be declared synchronously', t => {\n test('runner emits a \"test\" event', t => {\n \tconst runner = new Runner();\n \n-\trunner.chain.test('foo', a => {\n+\trunner.chain('foo', a => {\n \t\ta.pass();\n \t});\n \n@@ -62,7 +62,7 @@ test('run serial tests before concurrent ones', t => {\n \tconst runner = new Runner();\n \tconst arr = [];\n \n-\trunner.chain.test('test', a => {\n+\trunner.chain('test', a => {\n \t\tarr.push('c');\n \t\ta.end();\n \t});\n@@ -106,8 +106,8 @@ test('anything can be skipped', t => {\n \trunner.chain.beforeEach(pusher('beforeEach'));\n \trunner.chain.beforeEach.skip(pusher('beforeEach.skip'));\n \n-\trunner.chain.test('concurrent', pusher('concurrent'));\n-\trunner.chain.test.skip('concurrent.skip', pusher('concurrent.skip'));\n+\trunner.chain('concurrent', pusher('concurrent'));\n+\trunner.chain.skip('concurrent.skip', pusher('concurrent.skip'));\n \n \trunner.chain.serial('serial', pusher('serial'));\n \trunner.chain.serial.skip('serial.skip', pusher('serial.skip'));\n@@ -137,8 +137,8 @@ test('include skipped tests in results', t => {\n \trunner.chain.beforeEach('beforeEach', noop);\n \trunner.chain.beforeEach.skip('beforeEach.skip', noop);\n \n-\trunner.chain.test.serial('test', a => a.pass());\n-\trunner.chain.test.serial.skip('test.skip', noop);\n+\trunner.chain.serial('test', a => a.pass());\n+\trunner.chain.serial.skip('test.skip', noop);\n \n \trunner.chain.after('after', noop);\n \trunner.chain.after.skip('after.skip', noop);\n@@ -186,7 +186,7 @@ test('test types and titles', t => {\n \trunner.chain.beforeEach(fn);\n \trunner.chain.after(fn);\n \trunner.chain.afterEach(named);\n-\trunner.chain.test('test', fn);\n+\trunner.chain('test', fn);\n \n \tconst tests = [\n \t\t{\n@@ -226,7 +226,7 @@ test('skip test', t => {\n \tconst runner = new Runner();\n \tconst arr = [];\n \n-\trunner.chain.test('test', a => {\n+\trunner.chain('test', a => {\n \t\tarr.push('a');\n \t\ta.pass();\n \t});\n@@ -255,7 +255,7 @@ test('test throws when given no function', t => {\n \tconst runner = new Runner();\n \n \tt.throws(() => {\n-\t\trunner.chain.test();\n+\t\trunner.chain();\n \t}, new TypeError('Expected an implementation. Use `test.todo()` for tests without an implementation.'));\n });\n \n@@ -265,7 +265,7 @@ test('todo test', t => {\n \tconst runner = new Runner();\n \tconst arr = [];\n \n-\trunner.chain.test('test', a => {\n+\trunner.chain('test', a => {\n \t\tarr.push('a');\n \t\ta.pass();\n \t});\n@@ -296,7 +296,7 @@ test('only test', t => {\n \tconst runner = new Runner();\n \tconst arr = [];\n \n-\trunner.chain.test('test', a => {\n+\trunner.chain('test', a => {\n \t\tarr.push('a');\n \t\ta.pass();\n \t});\n@@ -315,41 +315,11 @@ test('only test', t => {\n \t});\n });\n \n-test('throws if you try to set a hook as exclusive', t => {\n-\tconst runner = new Runner();\n-\n-\tt.throws(() => {\n-\t\trunner.chain.beforeEach.only('', noop);\n-\t}, new TypeError('`only` is only for tests and cannot be used with hooks'));\n-\n-\tt.end();\n-});\n-\n-test('throws if you try to set a before hook as always', t => {\n-\tconst runner = new Runner();\n-\n-\tt.throws(() => {\n-\t\trunner.chain.before.always('', noop);\n-\t}, new TypeError('`always` can only be used with `after` and `afterEach`'));\n-\n-\tt.end();\n-});\n-\n-test('throws if you try to set a test as always', t => {\n-\tconst runner = new Runner();\n-\n-\tt.throws(() => {\n-\t\trunner.chain.test.always('', noop);\n-\t}, new TypeError('`always` can only be used with `after` and `afterEach`'));\n-\n-\tt.end();\n-});\n-\n test('throws if you give a function to todo', t => {\n \tconst runner = new Runner();\n \n \tt.throws(() => {\n-\t\trunner.chain.test.todo('todo with function', noop);\n+\t\trunner.chain.todo('todo with function', noop);\n \t}, new TypeError('`todo` tests are not allowed to have an implementation. Use ' +\n \t'`test.skip()` for tests with an implementation.'));\n \n@@ -360,122 +330,18 @@ test('throws if todo has no title', t => {\n \tconst runner = new Runner();\n \n \tt.throws(() => {\n-\t\trunner.chain.test.todo();\n+\t\trunner.chain.todo();\n \t}, new TypeError('`todo` tests require a title'));\n \n \tt.end();\n });\n \n-test('throws if todo has failing, skip, or only', t => {\n-\tconst runner = new Runner();\n-\n-\tconst errorMessage = '`todo` tests are just for documentation and cannot be' +\n-\t\t' used with `skip`, `only`, or `failing`';\n-\n-\tt.throws(() => {\n-\t\trunner.chain.test.failing.todo('test');\n-\t}, new TypeError(errorMessage));\n-\n-\tt.throws(() => {\n-\t\trunner.chain.test.skip.todo('test');\n-\t}, new TypeError(errorMessage));\n-\n-\tt.throws(() => {\n-\t\trunner.chain.test.only.todo('test');\n-\t}, new TypeError(errorMessage));\n-\n-\tt.end();\n-});\n-\n-test('throws if todo isn\\'t a test', t => {\n-\tconst runner = new Runner();\n-\n-\tconst errorMessage = '`todo` is only for documentation of future tests and' +\n-\t\t' cannot be used with hooks';\n-\n-\tt.throws(() => {\n-\t\trunner.chain.before.todo('test');\n-\t}, new TypeError(errorMessage));\n-\n-\tt.throws(() => {\n-\t\trunner.chain.beforeEach.todo('test');\n-\t}, new TypeError(errorMessage));\n-\n-\tt.throws(() => {\n-\t\trunner.chain.after.todo('test');\n-\t}, new TypeError(errorMessage));\n-\n-\tt.throws(() => {\n-\t\trunner.chain.afterEach.todo('test');\n-\t}, new TypeError(errorMessage));\n-\n-\tt.end();\n-});\n-\n-test('throws if test has skip and only', t => {\n-\tconst runner = new Runner();\n-\n-\tt.throws(() => {\n-\t\trunner.chain.test.only.skip('test', noop);\n-\t}, new TypeError('`only` tests cannot be skipped'));\n-\n-\tt.end();\n-});\n-\n-test('throws if failing is used on non-tests', t => {\n-\tconst runner = new Runner();\n-\n-\tconst errorMessage = '`failing` is only for tests and cannot be used with hooks';\n-\n-\tt.throws(() => {\n-\t\trunner.chain.beforeEach.failing('', noop);\n-\t}, new TypeError(errorMessage));\n-\n-\tt.throws(() => {\n-\t\trunner.chain.before.failing('', noop);\n-\t}, new TypeError(errorMessage));\n-\n-\tt.throws(() => {\n-\t\trunner.chain.afterEach.failing('', noop);\n-\t}, new TypeError(errorMessage));\n-\n-\tt.throws(() => {\n-\t\trunner.chain.after.failing('', noop);\n-\t}, new TypeError(errorMessage));\n-\n-\tt.end();\n-});\n-\n-test('throws if only is used on non-tests', t => {\n-\tconst runner = new Runner();\n-\n-\tconst errorMessage = '`only` is only for tests and cannot be used with hooks';\n-\n-\tt.throws(() => {\n-\t\trunner.chain.beforeEach.only(noop);\n-\t}, new TypeError(errorMessage));\n-\n-\tt.throws(() => {\n-\t\trunner.chain.before.only(noop);\n-\t}, new TypeError(errorMessage));\n-\n-\tt.throws(() => {\n-\t\trunner.chain.afterEach.only(noop);\n-\t}, new TypeError(errorMessage));\n-\n-\tt.throws(() => {\n-\t\trunner.chain.after.only(noop);\n-\t}, new TypeError(errorMessage));\n-\n-\tt.end();\n-});\n-\n test('validate accepts skipping failing tests', t => {\n \tt.plan(2);\n \n \tconst runner = new Runner();\n \n-\trunner.chain.test.skip.failing('skip failing', noop);\n+\trunner.chain.failing.skip('skip failing', noop);\n \n \trunner.run({}).then(() => {\n \t\tconst stats = runner.buildStats();\n@@ -492,7 +358,7 @@ test('runOnlyExclusive option test', t => {\n \tconst options = {runOnlyExclusive: true};\n \tconst arr = [];\n \n-\trunner.chain.test('test', () => {\n+\trunner.chain('test', () => {\n \t\tarr.push('a');\n \t});\n \n@@ -524,7 +390,7 @@ test('options.serial forces all tests to be serial', t => {\n \t\ta.pass();\n \t});\n \n-\trunner.chain.test('test', a => {\n+\trunner.chain('test', a => {\n \t\ta.pass();\n \t\tt.strictDeepEqual(arr, [1, 2]);\n \t\tt.end();\n@@ -538,12 +404,12 @@ test('options.bail will bail out', t => {\n \n \tconst runner = new Runner({bail: true});\n \n-\trunner.chain.test('test', a => {\n+\trunner.chain('test', a => {\n \t\tt.pass();\n \t\ta.fail();\n \t});\n \n-\trunner.chain.test('test 2', () => {\n+\trunner.chain('test 2', () => {\n \t\tt.fail();\n \t});\n \n@@ -626,22 +492,22 @@ test('options.match will not run tests with non-matching titles', t => {\n \t\tmatch: ['*oo', '!foo']\n \t});\n \n-\trunner.chain.test('mhm. grass tasty. moo', a => {\n+\trunner.chain('mhm. grass tasty. moo', a => {\n \t\tt.pass();\n \t\ta.pass();\n \t});\n \n-\trunner.chain.test('juggaloo', a => {\n+\trunner.chain('juggaloo', a => {\n \t\tt.pass();\n \t\ta.pass();\n \t});\n \n-\trunner.chain.test('foo', a => {\n+\trunner.chain('foo', a => {\n \t\tt.fail();\n \t\ta.pass();\n \t});\n \n-\trunner.chain.test('test', a => {\n+\trunner.chain('test', a => {\n \t\tt.fail();\n \t\ta.pass();\n \t});\n@@ -668,7 +534,7 @@ test('options.match hold no effect on hooks with titles', t => {\n \t\tactual = 'foo';\n \t});\n \n-\trunner.chain.test('after', a => {\n+\trunner.chain('after', a => {\n \t\tt.is(actual, 'foo');\n \t\ta.pass();\n \t});\n@@ -689,12 +555,12 @@ test('options.match overrides .only', t => {\n \t\tmatch: ['*oo']\n \t});\n \n-\trunner.chain.test('moo', a => {\n+\trunner.chain('moo', a => {\n \t\tt.pass();\n \t\ta.pass();\n \t});\n \n-\trunner.chain.test.only('boo', a => {\n+\trunner.chain.only('boo', a => {\n \t\tt.pass();\n \t\ta.pass();\n \t});\n@@ -713,7 +579,7 @@ test('macros: Additional args will be spread as additional args on implementatio\n \n \tconst runner = new Runner();\n \n-\trunner.chain.test('test1', function (a) {\n+\trunner.chain('test1', function (a) {\n \t\tt.deepEqual(slice.call(arguments, 1), ['foo', 'bar']);\n \t\ta.pass();\n \t}, 'foo', 'bar');\n@@ -754,9 +620,9 @@ test('macros: Customize test names attaching a `title` function', t => {\n \t\tt.is(props.title, expectedTitles.shift());\n \t});\n \n-\trunner.chain.test(macroFn, 'A');\n-\trunner.chain.test('supplied', macroFn, 'B');\n-\trunner.chain.test(macroFn, 'C');\n+\trunner.chain(macroFn, 'A');\n+\trunner.chain('supplied', macroFn, 'B');\n+\trunner.chain(macroFn, 'C');\n \n \trunner.run({}).then(() => {\n \t\tconst stats = runner.buildStats();\n@@ -783,8 +649,8 @@ test('match applies to macros', t => {\n \t\tt.is(props.title, 'foobar');\n \t});\n \n-\trunner.chain.test(macroFn, 'foo');\n-\trunner.chain.test(macroFn, 'bar');\n+\trunner.chain(macroFn, 'foo');\n+\trunner.chain(macroFn, 'bar');\n \n \trunner.run({}).then(() => {\n \t\tconst stats = runner.buildStats();\n@@ -821,10 +687,10 @@ test('arrays of macros', t => {\n \n \tconst runner = new Runner();\n \n-\trunner.chain.test('A', [macroFnA, macroFnB], 'A');\n-\trunner.chain.test('B', [macroFnA, macroFnB], 'B');\n-\trunner.chain.test('C', macroFnA, 'C');\n-\trunner.chain.test('D', macroFnB, 'D');\n+\trunner.chain('A', [macroFnA, macroFnB], 'A');\n+\trunner.chain('B', [macroFnA, macroFnB], 'B');\n+\trunner.chain('C', macroFnA, 'C');\n+\trunner.chain('D', macroFnB, 'D');\n \n \trunner.run({}).then(() => {\n \t\tconst stats = runner.buildStats();\n@@ -865,8 +731,8 @@ test('match applies to arrays of macros', t => {\n \t\tt.is(props.title, 'foobar');\n \t});\n \n-\trunner.chain.test([fooMacro, barMacro, bazMacro], 'foo');\n-\trunner.chain.test([fooMacro, barMacro, bazMacro], 'bar');\n+\trunner.chain([fooMacro, barMacro, bazMacro], 'foo');\n+\trunner.chain([fooMacro, barMacro, bazMacro], 'bar');\n \n \trunner.run({}).then(() => {\n \t\tconst stats = runner.buildStats();"
      },
      {
        "sha": "995e19290dc982e050cef6b06b327d1a53373c22",
        "filename": "test/test-collection.js",
        "status": "modified",
        "additions": 0,
        "deletions": 41,
        "changes": 41,
        "blob_url": "https://github.com/avajs/ava/blob/d07fb0c5444318d27026d2c58bc511cba558a6a5/test%2Ftest-collection.js",
        "raw_url": "https://github.com/avajs/ava/raw/d07fb0c5444318d27026d2c58bc511cba558a6a5/test%2Ftest-collection.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ftest-collection.js?ref=d07fb0c5444318d27026d2c58bc511cba558a6a5",
        "patch": "@@ -77,47 +77,6 @@ function serialize(collection) {\n \treturn removeEmptyProps(serialized);\n }\n \n-test('throws if no type is supplied', t => {\n-\tconst collection = new TestCollection({});\n-\tt.throws(() => {\n-\t\tcollection.add({\n-\t\t\ttitle: 'someTitle',\n-\t\t\tmetadata: {}\n-\t\t});\n-\t}, {message: 'Test type must be specified'});\n-\tt.end();\n-});\n-\n-test('throws if you try to set a hook as exclusive', t => {\n-\tconst collection = new TestCollection({});\n-\tt.throws(() => {\n-\t\tcollection.add(mockTest({\n-\t\t\ttype: 'beforeEach',\n-\t\t\texclusive: true\n-\t\t}));\n-\t}, {message: '\"only\" cannot be used with a beforeEach hook'});\n-\tt.end();\n-});\n-\n-test('throws if you try to set a before hook as always', t => {\n-\tconst collection = new TestCollection({});\n-\tt.throws(() => {\n-\t\tcollection.add(mockTest({\n-\t\t\ttype: 'before',\n-\t\t\talways: true\n-\t\t}));\n-\t}, {message: '\"always\" can only be used with after and afterEach hooks'});\n-\tt.end();\n-});\n-\n-test('throws if you try to set a test as always', t => {\n-\tconst collection = new TestCollection({});\n-\tt.throws(() => {\n-\t\tcollection.add(mockTest({always: true}, 'test'));\n-\t}, {message: '\"always\" can only be used with after and afterEach hooks'});\n-\tt.end();\n-});\n-\n test('hasExclusive is set when an exclusive test is added', t => {\n \tconst collection = new TestCollection({});\n \tt.false(collection.hasExclusive);"
      },
      {
        "sha": "16fdd863f1847d75fb50d95b995364ebf7a5f928",
        "filename": "test/ts-types/regression-1347.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/avajs/ava/blob/d07fb0c5444318d27026d2c58bc511cba558a6a5/test%2Fts-types%2Fregression-1347.ts",
        "raw_url": "https://github.com/avajs/ava/raw/d07fb0c5444318d27026d2c58bc511cba558a6a5/test%2Fts-types%2Fregression-1347.ts",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fts-types%2Fregression-1347.ts?ref=d07fb0c5444318d27026d2c58bc511cba558a6a5",
        "patch": "@@ -1,5 +1,6 @@\n import test from '../..'\n \n test.cb('test', t => {\n+\tconst err = t.throws((): void => {throw new Error()})\n \tt.end()\n })"
      },
      {
        "sha": "9e5aa34b1155de099524290051ad412080157eb2",
        "filename": "types/base.d.ts",
        "status": "removed",
        "additions": 0,
        "deletions": 144,
        "changes": 144,
        "blob_url": "https://github.com/avajs/ava/blob/a28c89617ee2e73c639080ed4c5dcbfb66db9dd0/types%2Fbase.d.ts",
        "raw_url": "https://github.com/avajs/ava/raw/a28c89617ee2e73c639080ed4c5dcbfb66db9dd0/types%2Fbase.d.ts",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/types%2Fbase.d.ts?ref=a28c89617ee2e73c639080ed4c5dcbfb66db9dd0",
        "patch": "@@ -1,144 +0,0 @@\n-export type ErrorValidator\n-\t= (new (...args: any[]) => any)\n-\t| RegExp\n-\t| string\n-\t| ((error: any) => boolean);\n-\n-export interface Observable {\n-\tsubscribe(observer: (value: {}) => void): void;\n-}\n-export interface SnapshotOptions {\n-\tid?: string;\n-}\n-export type Test = (t: TestContext) => PromiseLike<void> | Iterator<any> | Observable | void;\n-export type GenericTest<T> = (t: GenericTestContext<T>) => PromiseLike<void> | Iterator<any> | Observable | void;\n-export type CallbackTest = (t: CallbackTestContext) => void;\n-export type GenericCallbackTest<T> = (t: GenericCallbackTestContext<T>) => void;\n-\n-export interface Context<T> { context: T }\n-export type AnyContext = Context<any>;\n-\n-export type ContextualTest = GenericTest<AnyContext>;\n-export type ContextualCallbackTest = GenericCallbackTest<AnyContext>;\n-\n-export interface AssertContext {\n-\t/**\n-\t * Passing assertion.\n-\t */\n-\tpass(message?: string): void;\n-\t/**\n-\t * Failing assertion.\n-\t */\n-\tfail(message?: string): void;\n-\t/**\n-\t * Assert that value is truthy.\n-\t */\n-\ttruthy(value: any, message?: string): void;\n-\t/**\n-\t * Assert that value is falsy.\n-\t */\n-\tfalsy(value: any, message?: string): void;\n-\t/**\n-\t * Assert that value is true.\n-\t */\n-\ttrue(value: any, message?: string): void;\n-\t/**\n-\t * Assert that value is false.\n-\t */\n-\tfalse(value: any, message?: string): void;\n-\t/**\n-\t * Assert that value is equal to expected.\n-\t */\n-\tis<U>(value: U, expected: U, message?: string): void;\n-\t/**\n-\t * Assert that value is not equal to expected.\n-\t */\n-\tnot<U>(value: U, expected: U, message?: string): void;\n-\t/**\n-\t * Assert that value is deep equal to expected.\n-\t */\n-\tdeepEqual<U>(value: U, expected: U, message?: string): void;\n-\t/**\n-\t * Assert that value is not deep equal to expected.\n-\t */\n-\tnotDeepEqual<U>(value: U, expected: U, message?: string): void;\n- \t/**\n- \t * Assert that function throws an error or promise rejects.\n- \t * @param error Can be a constructor, regex, error message or validation function.\n- \t */\n-\tthrows(value: PromiseLike<any>, error?: ErrorValidator, message?: string): Promise<any>;\n-\tthrows(value: () => PromiseLike<any>, error?: ErrorValidator, message?: string): Promise<any>;\n-\tthrows(value: () => void, error?: ErrorValidator, message?: string): any;\n-\t/**\n-\t * Assert that function doesn't throw an error or promise resolves.\n-\t */\n-\tnotThrows(value: PromiseLike<any>, message?: string): Promise<void>;\n-\tnotThrows(value: () => PromiseLike<any>, message?: string): Promise<void>;\n-\tnotThrows(value: () => void, message?: string): void;\n-\t/**\n-\t * Assert that contents matches regex.\n-\t */\n-\tregex(contents: string, regex: RegExp, message?: string): void;\n-\t/**\n-\t * Assert that contents matches a snapshot.\n-\t */\n-\tsnapshot(contents: any, message?: string): void;\n-\tsnapshot(contents: any, options: SnapshotOptions, message?: string): void;\n-\t/**\n-\t * Assert that contents does not match regex.\n-\t */\n-\tnotRegex(contents: string, regex: RegExp, message?: string): void;\n-\t/**\n-\t * Assert that error is falsy.\n-\t */\n-\tifError(error: any, message?: string): void;\n-}\n-export interface TestContext extends AssertContext {\n-\t/**\n-\t * Test title.\n-\t */\n-\ttitle: string;\n-\t/**\n-\t * Plan how many assertion there are in the test.\n-\t * The test will fail if the actual assertion count doesn't match planned assertions.\n-\t */\n-\tplan(count: number): void;\n-\n-\tskip: AssertContext;\n-\t/**\n-\t * Log values contextually alongside the test result instead of immediately printing them to `stdout`.\n-\t */\n-\tlog(...values: any[]): void;\n-}\n-export interface CallbackTestContext extends TestContext {\n-\t/**\n-\t * End the test.\n-\t */\n-\tend(): void;\n-}\n-\n-export type GenericTestContext<T> = TestContext & T;\n-export type GenericCallbackTestContext<T> = CallbackTestContext & T;\n-\n-export interface Macro<T> {\n-\t(t: T, ...args: any[]): void;\n-\ttitle? (providedTitle: string, ...args: any[]): string;\n-}\n-export type Macros<T> = Macro<T> | Macro<T>[];\n-\n-interface RegisterBase<T> {\n-    (title: string, run: GenericTest<T>): void;\n-    (title: string, run: Macros<GenericTestContext<T>>, ...args: any[]): void;\n-    (run: Macros<GenericTestContext<T>>, ...args: any[]): void;\n-}\n-\n-interface CallbackRegisterBase<T> {\n-    (title: string, run: GenericCallbackTest<T>): void;\n-    (title: string, run: Macros<GenericCallbackTestContext<T>>, ...args: any[]): void;\n-    (run: Macros<GenericCallbackTestContext<T>>, ...args: any[]): void;\n-}\n-\n-export default test;\n-export const test: RegisterContextual<any>;\n-export interface RegisterContextual<T> extends Register<Context<T>> {\n-}"
      },
      {
        "sha": "9516fbb61c728e576a0939172666ec515db324bd",
        "filename": "types/make.js",
        "status": "removed",
        "additions": 0,
        "deletions": 184,
        "changes": 184,
        "blob_url": "https://github.com/avajs/ava/blob/a28c89617ee2e73c639080ed4c5dcbfb66db9dd0/types%2Fmake.js",
        "raw_url": "https://github.com/avajs/ava/raw/a28c89617ee2e73c639080ed4c5dcbfb66db9dd0/types%2Fmake.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/types%2Fmake.js?ref=a28c89617ee2e73c639080ed4c5dcbfb66db9dd0",
        "patch": "@@ -1,184 +0,0 @@\n-'use strict';\n-\n-// TypeScript definitions are generated here.\n-// AVA allows chaining of function names, like `test.after.cb.always`.\n-// The order of these names is not important.\n-// Writing these definitions by hand is hard. Because of chaining,\n-// the number of combinations grows fast (2^n). To reduce this number,\n-// illegal combinations are filtered out in `verify`.\n-// The order of the options is not important. We could generate full\n-// definitions for each possible order, but that would give a very big\n-// output. Instead, we write an alias for different orders. For instance,\n-// `after.cb` is fully written, and `cb.after` is emitted as an alias\n-// using `typeof after.cb`.\n-\n-const path = require('path');\n-const fs = require('fs');\n-const isArraySorted = require('is-array-sorted');\n-const Runner = require('../lib/runner');\n-\n-const arrayHas = parts => part => parts.indexOf(part) !== -1;\n-\n-const base = fs.readFileSync(path.join(__dirname, 'base.d.ts'), 'utf8');\n-\n-// All suported function names\n-const allParts = Object.keys(new Runner({}).chain).filter(name => name !== 'test');\n-\n-// The output consists of the base declarations, the actual 'test' function declarations,\n-// and the namespaced chainable methods.\n-const output = base + generatePrefixed([]);\n-\n-fs.writeFileSync(path.join(__dirname, 'generated.d.ts'), output);\n-\n-// Generates type definitions, for the specified prefix\n-// The prefix is an array of function names\n-function generatePrefixed(prefix) {\n-\tlet output = '';\n-\tlet children = '';\n-\n-\tfor (const part of allParts) {\n-\t\tconst parts = prefix.concat([part]);\n-\n-\t\tif (prefix.indexOf(part) !== -1 || !verify(parts, true)) {\n-\t\t\t// Function already in prefix or not allowed here\n-\t\t\tcontinue;\n-\t\t}\n-\n-\t\t// If `parts` is not sorted, we alias it to the sorted chain\n-\t\tif (!isArraySorted(parts)) {\n-\t\t\tif (exists(parts)) {\n-\t\t\t\tparts.sort();\n-\n-\t\t\t\tlet chain;\n-\t\t\t\tif (hasChildren(parts)) {\n-\t\t\t\t\tchain = parts.join('_') + '<T>';\n-\t\t\t\t} else {\n-\t\t\t\t\t// This is a single function, not a namespace, so there's no type associated\n-\t\t\t\t\t// and we need to dereference it as a property type\n-\t\t\t\t\tconst last = parts.pop();\n-\t\t\t\t\tconst joined = parts.join('_');\n-\t\t\t\t\tchain = `${joined}<T>['${last}']`;\n-\t\t\t\t}\n-\n-\t\t\t\toutput += `\\t${part}: Register_${chain};\\n`;\n-\t\t\t}\n-\n-\t\t\tcontinue;\n-\t\t}\n-\n-\t\t// Check that `part` is a valid function name.\n-\t\t// `always` is a valid prefix, for instance of `always.after`,\n-\t\t// but not a valid function name.\n-\t\tif (verify(parts, false)) {\n-\t\t\tif (arrayHas(parts)('todo')) {\n-\t\t\t\t// 'todo' functions don't have a function argument, just a string\n-\t\t\t\toutput += `\\t${part}: (name: string) => void;\\n`;\n-\t\t\t} else {\n-\t\t\t\tif (arrayHas(parts)('cb')) {\n-\t\t\t\t\toutput += `\\t${part}: CallbackRegisterBase<T>`;\n-\t\t\t\t} else {\n-\t\t\t\t\toutput += `\\t${part}: RegisterBase<T>`;\n-\t\t\t\t}\n-\n-\t\t\t\tif (hasChildren(parts)) {\n-\t\t\t\t\t// This chain can be continued, make the property an intersection type with the chain continuation\n-\t\t\t\t\tconst joined = parts.join('_');\n-\t\t\t\t\toutput += ` & Register_${joined}<T>`;\n-\t\t\t\t}\n-\n-\t\t\t\toutput += ';\\n';\n-\t\t\t}\n-\t\t}\n-\n-\t\tchildren += generatePrefixed(parts);\n-\t}\n-\n-\tif (output === '') {\n-\t\treturn children;\n-\t}\n-\n-\tconst typeBody = `{\\n${output}}\\n${children}`;\n-\n-\tif (prefix.length === 0) {\n-\t\t// No prefix, so this is the type for the default export\n-\t\treturn `export interface Register<T> extends RegisterBase<T> ${typeBody}`;\n-\t}\n-\tconst namespace = ['Register'].concat(prefix).join('_');\n-\treturn `interface ${namespace}<T> ${typeBody}`;\n-}\n-\n-// Checks whether a chain is a valid function name (when `asPrefix === false`)\n-// or a valid prefix that could contain members.\n-// For instance, `test.always` is not a valid function name, but it is a valid\n-// prefix of `test.always.after`.\n-function verify(parts, asPrefix) {\n-\tconst has = arrayHas(parts);\n-\n-\tif (has('only') + has('skip') + has('todo') > 1) {\n-\t\treturn false;\n-\t}\n-\n-\tconst beforeAfterCount = has('before') + has('beforeEach') + has('after') + has('afterEach');\n-\n-\tif (beforeAfterCount > 1) {\n-\t\treturn false;\n-\t}\n-\n-\tif (beforeAfterCount === 1) {\n-\t\tif (has('only')) {\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\n-\tif (has('always')) {\n-\t\t// `always` can only be used with `after` or `afterEach`.\n-\t\t// Without it can still be a valid prefix\n-\t\tif (has('after') || has('afterEach')) {\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\tif (!verify(parts.concat(['after']), false) && !verify(parts.concat(['afterEach']), false)) {\n-\t\t\t// If `after` nor `afterEach` cannot be added to this prefix,\n-\t\t\t// `always` is not allowed here.\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\t// Only allowed as a prefix\n-\t\treturn asPrefix;\n-\t}\n-\n-\treturn true;\n-}\n-\n-// Returns true if a chain can have any child properties\n-function hasChildren(parts) {\n-\t// Concatenate the chain with each other part, and see if any concatenations are valid functions\n-\tconst validChildren = allParts\n-\t\t.filter(newPart => parts.indexOf(newPart) === -1)\n-\t\t.map(newPart => parts.concat([newPart]))\n-\t\t.filter(longer => verify(longer, false));\n-\n-\treturn validChildren.length > 0;\n-}\n-\n-// Checks whether a chain is a valid function name or a valid prefix with some member\n-function exists(parts) {\n-\tif (verify(parts, false)) {\n-\t\t// Valid function name\n-\t\treturn true;\n-\t}\n-\n-\tif (!verify(parts, true)) {\n-\t\t// Not valid prefix\n-\t\treturn false;\n-\t}\n-\n-\t// Valid prefix, check whether it has members\n-\tfor (const prefix of allParts) {\n-\t\tif (parts.indexOf(prefix) === -1 && exists(parts.concat([prefix]))) {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\treturn false;\n-}"
      }
    ]
  },
  {
    "url": "https://api.github.com/repos/avajs/ava/issues/1353",
    "repository_url": "https://api.github.com/repos/avajs/ava",
    "labels_url": "https://api.github.com/repos/avajs/ava/issues/1353/labels{/name}",
    "comments_url": "https://api.github.com/repos/avajs/ava/issues/1353/comments",
    "events_url": "https://api.github.com/repos/avajs/ava/issues/1353/events",
    "html_url": "https://github.com/avajs/ava/pull/1353",
    "id": 220603556,
    "node_id": "MDExOlB1bGxSZXF1ZXN0MTE1MDcxMzgy",
    "number": 1353,
    "title": "Make `t.is()` use `Object.is()`",
    "user": {
      "login": "alexrussell",
      "id": 412784,
      "node_id": "MDQ6VXNlcjQxMjc4NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/412784?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexrussell",
      "html_url": "https://github.com/alexrussell",
      "followers_url": "https://api.github.com/users/alexrussell/followers",
      "following_url": "https://api.github.com/users/alexrussell/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexrussell/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexrussell/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexrussell/subscriptions",
      "organizations_url": "https://api.github.com/users/alexrussell/orgs",
      "repos_url": "https://api.github.com/users/alexrussell/repos",
      "events_url": "https://api.github.com/users/alexrussell/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexrussell/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 4,
    "created_at": "2017-04-10T10:36:27Z",
    "updated_at": "2017-05-30T14:31:15Z",
    "closed_at": "2017-04-16T14:23:49Z",
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "draft": false,
    "pull_request": {
      "url": "https://api.github.com/repos/avajs/ava/pulls/1353",
      "html_url": "https://github.com/avajs/ava/pull/1353",
      "diff_url": "https://github.com/avajs/ava/pull/1353.diff",
      "patch_url": "https://github.com/avajs/ava/pull/1353.patch",
      "merged_at": "2017-04-16T14:23:49Z"
    },
    "body": "Refactor `is` assertion to use `Object.is()` rather than `===`.\r\nAlso add a few more test cases in for `is` to make it clearer what it is expected to do.\r\n\r\nAs per discussion in #1339, this will make it more sensible to compare `NaN` against `NaN`.\r\n\r\nThe good:\r\n\r\n- `NaN` now compares to `NaN` in a way that people expect (truthily)\r\n\r\nThe odd:\r\n\r\n- `+0`/`0` and `-0` are now **not** equal. As we discussed in #1339, this actually feels fine - this being a testing framework, it's good to be strict on this math stuff, while sensible on the NaN stuff.\r\n\r\nFixes #1339 \r\n\r\n/cc @novemberborn, @sotojuan, @sindresorhus ",
    "reactions": {
      "url": "https://api.github.com/repos/avajs/ava/issues/1353/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/avajs/ava/issues/1353/timeline",
    "performed_via_github_app": null,
    "state_reason": null,
    "score": 1,
    "files": [
      {
        "sha": "28b8ae09c90f1a9d01326e54651b98f964f289b4",
        "filename": "lib/assert.js",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/avajs/ava/blob/dce62c24db85244a4f2c45d692969760ac1dd9f1/lib%2Fassert.js",
        "raw_url": "https://github.com/avajs/ava/raw/dce62c24db85244a4f2c45d692969760ac1dd9f1/lib%2Fassert.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fassert.js?ref=dce62c24db85244a4f2c45d692969760ac1dd9f1",
        "patch": "@@ -59,31 +59,29 @@ function wrapAssertions(callbacks) {\n \t\t},\n \n \t\tis(actual, expected, message) {\n-\t\t\tif (actual === expected) {\n+\t\t\tif (Object.is(actual, expected)) {\n \t\t\t\tpass(this);\n \t\t\t} else {\n \t\t\t\tconst diff = formatAssertError.formatDiff(actual, expected);\n \t\t\t\tconst values = diff ? [diff] : [\n \t\t\t\t\tformatAssertError.formatWithLabel('Actual:', actual),\n-\t\t\t\t\tformatAssertError.formatWithLabel('Must be strictly equal to:', expected)\n+\t\t\t\t\tformatAssertError.formatWithLabel('Must be the same as:', expected)\n \t\t\t\t];\n \n \t\t\t\tfail(this, new AssertionError({\n \t\t\t\t\tassertion: 'is',\n \t\t\t\t\tmessage,\n-\t\t\t\t\toperator: '===',\n \t\t\t\t\tvalues\n \t\t\t\t}));\n \t\t\t}\n \t\t},\n \n \t\tnot(actual, expected, message) {\n-\t\t\tif (actual === expected) {\n+\t\t\tif (Object.is(actual, expected)) {\n \t\t\t\tfail(this, new AssertionError({\n \t\t\t\t\tassertion: 'not',\n \t\t\t\t\tmessage,\n-\t\t\t\t\toperator: '!==',\n-\t\t\t\t\tvalues: [formatAssertError.formatWithLabel('Value is strictly equal:', actual)]\n+\t\t\t\t\tvalues: [formatAssertError.formatWithLabel('Value is the same as:', actual)]\n \t\t\t\t}));\n \t\t\t} else {\n \t\t\t\tpass(this);"
      },
      {
        "sha": "893e6672a42084d9b0723afd34d7e84d2b411bcc",
        "filename": "readme.md",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/avajs/ava/blob/dce62c24db85244a4f2c45d692969760ac1dd9f1/readme.md",
        "raw_url": "https://github.com/avajs/ava/raw/dce62c24db85244a4f2c45d692969760ac1dd9f1/readme.md",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/readme.md?ref=dce62c24db85244a4f2c45d692969760ac1dd9f1",
        "patch": "@@ -632,8 +632,8 @@ function macro(t, input, expected) {\n \tt.is(eval(input), expected);\n }\n \n-test('2 + 2 === 4', macro, '2 + 2', 4);\n-test('2 * 3 === 6', macro, '2 * 3', 6);\n+test('2 + 2 = 4', macro, '2 + 2', 4);\n+test('2 * 3 = 6', macro, '2 * 3', 6);\n ```\n \n You can build the test title programmatically by attaching a `title` function to the macro:\n@@ -643,7 +643,7 @@ function macro(t, input, expected) {\n \tt.is(eval(input), expected);\n }\n \n-macro.title = (providedTitle, input, expected) => `${providedTitle} ${input} === ${expected}`.trim();\n+macro.title = (providedTitle, input, expected) => `${providedTitle} ${input} = ${expected}`.trim();\n \n test(macro, '2 + 2', 4);\n test(macro, '2 * 3', 6);\n@@ -914,23 +914,23 @@ Assert that `value` is `false`.\n \n ### `.is(value, expected, [message])`\n \n-Assert that `value` is equal to `expected`.\n+Assert that `value` is the same as `expected`. This is based on [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n \n ### `.not(value, expected, [message])`\n \n-Assert that `value` is not equal to `expected`.\n+Assert that `value` is not the same as `expected`. This is based on [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n \n ### `.deepEqual(value, expected, [message])`\n \n-Assert that `value` is deep equal to `expected`. This is based on [Lodash' `isEqual()`](https://lodash.com/docs/4.17.4#isEqual):\n+Assert that `value` is deeply equal to `expected`. This is based on [Lodash's `isEqual()`](https://lodash.com/docs/4.17.4#isEqual):\n \n > Performs a deep comparison between two values to determine if they are equivalent.\n >\n > *Note*: This method supports comparing arrays, array buffers, booleans, date objects, error objects, maps, numbers, `Object` objects, regexes, sets, strings, symbols, and typed arrays. `Object` objects are compared by their own, not inherited, enumerable properties. Functions and DOM nodes are compared by strict equality, i.e. `===`.\n \n ### `.notDeepEqual(value, expected, [message])`\n \n-Assert that `value` is not deep equal to `expected`. The inverse of `.deepEqual()`.\n+Assert that `value` is not deeply equal to `expected`. The inverse of `.deepEqual()`.\n \n ### `.throws(function|promise, [error, [message]])`\n "
      },
      {
        "sha": "64bb9bee9e4c1e443ecd862e0cbe797b08983222",
        "filename": "test/assert.js",
        "status": "modified",
        "additions": 141,
        "deletions": 9,
        "changes": 150,
        "blob_url": "https://github.com/avajs/ava/blob/dce62c24db85244a4f2c45d692969760ac1dd9f1/test%2Fassert.js",
        "raw_url": "https://github.com/avajs/ava/raw/dce62c24db85244a4f2c45d692969760ac1dd9f1/test%2Fassert.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fassert.js?ref=dce62c24db85244a4f2c45d692969760ac1dd9f1",
        "patch": "@@ -102,12 +102,118 @@ test('.is()', t => {\n \t\tassertions.is('foo', 'foo');\n \t});\n \n+\tpasses(t, () => {\n+\t\tassertions.is('', '');\n+\t});\n+\n+\tpasses(t, () => {\n+\t\tassertions.is(true, true);\n+\t});\n+\n+\tpasses(t, () => {\n+\t\tassertions.is(false, false);\n+\t});\n+\n+\tpasses(t, () => {\n+\t\tassertions.is(null, null);\n+\t});\n+\n+\tpasses(t, () => {\n+\t\tassertions.is(undefined, undefined);\n+\t});\n+\n+\tpasses(t, () => {\n+\t\tassertions.is(1, 1);\n+\t});\n+\n+\tpasses(t, () => {\n+\t\tassertions.is(0, 0);\n+\t});\n+\n+\tpasses(t, () => {\n+\t\tassertions.is(-0, -0);\n+\t});\n+\n+\tpasses(t, () => {\n+\t\tassertions.is(NaN, NaN);\n+\t});\n+\n+\tpasses(t, () => {\n+\t\tassertions.is(0 / 0, NaN);\n+\t});\n+\n+\tpasses(t, () => {\n+\t\tconst someRef = {foo: 'bar'};\n+\t\tassertions.is(someRef, someRef);\n+\t});\n+\n+\tfails(t, () => {\n+\t\tassertions.is(0, -0);\n+\t});\n+\n+\tfails(t, () => {\n+\t\tassertions.is(0, false);\n+\t});\n+\n+\tfails(t, () => {\n+\t\tassertions.is('', false);\n+\t});\n+\n+\tfails(t, () => {\n+\t\tassertions.is('0', 0);\n+\t});\n+\n+\tfails(t, () => {\n+\t\tassertions.is('17', 17);\n+\t});\n+\n+\tfails(t, () => {\n+\t\tassertions.is([1, 2], '1,2');\n+\t});\n+\n+\tfails(t, () => {\n+\t\t// eslint-disable-next-line no-new-wrappers\n+\t\tassertions.is(new String('foo'), 'foo');\n+\t});\n+\n+\tfails(t, () => {\n+\t\tassertions.is(null, undefined);\n+\t});\n+\n+\tfails(t, () => {\n+\t\tassertions.is(null, false);\n+\t});\n+\n+\tfails(t, () => {\n+\t\tassertions.is(undefined, false);\n+\t});\n+\n+\tfails(t, () => {\n+\t\tassertions.is({foo: 'bar'}, {foo: 'bar'});\n+\t});\n+\n+\tfails(t, () => {\n+\t\t// eslint-disable-next-line no-new-wrappers\n+\t\tassertions.is(new String('foo'), new String('foo'));\n+\t});\n+\n+\tfails(t, () => {\n+\t\tassertions.is(0, null);\n+\t});\n+\n+\tfails(t, () => {\n+\t\tassertions.is(0, NaN);\n+\t});\n+\n+\tfails(t, () => {\n+\t\tassertions.is('foo', NaN);\n+\t});\n+\n \tfailsWith(t, () => {\n \t\tassertions.is('foo', 'bar');\n \t}, {\n \t\tassertion: 'is',\n \t\tmessage: '',\n-\t\toperator: '===',\n \t\tvalues: [\n \t\t\t{label: 'Difference:', formatted: /foobar/}\n \t\t]\n@@ -118,10 +224,9 @@ test('.is()', t => {\n \t}, {\n \t\tassertion: 'is',\n \t\tmessage: '',\n-\t\toperator: '===',\n \t\tvalues: [\n \t\t\t{label: 'Actual:', formatted: /foo/},\n-\t\t\t{label: 'Must be strictly equal to:', formatted: /42/}\n+\t\t\t{label: 'Must be the same as:', formatted: /42/}\n \t\t]\n \t});\n \n@@ -130,10 +235,31 @@ test('.is()', t => {\n \t}, {\n \t\tassertion: 'is',\n \t\tmessage: 'my message',\n-\t\toperator: '===',\n \t\tvalues: [\n \t\t\t{label: 'Actual:', formatted: /foo/},\n-\t\t\t{label: 'Must be strictly equal to:', formatted: /42/}\n+\t\t\t{label: 'Must be the same as:', formatted: /42/}\n+\t\t]\n+\t});\n+\n+\tfailsWith(t, () => {\n+\t\tassertions.is(0, -0, 'my message');\n+\t}, {\n+\t\tassertion: 'is',\n+\t\tmessage: 'my message',\n+\t\tvalues: [\n+\t\t\t{label: 'Actual:', formatted: /0/},\n+\t\t\t{label: 'Must be the same as:', formatted: /-0/}\n+\t\t]\n+\t});\n+\n+\tfailsWith(t, () => {\n+\t\tassertions.is(-0, 0, 'my message');\n+\t}, {\n+\t\tassertion: 'is',\n+\t\tmessage: 'my message',\n+\t\tvalues: [\n+\t\t\t{label: 'Actual:', formatted: /-0/},\n+\t\t\t{label: 'Must be the same as:', formatted: /0/}\n \t\t]\n \t});\n \n@@ -145,22 +271,28 @@ test('.not()', t => {\n \t\tassertions.not('foo', 'bar');\n \t});\n \n+\tfails(t, () => {\n+\t\tassertions.not(NaN, NaN);\n+\t});\n+\n+\tfails(t, () => {\n+\t\tassertions.not(0 / 0, NaN);\n+\t});\n+\n \tfailsWith(t, () => {\n \t\tassertions.not('foo', 'foo');\n \t}, {\n \t\tassertion: 'not',\n \t\tmessage: '',\n-\t\toperator: '!==',\n-\t\tvalues: [{label: 'Value is strictly equal:', formatted: /foo/}]\n+\t\tvalues: [{label: 'Value is the same as:', formatted: /foo/}]\n \t});\n \n \tfailsWith(t, () => {\n \t\tassertions.not('foo', 'foo', 'my message');\n \t}, {\n \t\tassertion: 'not',\n \t\tmessage: 'my message',\n-\t\toperator: '!==',\n-\t\tvalues: [{label: 'Value is strictly equal:', formatted: /foo/}]\n+\t\tvalues: [{label: 'Value is the same as:', formatted: /foo/}]\n \t});\n \n \tt.end();"
      },
      {
        "sha": "f0647aa0e651fc5560220757593c09d84bd10fe2",
        "filename": "test/test.js",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/dce62c24db85244a4f2c45d692969760ac1dd9f1/test%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/dce62c24db85244a4f2c45d692969760ac1dd9f1/test%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ftest.js?ref=dce62c24db85244a4f2c45d692969760ac1dd9f1",
        "patch": "@@ -379,7 +379,7 @@ test('fails with the first assertError', t => {\n \tt.is(result.reason.name, 'AssertionError');\n \tt.same(result.reason.values, [\n \t\t{label: 'Actual:', formatted: formatValue(1)},\n-\t\t{label: 'Must be strictly equal to:', formatted: formatValue(2)}\n+\t\t{label: 'Must be the same as:', formatted: formatValue(2)}\n \t]);\n \tt.end();\n });"
      }
    ]
  },
  {
    "url": "https://api.github.com/repos/avajs/ava/issues/1302",
    "repository_url": "https://api.github.com/repos/avajs/ava",
    "labels_url": "https://api.github.com/repos/avajs/ava/issues/1302/labels{/name}",
    "comments_url": "https://api.github.com/repos/avajs/ava/issues/1302/comments",
    "events_url": "https://api.github.com/repos/avajs/ava/issues/1302/events",
    "html_url": "https://github.com/avajs/ava/pull/1302",
    "id": 213112853,
    "node_id": "MDExOlB1bGxSZXF1ZXN0MTA5OTY3ODc4",
    "number": 1302,
    "title": "Refactor assertions",
    "user": {
      "login": "novemberborn",
      "id": 33538,
      "node_id": "MDQ6VXNlcjMzNTM4",
      "avatar_url": "https://avatars.githubusercontent.com/u/33538?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/novemberborn",
      "html_url": "https://github.com/novemberborn",
      "followers_url": "https://api.github.com/users/novemberborn/followers",
      "following_url": "https://api.github.com/users/novemberborn/following{/other_user}",
      "gists_url": "https://api.github.com/users/novemberborn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/novemberborn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/novemberborn/subscriptions",
      "organizations_url": "https://api.github.com/users/novemberborn/orgs",
      "repos_url": "https://api.github.com/users/novemberborn/repos",
      "events_url": "https://api.github.com/users/novemberborn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/novemberborn/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2017-03-09T17:41:59Z",
    "updated_at": "2017-03-14T12:51:02Z",
    "closed_at": "2017-03-14T12:50:36Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "draft": false,
    "pull_request": {
      "url": "https://api.github.com/repos/avajs/ava/pulls/1302",
      "html_url": "https://github.com/avajs/ava/pull/1302",
      "diff_url": "https://github.com/avajs/ava/pull/1302.diff",
      "patch_url": "https://github.com/avajs/ava/pull/1302.patch",
      "merged_at": "2017-03-14T12:50:36Z"
    },
    "body": "See commits. Behavior should be the same, aside from these changes:\r\n\r\n* Fixes #1227 \r\n* Fixes #1150 \r\n* Assertions now return `undefined` rather than `null`\r\n* Removes the undocumented `t.assertCount` getter\r\n* All test failures (exception thrown, rejected promise returned, `t.end(error)`) are now wrapped in an assertion error, but we'll still print the actual error\r\n* Do the same for when `t.throws()` / `t.notThrows()` are called with an improper argument. We can now even print the actual argument passed!\r\n* In the TAP reporter, the error YAML block now has varying properties (e.g. do not assume it has `operator` or even `assertion`)\r\n* Test serialization no longer overwrites non-standard error properties",
    "reactions": {
      "url": "https://api.github.com/repos/avajs/ava/issues/1302/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/avajs/ava/issues/1302/timeline",
    "performed_via_github_app": null,
    "state_reason": null,
    "score": 1,
    "files": [
      {
        "sha": "c05fbd90271c13cf27835ab1e2c264caa9ecc02e",
        "filename": "index.js.flow",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/index.js.flow",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/index.js.flow",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/index.js.flow?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -63,7 +63,7 @@ type AssertContext = {\n \t};\n \t// Assert that function doesn't throw an error or promise resolves.\n \tnotThrows: {\n-\t\t<U>(value: PromiseLike<U>, message?: string): Promise<U>;\n+\t\t(value: PromiseLike<mixed>, message?: string): Promise<void>;\n \t\t(value: () => mixed, message?: string): void;\n \t};\n \t// Assert that contents matches regex."
      },
      {
        "sha": "98876544ba6a9160c796fc061a41c41573e9f2d2",
        "filename": "lib/assert.js",
        "status": "modified",
        "additions": 315,
        "deletions": 137,
        "changes": 452,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Fassert.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Fassert.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fassert.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -1,158 +1,335 @@\n 'use strict';\n-const assert = require('core-assert');\n+const coreAssert = require('core-assert');\n const deepEqual = require('lodash.isequal');\n const observableToPromise = require('observable-to-promise');\n const indentString = require('indent-string');\n const isObservable = require('is-observable');\n const isPromise = require('is-promise');\n const jestSnapshot = require('jest-snapshot');\n+const enhanceAssert = require('./enhance-assert');\n const snapshotState = require('./snapshot-state');\n \n-const x = module.exports;\n-const noop = () => {};\n-\n-Object.defineProperty(x, 'AssertionError', {value: assert.AssertionError});\n-\n-function create(val, expected, operator, msg, fn) {\n-\treturn {\n-\t\tactual: val,\n-\t\texpected,\n-\t\tmessage: msg || ' ',\n-\t\toperator,\n-\t\tstackStartFunction: fn\n-\t};\n-}\n-\n-function test(ok, opts) {\n-\tif (!ok) {\n-\t\tconst err = new assert.AssertionError(opts);\n-\t\terr.showOutput = ['fail', 'throws', 'notThrows'].indexOf(err.operator) === -1;\n-\t\tthrow err;\n+class AssertionError extends Error {\n+\tconstructor(opts) {\n+\t\tsuper(opts.message || '');\n+\t\tthis.name = 'AssertionError';\n+\n+\t\tthis.actual = opts.actual;\n+\t\tthis.assertion = opts.assertion;\n+\t\tthis.expected = opts.expected;\n+\t\tthis.hasActual = 'actual' in opts;\n+\t\tthis.hasExpected = 'expected' in opts;\n+\t\tthis.operator = opts.operator;\n+\n+\t\t// Reserved for power-assert statements\n+\t\tthis.statements = null;\n+\n+\t\tif (opts.stack) {\n+\t\t\tthis.stack = opts.stack;\n+\t\t} else {\n+\t\t\tError.captureStackTrace(this, opts.stackStartFunction);\n+\t\t}\n \t}\n }\n+exports.AssertionError = AssertionError;\n \n-x.pass = msg => {\n-\ttest(true, create(true, true, 'pass', msg, x.pass));\n-};\n-\n-x.fail = msg => {\n-\tmsg = msg || 'Test failed via t.fail()';\n-\ttest(false, create(false, false, 'fail', msg, x.fail));\n-};\n-\n-x.truthy = (val, msg) => {\n-\ttest(val, create(val, true, '==', msg, x.truthy));\n-};\n-\n-x.falsy = (val, msg) => {\n-\ttest(!val, create(val, false, '==', msg, x.falsy));\n-};\n-\n-x.true = (val, msg) => {\n-\ttest(val === true, create(val, true, '===', msg, x.true));\n-};\n-\n-x.false = (val, msg) => {\n-\ttest(val === false, create(val, false, '===', msg, x.false));\n-};\n-\n-x.is = (val, expected, msg) => {\n-\ttest(val === expected, create(val, expected, '===', msg, x.is));\n-};\n-\n-x.not = (val, expected, msg) => {\n-\ttest(val !== expected, create(val, expected, '!==', msg, x.not));\n-};\n-\n-x.deepEqual = (val, expected, msg) => {\n-\ttest(deepEqual(val, expected), create(val, expected, '===', msg, x.deepEqual));\n-};\n+function wrapAssertions(callbacks) {\n+\tconst pass = callbacks.pass;\n+\tconst pending = callbacks.pending;\n+\tconst fail = callbacks.fail;\n \n-x.notDeepEqual = (val, expected, msg) => {\n-\ttest(!deepEqual(val, expected), create(val, expected, '!==', msg, x.notDeepEqual));\n-};\n-\n-x.throws = (fn, err, msg) => {\n-\tif (isObservable(fn)) {\n-\t\tfn = observableToPromise(fn);\n-\t}\n-\n-\tif (isPromise(fn)) {\n-\t\treturn fn\n-\t\t\t.then(() => {\n-\t\t\t\tx.throws(noop, err, msg);\n-\t\t\t}, fnErr => {\n-\t\t\t\treturn x.throws(() => {\n-\t\t\t\t\tthrow fnErr;\n-\t\t\t\t}, err, msg);\n-\t\t\t});\n-\t}\n+\tconst noop = () => {};\n+\tconst makeNoop = () => noop;\n+\tconst makeRethrow = reason => () => {\n+\t\tthrow reason;\n+\t};\n \n-\tif (typeof fn !== 'function') {\n-\t\tthrow new TypeError('t.throws must be called with a function, Promise, or Observable');\n-\t}\n+\tconst assertions = {\n+\t\tpass() {\n+\t\t\tpass(this);\n+\t\t},\n+\n+\t\tfail(message) {\n+\t\t\tfail(this, new AssertionError({\n+\t\t\t\tassertion: 'fail',\n+\t\t\t\tmessage: message || 'Test failed via t.fail()',\n+\t\t\t\tstackStartFunction: assertions.fail\n+\t\t\t}));\n+\t\t},\n+\n+\t\tis(actual, expected, message) {\n+\t\t\tif (actual === expected) {\n+\t\t\t\tpass(this);\n+\t\t\t} else {\n+\t\t\t\tfail(this, new AssertionError({\n+\t\t\t\t\tactual,\n+\t\t\t\t\tassertion: 'is',\n+\t\t\t\t\texpected,\n+\t\t\t\t\tmessage,\n+\t\t\t\t\toperator: '===',\n+\t\t\t\t\tstackStartFunction: assertions.is\n+\t\t\t\t}));\n+\t\t\t}\n+\t\t},\n+\n+\t\tnot(actual, expected, message) {\n+\t\t\tif (actual === expected) {\n+\t\t\t\tfail(this, new AssertionError({\n+\t\t\t\t\tactual,\n+\t\t\t\t\tassertion: 'not',\n+\t\t\t\t\texpected,\n+\t\t\t\t\tmessage,\n+\t\t\t\t\toperator: '!==',\n+\t\t\t\t\tstackStartFunction: assertions.not\n+\t\t\t\t}));\n+\t\t\t} else {\n+\t\t\t\tpass(this);\n+\t\t\t}\n+\t\t},\n+\n+\t\tdeepEqual(actual, expected, message) {\n+\t\t\tif (deepEqual(actual, expected)) {\n+\t\t\t\tpass(this);\n+\t\t\t} else {\n+\t\t\t\tfail(this, new AssertionError({\n+\t\t\t\t\tactual,\n+\t\t\t\t\tassertion: 'deepEqual',\n+\t\t\t\t\texpected,\n+\t\t\t\t\tmessage,\n+\t\t\t\t\tstackStartFunction: assertions.deepEqual\n+\t\t\t\t}));\n+\t\t\t}\n+\t\t},\n+\n+\t\tnotDeepEqual(actual, expected, message) {\n+\t\t\tif (deepEqual(actual, expected)) {\n+\t\t\t\tfail(this, new AssertionError({\n+\t\t\t\t\tactual,\n+\t\t\t\t\tassertion: 'notDeepEqual',\n+\t\t\t\t\texpected,\n+\t\t\t\t\tmessage,\n+\t\t\t\t\tstackStartFunction: assertions.notDeepEqual\n+\t\t\t\t}));\n+\t\t\t} else {\n+\t\t\t\tpass(this);\n+\t\t\t}\n+\t\t},\n+\n+\t\tthrows(fn, err, message) {\n+\t\t\tlet promise;\n+\t\t\tif (isPromise(fn)) {\n+\t\t\t\tpromise = fn;\n+\t\t\t} else if (isObservable(fn)) {\n+\t\t\t\tpromise = observableToPromise(fn);\n+\t\t\t} else if (typeof fn !== 'function') {\n+\t\t\t\tfail(this, new AssertionError({\n+\t\t\t\t\tactual: fn,\n+\t\t\t\t\tmessage: '`t.throws()` must be called with a function, Promise, or Observable'\n+\t\t\t\t}));\n+\t\t\t\treturn;\n+\t\t\t}\n \n-\ttry {\n-\t\tif (typeof err === 'string') {\n-\t\t\tconst errMsg = err;\n-\t\t\terr = err => err.message === errMsg;\n-\t\t}\n+\t\t\tlet coreAssertThrowsErrorArg;\n+\t\t\tif (typeof err === 'string') {\n+\t\t\t\tconst expectedMessage = err;\n+\t\t\t\tcoreAssertThrowsErrorArg = error => error.message === expectedMessage;\n+\t\t\t} else {\n+\t\t\t\t// Assume it's a constructor function or regular expression\n+\t\t\t\tcoreAssertThrowsErrorArg = err;\n+\t\t\t}\n \n-\t\tlet result;\n+\t\t\tconst test = fn => {\n+\t\t\t\ttry {\n+\t\t\t\t\tlet retval;\n+\t\t\t\t\tcoreAssert.throws(() => {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tfn();\n+\t\t\t\t\t\t} catch (err) {\n+\t\t\t\t\t\t\tretval = err;\n+\t\t\t\t\t\t\tthrow err;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}, coreAssertThrowsErrorArg);\n+\t\t\t\t\treturn retval;\n+\t\t\t\t} catch (err) {\n+\t\t\t\t\tthrow new AssertionError({\n+\t\t\t\t\t\tassertion: 'throws',\n+\t\t\t\t\t\tmessage,\n+\t\t\t\t\t\tstackStartFunction: assertions.throws\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\t\t\t};\n+\n+\t\t\tif (promise) {\n+\t\t\t\tconst result = promise.then(makeNoop, makeRethrow).then(test);\n+\t\t\t\tpending(this, result);\n+\t\t\t\treturn result;\n+\t\t\t}\n \n-\t\tassert.throws(() => {\n \t\t\ttry {\n-\t\t\t\tfn();\n+\t\t\t\tconst retval = test(fn);\n+\t\t\t\tpass(this);\n+\t\t\t\treturn retval;\n \t\t\t} catch (err) {\n-\t\t\t\tresult = err;\n-\t\t\t\tthrow err;\n+\t\t\t\tfail(this, err);\n+\t\t\t}\n+\t\t},\n+\n+\t\tnotThrows(fn, message) {\n+\t\t\tlet promise;\n+\t\t\tif (isPromise(fn)) {\n+\t\t\t\tpromise = fn;\n+\t\t\t} else if (isObservable(fn)) {\n+\t\t\t\tpromise = observableToPromise(fn);\n+\t\t\t} else if (typeof fn !== 'function') {\n+\t\t\t\tfail(this, new AssertionError({\n+\t\t\t\t\tactual: fn,\n+\t\t\t\t\tmessage: '`t.notThrows()` must be called with a function, Promise, or Observable'\n+\t\t\t\t}));\n+\t\t\t\treturn;\n \t\t\t}\n-\t\t}, err, msg);\n-\n-\t\treturn result;\n-\t} catch (err) {\n-\t\ttest(false, create(err.actual, err.expected, 'throws', err.message, x.throws));\n-\t}\n-};\n-\n-x.notThrows = (fn, msg) => {\n-\tif (isObservable(fn)) {\n-\t\tfn = observableToPromise(fn);\n-\t}\n-\n-\tif (isPromise(fn)) {\n-\t\treturn fn\n-\t\t\t.catch(err => {\n-\t\t\t\tx.notThrows(() => {\n-\t\t\t\t\tthrow err;\n-\t\t\t\t}, msg);\n-\t\t\t});\n-\t}\n-\n-\tif (typeof fn !== 'function') {\n-\t\tthrow new TypeError('t.notThrows must be called with a function, Promise, or Observable');\n-\t}\n \n-\ttry {\n-\t\tassert.doesNotThrow(fn, msg);\n-\t} catch (err) {\n-\t\ttest(false, create(err.actual, err.expected, 'notThrows', err.message, x.notThrows));\n-\t}\n-};\n+\t\t\tconst test = fn => {\n+\t\t\t\ttry {\n+\t\t\t\t\tcoreAssert.doesNotThrow(fn);\n+\t\t\t\t} catch (err) {\n+\t\t\t\t\tthrow new AssertionError({\n+\t\t\t\t\t\tactual: err.actual,\n+\t\t\t\t\t\tassertion: 'notThrows',\n+\t\t\t\t\t\tmessage,\n+\t\t\t\t\t\tstackStartFunction: assertions.notThrows\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\t\t\t};\n+\n+\t\t\tif (promise) {\n+\t\t\t\tconst result = promise\n+\t\t\t\t\t.then(\n+\t\t\t\t\t\tnoop,\n+\t\t\t\t\t\treason => test(makeRethrow(reason)));\n+\t\t\t\tpending(this, result);\n+\t\t\t\treturn result;\n+\t\t\t}\n \n-x.regex = (contents, regex, msg) => {\n-\ttest(regex.test(contents), create(regex, contents, '===', msg, x.regex));\n-};\n+\t\t\ttry {\n+\t\t\t\ttest(fn);\n+\t\t\t\tpass(this);\n+\t\t\t} catch (err) {\n+\t\t\t\tfail(this, err);\n+\t\t\t}\n+\t\t},\n+\n+\t\tifError(actual, message) {\n+\t\t\tif (actual) {\n+\t\t\t\tfail(this, new AssertionError({\n+\t\t\t\t\tactual,\n+\t\t\t\t\tassertion: 'ifError',\n+\t\t\t\t\tmessage,\n+\t\t\t\t\tstackStartFunction: assertions.ifError\n+\t\t\t\t}));\n+\t\t\t} else {\n+\t\t\t\tpass(this);\n+\t\t\t}\n+\t\t},\n+\n+\t\tsnapshot(actual, optionalMessage) {\n+\t\t\tconst result = snapshot(this, actual, optionalMessage);\n+\t\t\tif (result.pass) {\n+\t\t\t\tpass(this);\n+\t\t\t} else {\n+\t\t\t\tfail(this, new AssertionError({\n+\t\t\t\t\tactual,\n+\t\t\t\t\tassertion: 'snapshot',\n+\t\t\t\t\texpected: result.expected,\n+\t\t\t\t\tmessage: result.message,\n+\t\t\t\t\tstackStartFunction: assertions.snapshot\n+\t\t\t\t}));\n+\t\t\t}\n+\t\t}\n+\t};\n \n-x.notRegex = (contents, regex, msg) => {\n-\ttest(!regex.test(contents), create(regex, contents, '!==', msg, x.notRegex));\n-};\n+\tconst enhancedAssertions = enhanceAssert(pass, fail, {\n+\t\ttruthy(actual, message) {\n+\t\t\tif (!actual) {\n+\t\t\t\tthrow new AssertionError({\n+\t\t\t\t\tactual,\n+\t\t\t\t\tassertion: 'truthy',\n+\t\t\t\t\texpected: true,\n+\t\t\t\t\tmessage,\n+\t\t\t\t\toperator: '==',\n+\t\t\t\t\tstackStartFunction: enhancedAssertions.truthy\n+\t\t\t\t});\n+\t\t\t}\n+\t\t},\n+\n+\t\tfalsy(actual, message) {\n+\t\t\tif (actual) {\n+\t\t\t\tthrow new AssertionError({\n+\t\t\t\t\tactual,\n+\t\t\t\t\tassertion: 'falsy',\n+\t\t\t\t\texpected: false,\n+\t\t\t\t\tmessage,\n+\t\t\t\t\toperator: '==',\n+\t\t\t\t\tstackStartFunction: enhancedAssertions.falsy\n+\t\t\t\t});\n+\t\t\t}\n+\t\t},\n+\n+\t\ttrue(actual, message) {\n+\t\t\tif (actual !== true) {\n+\t\t\t\tthrow new AssertionError({\n+\t\t\t\t\tactual,\n+\t\t\t\t\tassertion: 'true',\n+\t\t\t\t\texpected: true,\n+\t\t\t\t\tmessage,\n+\t\t\t\t\toperator: '===',\n+\t\t\t\t\tstackStartFunction: enhancedAssertions.true\n+\t\t\t\t});\n+\t\t\t}\n+\t\t},\n+\n+\t\tfalse(actual, message) {\n+\t\t\tif (actual !== false) {\n+\t\t\t\tthrow new AssertionError({\n+\t\t\t\t\tactual,\n+\t\t\t\t\tassertion: 'false',\n+\t\t\t\t\texpected: false,\n+\t\t\t\t\tmessage,\n+\t\t\t\t\toperator: '===',\n+\t\t\t\t\tstackStartFunction: enhancedAssertions.false\n+\t\t\t\t});\n+\t\t\t}\n+\t\t},\n+\n+\t\tregex(actual, expected, message) {\n+\t\t\tif (!expected.test(actual)) {\n+\t\t\t\tthrow new AssertionError({\n+\t\t\t\t\tactual,\n+\t\t\t\t\tassertion: 'regex',\n+\t\t\t\t\texpected,\n+\t\t\t\t\tmessage,\n+\t\t\t\t\tstackStartFunction: enhancedAssertions.regex\n+\t\t\t\t});\n+\t\t\t}\n+\t\t},\n+\n+\t\tnotRegex(actual, expected, message) {\n+\t\t\tif (expected.test(actual)) {\n+\t\t\t\tthrow new AssertionError({\n+\t\t\t\t\tactual,\n+\t\t\t\t\tassertion: 'notRegex',\n+\t\t\t\t\texpected,\n+\t\t\t\t\tmessage,\n+\t\t\t\t\tstackStartFunction: enhancedAssertions.notRegex\n+\t\t\t\t});\n+\t\t\t}\n+\t\t}\n+\t});\n \n-x.ifError = (err, msg) => {\n-\ttest(!err, create(err, 'Error', '!==', msg, x.ifError));\n-};\n+\treturn Object.assign(assertions, enhancedAssertions);\n+}\n+exports.wrapAssertions = wrapAssertions;\n \n-x._snapshot = function (tree, optionalMessage, match, snapshotStateGetter) {\n+function snapshot(executionContext, tree, optionalMessage, match, snapshotStateGetter) {\n \t// Set defaults - this allows tests to mock deps easily\n \tconst toMatchSnapshot = match || jestSnapshot.toMatchSnapshot;\n \tconst getState = snapshotStateGetter || snapshotState.get;\n@@ -161,7 +338,7 @@ x._snapshot = function (tree, optionalMessage, match, snapshotStateGetter) {\n \n \tconst context = {\n \t\tdontThrow() {},\n-\t\tcurrentTestName: this.title,\n+\t\tcurrentTestName: executionContext.title,\n \t\tsnapshotState: state\n \t};\n \n@@ -191,9 +368,10 @@ x._snapshot = function (tree, optionalMessage, match, snapshotStateGetter) {\n \t\t}\n \t}\n \n-\ttest(result.pass, create(tree, expected, 'snapshot', message, x.snapshot));\n-};\n-\n-x.snapshot = function (tree, optionalMessage) {\n-\tx._snapshot.call(this, tree, optionalMessage);\n-};\n+\treturn {\n+\t\tpass: result.pass,\n+\t\texpected,\n+\t\tmessage\n+\t};\n+}\n+exports.snapshot = snapshot;"
      },
      {
        "sha": "9065f9e3880b0253b28989ff7f5a9c4d7f345016",
        "filename": "lib/enhance-assert.js",
        "status": "modified",
        "additions": 27,
        "deletions": 43,
        "changes": 70,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Fenhance-assert.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Fenhance-assert.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fenhance-assert.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -13,33 +13,6 @@ const PATTERNS = [\n \t't.notRegex(contents, regex, [message])'\n ];\n \n-const NON_ENHANCED_PATTERNS = [\n-\t't.pass([message])',\n-\t't.fail([message])',\n-\t't.throws(fn, [message])',\n-\t't.notThrows(fn, [message])',\n-\t't.ifError(error, [message])',\n-\t't.snapshot(contents, [message])',\n-\t't.is(value, expected, [message])',\n-\t't.not(value, expected, [message])',\n-\t't.deepEqual(value, expected, [message])',\n-\t't.notDeepEqual(value, expected, [message])'\n-];\n-\n-const enhanceAssert = opts => {\n-\tconst empower = require('empower-core');\n-\tconst enhanced = empower(opts.assert, {\n-\t\tdestructive: false,\n-\t\tonError: opts.onError,\n-\t\tonSuccess: opts.onSuccess,\n-\t\tpatterns: PATTERNS,\n-\t\twrapOnlyPatterns: NON_ENHANCED_PATTERNS,\n-\t\tbindReceiver: false\n-\t});\n-\n-\treturn enhanced;\n-};\n-\n const isRangeMatch = (a, b) => {\n \treturn (a[0] === b[0] && a[1] === b[1]) ||\n \t\t(a[0] > b[0] && a[0] < b[1]) ||\n@@ -55,22 +28,33 @@ const computeStatement = (tokens, range) => {\n \n const getNode = (ast, path) => dotProp.get(ast, path.replace(/\\//g, '.'));\n \n-const formatter = () => {\n-\treturn context => {\n-\t\tconst ast = JSON.parse(context.source.ast);\n-\t\tconst tokens = JSON.parse(context.source.tokens);\n-\t\tconst args = context.args[0].events;\n-\n-\t\treturn args\n-\t\t\t.map(arg => {\n-\t\t\t\tconst range = getNode(ast, arg.espath).range;\n-\t\t\t\treturn [computeStatement(tokens, range), arg.value];\n-\t\t\t})\n-\t\t\t.reverse();\n-\t};\n+const formatter = context => {\n+\tconst ast = JSON.parse(context.source.ast);\n+\tconst tokens = JSON.parse(context.source.tokens);\n+\tconst args = context.args[0].events;\n+\n+\treturn args\n+\t\t.map(arg => {\n+\t\t\tconst range = getNode(ast, arg.espath).range;\n+\t\t\treturn [computeStatement(tokens, range), arg.value];\n+\t\t})\n+\t\t.reverse();\n };\n \n+const enhanceAssert = (pass, fail, assertions) => {\n+\tconst empower = require('empower-core');\n+\treturn empower(assertions, {\n+\t\tdestructive: true,\n+\t\tonError(event) {\n+\t\t\tconst error = event.error;\n+\t\t\terror.statements = formatter(event.powerAssertContext);\n+\t\t\tfail(this, error);\n+\t\t},\n+\t\tonSuccess() {\n+\t\t\tpass(this);\n+\t\t},\n+\t\tpatterns: PATTERNS,\n+\t\tbindReceiver: false\n+\t});\n+};\n module.exports = enhanceAssert;\n-module.exports.PATTERNS = PATTERNS;\n-module.exports.NON_ENHANCED_PATTERNS = NON_ENHANCED_PATTERNS;\n-module.exports.formatter = formatter;"
      },
      {
        "sha": "9e9f0979eb7edfc4c04b3a284eefd90f093be2f6",
        "filename": "lib/format-assert-error.js",
        "status": "modified",
        "additions": 47,
        "deletions": 34,
        "changes": 81,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Fformat-assert-error.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Fformat-assert-error.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fformat-assert-error.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -25,51 +25,64 @@ const cleanUp = line => {\n \treturn ` ${line}`;\n };\n \n-module.exports = err => {\n-\tif (err.statements) {\n-\t\tconst statements = JSON.parse(err.statements);\n+module.exports = error => {\n+\tif (error.statements) {\n+\t\tconst statements = JSON.parse(error.statements);\n \n \t\treturn statements\n \t\t\t.map(statement => `${statement[0]}\\n${chalk.grey('=>')} ${statement[1]}`)\n \t\t\t.join('\\n\\n') + '\\n';\n \t}\n \n-\tif ((err.actualType === 'object' || err.actualType === 'array') && err.actualType === err.expectedType) {\n-\t\tconst patch = diff.createPatch('string', err.actual, err.expected);\n-\t\tconst msg = patch\n-\t\t\t.split('\\n')\n-\t\t\t.slice(4)\n-\t\t\t.map(cleanUp)\n-\t\t\t.filter(Boolean)\n-\t\t\t.join('\\n');\n+\tif (error.actual && error.expected && error.actual.type === error.expected.type) {\n+\t\tconst type = error.actual.type;\n+\t\tif (type === 'array' || type === 'object') {\n+\t\t\tconst patch = diff.createPatch('string', error.actual.formatted, error.expected.formatted);\n+\t\t\tconst msg = patch\n+\t\t\t\t.split('\\n')\n+\t\t\t\t.slice(4)\n+\t\t\t\t.map(cleanUp)\n+\t\t\t\t.filter(Boolean)\n+\t\t\t\t.join('\\n')\n+\t\t\t\t.trimRight();\n \n-\t\treturn `Difference:\\n\\n${msg}`;\n-\t}\n+\t\t\treturn `Difference:\\n\\n${msg}\\n`;\n+\t\t}\n+\n+\t\tif (type === 'string') {\n+\t\t\tconst diffMatchPatch = new DiffMatchPatch();\n+\t\t\tconst patch = diffMatchPatch.diff_main(stripAnsi(error.actual.formatted), stripAnsi(error.expected.formatted));\n+\t\t\tconst msg = patch\n+\t\t\t\t.map(part => {\n+\t\t\t\t\tif (part[0] === 1) {\n+\t\t\t\t\t\treturn chalk.bgGreen.black(part[1]);\n+\t\t\t\t\t}\n \n-\tif (err.actualType === 'string' && err.expectedType === 'string') {\n-\t\tconst diffMatchPatch = new DiffMatchPatch();\n-\t\tconst patch = diffMatchPatch.diff_main(stripAnsi(err.actual), stripAnsi(err.expected));\n-\t\tconst msg = patch\n-\t\t\t.map(part => {\n-\t\t\t\tif (part[0] === 1) {\n-\t\t\t\t\treturn chalk.bgGreen.black(part[1]);\n-\t\t\t\t}\n+\t\t\t\t\tif (part[0] === -1) {\n+\t\t\t\t\t\treturn chalk.bgRed.black(part[1]);\n+\t\t\t\t\t}\n \n-\t\t\t\tif (part[0] === -1) {\n-\t\t\t\t\treturn chalk.bgRed.black(part[1]);\n-\t\t\t\t}\n+\t\t\t\t\treturn chalk.red(part[1]);\n+\t\t\t\t})\n+\t\t\t\t.join('')\n+\t\t\t\t.trimRight();\n \n-\t\t\t\treturn chalk.red(part[1]);\n-\t\t\t})\n-\t\t\t.join('');\n+\t\t\treturn `Difference:\\n\\n${msg}\\n`;\n+\t\t}\n+\t}\n \n-\t\treturn `Difference:\\n\\n${msg}\\n`;\n+\tlet retval = null;\n+\tif (error.actual) {\n+\t\tretval = `Actual:\\n\\n${indentString(error.actual.formatted, 2).trimRight()}\\n`;\n+\t}\n+\tif (error.expected) {\n+\t\tif (retval) {\n+\t\t\tretval += '\\n';\n+\t\t} else {\n+\t\t\tretval = '';\n+\t\t}\n+\t\tretval += `Expected:\\n\\n${indentString(error.expected.formatted, 2).trimRight()}\\n`;\n \t}\n \n-\treturn [\n-\t\t'Actual:\\n',\n-\t\t`${indentString(err.actual, 2)}\\n`,\n-\t\t'Expected:\\n',\n-\t\t`${indentString(err.expected, 2)}\\n`\n-\t].join('\\n');\n+\treturn retval;\n };"
      },
      {
        "sha": "2c71e141bb0cc928f540cfc113c1a42ce552f329",
        "filename": "lib/reporters/mini.js",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Freporters%2Fmini.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Freporters%2Fmini.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Fmini.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -179,10 +179,9 @@ class MiniReporter {\n \t\t\t\t\treturn;\n \t\t\t\t}\n \n-\t\t\t\tconst title = test.error ? test.title : 'Unhandled Error';\n \t\t\t\tconst beforeSpacing = index === 0 ? '\\n\\n' : '\\n\\n\\n\\n';\n \n-\t\t\t\tstatus += beforeSpacing + '  ' + colors.title(title) + '\\n';\n+\t\t\t\tstatus += beforeSpacing + '  ' + colors.title(test.title) + '\\n';\n \t\t\t\tif (test.error.source) {\n \t\t\t\t\tstatus += '  ' + colors.errorSource(test.error.source.file + ':' + test.error.source.line) + '\\n';\n \n@@ -192,12 +191,14 @@ class MiniReporter {\n \t\t\t\t\t}\n \t\t\t\t}\n \n-\t\t\t\tif (test.error.showOutput) {\n-\t\t\t\t\tstatus += '\\n' + indentString(formatAssertError(test.error), 2);\n+\t\t\t\tif (test.error.avaAssertionError) {\n+\t\t\t\t\tconst formatted = formatAssertError(test.error);\n+\t\t\t\t\tif (formatted) {\n+\t\t\t\t\t\tstatus += '\\n' + indentString(formatted, 2);\n+\t\t\t\t\t}\n \t\t\t\t}\n \n-\t\t\t\t// `.trim()` is needed, because default `err.message` is ' ' (see lib/assert.js)\n-\t\t\t\tif (test.error.message.trim()) {\n+\t\t\t\tif (test.error.message) {\n \t\t\t\t\tstatus += '\\n' + indentString(test.error.message, 2) + '\\n';\n \t\t\t\t}\n "
      },
      {
        "sha": "4aed8f41a336bdc2e93f12c417b6dea69c5ff841",
        "filename": "lib/reporters/tap.js",
        "status": "modified",
        "additions": 16,
        "deletions": 9,
        "changes": 25,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Freporters%2Ftap.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Freporters%2Ftap.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Ftap.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -11,22 +11,29 @@ function getSourceFromStack(stack) {\n }\n \n function dumpError(error, includeMessage) {\n-\tconst obj = {};\n+\tconst obj = Object.assign({}, error.object);\n \tif (error.name) {\n \t\tobj.name = error.name;\n \t}\n \tif (includeMessage && error.message) {\n \t\tobj.message = error.message;\n \t}\n-\tif (error.operator) {\n-\t\tobj.operator = error.operator;\n-\t}\n-\tif (typeof error.actual === 'string') { // Be sure to print empty strings, which are falsy\n-\t\tobj.actual = stripAnsi(error.actual);\n-\t}\n-\tif (typeof error.expected === 'string') { // Be sure to print empty strings, which are falsy\n-\t\tobj.expected = stripAnsi(error.expected);\n+\n+\tif (error.avaAssertionError) {\n+\t\tif (error.assertion) {\n+\t\t\tobj.assertion = error.assertion;\n+\t\t}\n+\t\tif (error.operator) {\n+\t\t\tobj.operator = error.operator;\n+\t\t}\n+\t\tif (error.actual) {\n+\t\t\tobj.actual = stripAnsi(error.actual.formatted);\n+\t\t}\n+\t\tif (error.expected) {\n+\t\t\tobj.expected = stripAnsi(error.expected.formatted);\n+\t\t}\n \t}\n+\n \tif (error.stack) {\n \t\tobj.at = getSourceFromStack(error.stack);\n \t}"
      },
      {
        "sha": "4b9c9212030a3e65ff55a461c2b951f4f459d9c8",
        "filename": "lib/reporters/verbose.js",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Freporters%2Fverbose.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Freporters%2Fverbose.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Fverbose.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -111,12 +111,14 @@ class VerboseReporter {\n \t\t\t\t\t}\n \t\t\t\t}\n \n-\t\t\t\tif (test.error.showOutput) {\n-\t\t\t\t\toutput += '\\n' + indentString(formatAssertError(test.error), 2);\n+\t\t\t\tif (test.error.avaAssertionError) {\n+\t\t\t\t\tconst formatted = formatAssertError(test.error);\n+\t\t\t\t\tif (formatted) {\n+\t\t\t\t\t\toutput += '\\n' + indentString(formatted, 2);\n+\t\t\t\t\t}\n \t\t\t\t}\n \n-\t\t\t\t// `.trim()` is needed, because default `err.message` is ' ' (see lib/assert.js)\n-\t\t\t\tif (test.error.message.trim()) {\n+\t\t\t\tif (test.error.message) {\n \t\t\t\t\toutput += '\\n' + indentString(test.error.message, 2) + '\\n';\n \t\t\t\t}\n "
      },
      {
        "sha": "6526f7bdc3051c5a10181ebe7cbf00396a717090",
        "filename": "lib/run-status.js",
        "status": "modified",
        "additions": 1,
        "deletions": 17,
        "changes": 18,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Frun-status.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Frun-status.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Frun-status.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -1,7 +1,6 @@\n 'use strict';\n const EventEmitter = require('events');\n const chalk = require('chalk');\n-const isObj = require('is-obj');\n const flatten = require('arr-flatten');\n const figures = require('figures');\n const autoBind = require('auto-bind');\n@@ -17,16 +16,6 @@ function sum(arr, key) {\n \treturn result;\n }\n \n-function normalizeError(err) {\n-\tif (!isObj(err) || typeof err.message !== 'string') {\n-\t\terr = {\n-\t\t\tmessage: String(err)\n-\t\t};\n-\t}\n-\n-\treturn err;\n-}\n-\n class RunStatus extends EventEmitter {\n \tconstructor(opts) {\n \t\tsuper();\n@@ -68,7 +57,6 @@ class RunStatus extends EventEmitter {\n \t\tthis.rejectionCount += data.rejections.length;\n \n \t\tdata.rejections.forEach(err => {\n-\t\t\terr = normalizeError(err);\n \t\t\terr.type = 'rejection';\n \t\t\terr.file = data.file;\n \t\t\tthis.emit('error', err, this);\n@@ -77,7 +65,7 @@ class RunStatus extends EventEmitter {\n \t}\n \thandleExceptions(data) {\n \t\tthis.exceptionCount++;\n-\t\tconst err = normalizeError(data.exception);\n+\t\tconst err = data.exception;\n \t\terr.type = 'exception';\n \t\terr.file = data.file;\n \t\tthis.emit('error', err, this);\n@@ -99,10 +87,6 @@ class RunStatus extends EventEmitter {\n \t\ttest.title = this.prefixTitle(test.file) + test.title;\n \n \t\tif (test.error) {\n-\t\t\tif (test.error.name !== 'AssertionError') {\n-\t\t\t\ttest.error.message = `Error: ${test.error.message}`;\n-\t\t\t}\n-\n \t\t\tthis.errors.push(test);\n \t\t}\n "
      },
      {
        "sha": "bb16e476f615abd4b72b4a9b2faa8c442b9aac37",
        "filename": "lib/serialize-error.js",
        "status": "modified",
        "additions": 77,
        "deletions": 54,
        "changes": 131,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Fserialize-error.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Fserialize-error.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fserialize-error.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -4,6 +4,7 @@ const cleanYamlObject = require('clean-yaml-object');\n const StackUtils = require('stack-utils');\n const prettyFormat = require('@ava/pretty-format');\n const reactTestPlugin = require('@ava/pretty-format/plugins/ReactTestComponent');\n+const assert = require('./assert');\n const beautifyStack = require('./beautify-stack');\n const extractStack = require('./extract-stack');\n \n@@ -15,75 +16,97 @@ function serializeValue(value) {\n \t});\n }\n \n-function filter(propertyName, isRoot, source, target) {\n-\tif (!isRoot) {\n-\t\treturn true;\n-\t}\n+function isAvaAssertionError(source) {\n+\treturn source instanceof assert.AssertionError;\n+}\n \n-\tif ((propertyName === 'name' || propertyName === 'stack') &&\n-\t\ttypeof source[propertyName] !== 'string') {\n-\t\treturn false;\n-\t}\n+function filter(propertyName, isRoot) {\n+\treturn !isRoot || (propertyName !== 'message' && propertyName !== 'name' && propertyName !== 'stack');\n+}\n \n-\tif (propertyName === 'stack') {\n-\t\ttarget.stack = beautifyStack(source.stack);\n-\t\treturn false;\n+const stackUtils = new StackUtils();\n+function buildSource(stack) {\n+\tif (!stack) {\n+\t\treturn null;\n \t}\n \n-\tif (propertyName === 'statements') {\n-\t\tif (source.showOutput) {\n-\t\t\ttarget.statements = JSON.stringify(source[propertyName].map(statement => {\n-\t\t\t\tconst path = statement[0];\n-\t\t\t\tconst value = serializeValue(statement[1]);\n-\n-\t\t\t\treturn [path, value];\n-\t\t\t}));\n-\t\t}\n-\n-\t\treturn false;\n+\tconst firstStackLine = extractStack(stack).split('\\n')[0];\n+\tconst source = stackUtils.parseLine(firstStackLine);\n+\tif (!source) {\n+\t\treturn null;\n \t}\n \n-\tif (propertyName === 'actual' || propertyName === 'expected') {\n-\t\tif (source.showOutput) {\n-\t\t\tconst value = source[propertyName];\n-\t\t\ttarget[propertyName + 'Type'] = typeof value;\n-\t\t\ttarget[propertyName] = serializeValue(value);\n-\t\t}\n+\t// Assume the CWD is the project directory. This holds since this function\n+\t// is only called in test workers, which are created with their working\n+\t// directory set to the project directory.\n+\tconst projectDir = process.cwd();\n \n-\t\treturn false;\n-\t}\n+\tconst file = path.resolve(projectDir, source.file.trim());\n+\tconst rel = path.relative(projectDir, file);\n \n-\treturn true;\n-}\n+\tconst isWithinProject = rel.split(path.sep)[0] !== '..';\n+\tconst isDependency = isWithinProject && path.dirname(rel).split(path.sep).indexOf('node_modules') > -1;\n \n-const stackUtils = new StackUtils();\n+\treturn {\n+\t\tisDependency,\n+\t\tisWithinProject,\n+\t\tfile,\n+\t\tline: source.line\n+\t};\n+}\n \n module.exports = error => {\n-\tconst err = cleanYamlObject(error, filter);\n-\n-\tif (err.stack) {\n-\t\tconst firstStackLine = extractStack(err.stack).split('\\n')[0];\n-\t\tconst source = stackUtils.parseLine(firstStackLine);\n-\t\tif (source) {\n-\t\t\t// Assume the CWD is the project directory. This holds since this function\n-\t\t\t// is only called in test workers, which are created with their working\n-\t\t\t// directory set to the project directory.\n-\t\t\tconst projectDir = process.cwd();\n-\n-\t\t\tconst file = path.resolve(projectDir, source.file.trim());\n-\t\t\tconst rel = path.relative(projectDir, file);\n+\tconst stack = typeof error.stack === 'string' ?\n+\t\tbeautifyStack(error.stack) :\n+\t\tnull;\n+\tconst source = buildSource(stack);\n+\tconst retval = {\n+\t\tavaAssertionError: isAvaAssertionError(error),\n+\t\tsource\n+\t};\n+\tif (stack) {\n+\t\tretval.stack = stack;\n+\t}\n \n-\t\t\tconst isWithinProject = rel.split(path.sep)[0] !== '..';\n-\t\t\tconst isDependency = isWithinProject && path.dirname(rel).split(path.sep).indexOf('node_modules') > -1;\n+\tif (retval.avaAssertionError) {\n+\t\tretval.message = error.message;\n+\t\tretval.name = error.name;\n \n-\t\t\terr.source = {\n-\t\t\t\tisDependency,\n-\t\t\t\tisWithinProject,\n-\t\t\t\tfile,\n-\t\t\t\tline: source.line\n+\t\tif (error.assertion) {\n+\t\t\tretval.assertion = error.assertion;\n+\t\t}\n+\t\tif (error.operator) {\n+\t\t\tretval.operator = error.operator;\n+\t\t}\n+\t\tif (error.hasActual) {\n+\t\t\tretval.actual = {\n+\t\t\t\ttype: typeof error.actual,\n+\t\t\t\tformatted: serializeValue(error.actual)\n+\t\t\t};\n+\t\t}\n+\t\tif (error.hasExpected) {\n+\t\t\tretval.expected = {\n+\t\t\t\ttype: typeof error.expected,\n+\t\t\t\tformatted: serializeValue(error.expected)\n \t\t\t};\n \t\t}\n+\t\tif (error.statements) {\n+\t\t\tretval.statements = JSON.stringify(error.statements.map(statement => {\n+\t\t\t\tconst path = statement[0];\n+\t\t\t\tconst value = serializeValue(statement[1]);\n+\n+\t\t\t\treturn [path, value];\n+\t\t\t}));\n+\t\t}\n+\t} else {\n+\t\tretval.object = cleanYamlObject(error, filter); // Cleanly copy non-standard properties\n+\t\tif (typeof error.message === 'string') {\n+\t\t\tretval.message = error.message;\n+\t\t}\n+\t\tif (typeof error.name === 'string') {\n+\t\t\tretval.name = error.name;\n+\t\t}\n \t}\n \n-\treturn err;\n+\treturn retval;\n };"
      },
      {
        "sha": "d9c7309b2febda96fc1e704330c60ab2983e83a1",
        "filename": "lib/test-worker.js",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Ftest-worker.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Ftest-worker.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Ftest-worker.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -1,5 +1,6 @@\n 'use strict';\n /* eslint-disable import/order */\n+const isObj = require('is-obj');\n const process = require('./process-adapter');\n \n const opts = process.opts;\n@@ -44,6 +45,7 @@ process.on('uncaughtException', exception => {\n \t\t// Avoid using serializeError\n \t\tconst err = new Error('Failed to serialize uncaught exception');\n \t\tserialized = {\n+\t\t\tavaAssertionError: false,\n \t\t\tname: err.name,\n \t\t\tmessage: err.message,\n \t\t\tstack: err.stack\n@@ -91,7 +93,13 @@ process.on('ava-teardown', () => {\n \t}\n \n \trejections = rejections.map(rejection => {\n-\t\treturn serializeError(rejection.reason);\n+\t\tlet reason = rejection.reason;\n+\t\tif (!isObj(reason) || typeof reason.message !== 'string') {\n+\t\t\treason = {\n+\t\t\t\tmessage: String(reason)\n+\t\t\t};\n+\t\t}\n+\t\treturn serializeError(reason);\n \t});\n \n \tsend('unhandledRejections', {rejections});"
      },
      {
        "sha": "d3b4a8bc3ca3ff3a81b1c942650aa716b7ebbfbc",
        "filename": "lib/test.js",
        "status": "modified",
        "additions": 66,
        "deletions": 97,
        "changes": 163,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/lib%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Ftest.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -1,5 +1,4 @@\n 'use strict';\n-const inspect = require('util').inspect;\n const isGeneratorFn = require('is-generator-fn');\n const maxTimeout = require('max-timeout');\n const Promise = require('bluebird');\n@@ -10,27 +9,16 @@ const isPromise = require('is-promise');\n const isObservable = require('is-observable');\n const plur = require('plur');\n const assert = require('./assert');\n-const enhanceAssert = require('./enhance-assert');\n const globals = require('./globals');\n const throwsHelper = require('./throws-helper');\n \n-const formatter = enhanceAssert.formatter();\n-\n class SkipApi {\n \tconstructor(test) {\n \t\tthis._test = test;\n \t}\n }\n \n-function skipFn() {\n-\treturn this._test._assert(null);\n-}\n-\n-Object.keys(assert).forEach(el => {\n-\tSkipApi.prototype[el] = skipFn;\n-});\n-\n-class PublicApi {\n+class ExecutionContext {\n \tconstructor(test) {\n \t\tthis._test = test;\n \t\tthis.skip = new SkipApi(test);\n@@ -43,6 +31,12 @@ class PublicApi {\n \t\tError.stackTraceLimit = limitBefore;\n \t\tthis._test.plan(ct, obj.stack);\n \t}\n+\tget end() {\n+\t\treturn this._test.end;\n+\t}\n+\tget title() {\n+\t\treturn this._test.title;\n+\t}\n \tget context() {\n \t\tconst contextRef = this._test.contextRef;\n \t\treturn contextRef && contextRef.context;\n@@ -58,61 +52,31 @@ class PublicApi {\n \t\tcontextRef.context = context;\n \t}\n }\n+Object.defineProperty(ExecutionContext.prototype, 'context', {enumerable: true});\n \n-function onAssertionEvent(event) {\n-\tif (event.assertionThrew) {\n-\t\tif (event.powerAssertContext) {\n-\t\t\tevent.error.statements = formatter(event.powerAssertContext);\n-\t\t\tevent.error.message = event.originalMessage || '';\n-\t\t}\n-\t\tthis._test._setAssertError(event.error);\n-\t\tthis._test._assert(null);\n-\t\treturn null;\n-\t}\n-\n-\tlet ret = event.returnValue;\n-\n-\tif (isObservable(ret)) {\n-\t\tret = observableToPromise(ret);\n-\t}\n+{\n+\tconst assertions = assert.wrapAssertions({\n+\t\tpass(executionContext) {\n+\t\t\texecutionContext._test._assertionPassed();\n+\t\t},\n \n-\tif (isPromise(ret)) {\n-\t\tconst promise = ret.then(null, err => {\n-\t\t\terr.originalMessage = event.originalMessage;\n-\t\t\tthrow err;\n-\t\t});\n+\t\tpending(executionContext, promise) {\n+\t\t\texecutionContext._test._assertionPending(promise);\n+\t\t},\n \n-\t\tthis._test._assert(promise);\n+\t\tfail(executionContext, error) {\n+\t\t\texecutionContext._test._assertionFailed(error);\n+\t\t}\n+\t});\n+\tObject.assign(ExecutionContext.prototype, assertions);\n \n-\t\treturn promise;\n+\tfunction skipFn() {\n+\t\tthis._test._assertionPassed();\n \t}\n-\n-\tthis._test._assert(null);\n-\n-\treturn ret;\n-}\n-\n-Object.assign(PublicApi.prototype, enhanceAssert({\n-\tassert,\n-\tonSuccess: onAssertionEvent,\n-\tonError: onAssertionEvent\n-}));\n-\n-// Getters\n-[\n-\t'assertCount',\n-\t'title',\n-\t'end'\n-]\n-\t.forEach(name => {\n-\t\tObject.defineProperty(PublicApi.prototype, name, {\n-\t\t\tget() {\n-\t\t\t\treturn this._test[name];\n-\t\t\t}\n-\t\t});\n+\tObject.keys(assertions).forEach(el => {\n+\t\tSkipApi.prototype[el] = skipFn;\n \t});\n-\n-Object.defineProperty(PublicApi.prototype, 'context', {enumerable: true});\n+}\n \n class Test {\n \tconstructor(title, fn, contextRef, report) {\n@@ -122,11 +86,14 @@ class Test {\n \t\t\ttitle = null;\n \t\t}\n \n-\t\tassert.is(typeof fn, 'function', 'You must provide a callback');\n+\t\tif (typeof fn !== 'function') {\n+\t\t\tthrow new Error('You must provide a callback');\n+\t\t}\n \n \t\tthis.title = title || fnName(fn) || '[anonymous]';\n \t\tthis.fn = isGeneratorFn(fn) ? co.wrap(fn) : fn;\n-\t\tthis.assertions = [];\n+\t\tthis.pendingAssertions = [];\n+\t\tthis.assertCount = 0;\n \t\tthis.planCount = null;\n \t\tthis.duration = null;\n \t\tthis.assertError = undefined;\n@@ -148,19 +115,19 @@ class Test {\n \t\t\tthis.title = '[anonymous]';\n \t\t}\n \t}\n-\tget assertCount() {\n-\t\treturn this.assertions.length;\n+\t_assertionPassed() {\n+\t\tthis.assertCount++;\n \t}\n-\t_assert(promise) {\n-\t\tif (isPromise(promise)) {\n-\t\t\tthis.sync = false;\n-\t\t}\n-\n-\t\tthis.assertions.push(promise);\n+\t_assertionPending(promise) {\n+\t\tthis.sync = false;\n+\t\tthis.assertCount++;\n+\t\tthis.pendingAssertions.push(promise);\n+\t}\n+\t_assertionFailed(error) {\n+\t\tthis._setAssertError(error);\n+\t\tthis.assertCount++;\n \t}\n \t_setAssertError(err) {\n-\t\tthrowsHelper(err);\n-\n \t\tif (this.assertError !== undefined) {\n \t\t\treturn;\n \t\t}\n@@ -182,19 +149,20 @@ class Test {\n \t\tlet ret;\n \n \t\ttry {\n-\t\t\tret = this.fn(this._publicApi());\n+\t\t\tret = this.fn(this._createExecutionContext());\n \t\t} catch (err) {\n \t\t\tthis.threwSync = true;\n+\t\t\tthrowsHelper(err);\n \n-\t\t\tif (err instanceof Error) {\n-\t\t\t\tthis._setAssertError(err);\n-\t\t\t} else {\n-\t\t\t\tthis._setAssertError(new assert.AssertionError({\n+\t\t\tlet error = err;\n+\t\t\tif (!(err instanceof assert.AssertionError)) {\n+\t\t\t\terror = new assert.AssertionError({\n \t\t\t\t\tactual: err,\n-\t\t\t\t\tmessage: `Non-error thrown with value: ${inspect(err, {depth: null})}`,\n-\t\t\t\t\toperator: 'catch'\n-\t\t\t\t}));\n+\t\t\t\t\tmessage: `Error thrown in test`,\n+\t\t\t\t\tstack: err instanceof Error && err.stack\n+\t\t\t\t});\n \t\t\t}\n+\t\t\tthis._setAssertError(error);\n \t\t}\n \n \t\treturn ret;\n@@ -244,11 +212,13 @@ class Test {\n \t\t\treturn Promise.resolve(ret).then(\n \t\t\t\t() => this.exit(),\n \t\t\t\terr => {\n-\t\t\t\t\tif (!(err instanceof Error)) {\n+\t\t\t\t\tthrowsHelper(err);\n+\n+\t\t\t\t\tif (!(err instanceof assert.AssertionError)) {\n \t\t\t\t\t\terr = new assert.AssertionError({\n \t\t\t\t\t\t\tactual: err,\n-\t\t\t\t\t\t\tmessage: `Promise rejected with: ${inspect(err, {depth: null})}`,\n-\t\t\t\t\t\t\toperator: 'promise'\n+\t\t\t\t\t\t\tmessage: 'Rejected promise returned by test',\n+\t\t\t\t\t\t\tstack: err instanceof Error && err.stack\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \n@@ -293,11 +263,10 @@ class Test {\n \t}\n \t_end(err) {\n \t\tif (err) {\n-\t\t\tif (!(err instanceof Error)) {\n+\t\t\tif (!(err instanceof assert.AssertionError)) {\n \t\t\t\terr = new assert.AssertionError({\n \t\t\t\t\tactual: err,\n-\t\t\t\t\tmessage: 'Callback called with an error: ' + inspect(err, {depth: null}),\n-\t\t\t\t\toperator: 'callback'\n+\t\t\t\t\tmessage: 'Callback called with an error'\n \t\t\t\t});\n \t\t\t}\n \n@@ -316,15 +285,15 @@ class Test {\n \t\tthis.exit();\n \t}\n \t_checkPlanCount() {\n-\t\tif (this.assertError === undefined && this.planCount !== null && this.planCount !== this.assertions.length) {\n+\t\tif (this.assertError === undefined && this.planCount !== null && this.planCount !== this.assertCount) {\n \t\t\tthis._setAssertError(new assert.AssertionError({\n-\t\t\t\tactual: this.assertions.length,\n+\t\t\t\tactual: this.assertCount,\n+\t\t\t\tassertion: 'plan',\n \t\t\t\texpected: this.planCount,\n-\t\t\t\tmessage: `Planned for ${this.planCount} ${plur('assertion', this.planCount)}, but got ${this.assertions.length}.`,\n-\t\t\t\toperator: 'plan'\n+\t\t\t\tmessage: `Planned for ${this.planCount} ${plur('assertion', this.planCount)}, but got ${this.assertCount}.`,\n+\t\t\t\toperator: '===',\n+\t\t\t\tstack: this.planStack\n \t\t\t}));\n-\n-\t\t\tthis.assertError.stack = this.planStack;\n \t\t}\n \t}\n \texit() {\n@@ -343,7 +312,7 @@ class Test {\n \t\t\treturn result;\n \t\t}\n \n-\t\tPromise.all(this.assertions)\n+\t\tPromise.all(this.pendingAssertions)\n \t\t\t.catch(err => {\n \t\t\t\tthis._setAssertError(err);\n \t\t\t})\n@@ -361,8 +330,8 @@ class Test {\n \n \t\treturn this.promise().promise;\n \t}\n-\t_publicApi() {\n-\t\treturn new PublicApi(this);\n+\t_createExecutionContext() {\n+\t\treturn new ExecutionContext(this);\n \t}\n }\n "
      },
      {
        "sha": "685b76055f3aebbaf9fd2b340fd73a2da821a3bf",
        "filename": "test/assert.js",
        "status": "modified",
        "additions": 111,
        "deletions": 97,
        "changes": 208,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/test%2Fassert.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/test%2Fassert.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fassert.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -3,117 +3,127 @@ const test = require('tap').test;\n const sinon = require('sinon');\n const assert = require('../lib/assert');\n \n+const assertions = assert.wrapAssertions({\n+\tpass() {},\n+\n+\tpending() {},\n+\n+\tfail(_, error) {\n+\t\tthrow error;\n+\t}\n+});\n+\n test('.pass()', t => {\n \tt.doesNotThrow(() => {\n-\t\tassert.pass();\n+\t\tassertions.pass();\n \t});\n \n \tt.end();\n });\n \n test('.fail()', t => {\n \tt.throws(() => {\n-\t\tassert.fail();\n+\t\tassertions.fail();\n \t});\n \n \tt.end();\n });\n \n test('.truthy()', t => {\n \tt.throws(() => {\n-\t\tassert.truthy(0);\n-\t\tassert.truthy(false);\n+\t\tassertions.truthy(0);\n+\t\tassertions.truthy(false);\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.truthy(1);\n-\t\tassert.truthy(true);\n+\t\tassertions.truthy(1);\n+\t\tassertions.truthy(true);\n \t});\n \n \tt.end();\n });\n \n test('.falsy()', t => {\n \tt.throws(() => {\n-\t\tassert.falsy(1);\n-\t\tassert.falsy(true);\n+\t\tassertions.falsy(1);\n+\t\tassertions.falsy(true);\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.falsy(0);\n-\t\tassert.falsy(false);\n+\t\tassertions.falsy(0);\n+\t\tassertions.falsy(false);\n \t});\n \n \tt.end();\n });\n \n test('.true()', t => {\n \tt.throws(() => {\n-\t\tassert.true(1);\n+\t\tassertions.true(1);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.true(0);\n+\t\tassertions.true(0);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.true(false);\n+\t\tassertions.true(false);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.true('foo');\n+\t\tassertions.true('foo');\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.true(true);\n+\t\tassertions.true(true);\n \t});\n \n \tt.end();\n });\n \n test('.false()', t => {\n \tt.throws(() => {\n-\t\tassert.false(0);\n+\t\tassertions.false(0);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.false(1);\n+\t\tassertions.false(1);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.false(true);\n+\t\tassertions.false(true);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.false('foo');\n+\t\tassertions.false('foo');\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.false(false);\n+\t\tassertions.false(false);\n \t});\n \n \tt.end();\n });\n \n test('.is()', t => {\n \tt.doesNotThrow(() => {\n-\t\tassert.is('foo', 'foo');\n+\t\tassertions.is('foo', 'foo');\n \t});\n \n \tt.throws(() => {\n-\t\tassert.is('foo', 'bar');\n+\t\tassertions.is('foo', 'bar');\n \t});\n \n \tt.end();\n });\n \n test('.not()', t => {\n \tt.doesNotThrow(() => {\n-\t\tassert.not('foo', 'bar');\n+\t\tassertions.not('foo', 'bar');\n \t});\n \n \tt.throws(() => {\n-\t\tassert.not('foo', 'foo');\n+\t\tassertions.not('foo', 'foo');\n \t});\n \n \tt.end();\n@@ -124,11 +134,11 @@ test('.deepEqual()', t => {\n \t// used to test deep object equality\n \n \tt.throws(() => {\n-\t\tassert.deepEqual({a: false}, {a: 0});\n+\t\tassertions.deepEqual({a: false}, {a: 0});\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.deepEqual({\n+\t\tassertions.deepEqual({\n \t\t\ta: 'a',\n \t\t\tb: 'b'\n \t\t}, {\n@@ -138,7 +148,7 @@ test('.deepEqual()', t => {\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.deepEqual({\n+\t\tassertions.deepEqual({\n \t\t\ta: 'a',\n \t\t\tb: 'b',\n \t\t\tc: {\n@@ -154,17 +164,17 @@ test('.deepEqual()', t => {\n \t});\n \n \tt.throws(() => {\n-\t\tassert.deepEqual([1, 2, 3], [1, 2, 3, 4]);\n+\t\tassertions.deepEqual([1, 2, 3], [1, 2, 3, 4]);\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.deepEqual([1, 2, 3], [1, 2, 3]);\n+\t\tassertions.deepEqual([1, 2, 3], [1, 2, 3]);\n \t});\n \n \tt.throws(() => {\n \t\tconst fnA = a => a;\n \t\tconst fnB = a => a;\n-\t\tassert.deepEqual(fnA, fnB);\n+\t\tassertions.deepEqual(fnA, fnB);\n \t});\n \n \tt.doesNotThrow(() => {\n@@ -176,7 +186,7 @@ test('.deepEqual()', t => {\n \t\tconst y2 = {x: x2};\n \t\tx2.y = y2;\n \n-\t\tassert.deepEqual(x1, x2);\n+\t\tassertions.deepEqual(x1, x2);\n \t});\n \n \tt.doesNotThrow(() => {\n@@ -187,7 +197,7 @@ test('.deepEqual()', t => {\n \t\tconst x = new Foo(1);\n \t\tconst y = new Foo(1);\n \n-\t\tassert.deepEqual(x, y);\n+\t\tassertions.deepEqual(x, y);\n \t});\n \n \tt.throws(() => {\n@@ -202,11 +212,11 @@ test('.deepEqual()', t => {\n \t\tconst x = new Foo(1);\n \t\tconst y = new Bar(1);\n \n-\t\tassert.deepEqual(x, y);\n+\t\tassertions.deepEqual(x, y);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.deepEqual({\n+\t\tassertions.deepEqual({\n \t\t\ta: 'a',\n \t\t\tb: 'b',\n \t\t\tc: {\n@@ -222,73 +232,73 @@ test('.deepEqual()', t => {\n \t});\n \n \tt.throws(() => {\n-\t\tassert.deepEqual({}, []);\n+\t\tassertions.deepEqual({}, []);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.deepEqual({0: 'a', 1: 'b'}, ['a', 'b']);\n+\t\tassertions.deepEqual({0: 'a', 1: 'b'}, ['a', 'b']);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.deepEqual({a: 1}, {a: 1, b: undefined});\n+\t\tassertions.deepEqual({a: 1}, {a: 1, b: undefined});\n \t});\n \n \tt.throws(() => {\n-\t\tassert.deepEqual(new Date('1972-08-01'), null);\n+\t\tassertions.deepEqual(new Date('1972-08-01'), null);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.deepEqual(new Date('1972-08-01'), undefined);\n+\t\tassertions.deepEqual(new Date('1972-08-01'), undefined);\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.deepEqual(new Date('1972-08-01'), new Date('1972-08-01'));\n+\t\tassertions.deepEqual(new Date('1972-08-01'), new Date('1972-08-01'));\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.deepEqual({x: new Date('1972-08-01')}, {x: new Date('1972-08-01')});\n+\t\tassertions.deepEqual({x: new Date('1972-08-01')}, {x: new Date('1972-08-01')});\n \t});\n \n \tt.throws(() => {\n-\t\tassert.deepEqual(() => {}, () => {});\n+\t\tassertions.deepEqual(() => {}, () => {});\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.deepEqual(undefined, undefined);\n-\t\tassert.deepEqual({x: undefined}, {x: undefined});\n-\t\tassert.deepEqual({x: [undefined]}, {x: [undefined]});\n+\t\tassertions.deepEqual(undefined, undefined);\n+\t\tassertions.deepEqual({x: undefined}, {x: undefined});\n+\t\tassertions.deepEqual({x: [undefined]}, {x: [undefined]});\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.deepEqual(null, null);\n-\t\tassert.deepEqual({x: null}, {x: null});\n-\t\tassert.deepEqual({x: [null]}, {x: [null]});\n+\t\tassertions.deepEqual(null, null);\n+\t\tassertions.deepEqual({x: null}, {x: null});\n+\t\tassertions.deepEqual({x: [null]}, {x: [null]});\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.deepEqual(0, 0);\n-\t\tassert.deepEqual(1, 1);\n-\t\tassert.deepEqual(3.14, 3.14);\n+\t\tassertions.deepEqual(0, 0);\n+\t\tassertions.deepEqual(1, 1);\n+\t\tassertions.deepEqual(3.14, 3.14);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.deepEqual(0, 1);\n+\t\tassertions.deepEqual(0, 1);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.deepEqual(1, -1);\n+\t\tassertions.deepEqual(1, -1);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.deepEqual(3.14, 2.72);\n+\t\tassertions.deepEqual(3.14, 2.72);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.deepEqual({0: 'a', 1: 'b'}, ['a', 'b']);\n+\t\tassertions.deepEqual({0: 'a', 1: 'b'}, ['a', 'b']);\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.deepEqual(\n+\t\tassertions.deepEqual(\n \t\t\t[\n \t\t\t\t{foo: {z: 100, y: 200, x: 300}},\n \t\t\t\t'bar',\n@@ -305,7 +315,7 @@ test('.deepEqual()', t => {\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.deepEqual(\n+\t\tassertions.deepEqual(\n \t\t\t{x: {a: 1, b: 2}, y: {c: 3, d: 4}},\n \t\t\t{y: {d: 4, c: 3}, x: {b: 2, a: 1}}\n \t\t);\n@@ -314,61 +324,61 @@ test('.deepEqual()', t => {\n \t// Regression test end here\n \n \tt.doesNotThrow(() => {\n-\t\tassert.deepEqual({a: 'a'}, {a: 'a'});\n+\t\tassertions.deepEqual({a: 'a'}, {a: 'a'});\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.deepEqual(['a', 'b'], ['a', 'b']);\n+\t\tassertions.deepEqual(['a', 'b'], ['a', 'b']);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.deepEqual({a: 'a'}, {a: 'b'});\n+\t\tassertions.deepEqual({a: 'a'}, {a: 'b'});\n \t});\n \n \tt.throws(() => {\n-\t\tassert.deepEqual(['a', 'b'], ['a', 'a']);\n+\t\tassertions.deepEqual(['a', 'b'], ['a', 'a']);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.deepEqual([['a', 'b'], 'c'], [['a', 'b'], 'd']);\n+\t\tassertions.deepEqual([['a', 'b'], 'c'], [['a', 'b'], 'd']);\n \t});\n \n \tt.throws(() => {\n \t\tconst circular = ['a', 'b'];\n \t\tcircular.push(circular);\n-\t\tassert.deepEqual([circular, 'c'], [circular, 'd']);\n+\t\tassertions.deepEqual([circular, 'c'], [circular, 'd']);\n \t});\n \n \tt.end();\n });\n \n test('.notDeepEqual()', t => {\n \tt.doesNotThrow(() => {\n-\t\tassert.notDeepEqual({a: 'a'}, {a: 'b'});\n+\t\tassertions.notDeepEqual({a: 'a'}, {a: 'b'});\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.notDeepEqual(['a', 'b'], ['c', 'd']);\n+\t\tassertions.notDeepEqual(['a', 'b'], ['c', 'd']);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.notDeepEqual({a: 'a'}, {a: 'a'});\n+\t\tassertions.notDeepEqual({a: 'a'}, {a: 'a'});\n \t});\n \n \tt.throws(() => {\n-\t\tassert.notDeepEqual(['a', 'b'], ['a', 'b']);\n+\t\tassertions.notDeepEqual(['a', 'b'], ['a', 'b']);\n \t});\n \n \tt.end();\n });\n \n test('.throws()', t => {\n \tt.throws(() => {\n-\t\tassert.throws(() => {});\n+\t\tassertions.throws(() => {});\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.throws(() => {\n+\t\tassertions.throws(() => {\n \t\t\tthrow new Error('foo');\n \t\t});\n \t});\n@@ -378,7 +388,7 @@ test('.throws()', t => {\n \n test('.throws() returns the thrown error', t => {\n \tconst expected = new Error();\n-\tconst actual = assert.throws(() => {\n+\tconst actual = assertions.throws(() => {\n \t\tthrow expected;\n \t});\n \n@@ -390,7 +400,7 @@ test('.throws() returns the thrown error', t => {\n test('.throws() returns the rejection reason of promise', t => {\n \tconst expected = new Error();\n \n-\treturn assert.throws(Promise.reject(expected)).then(actual => {\n+\treturn assertions.throws(Promise.reject(expected)).then(actual => {\n \t\tt.is(actual, expected);\n \t\tt.end();\n \t});\n@@ -400,69 +410,75 @@ test('.throws should throw if passed a bad value', t => {\n \tt.plan(1);\n \n \tt.throws(() => {\n-\t\tassert.throws('not a function');\n+\t\tassertions.throws('not a function');\n \t}, {\n-\t\tname: 'TypeError',\n-\t\tmessage: /t\\.throws must be called with a function, Promise, or Observable/\n+\t\tname: 'AssertionError',\n+\t\tmessage: /`t\\.throws\\(\\)` must be called with a function, Promise, or Observable/\n \t});\n });\n \n test('.notThrows should throw if passed a bad value', t => {\n \tt.plan(1);\n \n \tt.throws(() => {\n-\t\tassert.notThrows('not a function');\n+\t\tassertions.notThrows('not a function');\n \t}, {\n-\t\tname: 'TypeError',\n-\t\tmessage: /t\\.notThrows must be called with a function, Promise, or Observable/\n+\t\tname: 'AssertionError',\n+\t\tmessage: /`t\\.notThrows\\(\\)` must be called with a function, Promise, or Observable/\n \t});\n });\n \n test('.notThrows()', t => {\n \tt.doesNotThrow(() => {\n-\t\tassert.notThrows(() => {});\n+\t\tassertions.notThrows(() => {});\n \t});\n \n \tt.throws(() => {\n-\t\tassert.notThrows(() => {\n+\t\tassertions.notThrows(() => {\n \t\t\tthrow new Error('foo');\n \t\t});\n \t});\n \n \tt.end();\n });\n \n+test('.notThrows() returns undefined for a fulfilled promise', t => {\n+\treturn assertions.notThrows(Promise.resolve(Symbol(''))).then(actual => {\n+\t\tt.is(actual, undefined);\n+\t});\n+});\n+\n test('.regex()', t => {\n \tt.doesNotThrow(() => {\n-\t\tassert.regex('abc', /^abc$/);\n+\t\tassertions.regex('abc', /^abc$/);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.regex('foo', /^abc$/);\n+\t\tassertions.regex('foo', /^abc$/);\n \t});\n \n \tt.end();\n });\n \n test('.notRegex()', t => {\n \tt.doesNotThrow(() => {\n-\t\tassert.notRegex('abc', /def/);\n+\t\tassertions.notRegex('abc', /def/);\n \t});\n \n \tt.throws(() => {\n-\t\tassert.notRegex('abc', /abc/);\n+\t\tassertions.notRegex('abc', /abc/);\n \t});\n \n \tt.end();\n });\n \n test('.ifError()', t => {\n \tt.throws(() => {\n-\t\tassert.ifError(new Error());\n+\t\tassertions.ifError(new Error());\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.ifError(null);\n+\t\tassertions.ifError(null);\n \t});\n \n \tt.end();\n@@ -477,11 +493,11 @@ test('.deepEqual() should not mask RangeError from underlying assert', t => {\n \tconst b = new Circular();\n \n \tt.throws(() => {\n-\t\tassert.notDeepEqual(a, b);\n+\t\tassertions.notDeepEqual(a, b);\n \t});\n \n \tt.doesNotThrow(() => {\n-\t\tassert.deepEqual(a, b);\n+\t\tassertions.deepEqual(a, b);\n \t});\n \n \tt.end();\n@@ -493,12 +509,14 @@ test('snapshot makes a snapshot using a library and global options', t => {\n \tconst stateGetter = sinon.stub().returns(state);\n \tconst matchStub = sinon.stub().returns({pass: true});\n \n-\tassert.title = 'Test name';\n+\tconst test = {\n+\t\ttitle: 'Test name'\n+\t};\n \n \tt.plan(4);\n \n \tt.doesNotThrow(() => {\n-\t\tassert._snapshot('tree', undefined, matchStub, stateGetter);\n+\t\tassert.snapshot(test, 'tree', undefined, matchStub, stateGetter);\n \t});\n \n \tt.ok(stateGetter.called);\n@@ -509,9 +527,6 @@ test('snapshot makes a snapshot using a library and global options', t => {\n \t});\n \n \tt.ok(saveSpy.calledOnce);\n-\n-\tdelete assert.title;\n-\n \tt.end();\n });\n \n@@ -521,7 +536,9 @@ test('snapshot handles jsx tree', t => {\n \tconst stateGetter = sinon.stub().returns(state);\n \tconst matchStub = sinon.stub().returns({pass: true});\n \n-\tassert.title = 'Test name';\n+\tconst test = {\n+\t\ttitle: 'Test name'\n+\t};\n \n \tt.plan(5);\n \n@@ -534,7 +551,7 @@ test('snapshot handles jsx tree', t => {\n \n \t\tObject.defineProperty(tree, '$$typeof', {value: Symbol.for('react.test.json')});\n \n-\t\tassert._snapshot(tree, undefined, matchStub, stateGetter);\n+\t\tassert.snapshot(test, tree, undefined, matchStub, stateGetter);\n \t});\n \n \tt.ok(stateGetter.called);\n@@ -554,8 +571,5 @@ test('snapshot handles jsx tree', t => {\n \t});\n \n \tt.ok(saveSpy.calledOnce);\n-\n-\tdelete assert.title;\n-\n \tt.end();\n });"
      },
      {
        "sha": "8bb22b80e56bdbee5914b9b9de82986939f10268",
        "filename": "test/format-assert-error.js",
        "status": "modified",
        "additions": 67,
        "deletions": 21,
        "changes": 88,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/test%2Fformat-assert-error.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/test%2Fformat-assert-error.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fformat-assert-error.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -26,10 +26,14 @@ test('render statements', t => {\n \n test('diff objects', t => {\n \tconst err = {\n-\t\tactual: prettyFormat({a: 1}),\n-\t\texpected: prettyFormat({a: 2}),\n-\t\tactualType: 'object',\n-\t\texpectedType: 'object'\n+\t\tactual: {\n+\t\t\ttype: 'object',\n+\t\t\tformatted: prettyFormat({a: 1})\n+\t\t},\n+\t\texpected: {\n+\t\t\ttype: 'object',\n+\t\t\tformatted: prettyFormat({a: 2})\n+\t\t}\n \t};\n \n \tt.is(format(err), [\n@@ -38,17 +42,21 @@ test('diff objects', t => {\n \t\t`${chalk.red('-')}   a: 1,`,\n \t\t`${chalk.green('+')}   a: 2,`,\n \t\t'  }',\n-\t\t' '\n+\t\t''\n \t].join('\\n'));\n \tt.end();\n });\n \n test('diff arrays', t => {\n \tconst err = {\n-\t\tactual: prettyFormat([1]),\n-\t\texpected: prettyFormat([2]),\n-\t\tactualType: 'array',\n-\t\texpectedType: 'array'\n+\t\tactual: {\n+\t\t\ttype: 'array',\n+\t\t\tformatted: prettyFormat([1])\n+\t\t},\n+\t\texpected: {\n+\t\t\ttype: 'array',\n+\t\t\tformatted: prettyFormat([2])\n+\t\t}\n \t};\n \n \tt.is(format(err), [\n@@ -57,17 +65,21 @@ test('diff arrays', t => {\n \t\t`${chalk.red('-')}   1,`,\n \t\t`${chalk.green('+')}   2,`,\n \t\t'  ]',\n-\t\t' '\n+\t\t''\n \t].join('\\n'));\n \tt.end();\n });\n \n test('diff strings', t => {\n \tconst err = {\n-\t\tactual: 'abc',\n-\t\texpected: 'abd',\n-\t\tactualType: 'string',\n-\t\texpectedType: 'string'\n+\t\tactual: {\n+\t\t\ttype: 'string',\n+\t\t\tformatted: 'abc'\n+\t\t},\n+\t\texpected: {\n+\t\t\ttype: 'string',\n+\t\t\tformatted: 'abd'\n+\t\t}\n \t};\n \n \tt.is(format(err), [\n@@ -77,19 +89,53 @@ test('diff strings', t => {\n \tt.end();\n });\n \n-test('diff different types', t => {\n+test('print different types', t => {\n \tconst err = {\n-\t\tactual: prettyFormat([1, 2, 3]),\n-\t\texpected: prettyFormat({a: 1, b: 2, c: 3}),\n-\t\tactualType: 'array',\n-\t\texpectedType: 'object'\n+\t\tactual: {\n+\t\t\ttype: 'array',\n+\t\t\tformatted: prettyFormat([1, 2, 3])\n+\t\t},\n+\t\texpected: {\n+\t\t\ttype: 'object',\n+\t\t\tformatted: prettyFormat({a: 1, b: 2, c: 3})\n+\t\t}\n \t};\n \n \tt.is(format(err), [\n \t\t'Actual:\\n',\n-\t\t`${indentString(err.actual, 2)}\\n`,\n+\t\t`${indentString(err.actual.formatted, 2)}\\n`,\n \t\t'Expected:\\n',\n-\t\t`${indentString(err.expected, 2)}\\n`\n+\t\t`${indentString(err.expected.formatted, 2)}\\n`\n+\t].join('\\n'));\n+\tt.end();\n+});\n+\n+test('print actual even if no expected', t => {\n+\tconst err = {\n+\t\tactual: {\n+\t\t\ttype: 'array',\n+\t\t\tformatted: prettyFormat([1, 2, 3])\n+\t\t}\n+\t};\n+\n+\tt.is(format(err), [\n+\t\t'Actual:\\n',\n+\t\t`${indentString(err.actual.formatted, 2)}\\n`\n+\t].join('\\n'));\n+\tt.end();\n+});\n+\n+test('print expected even if no actual', t => {\n+\tconst err = {\n+\t\texpected: {\n+\t\t\ttype: 'array',\n+\t\t\tformatted: prettyFormat([1, 2, 3])\n+\t\t}\n+\t};\n+\n+\tt.is(format(err), [\n+\t\t'Expected:\\n',\n+\t\t`${indentString(err.expected.formatted, 2)}\\n`\n \t].join('\\n'));\n \tt.end();\n });"
      },
      {
        "sha": "aa50a542c0292caa8352b1d892b3d491bbe68729",
        "filename": "test/promise.js",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/test%2Fpromise.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/test%2Fpromise.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fpromise.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -293,8 +293,8 @@ test('reject', t => {\n \t\t});\n \t}).run().then(result => {\n \t\tt.is(result.passed, false);\n-\t\tt.is(result.reason.name, 'Error');\n-\t\tt.is(result.reason.message, 'unicorn');\n+\t\tt.is(result.reason.actual.name, 'Error');\n+\t\tt.is(result.reason.actual.message, 'unicorn');\n \t\tt.end();\n \t});\n });\n@@ -303,7 +303,8 @@ test('reject with non-Error', t => {\n \tava(() => Promise.reject('failure')).run().then(result => {\n \t\tt.is(result.passed, false);\n \t\tt.is(result.reason.name, 'AssertionError');\n-\t\tt.is(result.reason.message, 'Promise rejected with: \\'failure\\'');\n+\t\tt.is(result.reason.message, 'Rejected promise returned by test');\n+\t\tt.is(result.reason.actual, 'failure');\n \t\tt.end();\n \t});\n });"
      },
      {
        "sha": "40e6b20efcc04bce747872b2dba49adcc4a8d7cd",
        "filename": "test/reporters/mini.js",
        "status": "modified",
        "additions": 54,
        "deletions": 93,
        "changes": 147,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/test%2Freporters%2Fmini.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/test%2Freporters%2Fmini.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Freporters%2Fmini.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -363,21 +363,29 @@ test('results with errors', t => {\n \terr1.stack = beautifyStack(err1.stack);\n \tconst err1Path = tempWrite.sync('a();');\n \terr1.source = source(err1Path);\n-\terr1.showOutput = true;\n-\terr1.actual = JSON.stringify('abc');\n-\terr1.actualType = 'string';\n-\terr1.expected = JSON.stringify('abd');\n-\terr1.expectedType = 'string';\n+\terr1.avaAssertionError = true;\n+\terr1.actual = {\n+\t\ttype: 'string',\n+\t\tformatted: JSON.stringify('abc')\n+\t};\n+\terr1.expected = {\n+\t\ttype: 'string',\n+\t\tformatted: JSON.stringify('abd')\n+\t};\n \n \tconst err2 = new Error('failure two');\n \terr2.stack = 'error message\\nTest.fn (test.js:1:1)\\n';\n \tconst err2Path = tempWrite.sync('b();');\n \terr2.source = source(err2Path);\n-\terr2.showOutput = true;\n-\terr2.actual = JSON.stringify([1]);\n-\terr2.actualType = 'array';\n-\terr2.expected = JSON.stringify([2]);\n-\terr2.expectedType = 'array';\n+\terr2.avaAssertionError = true;\n+\terr2.actual = {\n+\t\ttype: 'array',\n+\t\tformatted: JSON.stringify([1])\n+\t};\n+\terr2.expected = {\n+\t\ttype: 'array',\n+\t\tformatted: JSON.stringify([2])\n+\t};\n \n \tconst reporter = miniReporter();\n \treporter.failCount = 1;\n@@ -425,21 +433,29 @@ test('results with errors', t => {\n test('results with errors and disabled code excerpts', t => {\n \tconst err1 = new Error('failure one');\n \terr1.stack = beautifyStack(err1.stack);\n-\terr1.showOutput = true;\n-\terr1.actual = JSON.stringify('abc');\n-\terr1.actualType = 'string';\n-\terr1.expected = JSON.stringify('abd');\n-\terr1.expectedType = 'string';\n+\terr1.avaAssertionError = true;\n+\terr1.actual = {\n+\t\ttype: 'string',\n+\t\tformatted: JSON.stringify('abc')\n+\t};\n+\terr1.expected = {\n+\t\ttype: 'string',\n+\t\tformatted: JSON.stringify('abd')\n+\t};\n \n \tconst err2 = new Error('failure two');\n \terr2.stack = 'error message\\nTest.fn (test.js:1:1)\\n';\n \tconst err2Path = tempWrite.sync('b();');\n \terr2.source = source(err2Path);\n-\terr2.showOutput = true;\n-\terr2.actual = JSON.stringify([1]);\n-\terr2.actualType = 'array';\n-\terr2.expected = JSON.stringify([2]);\n-\terr2.expectedType = 'array';\n+\terr2.avaAssertionError = true;\n+\terr2.actual = {\n+\t\ttype: 'array',\n+\t\tformatted: JSON.stringify([1])\n+\t};\n+\terr2.expected = {\n+\t\ttype: 'array',\n+\t\tformatted: JSON.stringify([2])\n+\t};\n \n \tconst reporter = miniReporter({color: true});\n \treporter.failCount = 1;\n@@ -486,83 +502,29 @@ test('results with errors and broken code excerpts', t => {\n \terr1.stack = beautifyStack(err1.stack);\n \tconst err1Path = tempWrite.sync('a();');\n \terr1.source = source(err1Path, 10);\n-\terr1.showOutput = true;\n-\terr1.actual = JSON.stringify('abc');\n-\terr1.actualType = 'string';\n-\terr1.expected = JSON.stringify('abd');\n-\terr1.expectedType = 'string';\n-\n-\tconst err2 = new Error('failure two');\n-\terr2.stack = 'error message\\nTest.fn (test.js:1:1)\\n';\n-\tconst err2Path = tempWrite.sync('b();');\n-\terr2.source = source(err2Path);\n-\terr2.showOutput = true;\n-\terr2.actual = JSON.stringify([1]);\n-\terr2.actualType = 'array';\n-\terr2.expected = JSON.stringify([2]);\n-\terr2.expectedType = 'array';\n-\n-\tconst reporter = miniReporter({color: true});\n-\treporter.failCount = 1;\n-\n-\tconst runStatus = {\n-\t\terrors: [{\n-\t\t\ttitle: 'failed one',\n-\t\t\terror: err1\n-\t\t}, {\n-\t\t\ttitle: 'failed two',\n-\t\t\terror: err2\n-\t\t}]\n+\terr1.avaAssertionError = true;\n+\terr1.actual = {\n+\t\ttype: 'string',\n+\t\tformatted: JSON.stringify('abc')\n+\t};\n+\terr1.expected = {\n+\t\ttype: 'string',\n+\t\tformatted: JSON.stringify('abd')\n \t};\n-\n-\tconst output = reporter.finish(runStatus);\n-\n-\tcompareLineOutput(t, output, flatten([\n-\t\t'',\n-\t\t'  ' + chalk.red('1 failed'),\n-\t\t'',\n-\t\t'  ' + chalk.bold.white('failed one'),\n-\t\t'  ' + chalk.grey(`${err1.source.file}:${err1.source.line}`),\n-\t\t'',\n-\t\tindentString(formatAssertError(err1), 2).split('\\n'),\n-\t\t/failure one/,\n-\t\t'',\n-\t\tstackLineRegex,\n-\t\tcompareLineOutput.SKIP_UNTIL_EMPTY_LINE,\n-\t\t'',\n-\t\t'',\n-\t\t'',\n-\t\t'  ' + chalk.bold.white('failed two'),\n-\t\t'  ' + chalk.grey(`${err2.source.file}:${err2.source.line}`),\n-\t\t'',\n-\t\tindentString(codeExcerpt(err2.source), 2).split('\\n'),\n-\t\t'',\n-\t\tindentString(formatAssertError(err2), 2).split('\\n'),\n-\t\t/failure two/\n-\t]));\n-\tt.end();\n-});\n-\n-test('results with errors and disabled assert output', t => {\n-\tconst err1 = new Error('failure one');\n-\terr1.stack = beautifyStack(err1.stack);\n-\tconst err1Path = tempWrite.sync('a();');\n-\terr1.source = source(err1Path);\n-\terr1.showOutput = false;\n-\terr1.actual = JSON.stringify('abc');\n-\terr1.actualType = 'string';\n-\terr1.expected = JSON.stringify('abd');\n-\terr1.expectedType = 'string';\n \n \tconst err2 = new Error('failure two');\n \terr2.stack = 'error message\\nTest.fn (test.js:1:1)\\n';\n \tconst err2Path = tempWrite.sync('b();');\n \terr2.source = source(err2Path);\n-\terr2.showOutput = true;\n-\terr2.actual = JSON.stringify([1]);\n-\terr2.actualType = 'array';\n-\terr2.expected = JSON.stringify([2]);\n-\terr2.expectedType = 'array';\n+\terr2.avaAssertionError = true;\n+\terr2.actual = {\n+\t\ttype: 'array',\n+\t\tformatted: JSON.stringify([1])\n+\t};\n+\terr2.expected = {\n+\t\ttype: 'array',\n+\t\tformatted: JSON.stringify([2])\n+\t};\n \n \tconst reporter = miniReporter({color: true});\n \treporter.failCount = 1;\n@@ -586,8 +548,7 @@ test('results with errors and disabled assert output', t => {\n \t\t'  ' + chalk.bold.white('failed one'),\n \t\t'  ' + chalk.grey(`${err1.source.file}:${err1.source.line}`),\n \t\t'',\n-\t\tindentString(codeExcerpt(err1.source), 2).split('\\n'),\n-\t\t'',\n+\t\tindentString(formatAssertError(err1), 2).split('\\n'),\n \t\t/failure one/,\n \t\t'',\n \t\tstackLineRegex,"
      },
      {
        "sha": "514fa81778ebcc6b92eeb6b7f0aa02972e89fd3e",
        "filename": "test/reporters/tap.js",
        "status": "modified",
        "additions": 12,
        "deletions": 6,
        "changes": 18,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/test%2Freporters%2Ftap.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/test%2Freporters%2Ftap.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Freporters%2Ftap.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -36,9 +36,11 @@ test('failing test', t => {\n \t\terror: {\n \t\t\tname: 'AssertionError',\n \t\t\tmessage: 'false == true',\n+\t\t\tavaAssertionError: true,\n+\t\t\tassertion: 'true',\n \t\t\toperator: '==',\n-\t\t\texpected: 'true',\n-\t\t\tactual: 'false',\n+\t\t\texpected: {formatted: 'true'},\n+\t\t\tactual: {formatted: 'false'},\n \t\t\tstack: ['', 'Test.fn (test.js:1:2)'].join('\\n')\n \t\t}\n \t});\n@@ -48,6 +50,7 @@ not ok 1 - failing\n   ---\n     name: AssertionError\n     message: false == true\n+    assertion: 'true'\n     operator: ==\n     actual: 'false'\n     expected: 'true'\n@@ -64,14 +67,16 @@ test('multiline strings in YAML block', t => {\n \tconst actualOutput = reporter.test({\n \t\ttitle: 'multiline',\n \t\terror: {\n-\t\t\tactual: 'hello\\nworld'\n+\t\t\tobject: {\n+\t\t\t\tfoo: 'hello\\nworld'\n+\t\t\t}\n \t\t}\n \t});\n \n \tconst expectedOutput = `# multiline\n not ok 1 - multiline\n   ---\n-    actual: |-\n+    foo: |-\n       hello\n       world\n   ...`;\n@@ -86,8 +91,9 @@ test('strips ANSI from actual and expected values', t => {\n \tconst actualOutput = reporter.test({\n \t\ttitle: 'strip ansi',\n \t\terror: {\n-\t\t\tactual: '\\u001b[31mhello\\u001b[39m',\n-\t\t\texpected: '\\u001b[32mworld\\u001b[39m'\n+\t\t\tavaAssertionError: true,\n+\t\t\tactual: {formatted: '\\u001b[31mhello\\u001b[39m'},\n+\t\t\texpected: {formatted: '\\u001b[32mworld\\u001b[39m'}\n \t\t}\n \t});\n "
      },
      {
        "sha": "a1503602e6e86233ca714fc21e5af573d3e9500d",
        "filename": "test/reporters/verbose.js",
        "status": "modified",
        "additions": 54,
        "deletions": 90,
        "changes": 144,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/test%2Freporters%2Fverbose.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/test%2Freporters%2Fverbose.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Freporters%2Fverbose.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -373,21 +373,29 @@ test('results with errors', t => {\n \terror1.stack = beautifyStack(error1.stack);\n \tconst err1Path = tempWrite.sync('a()');\n \terror1.source = source(err1Path);\n-\terror1.showOutput = true;\n-\terror1.actual = JSON.stringify('abc');\n-\terror1.actualType = 'string';\n-\terror1.expected = JSON.stringify('abd');\n-\terror1.expectedType = 'string';\n+\terror1.avaAssertionError = true;\n+\terror1.actual = {\n+\t\ttype: 'string',\n+\t\tformatted: JSON.stringify('abc')\n+\t};\n+\terror1.expected = {\n+\t\ttype: 'string',\n+\t\tformatted: JSON.stringify('abd')\n+\t};\n \n \tconst error2 = new Error('error two message');\n \terror2.stack = 'error message\\nTest.fn (test.js:1:1)\\n';\n \tconst err2Path = tempWrite.sync('b()');\n \terror2.source = source(err2Path);\n-\terror2.showOutput = true;\n-\terror2.actual = JSON.stringify([1]);\n-\terror2.actualType = 'array';\n-\terror2.expected = JSON.stringify([2]);\n-\terror2.expectedType = 'array';\n+\terror2.avaAssertionError = true;\n+\terror2.actual = {\n+\t\ttype: 'array',\n+\t\tformatted: JSON.stringify([1])\n+\t};\n+\terror2.expected = {\n+\t\ttype: 'array',\n+\t\tformatted: JSON.stringify([2])\n+\t};\n \n \tconst reporter = createReporter({color: true});\n \tconst runStatus = createRunStatus();\n@@ -432,21 +440,29 @@ test('results with errors', t => {\n test('results with errors and disabled code excerpts', t => {\n \tconst error1 = new Error('error one message');\n \terror1.stack = beautifyStack(error1.stack);\n-\terror1.showOutput = true;\n-\terror1.actual = JSON.stringify('abc');\n-\terror1.actualType = 'string';\n-\terror1.expected = JSON.stringify('abd');\n-\terror1.expectedType = 'string';\n+\terror1.avaAssertionError = true;\n+\terror1.actual = {\n+\t\ttype: 'string',\n+\t\tformatted: JSON.stringify('abc')\n+\t};\n+\terror1.expected = {\n+\t\ttype: 'string',\n+\t\tformatted: JSON.stringify('abd')\n+\t};\n \n \tconst error2 = new Error('error two message');\n \terror2.stack = 'error message\\nTest.fn (test.js:1:1)\\n';\n \tconst err2Path = tempWrite.sync('b()');\n \terror2.source = source(err2Path);\n-\terror2.showOutput = true;\n-\terror2.actual = JSON.stringify([1]);\n-\terror2.actualType = 'array';\n-\terror2.expected = JSON.stringify([2]);\n-\terror2.expectedType = 'array';\n+\terror2.avaAssertionError = true;\n+\terror2.actual = {\n+\t\ttype: 'array',\n+\t\tformatted: JSON.stringify([1])\n+\t};\n+\terror2.expected = {\n+\t\ttype: 'array',\n+\t\tformatted: JSON.stringify([2])\n+\t};\n \n \tconst reporter = createReporter({color: true});\n \tconst runStatus = createRunStatus();\n@@ -490,21 +506,29 @@ test('results with errors and disabled code excerpts', t => {\n \terror1.stack = beautifyStack(error1.stack);\n \tconst err1Path = tempWrite.sync('a();');\n \terror1.source = source(err1Path, 10);\n-\terror1.showOutput = true;\n-\terror1.actual = JSON.stringify('abc');\n-\terror1.actualType = 'string';\n-\terror1.expected = JSON.stringify('abd');\n-\terror1.expectedType = 'string';\n+\terror1.avaAssertionError = true;\n+\terror1.actual = {\n+\t\ttype: 'string',\n+\t\tformatted: JSON.stringify('abc')\n+\t};\n+\terror1.expected = {\n+\t\ttype: 'string',\n+\t\tformatted: JSON.stringify('abd')\n+\t};\n \n \tconst error2 = new Error('error two message');\n \terror2.stack = 'error message\\nTest.fn (test.js:1:1)\\n';\n \tconst err2Path = tempWrite.sync('b()');\n \terror2.source = source(err2Path);\n-\terror2.showOutput = true;\n-\terror2.actual = JSON.stringify([1]);\n-\terror2.actualType = 'array';\n-\terror2.expected = JSON.stringify([2]);\n-\terror2.expectedType = 'array';\n+\terror2.avaAssertionError = true;\n+\terror2.actual = {\n+\t\ttype: 'array',\n+\t\tformatted: JSON.stringify([1])\n+\t};\n+\terror2.expected = {\n+\t\ttype: 'array',\n+\t\tformatted: JSON.stringify([2])\n+\t};\n \n \tconst reporter = createReporter({color: true});\n \tconst runStatus = createRunStatus();\n@@ -544,66 +568,6 @@ test('results with errors and disabled code excerpts', t => {\n \tt.end();\n });\n \n-test('results with errors and disabled assert output', t => {\n-\tconst error1 = new Error('error one message');\n-\terror1.stack = beautifyStack(error1.stack);\n-\tconst err1Path = tempWrite.sync('a();');\n-\terror1.source = source(err1Path);\n-\terror1.showOutput = false;\n-\terror1.actual = JSON.stringify('abc');\n-\terror1.actualType = 'string';\n-\terror1.expected = JSON.stringify('abd');\n-\terror1.expectedType = 'string';\n-\n-\tconst error2 = new Error('error two message');\n-\terror2.stack = 'error message\\nTest.fn (test.js:1:1)\\n';\n-\tconst err2Path = tempWrite.sync('b();');\n-\terror2.source = source(err2Path);\n-\terror2.showOutput = true;\n-\terror2.actual = JSON.stringify([1]);\n-\terror2.actualType = 'array';\n-\terror2.expected = JSON.stringify([2]);\n-\terror2.expectedType = 'array';\n-\n-\tconst reporter = createReporter({color: true});\n-\tconst runStatus = createRunStatus();\n-\trunStatus.failCount = 1;\n-\trunStatus.tests = [{\n-\t\ttitle: 'fail one',\n-\t\terror: error1\n-\t}, {\n-\t\ttitle: 'fail two',\n-\t\terror: error2\n-\t}];\n-\n-\tconst output = reporter.finish(runStatus);\n-\tcompareLineOutput(t, output, flatten([\n-\t\t'',\n-\t\t'  ' + chalk.red('1 test failed') + time,\n-\t\t'',\n-\t\t'  ' + chalk.bold.white('fail one'),\n-\t\t'  ' + chalk.grey(`${error1.source.file}:${error1.source.line}`),\n-\t\t'',\n-\t\tindentString(codeExcerpt(error1.source), 2).split('\\n'),\n-\t\t'',\n-\t\t/error one message/,\n-\t\t'',\n-\t\tstackLineRegex,\n-\t\tcompareLineOutput.SKIP_UNTIL_EMPTY_LINE,\n-\t\t'',\n-\t\t'',\n-\t\t'',\n-\t\t'  ' + chalk.bold.white('fail two'),\n-\t\t'  ' + chalk.grey(`${error2.source.file}:${error2.source.line}`),\n-\t\t'',\n-\t\tindentString(codeExcerpt(error2.source), 2).split('\\n'),\n-\t\t'',\n-\t\tindentString(formatAssertError(error2), 2).split('\\n'),\n-\t\t/error two message/\n-\t]));\n-\tt.end();\n-});\n-\n test('results when fail-fast is enabled', t => {\n \tconst reporter = createReporter();\n \tconst runStatus = createRunStatus();"
      },
      {
        "sha": "5ad30c5638515c97d5735ffcbc662ba0672da822",
        "filename": "test/run-status.js",
        "status": "modified",
        "additions": 0,
        "deletions": 30,
        "changes": 30,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/test%2Frun-status.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/test%2Frun-status.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Frun-status.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -86,33 +86,3 @@ test('calculate remaining test count', t => {\n \tt.is(runStatus.remainingCount, 5);\n \tt.end();\n });\n-\n-test('handle non-object rejections', t => {\n-\tconst runStatus = new RunStatus();\n-\n-\trunStatus.on('error', err => {\n-\t\tt.deepEqual(err, {\n-\t\t\tfile: 'foo.js',\n-\t\t\tmessage: '42',\n-\t\t\ttype: 'rejection'\n-\t\t});\n-\t\tt.end();\n-\t});\n-\n-\trunStatus.handleRejections({file: 'foo.js', rejections: [42]});\n-});\n-\n-test('handle non-object exceptions', t => {\n-\tconst runStatus = new RunStatus();\n-\n-\trunStatus.on('error', err => {\n-\t\tt.deepEqual(err, {\n-\t\t\tfile: 'bar.js',\n-\t\t\tmessage: '/ab/g',\n-\t\t\ttype: 'exception'\n-\t\t});\n-\t\tt.end();\n-\t});\n-\n-\trunStatus.handleExceptions({file: 'bar.js', exception: /ab/g});\n-});"
      },
      {
        "sha": "14cb10e53a250b07d162cf830c987397872c35cc",
        "filename": "test/serialize-error.js",
        "status": "modified",
        "additions": 38,
        "deletions": 47,
        "changes": 85,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/test%2Fserialize-error.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/test%2Fserialize-error.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fserialize-error.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -9,6 +9,7 @@ const sourceMapSupport = require('source-map-support');\n const tempWrite = require('temp-write');\n const uniqueTempDir = require('unique-temp-dir');\n const test = require('tap').test;\n+const avaAssert = require('../lib/assert');\n const beautifyStack = require('../lib/beautify-stack');\n const serialize = require('../lib/serialize-error');\n \n@@ -27,7 +28,9 @@ test('serialize standard props', t => {\n \tconst err = new Error('Hello');\n \tconst serializedErr = serialize(err);\n \n-\tt.is(Object.keys(serializedErr).length, 4);\n+\tt.is(Object.keys(serializedErr).length, 6);\n+\tt.is(serializedErr.avaAssertionError, false);\n+\tt.deepEqual(serializedErr.object, {});\n \tt.is(serializedErr.name, 'Error');\n \tt.is(serializedErr.stack, beautifyStack(err.stack));\n \tt.is(serializedErr.message, 'Hello');\n@@ -38,6 +41,12 @@ test('serialize standard props', t => {\n \tt.end();\n });\n \n+test('additional error properties are preserved', t => {\n+\tconst serializedErr = serialize(Object.assign(new Error(), {foo: 'bar'}));\n+\tt.deepEqual(serializedErr.object, {foo: 'bar'});\n+\tt.end();\n+});\n+\n test('source file is an absolute path', t => {\n \tconst err = new Error('Hello');\n \tconst serializedErr = serialize(err);\n@@ -117,18 +126,24 @@ test('determines whether source file, if within the project, is a dependency', t\n \tt.end();\n });\n \n-test('serialize statements', t => {\n-\tconst err = new Error();\n-\terr.showOutput = true;\n+test('sets avaAssertionError to true if indeed an assertion error', t => {\n+\tconst err = new avaAssert.AssertionError({});\n+\tconst serializedErr = serialize(err);\n+\tt.true(serializedErr.avaAssertionError);\n+\tt.end();\n+});\n+\n+test('serialize statements of assertion errors', t => {\n+\tconst err = new avaAssert.AssertionError({\n+\t\tassertion: 'true'\n+\t});\n \terr.statements = [\n \t\t['actual.a[0]', 1],\n \t\t['actual.a', [1]],\n \t\t['actual', {a: [1]}]\n \t];\n \n \tconst serializedErr = serialize(err);\n-\n-\tt.true(serializedErr.showOutput);\n \tt.deepEqual(serializedErr.statements, JSON.stringify([\n \t\t['actual.a[0]', serializeValue(1)],\n \t\t['actual.a', serializeValue([1])],\n@@ -137,57 +152,33 @@ test('serialize statements', t => {\n \tt.end();\n });\n \n-test('skip statements if output is off', t => {\n-\tconst err = new Error();\n-\terr.showOutput = false;\n-\terr.statements = [\n-\t\t['actual.a[0]', 1],\n-\t\t['actual.a', [1]],\n-\t\t['actual', {a: [1]}]\n-\t];\n-\n-\tconst serializedErr = serialize(err);\n-\n-\tt.false(serializedErr.showOutput);\n-\tt.notOk(serializedErr.statements);\n-\tt.end();\n-});\n-\n-test('serialize actual and expected props', t => {\n-\tconst err = new Error();\n-\terr.showOutput = true;\n-\terr.actual = 1;\n-\terr.expected = 'a';\n+test('serialize actual and expected props of assertion errors', t => {\n+\tconst err = new avaAssert.AssertionError({\n+\t\tassertion: 'is',\n+\t\tactual: 1,\n+\t\texpected: 'a'\n+\t});\n \n \tconst serializedErr = serialize(err);\n-\n-\tt.true(serializedErr.showOutput);\n-\tt.is(serializedErr.actual, serializeValue(1));\n-\tt.is(serializedErr.expected, serializeValue('a'));\n-\tt.is(serializedErr.actualType, 'number');\n-\tt.is(serializedErr.expectedType, 'string');\n+\tt.is(serializedErr.actual.formatted, serializeValue(1));\n+\tt.is(serializedErr.expected.formatted, serializeValue('a'));\n+\tt.is(serializedErr.actual.type, 'number');\n+\tt.is(serializedErr.expected.type, 'string');\n \tt.end();\n });\n \n-test('skip actual and expected if output is off', t => {\n-\tconst err = new Error();\n-\terr.showOutput = false;\n-\terr.actual = 1;\n-\terr.expected = 'a';\n+test('only serialize actual and expected props of assertion errors if error was created with one', t => {\n+\tconst err = new avaAssert.AssertionError({});\n \n \tconst serializedErr = serialize(err);\n-\n-\tt.false(serializedErr.showOutput);\n-\tt.notOk(serializedErr.actual);\n-\tt.notOk(serializedErr.expected);\n-\tt.notOk(serializedErr.actualType);\n-\tt.notOk(serializedErr.expectedType);\n+\tt.is(serializedErr.actual, undefined);\n+\tt.is(serializedErr.expected, undefined);\n \tt.end();\n });\n \n test('does not call toJSON() when serializing actual and expected', t => {\n-\tconst err = Object.assign(new Error(), {\n-\t\tshowOutput: true,\n+\tconst err = new avaAssert.AssertionError({\n+\t\tassertion: 'is',\n \t\tactual: {\n \t\t\tfoo: 'bar',\n \t\t\ttoJSON() {\n@@ -207,7 +198,7 @@ test('does not call toJSON() when serializing actual and expected', t => {\n \t});\n \n \tconst serializedErr = serialize(err);\n-\tt.notSame(serializedErr.actual, serializedErr.expected);\n+\tt.notSame(serializedErr.actual.formatted, serializedErr.expected);\n \tt.end();\n });\n "
      },
      {
        "sha": "63dfb481f529a332b2e11232051c645c0f83d4f3",
        "filename": "test/test.js",
        "status": "modified",
        "additions": 25,
        "deletions": 19,
        "changes": 44,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/test%2Ftest.js",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/test%2Ftest.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Ftest.js?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -131,14 +131,15 @@ test('run more assertions than planned', t => {\n \tt.end();\n });\n \n-test('handle non-assertion errors', t => {\n+test('wrap non-assertion errors', t => {\n+\tconst err = new Error();\n \tconst result = ava(() => {\n-\t\tthrow new Error();\n+\t\tthrow err;\n \t}).run();\n \n \tt.is(result.passed, false);\n-\tt.is(result.reason.name, 'Error');\n-\tt.true(result.reason instanceof Error);\n+\tt.is(result.reason.name, 'AssertionError');\n+\tt.is(result.reason.actual, err);\n \tt.end();\n });\n \n@@ -157,7 +158,9 @@ test('end can be used as callback with error', t => {\n \t\ta.end(err);\n \t}).run().then(result => {\n \t\tt.is(result.passed, false);\n-\t\tt.is(result.reason, err);\n+\t\tt.is(result.reason.name, 'AssertionError');\n+\t\tt.is(result.reason.actual, err);\n+\t\tt.is(result.reason.message, 'Callback called with an error');\n \t\tt.end();\n \t});\n });\n@@ -171,20 +174,20 @@ test('end can be used as callback with a non-error as its error argument', t =>\n \t\tt.ok(result.reason);\n \t\tt.is(result.reason.name, 'AssertionError');\n \t\tt.is(result.reason.actual, nonError);\n-\t\tt.is(result.reason.message, 'Callback called with an error: { foo: \\'bar\\' }');\n+\t\tt.is(result.reason.message, 'Callback called with an error');\n \t\tt.end();\n \t});\n });\n \n test('handle non-assertion errors even when planned', t => {\n+\tconst err = new Error('bar');\n \tconst result = ava(a => {\n \t\ta.plan(1);\n-\t\tthrow new Error('bar');\n+\t\tthrow err;\n \t}).run();\n \n \tt.is(result.passed, false);\n-\tt.is(result.reason.name, 'Error');\n-\tt.is(result.reason.message, 'bar');\n+\tt.is(result.reason.actual, err);\n \tt.end();\n });\n \n@@ -264,7 +267,7 @@ test('handle throws without error', t => {\n \n \tt.is(result.passed, false);\n \tt.ok(result.reason);\n-\tt.is(actual, null);\n+\tt.is(actual, undefined);\n \tt.end();\n });\n \n@@ -288,7 +291,9 @@ test('fails if a bad value is passed to t.throws', t => {\n \n \tt.is(result.passed, false);\n \tt.ok(result.reason);\n-\tt.is(result.reason.name, 'TypeError');\n+\tt.is(result.reason.name, 'AssertionError');\n+\tt.is(result.reason.message, '`t.throws()` must be called with a function, Promise, or Observable');\n+\tt.is(result.reason.actual, 'not a function');\n \tt.end();\n });\n \n@@ -427,9 +432,8 @@ test('fails with thrown falsy value', t => {\n \n \tt.is(result.passed, false);\n \tt.is(result.reason.actual, 0);\n-\tt.is(result.reason.message, 'Non-error thrown with value: 0');\n+\tt.is(result.reason.message, 'Error thrown in test');\n \tt.is(result.reason.name, 'AssertionError');\n-\tt.is(result.reason.operator, 'catch');\n \tt.end();\n });\n \n@@ -441,9 +445,8 @@ test('fails with thrown non-error object', t => {\n \n \tt.is(result.passed, false);\n \tt.is(result.reason.actual, obj);\n-\tt.is(result.reason.message, 'Non-error thrown with value: { foo: \\'bar\\' }');\n+\tt.is(result.reason.message, 'Error thrown in test');\n \tt.is(result.reason.name, 'AssertionError');\n-\tt.is(result.reason.operator, 'catch');\n \tt.end();\n });\n \n@@ -489,12 +492,13 @@ test('end should not be called multiple times', t => {\n });\n \n test('cb test that throws sync', t => {\n+\tconst err = new Error('foo');\n \tconst result = ava.cb(() => {\n-\t\tthrow new Error('foo');\n+\t\tthrow err;\n \t}).run();\n \n \tt.is(result.passed, false);\n-\tt.is(result.reason.message, 'foo');\n+\tt.is(result.reason.actual, err);\n \tt.end();\n });\n \n@@ -575,9 +579,10 @@ test('number of assertions matches t.plan when the test exits, but before all pr\n \t\t}, 5);\n \t}).run().then(result => {\n \t\tt.is(result.passed, false);\n-\t\tt.is(result.reason.operator, 'plan');\n+\t\tt.is(result.reason.assertion, 'plan');\n \t\tt.is(result.reason.actual, 3);\n \t\tt.is(result.reason.expected, 2);\n+\t\tt.is(result.reason.operator, '===');\n \t\tt.end();\n \t});\n });\n@@ -592,9 +597,10 @@ test('number of assertions doesn\\'t match plan when the test exits, but before a\n \t\t}, 5);\n \t}).run().then(result => {\n \t\tt.is(result.passed, false);\n-\t\tt.is(result.reason.operator, 'plan');\n+\t\tt.is(result.reason.assertion, 'plan');\n \t\tt.is(result.reason.actual, 2);\n \t\tt.is(result.reason.expected, 3);\n+\t\tt.is(result.reason.operator, '===');\n \t\tt.end();\n \t});\n });"
      },
      {
        "sha": "448e7aaaa07276e9d1d83d40e0be6ccbb772ff00",
        "filename": "types/base.d.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/avajs/ava/blob/42b117a24d757ed11ba84d748dd930b05792d770/types%2Fbase.d.ts",
        "raw_url": "https://github.com/avajs/ava/raw/42b117a24d757ed11ba84d748dd930b05792d770/types%2Fbase.d.ts",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/types%2Fbase.d.ts?ref=42b117a24d757ed11ba84d748dd930b05792d770",
        "patch": "@@ -65,7 +65,7 @@ export interface AssertContext {\n \t/**\n \t * Assert that function doesn't throw an error or promise resolves.\n \t */\n-\tnotThrows<U>(value: PromiseLike<U>, message?: string): Promise<U>;\n+\tnotThrows(value: PromiseLike<any>, message?: string): Promise<void>;\n \tnotThrows(value: () => void, message?: string): void;\n \t/**\n \t * Assert that contents matches regex."
      }
    ]
  },
  {
    "url": "https://api.github.com/repos/avajs/ava/issues/713",
    "repository_url": "https://api.github.com/repos/avajs/ava",
    "labels_url": "https://api.github.com/repos/avajs/ava/issues/713/labels{/name}",
    "comments_url": "https://api.github.com/repos/avajs/ava/issues/713/comments",
    "events_url": "https://api.github.com/repos/avajs/ava/issues/713/events",
    "html_url": "https://github.com/avajs/ava/pull/713",
    "id": 145911093,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NjUyNjEwOTg=",
    "number": 713,
    "title": "Refactor API",
    "user": {
      "login": "jamestalmage",
      "id": 4082216,
      "node_id": "MDQ6VXNlcjQwODIyMTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4082216?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamestalmage",
      "html_url": "https://github.com/jamestalmage",
      "followers_url": "https://api.github.com/users/jamestalmage/followers",
      "following_url": "https://api.github.com/users/jamestalmage/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamestalmage/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamestalmage/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamestalmage/subscriptions",
      "organizations_url": "https://api.github.com/users/jamestalmage/orgs",
      "repos_url": "https://api.github.com/users/jamestalmage/repos",
      "events_url": "https://api.github.com/users/jamestalmage/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamestalmage/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 5,
    "created_at": "2016-04-05T07:18:05Z",
    "updated_at": "2016-04-07T06:01:34Z",
    "closed_at": "2016-04-07T06:01:34Z",
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "draft": false,
    "pull_request": {
      "url": "https://api.github.com/repos/avajs/ava/pulls/713",
      "html_url": "https://github.com/avajs/ava/pull/713",
      "diff_url": "https://github.com/avajs/ava/pull/713.diff",
      "patch_url": "https://github.com/avajs/ava/pull/713.patch",
      "merged_at": "2016-04-07T06:01:34Z"
    },
    "body": "This is preliminary work on simplifying the API. The major (breaking) change is a new `test-run` event that passes an emitter for that specific test run. Said emitter is an instance of the new TestData class (might be more appropriately named TestRun). This contains test results that we were storing directly on the API instance. That really doesn't make sense anymore given that the API instance is called multiple times by Watcher. I feel this way makes a little more sense. There is definitely room for further refactoring, but this represents a big diff, and I want to get it reviewed and merged before further refactoring.\n",
    "reactions": {
      "url": "https://api.github.com/repos/avajs/ava/issues/713/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/avajs/ava/issues/713/timeline",
    "performed_via_github_app": null,
    "state_reason": null,
    "score": 1,
    "files": [
      {
        "sha": "0114eed35da9c26407a69262f22799b293e8318e",
        "filename": "api.js",
        "status": "modified",
        "additions": 128,
        "deletions": 310,
        "changes": 438,
        "blob_url": "https://github.com/avajs/ava/blob/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/api.js",
        "raw_url": "https://github.com/avajs/ava/raw/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/api.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/api.js?ref=bdce76af3f3cfec9cd2608f126a2eaa9036e9399",
        "patch": "@@ -2,25 +2,19 @@\n var EventEmitter = require('events').EventEmitter;\n var path = require('path');\n var util = require('util');\n-var fs = require('fs');\n-var flatten = require('arr-flatten');\n var Promise = require('bluebird');\n-var figures = require('figures');\n-var globby = require('globby');\n-var chalk = require('chalk');\n var objectAssign = require('object-assign');\n var commonPathPrefix = require('common-path-prefix');\n var resolveCwd = require('resolve-cwd');\n var uniqueTempDir = require('unique-temp-dir');\n var findCacheDir = require('find-cache-dir');\n var debounce = require('lodash.debounce');\n-var slash = require('slash');\n-var isObj = require('is-obj');\n var ms = require('ms');\n var AvaError = require('./lib/ava-error');\n var fork = require('./lib/fork');\n-var formatter = require('./lib/enhance-assert').formatter();\n var CachingPrecompiler = require('./lib/caching-precompiler');\n+var AvaFiles = require('./lib/ava-files');\n+var TestData = require('./lib/run-status');\n \n function Api(options) {\n \tif (!(this instanceof Api)) {\n@@ -40,44 +34,15 @@ function Api(options) {\n \t\treturn ret;\n \t});\n \n-\tthis.excludePatterns = [\n-\t\t'!**/node_modules/**',\n-\t\t'!**/fixtures/**',\n-\t\t'!**/helpers/**'\n-\t];\n-\n \tObject.keys(Api.prototype).forEach(function (key) {\n \t\tthis[key] = this[key].bind(this);\n \t}, this);\n-\n-\tthis._reset();\n-\n-\tif (this.options.timeout) {\n-\t\tvar timeout = ms(this.options.timeout);\n-\t\tthis._restartTimer = debounce(this._onTimeout, timeout);\n-\t}\n }\n \n util.inherits(Api, EventEmitter);\n module.exports = Api;\n \n-Api.prototype._reset = function () {\n-\tthis.rejectionCount = 0;\n-\tthis.exceptionCount = 0;\n-\tthis.passCount = 0;\n-\tthis.skipCount = 0;\n-\tthis.todoCount = 0;\n-\tthis.failCount = 0;\n-\tthis.fileCount = 0;\n-\tthis.testCount = 0;\n-\tthis.hasExclusive = false;\n-\tthis.errors = [];\n-\tthis.stats = [];\n-\tthis.tests = [];\n-\tthis.base = '';\n-};\n-\n-Api.prototype._runFile = function (file) {\n+Api.prototype._runFile = function (file, testData) {\n \tvar hash = this.precompiler.precompileFile(file);\n \tvar precompiled = {};\n \tprecompiled[file] = hash;\n@@ -86,323 +51,176 @@ Api.prototype._runFile = function (file) {\n \t\tprecompiled: precompiled\n \t});\n \n-\treturn fork(file, options)\n-\t\t.on('teardown', this._handleTeardown)\n-\t\t.on('stats', this._handleStats)\n-\t\t.on('test', this._handleTest)\n-\t\t.on('unhandledRejections', this._handleRejections)\n-\t\t.on('uncaughtException', this._handleExceptions)\n-\t\t.on('stdout', this._handleOutput.bind(this, 'stdout'))\n-\t\t.on('stderr', this._handleOutput.bind(this, 'stderr'));\n-};\n-\n-Api.prototype._handleOutput = function (channel, data) {\n-\tthis.emit(channel, data);\n-};\n-\n-function normalizeError(err) {\n-\tif (!isObj(err)) {\n-\t\terr = {\n-\t\t\tmessage: err,\n-\t\t\tstack: err\n-\t\t};\n-\t}\n-\n-\treturn err;\n-}\n+\tvar emitter = fork(file, options);\n \n-Api.prototype._handleRejections = function (data) {\n-\tthis.rejectionCount += data.rejections.length;\n-\n-\tdata.rejections.forEach(function (err) {\n-\t\terr = normalizeError(err);\n-\t\terr.type = 'rejection';\n-\t\terr.file = data.file;\n-\t\tthis.emit('error', err);\n-\t\tthis.errors.push(err);\n-\t}, this);\n-};\n-\n-Api.prototype._handleExceptions = function (data) {\n-\tthis.exceptionCount++;\n-\tvar err = normalizeError(data.exception);\n-\terr.type = 'exception';\n-\terr.file = data.file;\n-\tthis.emit('error', err);\n-\tthis.errors.push(err);\n-};\n-\n-Api.prototype._handleTeardown = function (data) {\n-\tthis.emit('dependencies', data.file, data.dependencies);\n-};\n-\n-Api.prototype._handleStats = function (stats) {\n-\tthis.emit('stats', stats);\n-\n-\tif (this.hasExclusive && !stats.hasExclusive) {\n-\t\treturn;\n-\t}\n-\n-\tif (!this.hasExclusive && stats.hasExclusive) {\n-\t\tthis.hasExclusive = true;\n-\t\tthis.testCount = 0;\n-\t}\n+\ttestData.observeFork(emitter);\n \n-\tthis.testCount += stats.testCount;\n+\treturn emitter;\n };\n \n-Api.prototype._handleTest = function (test) {\n-\ttest.title = this._prefixTitle(test.file) + test.title;\n-\n-\tif (test.error) {\n-\t\tif (test.error.powerAssertContext) {\n-\t\t\tvar message = formatter(test.error.powerAssertContext);\n-\n-\t\t\tif (test.error.originalMessage) {\n-\t\t\t\tmessage = test.error.originalMessage + ' ' + message;\n-\t\t\t}\n-\n-\t\t\ttest.error.message = message;\n-\t\t}\n-\n-\t\tif (test.error.name !== 'AssertionError') {\n-\t\t\ttest.error.message = 'failed with \"' + test.error.message + '\"';\n-\t\t}\n-\n-\t\tthis.errors.push(test);\n-\t}\n-\n-\tthis.emit('test', test);\n-};\n-\n-Api.prototype._prefixTitle = function (file) {\n-\tif (this.fileCount === 1 && !this.options.explicitTitles) {\n-\t\treturn '';\n-\t}\n-\n-\tvar separator = ' ' + chalk.gray.dim(figures.pointerSmall) + ' ';\n-\n-\tvar prefix = path.relative('.', file)\n-\t\t.replace(this.base, '')\n-\t\t.replace(/\\.spec/, '')\n-\t\t.replace(/\\.test/, '')\n-\t\t.replace(/test\\-/g, '')\n-\t\t.replace(/\\.js$/, '')\n-\t\t.split(path.sep)\n-\t\t.join(separator);\n-\n-\tif (prefix.length > 0) {\n-\t\tprefix += separator;\n-\t}\n-\n-\treturn prefix;\n-};\n-\n-Api.prototype._onTimeout = function () {\n+Api.prototype._onTimeout = function (testData) {\n \tvar timeout = ms(this.options.timeout);\n \tvar message = 'Exited because no new tests completed within the last ' + timeout + 'ms of inactivity';\n \n-\tthis._handleExceptions({\n+\ttestData.handleExceptions({\n \t\texception: new AvaError(message),\n \t\tfile: null\n \t});\n \n-\tthis.emit('timeout');\n+\ttestData.emit('timeout');\n };\n \n Api.prototype.run = function (files, options) {\n \tvar self = this;\n \n-\tthis._reset();\n-\n-\tif (options && options.runOnlyExclusive) {\n-\t\tthis.hasExclusive = true;\n-\t}\n-\n-\tif (this.options.timeout) {\n-\t\tthis._restartTimer();\n-\t\tthis.on('test', this._restartTimer);\n-\t}\n-\n-\treturn handlePaths(files, this.excludePatterns)\n-\t\t.map(function (file) {\n-\t\t\treturn path.resolve(file);\n-\t\t})\n+\treturn new AvaFiles(files)\n+\t\t.findTestFiles()\n \t\t.then(function (files) {\n-\t\t\tif (files.length === 0) {\n-\t\t\t\tself._handleExceptions({\n-\t\t\t\t\texception: new AvaError('Couldn\\'t find any files to test'),\n-\t\t\t\t\tfile: undefined\n-\t\t\t\t});\n-\n-\t\t\t\treturn [];\n-\t\t\t}\n-\n-\t\t\tvar cacheEnabled = self.options.cacheEnabled !== false;\n-\t\t\tvar cacheDir = (cacheEnabled && findCacheDir({name: 'ava', files: files})) ||\n-\t\t\t\tuniqueTempDir();\n-\n-\t\t\tself.options.cacheDir = cacheDir;\n-\t\t\tself.precompiler = new CachingPrecompiler(cacheDir, self.options.babelConfig);\n-\t\t\tself.fileCount = files.length;\n-\t\t\tself.base = path.relative('.', commonPathPrefix(files)) + path.sep;\n+\t\t\treturn self._run(files, options);\n+\t\t});\n+};\n \n-\t\t\tvar tests = new Array(self.fileCount);\n+Api.prototype._run = function (files, _options) {\n+\tvar self = this;\n+\tvar runStatus = new TestData({\n+\t\tprefixTitles: this.options.explicitTitles || files.length > 1,\n+\t\trunOnlyExclusive: _options && _options.runOnlyExclusive,\n+\t\tbase: path.relative('.', commonPathPrefix(files)) + path.sep\n+\t});\n \n-\t\t\tself.on('timeout', function () {\n-\t\t\t\ttests.forEach(function (fork) {\n-\t\t\t\t\tfork.exit();\n-\t\t\t\t});\n-\t\t\t});\n+\tif (self.options.timeout) {\n+\t\tvar timeout = ms(self.options.timeout);\n+\t\trunStatus._restartTimer = debounce(function () {\n+\t\t\tself._onTimeout(runStatus);\n+\t\t}, timeout);\n+\t\trunStatus._restartTimer();\n+\t\trunStatus.on('test', runStatus._restartTimer);\n+\t}\n \n-\t\t\treturn new Promise(function (resolve) {\n-\t\t\t\tfunction run() {\n-\t\t\t\t\tif (self.options.match.length > 0 && !self.hasExclusive) {\n-\t\t\t\t\t\tself._handleExceptions({\n-\t\t\t\t\t\t\texception: new AvaError('Couldn\\'t find any matching tests'),\n-\t\t\t\t\t\t\tfile: undefined\n-\t\t\t\t\t\t});\n+\tself.emit('test-run', runStatus, files);\n \n-\t\t\t\t\t\tresolve([]);\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n+\tif (files.length === 0) {\n+\t\trunStatus.handleExceptions({\n+\t\t\texception: new AvaError('Couldn\\'t find any files to test'),\n+\t\t\tfile: undefined\n+\t\t});\n \n-\t\t\t\t\tself.emit('ready');\n+\t\treturn Promise.resolve([]);\n+\t}\n \n-\t\t\t\t\tvar method = self.options.serial ? 'mapSeries' : 'map';\n-\t\t\t\t\tvar options = {\n-\t\t\t\t\t\trunOnlyExclusive: self.hasExclusive\n-\t\t\t\t\t};\n+\tvar cacheEnabled = self.options.cacheEnabled !== false;\n+\tvar cacheDir = (cacheEnabled && findCacheDir({name: 'ava', files: files})) ||\n+\t\tuniqueTempDir();\n \n-\t\t\t\t\tresolve(Promise[method](files, function (file, index) {\n-\t\t\t\t\t\treturn tests[index].run(options).catch(function (err) {\n-\t\t\t\t\t\t\t// The test failed catastrophically. Flag it up as an\n-\t\t\t\t\t\t\t// exception, then return an empty result. Other tests may\n-\t\t\t\t\t\t\t// continue to run.\n-\t\t\t\t\t\t\tself._handleExceptions({\n-\t\t\t\t\t\t\t\texception: err,\n-\t\t\t\t\t\t\t\tfile: file\n-\t\t\t\t\t\t\t});\n-\n-\t\t\t\t\t\t\treturn {\n-\t\t\t\t\t\t\t\tstats: {\n-\t\t\t\t\t\t\t\t\tpassCount: 0,\n-\t\t\t\t\t\t\t\t\tskipCount: 0,\n-\t\t\t\t\t\t\t\t\ttodoCount: 0,\n-\t\t\t\t\t\t\t\t\tfailCount: 0\n-\t\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\t\ttests: []\n-\t\t\t\t\t\t\t};\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}));\n-\t\t\t\t}\n+\tself.options.cacheDir = cacheDir;\n+\tself.precompiler = new CachingPrecompiler(cacheDir, self.options.babelConfig);\n+\tself.fileCount = files.length;\n \n-\t\t\t\t// receive test count from all files and then run the tests\n-\t\t\t\tvar unreportedFiles = self.fileCount;\n-\t\t\t\tvar bailed = false;\n+\tvar tests = new Array(self.fileCount);\n \n-\t\t\t\tfiles.every(function (file, index) {\n-\t\t\t\t\tvar tried = false;\n+\t// TODO: thid should be cleared at the end of the run\n+\trunStatus.on('timeout', function () {\n+\t\ttests.forEach(function (fork) {\n+\t\t\tfork.exit();\n+\t\t});\n+\t});\n \n-\t\t\t\t\tfunction tryRun() {\n-\t\t\t\t\t\tif (!tried && !bailed) {\n-\t\t\t\t\t\t\ttried = true;\n-\t\t\t\t\t\t\tunreportedFiles--;\n+\treturn new Promise(function (resolve) {\n+\t\tfunction run() {\n+\t\t\tif (self.options.match.length > 0 && !runStatus.hasExclusive) {\n+\t\t\t\trunStatus.handleExceptions({\n+\t\t\t\t\texception: new AvaError('Couldn\\'t find any matching tests'),\n+\t\t\t\t\tfile: undefined\n+\t\t\t\t});\n \n-\t\t\t\t\t\t\tif (unreportedFiles === 0) {\n-\t\t\t\t\t\t\t\trun();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+\t\t\t\tresolve([]);\n+\t\t\t\treturn;\n+\t\t\t}\n \n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tvar test = tests[index] = self._runFile(file);\n+\t\t\tself.emit('ready');\n+\n+\t\t\tvar method = self.options.serial ? 'mapSeries' : 'map';\n+\t\t\tvar options = {\n+\t\t\t\trunOnlyExclusive: runStatus.hasExclusive\n+\t\t\t};\n+\n+\t\t\tresolve(Promise[method](files, function (file, index) {\n+\t\t\t\treturn tests[index].run(options).catch(function (err) {\n+\t\t\t\t\t// The test failed catastrophically. Flag it up as an\n+\t\t\t\t\t// exception, then return an empty result. Other tests may\n+\t\t\t\t\t// continue to run.\n+\t\t\t\t\trunStatus.handleExceptions({\n+\t\t\t\t\t\texception: err,\n+\t\t\t\t\t\tfile: file\n+\t\t\t\t\t});\n \n-\t\t\t\t\t\ttest.on('stats', tryRun);\n-\t\t\t\t\t\ttest.catch(tryRun);\n+\t\t\t\t\treturn {\n+\t\t\t\t\t\tstats: {\n+\t\t\t\t\t\t\tpassCount: 0,\n+\t\t\t\t\t\t\tskipCount: 0,\n+\t\t\t\t\t\t\ttodoCount: 0,\n+\t\t\t\t\t\t\tfailCount: 0\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\ttests: []\n+\t\t\t\t\t};\n+\t\t\t\t});\n+\t\t\t}));\n+\t\t}\n \n-\t\t\t\t\t\treturn true;\n-\t\t\t\t\t} catch (err) {\n-\t\t\t\t\t\tbailed = true;\n+\t\t// receive test count from all files and then run the tests\n+\t\tvar unreportedFiles = self.fileCount;\n+\t\tvar bailed = false;\n \n-\t\t\t\t\t\tself._handleExceptions({\n-\t\t\t\t\t\t\texception: err,\n-\t\t\t\t\t\t\tfile: file\n-\t\t\t\t\t\t});\n+\t\tfiles.every(function (file, index) {\n+\t\t\tvar tried = false;\n \n-\t\t\t\t\t\tresolve([]);\n+\t\t\tfunction tryRun() {\n+\t\t\t\tif (!tried && !bailed) {\n+\t\t\t\t\ttried = true;\n+\t\t\t\t\tunreportedFiles--;\n \n-\t\t\t\t\t\treturn false;\n+\t\t\t\t\tif (unreportedFiles === 0) {\n+\t\t\t\t\t\trun();\n \t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t}).then(function (results) {\n-\t\t\t\tif (results.length === 0) {\n-\t\t\t\t\t// No tests ran, make sure to tear down the child processes.\n-\t\t\t\t\ttests.forEach(function (test) {\n-\t\t\t\t\t\ttest.send('teardown');\n-\t\t\t\t\t});\n \t\t\t\t}\n-\n-\t\t\t\treturn results;\n-\t\t\t});\n-\t\t})\n-\t\t.then(function (results) {\n-\t\t\t// cancel debounced _onTimeout() from firing\n-\t\t\tif (self.options.timeout) {\n-\t\t\t\tself._restartTimer.cancel();\n \t\t\t}\n \n-\t\t\t// assemble stats from all tests\n-\t\t\tself.stats = results.map(function (result) {\n-\t\t\t\treturn result.stats;\n-\t\t\t});\n-\n-\t\t\tself.tests = results.map(function (result) {\n-\t\t\t\treturn result.tests;\n-\t\t\t});\n-\n-\t\t\tself.tests = flatten(self.tests);\n+\t\t\ttry {\n+\t\t\t\tvar test = tests[index] = self._runFile(file, runStatus);\n \n-\t\t\tself.passCount = sum(self.stats, 'passCount');\n-\t\t\tself.skipCount = sum(self.stats, 'skipCount');\n-\t\t\tself.todoCount = sum(self.stats, 'todoCount');\n-\t\t\tself.failCount = sum(self.stats, 'failCount');\n-\t\t});\n-};\n+\t\t\t\ttest.on('stats', tryRun);\n+\t\t\t\ttest.catch(tryRun);\n \n-function handlePaths(files, excludePatterns) {\n-\t// convert pinkie-promise to Bluebird promise\n-\tfiles = Promise.resolve(globby(files.concat(excludePatterns)));\n+\t\t\t\treturn true;\n+\t\t\t} catch (err) {\n+\t\t\t\tbailed = true;\n \n-\treturn files\n-\t\t.map(function (file) {\n-\t\t\tif (fs.statSync(file).isDirectory()) {\n-\t\t\t\tvar pattern = path.join(file, '**', '*.js');\n+\t\t\t\trunStatus.handleExceptions({\n+\t\t\t\t\texception: err,\n+\t\t\t\t\tfile: file\n+\t\t\t\t});\n \n-\t\t\t\tif (process.platform === 'win32') {\n-\t\t\t\t\t// Always use / in patterns, harmonizing matching across platforms.\n-\t\t\t\t\tpattern = slash(pattern);\n-\t\t\t\t}\n+\t\t\t\tresolve([]);\n \n-\t\t\t\treturn handlePaths([pattern], excludePatterns);\n+\t\t\t\treturn false;\n \t\t\t}\n-\n-\t\t\t// globby returns slashes even on Windows. Normalize here so the file\n-\t\t\t// paths are consistently platform-accurate as tests are run.\n-\t\t\treturn path.normalize(file);\n-\t\t})\n-\t\t.then(flatten)\n-\t\t.filter(function (file) {\n-\t\t\treturn path.extname(file) === '.js' && path.basename(file)[0] !== '_';\n \t\t});\n-}\n+\t}).then(function (results) {\n+\t\tif (results.length === 0) {\n+\t\t\t// No tests ran, make sure to tear down the child processes.\n+\t\t\ttests.forEach(function (test) {\n+\t\t\t\ttest.send('teardown');\n+\t\t\t});\n+\t\t}\n \n-function sum(arr, key) {\n-\tvar result = 0;\n+\t\treturn results;\n+\t}).then(function (results) {\n+\t\t// cancel debounced _onTimeout() from firing\n+\t\tif (self.options.timeout) {\n+\t\t\trunStatus._restartTimer.cancel();\n+\t\t}\n \n-\tarr.forEach(function (item) {\n-\t\tresult += item[key];\n+\t\trunStatus.processResults(results);\n+\t\treturn runStatus;\n \t});\n-\n-\treturn result;\n-}\n+};"
      },
      {
        "sha": "1f6ec6c65aa5c3d3b2e6559692e09a923e266eec",
        "filename": "cli.js",
        "status": "modified",
        "additions": 10,
        "deletions": 7,
        "changes": 17,
        "blob_url": "https://github.com/avajs/ava/blob/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/cli.js",
        "raw_url": "https://github.com/avajs/ava/raw/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/cli.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/cli.js?ref=bdce76af3f3cfec9cd2608f126a2eaa9036e9399",
        "patch": "@@ -142,11 +142,14 @@ var logger = new Logger(reporter);\n \n logger.start();\n \n-api.on('test', logger.test);\n-api.on('error', logger.unhandledError);\n+api.on('test-run', function (runStatus) {\n+\treporter.api = runStatus;\n+\trunStatus.on('test', logger.test);\n+\trunStatus.on('error', logger.unhandledError);\n \n-api.on('stdout', logger.stdout);\n-api.on('stderr', logger.stderr);\n+\trunStatus.on('stdout', logger.stdout);\n+\trunStatus.on('stderr', logger.stderr);\n+});\n \n var files = cli.input.length ? cli.input : arrify(conf.files);\n if (files.length === 0) {\n@@ -173,9 +176,9 @@ if (cli.flags.watch) {\n \t}\n } else {\n \tapi.run(files)\n-\t\t.then(function () {\n-\t\t\tlogger.finish();\n-\t\t\tlogger.exit(api.failCount > 0 || api.rejectionCount > 0 || api.exceptionCount > 0 ? 1 : 0);\n+\t\t.then(function (runStatus) {\n+\t\t\tlogger.finish(runStatus);\n+\t\t\tlogger.exit(runStatus.failCount > 0 || runStatus.rejectionCount > 0 || runStatus.exceptionCount > 0 ? 1 : 0);\n \t\t})\n \t\t.catch(function (err) {\n \t\t\t// Don't swallow exceptions. Note that any expected error should already"
      },
      {
        "sha": "04ba6e0e97b3e80484660abe95ba9497363c5d6b",
        "filename": "lib/ava-files.js",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/avajs/ava/blob/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/lib%2Fava-files.js",
        "raw_url": "https://github.com/avajs/ava/raw/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/lib%2Fava-files.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fava-files.js?ref=bdce76af3f3cfec9cd2608f126a2eaa9036e9399",
        "patch": "@@ -0,0 +1,74 @@\n+var fs = require('fs');\n+var path = require('path');\n+var Promise = require('bluebird');\n+var slash = require('slash');\n+var globby = require('globby');\n+var flatten = require('arr-flatten');\n+\n+function defaultExcludePatterns() {\n+\treturn [\n+\t\t'!**/node_modules/**',\n+\t\t'!**/fixtures/**',\n+\t\t'!**/helpers/**'\n+\t];\n+}\n+\n+function defaultIncludePatterns() {\n+\treturn [\n+\t\t'test.js',\n+\t\t'test-*.js',\n+\t\t'test'\n+\t];\n+}\n+\n+function AvaFiles(files) {\n+\tif (!(this instanceof AvaFiles)) {\n+\t\tthrow new TypeError('Class constructor AvaFiles cannot be invoked without \\'new\\'');\n+\t}\n+\n+\tif (!files || !files.length) {\n+\t\tfiles = defaultIncludePatterns();\n+\t}\n+\n+\tthis.excludePatterns = defaultExcludePatterns();\n+\n+\tthis.files = files;\n+}\n+\n+AvaFiles.prototype.findTestFiles = function () {\n+\treturn handlePaths(this.files, this.excludePatterns);\n+};\n+\n+function handlePaths(files, excludePatterns) {\n+\t// convert pinkie-promise to Bluebird promise\n+\tfiles = Promise.resolve(globby(files.concat(excludePatterns)));\n+\n+\treturn files\n+\t\t.map(function (file) {\n+\t\t\tif (fs.statSync(file).isDirectory()) {\n+\t\t\t\tvar pattern = path.join(file, '**', '*.js');\n+\n+\t\t\t\tif (process.platform === 'win32') {\n+\t\t\t\t\t// Always use / in patterns, harmonizing matching across platforms.\n+\t\t\t\t\tpattern = slash(pattern);\n+\t\t\t\t}\n+\n+\t\t\t\treturn handlePaths([pattern], excludePatterns);\n+\t\t\t}\n+\n+\t\t\t// globby returns slashes even on Windows. Normalize here so the file\n+\t\t\t// paths are consistently platform-accurate as tests are run.\n+\t\t\treturn path.normalize(file);\n+\t\t})\n+\t\t.then(flatten)\n+\t\t.filter(function (file) {\n+\t\t\treturn path.extname(file) === '.js' && path.basename(file)[0] !== '_';\n+\t\t})\n+\t\t.map(function (file) {\n+\t\t\treturn path.resolve(file);\n+\t\t});\n+}\n+\n+module.exports = AvaFiles;\n+module.exports.defaultIncludePatterns = defaultIncludePatterns;\n+module.exports.defaultExcludePatterns = defaultExcludePatterns;"
      },
      {
        "sha": "e9847a5739ba761665784b89852c99af19dfaf65",
        "filename": "lib/logger.js",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/avajs/ava/blob/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/lib%2Flogger.js",
        "raw_url": "https://github.com/avajs/ava/raw/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/lib%2Flogger.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Flogger.js?ref=bdce76af3f3cfec9cd2608f126a2eaa9036e9399",
        "patch": "@@ -14,64 +14,64 @@ function Logger(reporter) {\n \n module.exports = Logger;\n \n-Logger.prototype.start = function () {\n+Logger.prototype.start = function (runStatus) {\n \tif (!this.reporter.start) {\n \t\treturn;\n \t}\n \n-\tthis.write(this.reporter.start());\n+\tthis.write(this.reporter.start(runStatus), runStatus);\n };\n \n-Logger.prototype.reset = function () {\n+Logger.prototype.reset = function (runStatus) {\n \tif (!this.reporter.reset) {\n \t\treturn;\n \t}\n \n-\tthis.write(this.reporter.reset());\n+\tthis.write(this.reporter.reset(runStatus), runStatus);\n };\n \n-Logger.prototype.test = function (test) {\n-\tthis.write(this.reporter.test(test));\n+Logger.prototype.test = function (test, runStatus) {\n+\tthis.write(this.reporter.test(test, runStatus), runStatus);\n };\n \n-Logger.prototype.unhandledError = function (err) {\n+Logger.prototype.unhandledError = function (err, runStatus) {\n \tif (!this.reporter.unhandledError) {\n \t\treturn;\n \t}\n \n-\tthis.write(this.reporter.unhandledError(err));\n+\tthis.write(this.reporter.unhandledError(err, runStatus), runStatus);\n };\n \n-Logger.prototype.finish = function () {\n+Logger.prototype.finish = function (runStatus) {\n \tif (!this.reporter.finish) {\n \t\treturn;\n \t}\n \n-\tthis.write(this.reporter.finish());\n+\tthis.write(this.reporter.finish(runStatus), runStatus);\n };\n \n-Logger.prototype.write = function (str) {\n+Logger.prototype.write = function (str, runStatus) {\n \tif (typeof str === 'undefined') {\n \t\treturn;\n \t}\n \n-\tthis.reporter.write(str);\n+\tthis.reporter.write(str, runStatus);\n };\n \n-Logger.prototype.stdout = function (data) {\n+Logger.prototype.stdout = function (data, runStatus) {\n \tif (!this.reporter.stdout) {\n \t\treturn;\n \t}\n \n-\tthis.reporter.stdout(data);\n+\tthis.reporter.stdout(data, runStatus);\n };\n \n-Logger.prototype.stderr = function (data) {\n+Logger.prototype.stderr = function (data, runStatus) {\n \tif (!this.reporter.stderr) {\n \t\treturn;\n \t}\n \n-\tthis.reporter.stderr(data);\n+\tthis.reporter.stderr(data, runStatus);\n };\n \n Logger.prototype.exit = function (code) {"
      },
      {
        "sha": "124fc54445bdfeaa25c988c2933882eb3a82f0e2",
        "filename": "lib/reporters/mini.js",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/avajs/ava/blob/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/lib%2Freporters%2Fmini.js",
        "raw_url": "https://github.com/avajs/ava/raw/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/lib%2Freporters%2Fmini.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Fmini.js?ref=bdce76af3f3cfec9cd2608f126a2eaa9036e9399",
        "patch": "@@ -135,7 +135,7 @@ MiniReporter.prototype.reportCounts = function () {\n \treturn status;\n };\n \n-MiniReporter.prototype.finish = function () {\n+MiniReporter.prototype.finish = function (runStatus) {\n \tthis.clearInterval();\n \n \tvar status = this.reportCounts();\n@@ -151,7 +151,7 @@ MiniReporter.prototype.finish = function () {\n \tvar i = 0;\n \n \tif (this.failCount > 0) {\n-\t\tthis.api.errors.forEach(function (test) {\n+\t\trunStatus.errors.forEach(function (test) {\n \t\t\tif (!test.error || !test.error.message) {\n \t\t\t\treturn;\n \t\t\t}\n@@ -173,7 +173,7 @@ MiniReporter.prototype.finish = function () {\n \t}\n \n \tif (this.rejectionCount > 0 || this.exceptionCount > 0) {\n-\t\tthis.api.errors.forEach(function (err) {\n+\t\trunStatus.errors.forEach(function (err) {\n \t\t\tif (err.title) {\n \t\t\t\treturn;\n \t\t\t}"
      },
      {
        "sha": "937ee9e337ee00413eebd833326ea863ed3053c7",
        "filename": "lib/reporters/tap.js",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/avajs/ava/blob/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/lib%2Freporters%2Ftap.js",
        "raw_url": "https://github.com/avajs/ava/raw/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/lib%2Freporters%2Ftap.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Ftap.js?ref=bdce76af3f3cfec9cd2608f126a2eaa9036e9399",
        "patch": "@@ -75,19 +75,19 @@ TapReporter.prototype.unhandledError = function (err) {\n \treturn output.join('\\n');\n };\n \n-TapReporter.prototype.finish = function () {\n+TapReporter.prototype.finish = function (runStatus) {\n \tvar output = [\n \t\t'',\n-\t\t'1..' + (this.api.passCount + this.api.failCount + this.api.skipCount),\n-\t\t'# tests ' + (this.api.passCount + this.api.failCount + this.api.skipCount),\n-\t\t'# pass ' + this.api.passCount\n+\t\t'1..' + (runStatus.passCount + runStatus.failCount + runStatus.skipCount),\n+\t\t'# tests ' + (runStatus.passCount + runStatus.failCount + runStatus.skipCount),\n+\t\t'# pass ' + runStatus.passCount\n \t];\n \n-\tif (this.api.skipCount > 0) {\n-\t\toutput.push('# skip ' + this.api.skipCount);\n+\tif (runStatus.skipCount > 0) {\n+\t\toutput.push('# skip ' + runStatus.skipCount);\n \t}\n \n-\toutput.push('# fail ' + (this.api.failCount + this.api.rejectionCount + this.api.exceptionCount), '');\n+\toutput.push('# fail ' + (runStatus.failCount + runStatus.rejectionCount + runStatus.exceptionCount), '');\n \n \treturn output.join('\\n');\n };"
      },
      {
        "sha": "8befa84ff2e555e51774126920e4f98f6e354ed7",
        "filename": "lib/reporters/verbose.js",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/avajs/ava/blob/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/lib%2Freporters%2Fverbose.js",
        "raw_url": "https://github.com/avajs/ava/raw/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/lib%2Freporters%2Fverbose.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Fverbose.js?ref=bdce76af3f3cfec9cd2608f126a2eaa9036e9399",
        "patch": "@@ -20,7 +20,7 @@ VerboseReporter.prototype.start = function () {\n \treturn '';\n };\n \n-VerboseReporter.prototype.test = function (test) {\n+VerboseReporter.prototype.test = function (test, runStatus) {\n \tif (test.error) {\n \t\treturn '  ' + colors.error(figures.cross) + ' ' + test.title + ' ' + colors.error(test.error.message);\n \t}\n@@ -31,7 +31,7 @@ VerboseReporter.prototype.test = function (test) {\n \t\treturn '  ' + colors.skip('- ' + test.title);\n \t}\n \n-\tif (this.api.fileCount === 1 && this.api.testCount === 1 && test.title === '[anonymous]') {\n+\tif (runStatus.fileCount === 1 && runStatus.testCount === 1 && test.title === '[anonymous]') {\n \t\treturn undefined;\n \t}\n \n@@ -65,37 +65,37 @@ VerboseReporter.prototype.unhandledError = function (err) {\n \treturn output;\n };\n \n-VerboseReporter.prototype.finish = function () {\n+VerboseReporter.prototype.finish = function (runStatus) {\n \tvar output = '\\n';\n \n-\tif (this.api.failCount > 0) {\n-\t\toutput += '  ' + colors.error(this.api.failCount, plur('test', this.api.failCount), 'failed') + '\\n';\n+\tif (runStatus.failCount > 0) {\n+\t\toutput += '  ' + colors.error(runStatus.failCount, plur('test', runStatus.failCount), 'failed') + '\\n';\n \t} else {\n-\t\toutput += '  ' + colors.pass(this.api.passCount, plur('test', this.api.passCount), 'passed') + '\\n';\n+\t\toutput += '  ' + colors.pass(runStatus.passCount, plur('test', runStatus.passCount), 'passed') + '\\n';\n \t}\n \n-\tif (this.api.skipCount > 0) {\n-\t\toutput += '  ' + colors.skip(this.api.skipCount, plur('test', this.api.skipCount), 'skipped') + '\\n';\n+\tif (runStatus.skipCount > 0) {\n+\t\toutput += '  ' + colors.skip(runStatus.skipCount, plur('test', runStatus.skipCount), 'skipped') + '\\n';\n \t}\n \n-\tif (this.api.todoCount > 0) {\n-\t\toutput += '  ' + colors.todo(this.api.todoCount, plur('test', this.api.todoCount), 'todo') + '\\n';\n+\tif (runStatus.todoCount > 0) {\n+\t\toutput += '  ' + colors.todo(runStatus.todoCount, plur('test', runStatus.todoCount), 'todo') + '\\n';\n \t}\n \n-\tif (this.api.rejectionCount > 0) {\n-\t\toutput += '  ' + colors.error(this.api.rejectionCount, 'unhandled', plur('rejection', this.api.rejectionCount)) + '\\n';\n+\tif (runStatus.rejectionCount > 0) {\n+\t\toutput += '  ' + colors.error(runStatus.rejectionCount, 'unhandled', plur('rejection', runStatus.rejectionCount)) + '\\n';\n \t}\n \n-\tif (this.api.exceptionCount > 0) {\n-\t\toutput += '  ' + colors.error(this.api.exceptionCount, 'uncaught', plur('exception', this.api.exceptionCount)) + '\\n';\n+\tif (runStatus.exceptionCount > 0) {\n+\t\toutput += '  ' + colors.error(runStatus.exceptionCount, 'uncaught', plur('exception', runStatus.exceptionCount)) + '\\n';\n \t}\n \n-\tif (this.api.failCount > 0) {\n+\tif (runStatus.failCount > 0) {\n \t\toutput += '\\n';\n \n \t\tvar i = 0;\n \n-\t\tthis.api.tests.forEach(function (test) {\n+\t\trunStatus.tests.forEach(function (test) {\n \t\t\tif (!(test.error && test.error.message)) {\n \t\t\t\treturn;\n \t\t\t}"
      },
      {
        "sha": "d5d167db09cd18b0111b4e97e878ae31580f5531",
        "filename": "lib/run-status.js",
        "status": "added",
        "additions": 181,
        "deletions": 0,
        "changes": 181,
        "blob_url": "https://github.com/avajs/ava/blob/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/lib%2Frun-status.js",
        "raw_url": "https://github.com/avajs/ava/raw/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/lib%2Frun-status.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Frun-status.js?ref=bdce76af3f3cfec9cd2608f126a2eaa9036e9399",
        "patch": "@@ -0,0 +1,181 @@\n+'use strict';\n+var path = require('path');\n+var util = require('util');\n+var chalk = require('chalk');\n+var isObj = require('is-obj');\n+var flatten = require('arr-flatten');\n+var figures = require('figures');\n+var EventEmitter = require('events').EventEmitter;\n+var formatter = require('./enhance-assert').formatter();\n+\n+function TestData(opts) {\n+\tif (!(this instanceof TestData)) {\n+\t\tthrow new TypeError('Class constructor TestData cannot be invoked without \\'new\\'');\n+\t}\n+\tEventEmitter.call(this);\n+\n+\topts = opts || {};\n+\tthis.prefixTitles = opts.prefixTitles !== false;\n+\tthis.hasExclusive = Boolean(opts.runOnlyExclusive);\n+\tthis.base = opts.base || '';\n+\n+\tthis.rejectionCount = 0;\n+\tthis.exceptionCount = 0;\n+\tthis.passCount = 0;\n+\tthis.skipCount = 0;\n+\tthis.todoCount = 0;\n+\tthis.failCount = 0;\n+\tthis.fileCount = 0;\n+\tthis.testCount = 0;\n+\tthis.errors = [];\n+\tthis.stats = [];\n+\tthis.tests = [];\n+\n+\tObject.keys(TestData.prototype).forEach(function (key) {\n+\t\tthis[key] = this[key].bind(this);\n+\t}, this);\n+}\n+\n+util.inherits(TestData, EventEmitter);\n+module.exports = TestData;\n+\n+TestData.prototype.observeFork = function (emitter) {\n+\temitter\n+\t\t.on('teardown', this.handleTeardown)\n+\t\t.on('stats', this.handleStats)\n+\t\t.on('test', this.handleTest)\n+\t\t.on('unhandledRejections', this.handleRejections)\n+\t\t.on('uncaughtException', this.handleExceptions)\n+\t\t.on('stdout', this.handleOutput.bind(this, 'stdout'))\n+\t\t.on('stderr', this.handleOutput.bind(this, 'stderr'));\n+};\n+\n+function normalizeError(err) {\n+\tif (!isObj(err)) {\n+\t\terr = {\n+\t\t\tmessage: err,\n+\t\t\tstack: err\n+\t\t};\n+\t}\n+\n+\treturn err;\n+}\n+\n+TestData.prototype.handleRejections = function (data) {\n+\tthis.rejectionCount += data.rejections.length;\n+\n+\tdata.rejections.forEach(function (err) {\n+\t\terr = normalizeError(err);\n+\t\terr.type = 'rejection';\n+\t\terr.file = data.file;\n+\t\tthis.emit('error', err, this);\n+\t\tthis.errors.push(err);\n+\t}, this);\n+};\n+\n+TestData.prototype.handleExceptions = function (data) {\n+\tthis.exceptionCount++;\n+\tvar err = normalizeError(data.exception);\n+\terr.type = 'exception';\n+\terr.file = data.file;\n+\tthis.emit('error', err, this);\n+\tthis.errors.push(err);\n+};\n+\n+TestData.prototype.handleTeardown = function (data) {\n+\tthis.emit('dependencies', data.file, data.dependencies, this);\n+};\n+\n+TestData.prototype.handleStats = function (stats) {\n+\tthis.emit('stats', stats, this);\n+\n+\tif (this.hasExclusive && !stats.hasExclusive) {\n+\t\treturn;\n+\t}\n+\n+\tif (!this.hasExclusive && stats.hasExclusive) {\n+\t\tthis.hasExclusive = true;\n+\t\tthis.testCount = 0;\n+\t}\n+\n+\tthis.testCount += stats.testCount;\n+};\n+\n+TestData.prototype.handleTest = function (test) {\n+\ttest.title = this.prefixTitle(test.file) + test.title;\n+\n+\tif (test.error) {\n+\t\tif (test.error.powerAssertContext) {\n+\t\t\tvar message = formatter(test.error.powerAssertContext);\n+\n+\t\t\tif (test.error.originalMessage) {\n+\t\t\t\tmessage = test.error.originalMessage + ' ' + message;\n+\t\t\t}\n+\n+\t\t\ttest.error.message = message;\n+\t\t}\n+\n+\t\tif (test.error.name !== 'AssertionError') {\n+\t\t\ttest.error.message = 'failed with \"' + test.error.message + '\"';\n+\t\t}\n+\n+\t\tthis.errors.push(test);\n+\t}\n+\n+\tthis.emit('test', test, this);\n+};\n+\n+TestData.prototype.prefixTitle = function (file) {\n+\tif (!this.prefixTitles) {\n+\t\treturn '';\n+\t}\n+\n+\tvar separator = ' ' + chalk.gray.dim(figures.pointerSmall) + ' ';\n+\n+\tvar prefix = path.relative('.', file)\n+\t\t.replace(this.base, '')\n+\t\t.replace(/\\.spec/, '')\n+\t\t.replace(/\\.test/, '')\n+\t\t.replace(/test\\-/g, '')\n+\t\t.replace(/\\.js$/, '')\n+\t\t.split(path.sep)\n+\t\t.join(separator);\n+\n+\tif (prefix.length > 0) {\n+\t\tprefix += separator;\n+\t}\n+\n+\treturn prefix;\n+};\n+\n+TestData.prototype.handleOutput = function (channel, data) {\n+\tthis.emit(channel, data, this);\n+};\n+\n+TestData.prototype.processResults = function (results) {\n+\t// assemble stats from all tests\n+\tthis.stats = results.map(function (result) {\n+\t\treturn result.stats;\n+\t});\n+\n+\tthis.tests = results.map(function (result) {\n+\t\treturn result.tests;\n+\t});\n+\n+\tthis.tests = flatten(this.tests);\n+\n+\tthis.passCount = sum(this.stats, 'passCount');\n+\tthis.skipCount = sum(this.stats, 'skipCount');\n+\tthis.todoCount = sum(this.stats, 'todoCount');\n+\tthis.failCount = sum(this.stats, 'failCount');\n+};\n+\n+function sum(arr, key) {\n+\tvar result = 0;\n+\n+\tarr.forEach(function (item) {\n+\t\tresult += item[key];\n+\t});\n+\n+\treturn result;\n+}"
      },
      {
        "sha": "dd4f74c7ca550c9b089d8c075af304c171ba6d3c",
        "filename": "lib/watcher.js",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/avajs/ava/blob/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/lib%2Fwatcher.js",
        "raw_url": "https://github.com/avajs/ava/raw/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/lib%2Fwatcher.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Fwatcher.js?ref=bdce76af3f3cfec9cd2608f126a2eaa9036e9399",
        "patch": "@@ -9,6 +9,7 @@ var defaultIgnore = require('ignore-by-default').directories();\n var multimatch = require('multimatch');\n var slash = require('slash');\n var AvaError = require('./ava-error');\n+var AvaFiles = require('./ava-files');\n \n function requireChokidar() {\n \ttry {\n@@ -35,7 +36,7 @@ var matchable = process.platform === 'win32' ? slash : function (path) {\n function Watcher(logger, api, files, sources) {\n \tthis.debouncer = new Debouncer(this);\n \n-\tthis.isTest = makeTestMatcher(files, api.excludePatterns);\n+\tthis.isTest = makeTestMatcher(files, AvaFiles.defaultExcludePatterns());\n \tthis.run = function (specificFiles) {\n \t\tlogger.reset();\n \n@@ -58,8 +59,8 @@ function Watcher(logger, api, files, sources) {\n \n \t\tthis.busy = api.run(specificFiles || files, {\n \t\t\trunOnlyExclusive: runOnlyExclusive\n-\t\t}).then(function () {\n-\t\t\tlogger.finish();\n+\t\t}).then(function (runStatus) {\n+\t\t\tlogger.finish(runStatus);\n \t\t}, rethrowAsync);\n \t};\n "
      },
      {
        "sha": "5b98a10b37c597e6533b525d9fe8ac4756cb8221",
        "filename": "test/api.js",
        "status": "modified",
        "additions": 245,
        "deletions": 201,
        "changes": 446,
        "blob_url": "https://github.com/avajs/ava/blob/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/test%2Fapi.js",
        "raw_url": "https://github.com/avajs/ava/raw/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/test%2Fapi.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fapi.js?ref=bdce76af3f3cfec9cd2608f126a2eaa9036e9399",
        "patch": "@@ -21,8 +21,8 @@ test('ES2015 support', function (t) {\n \tvar api = new Api();\n \n \tapi.run([path.join(__dirname, 'fixture/es2015.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 1);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n });\n \n@@ -32,8 +32,8 @@ test('generators support', function (t) {\n \tvar api = new Api();\n \n \tapi.run([path.join(__dirname, 'fixture/generators.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 1);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n });\n \n@@ -43,8 +43,8 @@ test('async/await support', function (t) {\n \tvar api = new Api();\n \n \tapi.run([path.join(__dirname, 'fixture/async-await.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 2);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 2);\n \t\t});\n });\n \n@@ -76,13 +76,15 @@ test('test title prefixes — multiple files', function (t) {\n \t\t\tt.is(expected.length, 0);\n \t\t});\n \n-\tapi.on('test', function (a) {\n-\t\tindex = expected.indexOf(a.title);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('test', function (a) {\n+\t\t\tindex = expected.indexOf(a.title);\n \n-\t\tt.true(index >= 0);\n+\t\t\tt.true(index >= 0);\n \n-\t\t// remove line from expected output\n-\t\texpected.splice(index, 1);\n+\t\t\t// remove line from expected output\n+\t\t\texpected.splice(index, 1);\n+\t\t});\n \t});\n });\n \n@@ -107,13 +109,15 @@ test('test title prefixes — single file', function (t) {\n \t\t\tt.is(expected.length, 0);\n \t\t});\n \n-\tapi.on('test', function (a) {\n-\t\tindex = expected.indexOf(a.title);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('test', function (a) {\n+\t\t\tindex = expected.indexOf(a.title);\n \n-\t\tt.true(index >= 0);\n+\t\t\tt.true(index >= 0);\n \n-\t\t// remove line from expected output\n-\t\texpected.splice(index, 1);\n+\t\t\t// remove line from expected output\n+\t\t\texpected.splice(index, 1);\n+\t\t});\n \t});\n });\n \n@@ -140,13 +144,15 @@ test('test title prefixes — single file (explicit)', function (t) {\n \t\t\tt.is(expected.length, 0);\n \t\t});\n \n-\tapi.on('test', function (a) {\n-\t\tindex = expected.indexOf(a.title);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('test', function (a) {\n+\t\t\tindex = expected.indexOf(a.title);\n \n-\t\tt.true(index >= 0);\n+\t\t\tt.true(index >= 0);\n \n-\t\t// remove line from expected output\n-\t\texpected.splice(index, 1);\n+\t\t\t// remove line from expected output\n+\t\t\texpected.splice(index, 1);\n+\t\t});\n \t});\n });\n \n@@ -161,10 +167,10 @@ test('display filename prefixes for failed test stack traces', function (t) {\n \tvar api = new Api();\n \n \tapi.run(files)\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 2);\n-\t\t\tt.is(api.failCount, 1);\n-\t\t\tt.match(api.errors[0].title, /one-pass-one-fail \\S this is a failing test/);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 2);\n+\t\t\tt.is(result.failCount, 1);\n+\t\t\tt.match(result.errors[0].title, /one-pass-one-fail \\S this is a failing test/);\n \t\t});\n });\n \n@@ -181,10 +187,10 @@ test('display filename prefixes for failed test stack traces in subdirs', functi\n \tvar api = new Api();\n \n \tapi.run(files)\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 1);\n-\t\t\tt.is(api.failCount, 1);\n-\t\t\tt.match(api.errors[0].title, /subdir \\S failing-subdir \\S subdir fail/);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 1);\n+\t\t\tt.is(result.failCount, 1);\n+\t\t\tt.match(result.errors[0].title, /subdir \\S failing-subdir \\S subdir fail/);\n \t\t});\n });\n \n@@ -197,15 +203,17 @@ test('fail-fast mode', function (t) {\n \n \tvar tests = [];\n \n-\tapi.on('test', function (test) {\n-\t\ttests.push({\n-\t\t\tok: !test.error,\n-\t\t\ttitle: test.title\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('test', function (test) {\n+\t\t\ttests.push({\n+\t\t\t\tok: !test.error,\n+\t\t\t\ttitle: test.title\n+\t\t\t});\n \t\t});\n \t});\n \n \tapi.run([path.join(__dirname, 'fixture/fail-fast.js')])\n-\t\t.then(function () {\n+\t\t.then(function (result) {\n \t\t\tt.ok(api.options.failFast);\n \t\t\tt.same(tests, [{\n \t\t\t\tok: true,\n@@ -214,9 +222,9 @@ test('fail-fast mode', function (t) {\n \t\t\t\tok: false,\n \t\t\t\ttitle: 'second fail'\n \t\t\t}]);\n-\t\t\tt.is(api.passCount, 1);\n-\t\t\tt.is(api.failCount, 1);\n-\t\t\tt.match(api.errors[0].error.message, /Test failed via t.fail()/);\n+\t\t\tt.is(result.passCount, 1);\n+\t\t\tt.is(result.failCount, 1);\n+\t\t\tt.match(result.errors[0].error.message, /Test failed via t.fail()/);\n \t\t});\n });\n \n@@ -228,10 +236,10 @@ test('serial execution mode', function (t) {\n \t});\n \n \tapi.run([path.join(__dirname, 'fixture/serial.js')])\n-\t\t.then(function () {\n+\t\t.then(function (result) {\n \t\t\tt.ok(api.options.serial);\n-\t\t\tt.is(api.passCount, 3);\n-\t\t\tt.is(api.failCount, 0);\n+\t\t\tt.is(result.passCount, 3);\n+\t\t\tt.is(result.failCount, 0);\n \t\t});\n });\n \n@@ -241,9 +249,9 @@ test('circular references on assertions do not break process.send', function (t)\n \tvar api = new Api();\n \n \tapi.run([path.join(__dirname, 'fixture/circular-reference-on-assertion.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.failCount, 1);\n-\t\t\tt.match(api.errors[0].error.message, /'c'.*?'d'/);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.failCount, 1);\n+\t\t\tt.match(result.errors[0].error.message, /'c'.*?'d'/);\n \t\t});\n });\n \n@@ -253,8 +261,8 @@ test('change process.cwd() to a test\\'s directory', function (t) {\n \tvar api = new Api();\n \n \tapi.run([path.join(__dirname, 'fixture/process-cwd.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 1);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n });\n \n@@ -263,14 +271,16 @@ test('unhandled promises will throw an error', function (t) {\n \n \tvar api = new Api();\n \n-\tapi.on('error', function (data) {\n-\t\tt.is(data.name, 'Error');\n-\t\tt.match(data.message, /You can't handle this!/);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('error', function (data) {\n+\t\t\tt.is(data.name, 'Error');\n+\t\t\tt.match(data.message, /You can't handle this!/);\n+\t\t});\n \t});\n \n \tapi.run([path.join(__dirname, 'fixture/loud-rejection.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 1);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n });\n \n@@ -279,14 +289,16 @@ test('uncaught exception will throw an error', function (t) {\n \n \tvar api = new Api();\n \n-\tapi.on('error', function (data) {\n-\t\tt.is(data.name, 'Error');\n-\t\tt.match(data.message, /Can't catch me!/);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('error', function (data) {\n+\t\t\tt.is(data.name, 'Error');\n+\t\t\tt.match(data.message, /Can't catch me!/);\n+\t\t});\n \t});\n \n \tapi.run([path.join(__dirname, 'fixture/uncaught-exception.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 1);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n });\n \n@@ -296,9 +308,9 @@ test('errors can occur without messages', function (t) {\n \tvar api = new Api();\n \n \tapi.run([path.join(__dirname, 'fixture/error-without-message.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.failCount, 1);\n-\t\t\tt.is(api.errors.length, 1);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.failCount, 1);\n+\t\t\tt.is(result.errors.length, 1);\n \t\t});\n });\n \n@@ -309,15 +321,17 @@ test('stack traces for exceptions are corrected using a source map file', functi\n \t\tcacheEnabled: true\n \t});\n \n-\tapi.on('error', function (data) {\n-\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n-\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n-\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-file.js:11.*$/m);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('error', function (data) {\n+\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n+\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n+\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-file.js:11.*$/m);\n+\t\t});\n \t});\n \n \tapi.run([path.join(__dirname, 'fixture/source-map-file.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 1);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n });\n \n@@ -328,15 +342,17 @@ test('stack traces for exceptions are corrected using a source map file (cache o\n \t\tcacheEnabled: false\n \t});\n \n-\tapi.on('error', function (data) {\n-\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n-\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n-\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-file.js:11.*$/m);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('error', function (data) {\n+\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n+\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n+\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-file.js:11.*$/m);\n+\t\t});\n \t});\n \n \tapi.run([path.join(__dirname, 'fixture/source-map-file.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 1);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n });\n \n@@ -347,15 +363,17 @@ test('stack traces for exceptions are corrected using a source map, taking an in\n \t\tcacheEnabled: true\n \t});\n \n-\tapi.on('error', function (data) {\n-\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n-\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n-\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-initial-input.js:7.*$/m);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('error', function (data) {\n+\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n+\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n+\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-initial-input.js:7.*$/m);\n+\t\t});\n \t});\n \n \tapi.run([path.join(__dirname, 'fixture/source-map-initial.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 1);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n });\n \n@@ -366,15 +384,17 @@ test('stack traces for exceptions are corrected using a source map, taking an in\n \t\tcacheEnabled: false\n \t});\n \n-\tapi.on('error', function (data) {\n-\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n-\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n-\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-initial-input.js:7.*$/m);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('error', function (data) {\n+\t\t\tt.match(data.message, /Thrown by source-map-fixtures/);\n+\t\t\tt.match(data.stack, /^.*?Object\\.t.*?as run\\b.*source-map-fixtures.src.throws.js:1.*$/m);\n+\t\t\tt.match(data.stack, /^.*?Immediate\\b.*source-map-initial-input.js:7.*$/m);\n+\t\t});\n \t});\n \n \tapi.run([path.join(__dirname, 'fixture/source-map-initial.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 1);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n });\n \n@@ -384,8 +404,8 @@ test('absolute paths', function (t) {\n \tvar api = new Api();\n \n \tapi.run([path.resolve('test/fixture/es2015.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 1);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n });\n \n@@ -395,9 +415,9 @@ test('search directories recursively for files', function (t) {\n \tvar api = new Api();\n \n \tapi.run([path.join(__dirname, 'fixture/subdir')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 2);\n-\t\t\tt.is(api.failCount, 1);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 2);\n+\t\t\tt.is(result.failCount, 1);\n \t\t});\n });\n \n@@ -407,10 +427,10 @@ test('titles of both passing and failing tests and AssertionErrors are returned'\n \tvar api = new Api();\n \n \tapi.run([path.join(__dirname, 'fixture/one-pass-one-fail.js')])\n-\t\t.then(function () {\n-\t\t\tt.match(api.errors[0].title, /this is a failing test/);\n-\t\t\tt.match(api.tests[0].title, /this is a passing test/);\n-\t\t\tt.match(api.errors[0].error.name, /AssertionError/);\n+\t\t.then(function (result) {\n+\t\t\tt.match(result.errors[0].title, /this is a failing test/);\n+\t\t\tt.match(result.tests[0].title, /this is a passing test/);\n+\t\t\tt.match(result.errors[0].error.name, /AssertionError/);\n \t\t});\n });\n \n@@ -419,9 +439,11 @@ test('empty test files cause an AvaError to be emitted', function (t) {\n \n \tvar api = new Api();\n \n-\tapi.on('error', function (err) {\n-\t\tt.is(err.name, 'AvaError');\n-\t\tt.match(err.message, /No tests found.*?import \"ava\"/);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('error', function (err) {\n+\t\t\tt.is(err.name, 'AvaError');\n+\t\t\tt.match(err.message, /No tests found.*?import \"ava\"/);\n+\t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/empty.js')]);\n@@ -432,9 +454,11 @@ test('test file with no tests causes an AvaError to be emitted', function (t) {\n \n \tvar api = new Api();\n \n-\tapi.on('error', function (err) {\n-\t\tt.is(err.name, 'AvaError');\n-\t\tt.match(err.message, /No tests/);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('error', function (err) {\n+\t\t\tt.is(err.name, 'AvaError');\n+\t\t\tt.match(err.message, /No tests/);\n+\t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/no-tests.js')]);\n@@ -445,9 +469,11 @@ test('test file that immediately exits with 0 exit code ', function (t) {\n \n \tvar api = new Api();\n \n-\tapi.on('error', function (err) {\n-\t\tt.is(err.name, 'AvaError');\n-\t\tt.match(err.message, /Test results were not received from/);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('error', function (err) {\n+\t\t\tt.is(err.name, 'AvaError');\n+\t\t\tt.match(err.message, /Test results were not received from/);\n+\t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/immediate-0-exit.js')]);\n@@ -458,9 +484,11 @@ test('testing nonexistent files causes an AvaError to be emitted', function (t)\n \n \tvar api = new Api();\n \n-\tapi.on('error', function (err) {\n-\t\tt.is(err.name, 'AvaError');\n-\t\tt.match(err.message, /Couldn't find any files to test/);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('error', function (err) {\n+\t\t\tt.is(err.name, 'AvaError');\n+\t\t\tt.match(err.message, /Couldn't find any files to test/);\n+\t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/broken.js')]);\n@@ -471,22 +499,11 @@ test('test file in node_modules is ignored', function (t) {\n \n \tvar api = new Api();\n \n-\tapi.on('error', function (err) {\n-\t\tt.is(err.name, 'AvaError');\n-\t\tt.match(err.message, /Couldn't find any files to test/);\n-\t});\n-\n-\treturn api.run([path.join(__dirname, 'fixture/ignored-dirs/node_modules/test.js')]);\n-});\n-\n-test('test file in node_modules is ignored', function (t) {\n-\tt.plan(2);\n-\n-\tvar api = new Api();\n-\n-\tapi.on('error', function (err) {\n-\t\tt.is(err.name, 'AvaError');\n-\t\tt.match(err.message, /Couldn't find any files to test/);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('error', function (err) {\n+\t\t\tt.is(err.name, 'AvaError');\n+\t\t\tt.match(err.message, /Couldn't find any files to test/);\n+\t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/ignored-dirs/node_modules/test.js')]);\n@@ -497,9 +514,11 @@ test('test file in fixtures is ignored', function (t) {\n \n \tvar api = new Api();\n \n-\tapi.on('error', function (err) {\n-\t\tt.is(err.name, 'AvaError');\n-\t\tt.match(err.message, /Couldn't find any files to test/);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('error', function (err) {\n+\t\t\tt.is(err.name, 'AvaError');\n+\t\t\tt.match(err.message, /Couldn't find any files to test/);\n+\t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/ignored-dirs/fixtures/test.js')]);\n@@ -510,9 +529,11 @@ test('test file in helpers is ignored', function (t) {\n \n \tvar api = new Api();\n \n-\tapi.on('error', function (err) {\n-\t\tt.is(err.name, 'AvaError');\n-\t\tt.match(err.message, /Couldn't find any files to test/);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('error', function (err) {\n+\t\t\tt.is(err.name, 'AvaError');\n+\t\t\tt.match(err.message, /Couldn't find any files to test/);\n+\t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/ignored-dirs/helpers/test.js')]);\n@@ -528,8 +549,8 @@ test('Node.js-style --require CLI argument', function (t) {\n \t});\n \n \tapi.run([path.join(__dirname, 'fixture/validate-installed-global.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 1);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n });\n \n@@ -548,16 +569,16 @@ test('power-assert support', function (t) {\n \tvar api = new Api();\n \n \tapi.run([path.join(__dirname, 'fixture/power-assert.js')])\n-\t\t.then(function () {\n-\t\t\tt.ok(api.errors[0].error.powerAssertContext);\n+\t\t.then(function (result) {\n+\t\t\tt.ok(result.errors[0].error.powerAssertContext);\n \n \t\t\tt.match(\n-\t\t\t\tapi.errors[0].error.message,\n+\t\t\t\tresult.errors[0].error.message,\n \t\t\t\t/t\\.true\\(a === 'bar'\\)\\s*\\n\\s+\\|\\s*\\n\\s+\"foo\"/m\n \t\t\t);\n \n \t\t\tt.match(\n-\t\t\t\tapi.errors[1].error.message,\n+\t\t\t\tresult.errors[1].error.message,\n \t\t\t\t/with message\\s+t\\.true\\(a === 'foo', 'with message'\\)\\s*\\n\\s+\\|\\s*\\n\\s+\"bar\"/m\n \t\t\t);\n \t\t});\n@@ -604,9 +625,9 @@ test('test file with only skipped tests does not create a failure', function (t)\n \tvar api = new Api();\n \n \tapi.run([path.join(__dirname, 'fixture/skip-only.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.tests.length, 1);\n-\t\t\tt.true(api.tests[0].skip);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.tests.length, 1);\n+\t\t\tt.true(result.tests[0].skip);\n \t\t});\n });\n \n@@ -622,11 +643,11 @@ test('test file with exclusive tests causes non-exclusive tests in other files t\n \tvar api = new Api();\n \n \tapi.run(files)\n-\t\t.then(function () {\n-\t\t\tt.ok(api.hasExclusive);\n-\t\t\tt.is(api.testCount, 2);\n-\t\t\tt.is(api.passCount, 2);\n-\t\t\tt.is(api.failCount, 0);\n+\t\t.then(function (result) {\n+\t\t\tt.ok(result.hasExclusive);\n+\t\t\tt.is(result.testCount, 2);\n+\t\t\tt.is(result.passCount, 2);\n+\t\t\tt.is(result.failCount, 0);\n \t\t});\n });\n \n@@ -637,11 +658,11 @@ test('test files can be forced to run in exclusive mode', function (t) {\n \treturn api.run(\n \t\t[path.join(__dirname, 'fixture/es2015.js')],\n \t\t{runOnlyExclusive: true}\n-\t).then(function () {\n-\t\tt.ok(api.hasExclusive);\n-\t\tt.is(api.testCount, 0);\n-\t\tt.is(api.passCount, 0);\n-\t\tt.is(api.failCount, 0);\n+\t).then(function (result) {\n+\t\tt.ok(result.hasExclusive);\n+\t\tt.is(result.testCount, 0);\n+\t\tt.is(result.passCount, 0);\n+\t\tt.is(result.failCount, 0);\n \t});\n });\n \n@@ -650,11 +671,11 @@ test('resets state before running', function (t) {\n \n \tvar api = new Api();\n \n-\tapi.run([path.resolve('test/fixture/es2015.js')]).then(function () {\n-\t\tt.is(api.passCount, 1);\n+\tapi.run([path.resolve('test/fixture/es2015.js')]).then(function (result) {\n+\t\tt.is(result.passCount, 1);\n \t\treturn api.run([path.resolve('test/fixture/es2015.js')]);\n-\t}).then(function () {\n-\t\tt.is(api.passCount, 1);\n+\t}).then(function (result) {\n+\t\tt.is(result.passCount, 1);\n \t});\n });\n \n@@ -678,30 +699,35 @@ test('emits dependencies for test files', function (t) {\n \t\tpath.resolve('test/fixture/with-dependencies/dep-3.custom')\n \t];\n \n-\tapi.on('dependencies', function (file, dependencies) {\n-\t\tt.notEqual(testFiles.indexOf(file), -1);\n-\t\tt.same(dependencies.slice(-3), sourceFiles);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('dependencies', function (file, dependencies) {\n+\t\t\tt.notEqual(testFiles.indexOf(file), -1);\n+\t\t\tt.same(dependencies.slice(-3), sourceFiles);\n+\t\t});\n+\n+\t\t// The test files are designed to cause errors so ignore them here.\n+\t\trunStatus.on('error', function () {});\n \t});\n \n \tvar result = api.run(['test/fixture/with-dependencies/*test*.js']);\n \n-\t// The test files are designed to cause errors so ignore them here.\n-\tapi.on('error', function () {});\n-\tresult.catch(function () {});\n+\treturn result.catch(function () {});\n });\n \n test('emits stats for test files', function (t) {\n \tt.plan(2);\n \n \tvar api = new Api();\n-\tapi.on('stats', function (stats) {\n-\t\tif (stats.file === path.normalize('test/fixture/exclusive.js')) {\n-\t\t\tt.is(stats.hasExclusive, true);\n-\t\t} else if (stats.file === path.normalize('test/fixture/generators.js')) {\n-\t\t\tt.is(stats.hasExclusive, false);\n-\t\t} else {\n-\t\t\tt.ok(false);\n-\t\t}\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('stats', function (stats) {\n+\t\t\tif (stats.file === path.normalize('test/fixture/exclusive.js')) {\n+\t\t\t\tt.is(stats.hasExclusive, true);\n+\t\t\t} else if (stats.file === path.normalize('test/fixture/generators.js')) {\n+\t\t\t\tt.is(stats.hasExclusive, false);\n+\t\t\t} else {\n+\t\t\t\tt.ok(false);\n+\t\t\t}\n+\t\t});\n \t});\n \n \treturn api.run([\n@@ -715,18 +741,20 @@ test('verify test count', function (t) {\n \n \tvar api = new Api();\n \n-\tt.is(api.passCount, 0);\n-\tt.is(api.failCount, 0);\n-\tt.is(api.skipCount, 0);\n-\tt.is(api.todoCount, 0);\n+\tapi.on('test-run', function (runStatus) {\n+\t\tt.is(runStatus.passCount, 0);\n+\t\tt.is(runStatus.failCount, 0);\n+\t\tt.is(runStatus.skipCount, 0);\n+\t\tt.is(runStatus.todoCount, 0);\n+\t});\n \n \treturn api.run([\n \t\tpath.join(__dirname, 'fixture/test-count.js')\n-\t]).then(function () {\n-\t\tt.is(api.passCount, 1);\n-\t\tt.is(api.failCount, 1);\n-\t\tt.is(api.skipCount, 1);\n-\t\tt.is(api.todoCount, 1);\n+\t]).then(function (result) {\n+\t\tt.is(result.passCount, 1);\n+\t\tt.is(result.failCount, 1);\n+\t\tt.is(result.skipCount, 1);\n+\t\tt.is(result.todoCount, 1);\n \t});\n });\n \n@@ -741,14 +769,16 @@ test('Custom Babel Plugin Support', function (t) {\n \t\tcacheEnabled: false\n \t});\n \n-\tapi.on('test', function (data) {\n-\t\tt.is(data.title, 'FOO');\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('test', function (data) {\n+\t\t\tt.is(data.title, 'FOO');\n+\t\t});\n \t});\n \n \tapi.run([path.join(__dirname, 'fixture/babelrc/test.js')])\n \t\t.then(\n-\t\t\tfunction () {\n-\t\t\t\tt.is(api.passCount, 1);\n+\t\t\tfunction (result) {\n+\t\t\t\tt.is(result.passCount, 1);\n \t\t\t},\n \t\t\tt.threw\n \t\t);\n@@ -759,13 +789,15 @@ test('Default babel config doesn\\'t use .babelrc', function (t) {\n \n \tvar api = new Api();\n \n-\tapi.on('test', function (data) {\n-\t\tt.is(data.title, 'foo');\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('test', function (data) {\n+\t\t\tt.is(data.title, 'foo');\n+\t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/babelrc/test.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 1);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n });\n \n@@ -777,13 +809,15 @@ test('babelConfig:\"inherit\" uses .babelrc', function (t) {\n \t\tcacheEnabled: false\n \t});\n \n-\tapi.on('test', function (data) {\n-\t\tt.ok((data.title === 'foo') || (data.title === 'repeated test: foo'));\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('test', function (data) {\n+\t\t\tt.ok((data.title === 'foo') || (data.title === 'repeated test: foo'));\n+\t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/babelrc/test.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 2);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 2);\n \t\t});\n });\n \n@@ -795,13 +829,15 @@ test('babelConfig:{babelrc:true} uses .babelrc', function (t) {\n \t\tcacheEnabled: false\n \t});\n \n-\tapi.on('test', function (data) {\n-\t\tt.ok((data.title === 'foo') || (data.title === 'repeated test: foo'));\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('test', function (data) {\n+\t\t\tt.ok((data.title === 'foo') || (data.title === 'repeated test: foo'));\n+\t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/babelrc/test.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 2);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 2);\n \t\t});\n });\n \n@@ -816,13 +852,15 @@ test('babelConfig:{babelrc:true, plugins:[...]} merges plugins with .babelrc', f\n \t\tcacheEnabled: false\n \t});\n \n-\tapi.on('test', function (data) {\n-\t\tt.ok((data.title === 'FOO') || /^repeated test:/.test(data.title));\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('test', function (data) {\n+\t\t\tt.ok((data.title === 'FOO') || /^repeated test:/.test(data.title));\n+\t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/babelrc/test.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 2);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 2);\n \t\t});\n });\n \n@@ -837,13 +875,15 @@ test('babelConfig:{extends:path, plugins:[...]} merges plugins with .babelrc', f\n \t\tcacheEnabled: false\n \t});\n \n-\tapi.on('test', function (data) {\n-\t\tt.ok((data.title === 'BAR'));\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('test', function (data) {\n+\t\t\tt.ok((data.title === 'BAR'));\n+\t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/babelrc/test.js')])\n-\t\t.then(function () {\n-\t\t\tt.is(api.passCount, 1);\n+\t\t.then(function (result) {\n+\t\t\tt.is(result.passCount, 1);\n \t\t});\n });\n \n@@ -854,9 +894,11 @@ test('using --match with no matching tests causes an AvaError to be emitted', fu\n \t\tmatch: ['can\\'t match this']\n \t});\n \n-\tapi.on('error', function (err) {\n-\t\tt.is(err.name, 'AvaError');\n-\t\tt.match(err.message, /Couldn't find any matching tests/);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('error', function (err) {\n+\t\t\tt.is(err.name, 'AvaError');\n+\t\t\tt.match(err.message, /Couldn't find any matching tests/);\n+\t\t});\n \t});\n \n \treturn api.run([path.join(__dirname, 'fixture/match-no-match.js')]);\n@@ -867,9 +909,11 @@ test('errors thrown when running files are emitted', function (t) {\n \n \tvar api = new Api();\n \n-\tapi.on('error', function (err) {\n-\t\tt.is(err.name, 'SyntaxError');\n-\t\tt.match(err.message, /Unexpected token/);\n+\tapi.on('test-run', function (runStatus) {\n+\t\trunStatus.on('error', function (err) {\n+\t\t\tt.is(err.name, 'SyntaxError');\n+\t\t\tt.match(err.message, /Unexpected token/);\n+\t\t});\n \t});\n \n \treturn api.run(["
      },
      {
        "sha": "a111e0660f07e8d57a7ebd4fda8a6c8c31a46421",
        "filename": "test/reporters/mini.js",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/avajs/ava/blob/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/test%2Freporters%2Fmini.js",
        "raw_url": "https://github.com/avajs/ava/raw/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/test%2Freporters%2Fmini.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Freporters%2Fmini.js?ref=bdce76af3f3cfec9cd2608f126a2eaa9036e9399",
        "patch": "@@ -214,11 +214,11 @@ test('results with passing tests and rejections', function (t) {\n \terr.type = 'rejection';\n \terr.stack = beautifyStack(err.stack);\n \n-\treporter.api = {\n+\tvar runStatus = {\n \t\terrors: [err]\n \t};\n \n-\tvar output = reporter.finish().split('\\n');\n+\tvar output = reporter.finish(runStatus).split('\\n');\n \n \tt.is(output[0], '');\n \tt.is(output[1], '   ' + chalk.green('1 passed'));\n@@ -242,11 +242,11 @@ test('results with passing tests and exceptions', function (t) {\n \tvar avaErr = new AvaError('A futuristic test runner');\n \tavaErr.type = 'exception';\n \n-\treporter.api = {\n+\tvar runStatus = {\n \t\terrors: [err, avaErr]\n \t};\n \n-\tvar output = reporter.finish().split('\\n');\n+\tvar output = reporter.finish(runStatus).split('\\n');\n \n \tt.is(output[0], '');\n \tt.is(output[1], '   ' + chalk.green('1 passed'));\n@@ -267,14 +267,14 @@ test('results with errors', function (t) {\n \tvar err = new Error('failure');\n \terr.stack = beautifyStack(err.stack);\n \n-\treporter.api = {\n+\tvar runStatus = {\n \t\terrors: [{\n \t\t\ttitle: 'failed',\n \t\t\terror: err\n \t\t}]\n \t};\n \n-\tvar output = reporter.finish().split('\\n');\n+\tvar output = reporter.finish(runStatus).split('\\n');\n \n \tt.is(output[0], '');\n \tt.is(output[1], '   ' + chalk.red('1 failed'));"
      },
      {
        "sha": "c8c0f27245bd33ba49690c0f0f2270d7f9973ad8",
        "filename": "test/reporters/tap.js",
        "status": "modified",
        "additions": 13,
        "deletions": 17,
        "changes": 30,
        "blob_url": "https://github.com/avajs/ava/blob/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/test%2Freporters%2Ftap.js",
        "raw_url": "https://github.com/avajs/ava/raw/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/test%2Freporters%2Ftap.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Freporters%2Ftap.js?ref=bdce76af3f3cfec9cd2608f126a2eaa9036e9399",
        "patch": "@@ -96,24 +96,22 @@ test('ava error', function (t) {\n \n test('results', function (t) {\n \tvar reporter = tapReporter();\n-\tvar api = {\n+\tvar runStatus = {\n \t\tpassCount: 1,\n \t\tfailCount: 2,\n \t\tskipCount: 1,\n \t\trejectionCount: 3,\n \t\texceptionCount: 4\n \t};\n \n-\treporter.api = api;\n-\n-\tvar actualOutput = reporter.finish();\n+\tvar actualOutput = reporter.finish(runStatus);\n \tvar expectedOutput = [\n \t\t'',\n-\t\t'1..' + (api.passCount + api.failCount + api.skipCount),\n-\t\t'# tests ' + (api.passCount + api.failCount + api.skipCount),\n-\t\t'# pass ' + api.passCount,\n-\t\t'# skip ' + api.skipCount,\n-\t\t'# fail ' + (api.failCount + api.rejectionCount + api.exceptionCount),\n+\t\t'1..' + (runStatus.passCount + runStatus.failCount + runStatus.skipCount),\n+\t\t'# tests ' + (runStatus.passCount + runStatus.failCount + runStatus.skipCount),\n+\t\t'# pass ' + runStatus.passCount,\n+\t\t'# skip ' + runStatus.skipCount,\n+\t\t'# fail ' + (runStatus.failCount + runStatus.rejectionCount + runStatus.exceptionCount),\n \t\t''\n \t].join('\\n');\n \n@@ -123,23 +121,21 @@ test('results', function (t) {\n \n test('results does not show skipped tests if there are none', function (t) {\n \tvar reporter = tapReporter();\n-\tvar api = {\n+\tvar runStatus = {\n \t\tpassCount: 1,\n \t\tfailCount: 2,\n \t\tskipCount: 0,\n \t\trejectionCount: 3,\n \t\texceptionCount: 4\n \t};\n \n-\treporter.api = api;\n-\n-\tvar actualOutput = reporter.finish();\n+\tvar actualOutput = reporter.finish(runStatus);\n \tvar expectedOutput = [\n \t\t'',\n-\t\t'1..' + (api.passCount + api.failCount),\n-\t\t'# tests ' + (api.passCount + api.failCount),\n-\t\t'# pass ' + api.passCount,\n-\t\t'# fail ' + (api.failCount + api.rejectionCount + api.exceptionCount),\n+\t\t'1..' + (runStatus.passCount + runStatus.failCount),\n+\t\t'# tests ' + (runStatus.passCount + runStatus.failCount),\n+\t\t'# pass ' + runStatus.passCount,\n+\t\t'# fail ' + (runStatus.failCount + runStatus.rejectionCount + runStatus.exceptionCount),\n \t\t''\n \t].join('\\n');\n "
      },
      {
        "sha": "3e3f8cc2f316efaaf61704a45fccfe8b60251553",
        "filename": "test/reporters/verbose.js",
        "status": "modified",
        "additions": 44,
        "deletions": 35,
        "changes": 79,
        "blob_url": "https://github.com/avajs/ava/blob/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/test%2Freporters%2Fverbose.js",
        "raw_url": "https://github.com/avajs/ava/raw/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/test%2Freporters%2Fverbose.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Freporters%2Fverbose.js?ref=bdce76af3f3cfec9cd2608f126a2eaa9036e9399",
        "patch": "@@ -9,12 +9,14 @@ chalk.enabled = true;\n \n function createReporter() {\n \tvar reporter = verboseReporter();\n-\treporter.api = {\n+\treturn reporter;\n+}\n+\n+function createTestData() {\n+\treturn {\n \t\tfileCount: 1,\n \t\ttestCount: 1\n \t};\n-\n-\treturn reporter;\n }\n \n test('beautify stack - removes uninteresting lines', function (t) {\n@@ -33,7 +35,7 @@ test('beautify stack - removes uninteresting lines', function (t) {\n test('start', function (t) {\n \tvar reporter = createReporter();\n \n-\tt.is(reporter.start(), '');\n+\tt.is(reporter.start(createTestData()), '');\n \tt.end();\n });\n \n@@ -43,7 +45,7 @@ test('passing test and duration less than threshold', function (t) {\n \tvar actualOutput = reporter.test({\n \t\ttitle: 'passed',\n \t\tduration: 90\n-\t});\n+\t}, createTestData());\n \n \tvar expectedOutput = '  ' + chalk.green(figures.tick) + ' passed';\n \n@@ -57,7 +59,7 @@ test('passing test and duration greater than threshold', function (t) {\n \tvar actualOutput = reporter.test({\n \t\ttitle: 'passed',\n \t\tduration: 150\n-\t});\n+\t}, createTestData());\n \n \tvar expectedOutput = '  ' + chalk.green(figures.tick) + ' passed' + chalk.grey.dim(' (150ms)');\n \n@@ -70,7 +72,7 @@ test('don\\'t display test title if there is only one anonymous test', function (\n \n \tvar output = reporter.test({\n \t\ttitle: '[anonymous]'\n-\t});\n+\t}, createTestData());\n \n \tt.is(output, undefined);\n \tt.end();\n@@ -84,7 +86,7 @@ test('failing test', function (t) {\n \t\terror: {\n \t\t\tmessage: 'assertion failed'\n \t\t}\n-\t});\n+\t}, createTestData());\n \n \tvar expectedOutput = '  ' + chalk.red(figures.cross) + ' failed ' + chalk.red('assertion failed');\n \n@@ -98,7 +100,7 @@ test('skipped test', function (t) {\n \tvar actualOutput = reporter.test({\n \t\ttitle: 'skipped',\n \t\tskip: true\n-\t});\n+\t}, createTestData());\n \n \tvar expectedOutput = '  ' + chalk.yellow('- skipped');\n \n@@ -113,7 +115,7 @@ test('todo test', function (t) {\n \t\ttitle: 'todo',\n \t\tskip: true,\n \t\ttodo: true\n-\t});\n+\t}, createTestData());\n \n \tvar expectedOutput = '  ' + chalk.blue('- todo');\n \n@@ -130,7 +132,7 @@ test('uncaught exception', function (t) {\n \t\ttype: 'exception',\n \t\tfile: 'test.js',\n \t\tstack: beautifyStack(error.stack)\n-\t}).split('\\n');\n+\t}, createTestData()).split('\\n');\n \n \tt.is(output[0], chalk.red('Uncaught Exception: test.js'));\n \tt.match(output[1], /Error: Unexpected token/);\n@@ -146,7 +148,7 @@ test('ava error', function (t) {\n \t\tfile: 'test.js',\n \t\tname: 'AvaError',\n \t\tmessage: 'A futuristic test runner'\n-\t}).split('\\n');\n+\t}, createTestData()).split('\\n');\n \n \tt.is(output[0], chalk.red('  ' + figures.cross + ' A futuristic test runner'));\n \tt.end();\n@@ -161,7 +163,7 @@ test('unhandled rejection', function (t) {\n \t\ttype: 'rejection',\n \t\tfile: 'test.js',\n \t\tstack: beautifyStack(error.stack)\n-\t}).split('\\n');\n+\t}, createTestData()).split('\\n');\n \n \tt.is(output[0], chalk.red('Unhandled Rejection: test.js'));\n \tt.match(output[1], /Error: Unexpected token/);\n@@ -178,7 +180,7 @@ test('unhandled error without stack', function (t) {\n \t\tmessage: 'test'\n \t};\n \n-\tvar output = reporter.unhandledError(err).split('\\n');\n+\tvar output = reporter.unhandledError(err, createTestData()).split('\\n');\n \n \tt.is(output[0], chalk.red('Uncaught Exception: test.js'));\n \tt.is(output[1], '  ' + chalk.red(JSON.stringify(err)));\n@@ -187,9 +189,10 @@ test('unhandled error without stack', function (t) {\n \n test('results with passing tests', function (t) {\n \tvar reporter = createReporter();\n-\treporter.api.passCount = 1;\n+\tvar runStatus = createTestData();\n+\trunStatus.passCount = 1;\n \n-\tvar actualOutput = reporter.finish();\n+\tvar actualOutput = reporter.finish(runStatus);\n \tvar expectedOutput = [\n \t\t'',\n \t\t'  ' + chalk.green('1 test passed'),\n@@ -202,10 +205,11 @@ test('results with passing tests', function (t) {\n \n test('results with skipped tests', function (t) {\n \tvar reporter = createReporter();\n-\treporter.api.passCount = 1;\n-\treporter.api.skipCount = 1;\n+\tvar runStatus = createTestData();\n+\trunStatus.passCount = 1;\n+\trunStatus.skipCount = 1;\n \n-\tvar actualOutput = reporter.finish();\n+\tvar actualOutput = reporter.finish(runStatus);\n \tvar expectedOutput = [\n \t\t'',\n \t\t'  ' + chalk.green('1 test passed'),\n@@ -219,10 +223,11 @@ test('results with skipped tests', function (t) {\n \n test('results with todo tests', function (t) {\n \tvar reporter = createReporter();\n-\treporter.api.passCount = 1;\n-\treporter.api.todoCount = 1;\n+\tvar runStatus = createTestData();\n+\trunStatus.passCount = 1;\n+\trunStatus.todoCount = 1;\n \n-\tvar actualOutput = reporter.finish();\n+\tvar actualOutput = reporter.finish(runStatus);\n \tvar expectedOutput = [\n \t\t'',\n \t\t'  ' + chalk.green('1 test passed'),\n@@ -236,10 +241,11 @@ test('results with todo tests', function (t) {\n \n test('results with passing tests and rejections', function (t) {\n \tvar reporter = createReporter();\n-\treporter.api.passCount = 1;\n-\treporter.api.rejectionCount = 1;\n+\tvar runStatus = createTestData();\n+\trunStatus.passCount = 1;\n+\trunStatus.rejectionCount = 1;\n \n-\tvar actualOutput = reporter.finish();\n+\tvar actualOutput = reporter.finish(runStatus);\n \tvar expectedOutput = [\n \t\t'',\n \t\t'  ' + chalk.green('1 test passed'),\n@@ -253,10 +259,11 @@ test('results with passing tests and rejections', function (t) {\n \n test('results with passing tests and exceptions', function (t) {\n \tvar reporter = createReporter();\n-\treporter.api.passCount = 1;\n-\treporter.api.exceptionCount = 1;\n+\tvar runStatus = createTestData();\n+\trunStatus.passCount = 1;\n+\trunStatus.exceptionCount = 1;\n \n-\tvar actualOutput = reporter.finish();\n+\tvar actualOutput = reporter.finish(runStatus);\n \tvar expectedOutput = [\n \t\t'',\n \t\t'  ' + chalk.green('1 test passed'),\n@@ -270,11 +277,12 @@ test('results with passing tests and exceptions', function (t) {\n \n test('results with passing tests, rejections and exceptions', function (t) {\n \tvar reporter = createReporter();\n-\treporter.api.passCount = 1;\n-\treporter.api.exceptionCount = 1;\n-\treporter.api.rejectionCount = 1;\n+\tvar runStatus = createTestData();\n+\trunStatus.passCount = 1;\n+\trunStatus.exceptionCount = 1;\n+\trunStatus.rejectionCount = 1;\n \n-\tvar actualOutput = reporter.finish();\n+\tvar actualOutput = reporter.finish(runStatus);\n \tvar expectedOutput = [\n \t\t'',\n \t\t'  ' + chalk.green('1 test passed'),\n@@ -292,13 +300,14 @@ test('results with errors', function (t) {\n \terror.stack = beautifyStack(error.stack);\n \n \tvar reporter = createReporter();\n-\treporter.api.failCount = 1;\n-\treporter.api.tests = [{\n+\tvar runStatus = createTestData();\n+\trunStatus.failCount = 1;\n+\trunStatus.tests = [{\n \t\ttitle: 'fail',\n \t\terror: error\n \t}];\n \n-\tvar output = reporter.finish().split('\\n');\n+\tvar output = reporter.finish(runStatus).split('\\n');\n \n \tt.is(output[1], '  ' + chalk.red('1 test failed'));\n \tt.is(output[3], '  ' + chalk.red('1. fail'));"
      },
      {
        "sha": "3e893e2411f4761e64340e727b3fb8bc950c103b",
        "filename": "test/watcher.js",
        "status": "modified",
        "additions": 28,
        "deletions": 10,
        "changes": 38,
        "blob_url": "https://github.com/avajs/ava/blob/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/test%2Fwatcher.js",
        "raw_url": "https://github.com/avajs/ava/raw/bdce76af3f3cfec9cd2608f126a2eaa9036e9399/test%2Fwatcher.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fwatcher.js?ref=bdce76af3f3cfec9cd2608f126a2eaa9036e9399",
        "patch": "@@ -63,24 +63,24 @@ group('chokidar is installed', function (beforeEach, test, group) {\n \t};\n \n \tvar api = {\n-\t\texcludePatterns: [\n-\t\t\t'!**/node_modules/**',\n-\t\t\t'!**/fixtures/**',\n-\t\t\t'!**/helpers/**'\n-\t\t],\n \t\ton: function () {},\n \t\trun: sinon.stub()\n \t};\n \n+\tvar avaFiles = sinon.stub();\n+\tavaFiles.defaultExcludePatterns = sinon.stub();\n+\tavaFiles.defaultIncludePatterns = sinon.stub();\n+\n \tvar Subject = proxyquire.noCallThru().load('../lib/watcher', {\n-\t\tchokidar: chokidar,\n-\t\tdebug: function (name) {\n+\t\t'chokidar': chokidar,\n+\t\t'debug': function (name) {\n \t\t\treturn function () {\n \t\t\t\tvar args = [name];\n \t\t\t\targs.push.apply(args, arguments);\n \t\t\t\tdebug.apply(null, args);\n \t\t\t};\n-\t\t}\n+\t\t},\n+\t\t'./ava-files': avaFiles\n \t});\n \n \tvar clock;\n@@ -102,6 +102,22 @@ group('chokidar is installed', function (beforeEach, test, group) {\n \t\tlogger.finish.reset();\n \t\tlogger.reset.reset();\n \n+\t\tavaFiles.reset();\n+\t\tavaFiles.defaultExcludePatterns.reset();\n+\t\tavaFiles.defaultIncludePatterns.reset();\n+\n+\t\tavaFiles.defaultExcludePatterns.returns([\n+\t\t\t'!**/node_modules/**',\n+\t\t\t'!**/fixtures/**',\n+\t\t\t'!**/helpers/**'\n+\t\t]);\n+\n+\t\tavaFiles.defaultIncludePatterns.returns([\n+\t\t\t'test.js',\n+\t\t\t'test-*.js',\n+\t\t\t'test'\n+\t\t]);\n+\n \t\tapi.run.reset();\n \t\tapi.run.returns(new Promise(function () {}));\n \t\tfiles = [\n@@ -431,7 +447,8 @@ group('chokidar is installed', function (beforeEach, test, group) {\n \t\tt.plan(2);\n \n \t\tfiles = ['foo-{bar,baz}.js'];\n-\t\tapi.excludePatterns = ['!*bar*'];\n+\t\t// TODO(@jamestalmage, @novemberborn): There is no way for users to actually set exclude patterns yet.\n+\t\tavaFiles.defaultExcludePatterns.returns(['!*bar*']);\n \t\tapi.run.returns(Promise.resolve());\n \t\tstart();\n \n@@ -502,7 +519,8 @@ group('chokidar is installed', function (beforeEach, test, group) {\n \t\tt.plan(2);\n \n \t\tfiles = ['dir'];\n-\t\tapi.excludePatterns = ['!**/exclude/**'];\n+\t\t// TODO(@jamestalmage, @novemberborn): There is no way for users to actually set exclude patterns yet.\n+\t\tavaFiles.defaultExcludePatterns.returns(['!**/exclude/**']);\n \t\tapi.run.returns(Promise.resolve());\n \t\tstart();\n "
      }
    ]
  },
  {
    "url": "https://api.github.com/repos/avajs/ava/issues/363",
    "repository_url": "https://api.github.com/repos/avajs/ava",
    "labels_url": "https://api.github.com/repos/avajs/ava/issues/363/labels{/name}",
    "comments_url": "https://api.github.com/repos/avajs/ava/issues/363/comments",
    "events_url": "https://api.github.com/repos/avajs/ava/issues/363/events",
    "html_url": "https://github.com/avajs/ava/pull/363",
    "id": 123790179,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NTQ1NDM2NjA=",
    "number": 363,
    "title": "Internal reporters",
    "user": {
      "login": "vadimdemedes",
      "id": 697676,
      "node_id": "MDQ6VXNlcjY5NzY3Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/697676?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vadimdemedes",
      "html_url": "https://github.com/vadimdemedes",
      "followers_url": "https://api.github.com/users/vadimdemedes/followers",
      "following_url": "https://api.github.com/users/vadimdemedes/following{/other_user}",
      "gists_url": "https://api.github.com/users/vadimdemedes/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vadimdemedes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vadimdemedes/subscriptions",
      "organizations_url": "https://api.github.com/users/vadimdemedes/orgs",
      "repos_url": "https://api.github.com/users/vadimdemedes/repos",
      "events_url": "https://api.github.com/users/vadimdemedes/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vadimdemedes/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2015-12-24T10:50:07Z",
    "updated_at": "2015-12-24T12:09:09Z",
    "closed_at": "2015-12-24T12:09:07Z",
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "draft": false,
    "pull_request": {
      "url": "https://api.github.com/repos/avajs/ava/pulls/363",
      "html_url": "https://github.com/avajs/ava/pull/363",
      "diff_url": "https://github.com/avajs/ava/pull/363.diff",
      "patch_url": "https://github.com/avajs/ava/pull/363.patch",
      "merged_at": "2015-12-24T12:09:07Z"
    },
    "body": "This PR refactors and cleans up all our output, makes it easier to test and introduces the possibility to change reporters and write new ones.\n\n**Note**: it is not meant to be exposed to end users, this is only for internal usage. \n\nThis is a preparation for #359. After #359 we'll have 3 reporters:\n- verbose (current default reporter)\n- mini\n- tap\n",
    "reactions": {
      "url": "https://api.github.com/repos/avajs/ava/issues/363/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/avajs/ava/issues/363/timeline",
    "performed_via_github_app": null,
    "state_reason": null,
    "score": 1,
    "files": [
      {
        "sha": "20c21b152793aa67532dac9052b26f237a90fbad",
        "filename": "cli.js",
        "status": "modified",
        "additions": 23,
        "deletions": 59,
        "changes": 82,
        "blob_url": "https://github.com/avajs/ava/blob/2fab4b1e5330d61e445a8fb3b8ba8a71574b144d/cli.js",
        "raw_url": "https://github.com/avajs/ava/raw/2fab4b1e5330d61e445a8fb3b8ba8a71574b144d/cli.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/cli.js?ref=2fab4b1e5330d61e445a8fb3b8ba8a71574b144d",
        "patch": "@@ -17,13 +17,15 @@ if (debug.enabled) {\n \trequire('time-require');\n }\n \n+var updateNotifier = require('update-notifier');\n+var figures = require('figures');\n var arrify = require('arrify');\n var meow = require('meow');\n-var updateNotifier = require('update-notifier');\n var chalk = require('chalk');\n var Promise = require('bluebird');\n-var log = require('./lib/logger');\n-var tap = require('./lib/tap');\n+var verboseReporter = require('./lib/reporters/verbose');\n+var tapReporter = require('./lib/reporters/tap');\n+var Logger = require('./lib/logger');\n var Api = require('./api');\n \n // Bluebird specific\n@@ -68,75 +70,37 @@ if (cli.flags.init) {\n \treturn;\n }\n \n-if (cli.flags.tap) {\n-\tconsole.log(tap.start());\n-} else {\n-\tlog.write();\n-}\n-\n var api = new Api(cli.input, {\n \tfailFast: cli.flags.failFast,\n \tserial: cli.flags.serial,\n \trequire: arrify(cli.flags.require)\n });\n \n-api.on('test', function (test) {\n-\tif (cli.flags.tap) {\n-\t\tconsole.log(tap.test(test));\n-\t\treturn;\n-\t}\n-\n-\tif (test.error) {\n-\t\tlog.error(test.title, chalk.red(test.error.message));\n-\t} else {\n-\t\t// don't log it if there's only one file and one anonymous test\n-\t\tif (api.fileCount === 1 && api.testCount === 1 && test.title === '[anonymous]') {\n-\t\t\treturn;\n-\t\t}\n+var logger = new Logger();\n+logger.api = api;\n \n-\t\tlog.test(test);\n-\t}\n-});\n+if (cli.flags.tap) {\n+\tlogger.use(tapReporter());\n+} else {\n+\tlogger.use(verboseReporter());\n+}\n \n-api.on('error', function (data) {\n-\tif (cli.flags.tap) {\n-\t\tconsole.log(tap.unhandledError(data));\n-\t\treturn;\n-\t}\n+logger.start();\n \n-\tlog.unhandledError(data.type, data.file, data);\n-});\n+api.on('test', logger.test);\n+api.on('error', logger.unhandledError);\n \n api.run()\n \t.then(function () {\n-\t\tif (cli.flags.tap) {\n-\t\t\tconsole.log(tap.finish(api.passCount, api.failCount, api.rejectionCount, api.exceptionCount));\n+\t\tlogger.finish();\n+\t\tlogger.exit(api.failCount > 0 || api.rejectionCount > 0 || api.exceptionCount > 0 ? 1 : 0);\n+\t})\n+\t.catch(function (err) {\n+\t\tif (err instanceof Error) {\n+\t\t\tconsole.log('  ' + chalk.red(figures.cross) + ' ' + err.message);\n \t\t} else {\n-\t\t\tlog.write();\n-\t\t\tlog.report(api.passCount, api.failCount, api.rejectionCount, api.exceptionCount);\n-\t\t\tlog.write();\n-\n-\t\t\tif (api.failCount > 0) {\n-\t\t\t\tlog.errors(api.errors);\n-\t\t\t}\n+\t\t\tconsole.error(err.stack);\n \t\t}\n \n-\t\tprocess.stdout.write('');\n-\t\tflushIoAndExit(api.failCount > 0 || api.rejectionCount > 0 || api.exceptionCount > 0 ? 1 : 0);\n-\t})\n-\t.catch(function (err) {\n-\t\tlog.error(err.message);\n-\t\tflushIoAndExit(1);\n+\t\tlogger.exit(1);\n \t});\n-\n-function flushIoAndExit(code) {\n-\t// TODO: figure out why this needs to be here to\n-\t// correctly flush the output when multiple test files\n-\tprocess.stdout.write('');\n-\tprocess.stderr.write('');\n-\n-\t// timeout required to correctly flush IO on Node.js 0.10 on Windows\n-\tsetTimeout(function () {\n-\t\tprocess.exit(code);\n-\t}, process.env.AVA_APPVEYOR ? 500 : 0);\n-}"
      },
      {
        "sha": "00d40a88cbb662f36b8632056eda3d8e5b2d9fe3",
        "filename": "lib/logger.js",
        "status": "modified",
        "additions": 41,
        "deletions": 73,
        "changes": 114,
        "blob_url": "https://github.com/avajs/ava/blob/2fab4b1e5330d61e445a8fb3b8ba8a71574b144d/lib%2Flogger.js",
        "raw_url": "https://github.com/avajs/ava/raw/2fab4b1e5330d61e445a8fb3b8ba8a71574b144d/lib%2Flogger.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Flogger.js?ref=2fab4b1e5330d61e445a8fb3b8ba8a71574b144d",
        "patch": "@@ -1,98 +1,66 @@\n 'use strict';\n-var prettyMs = require('pretty-ms');\n-var figures = require('figures');\n-var Squeak = require('squeak');\n-var chalk = require('chalk');\n-var plur = require('plur');\n-var log = new Squeak({separator: ' '});\n-var x = module.exports;\n \n-function beautifyStack(stack) {\n-\tvar re = /(?:^(?! {4}at\\b).{6})|(?:\\((?:[A-Z]:)?(?:[\\\\\\/](?:(?!node_modules[\\\\\\/]ava[\\\\\\/])[^:\\\\\\/])+)+:\\d+:\\d+\\))/;\n-\tvar found = false;\n+function Logger() {\n+\tif (!(this instanceof Logger)) {\n+\t\treturn new Logger();\n+\t}\n \n-\treturn stack.split('\\n').filter(function (line) {\n-\t\tvar relevant = re.test(line);\n-\t\tfound = found || relevant;\n-\t\treturn !found || relevant;\n-\t}).join('\\n');\n+\tObject.keys(Logger.prototype).forEach(function (key) {\n+\t\tthis[key] = this[key].bind(this);\n+\t}, this);\n }\n \n-x._beautifyStack = beautifyStack;\n-\n-log.type('success', {\n-\tcolor: 'green',\n-\tprefix: figures.tick\n-});\n-\n-log.type('error', {\n-\tcolor: 'red',\n-\tprefix: figures.cross\n-});\n+module.exports = Logger;\n \n-x.write = log.write.bind(log);\n-x.writelpad = log.writelpad.bind(log);\n-x.success = log.success.bind(log);\n-x.error = log.error.bind(log);\n-\n-x.test = function (props) {\n-\tif (props.err) {\n-\t\tlog.error(props.title, chalk.red(props.err.message));\n-\t\treturn;\n-\t}\n+Logger.prototype.use = function (reporter) {\n+\tthis.reporter = reporter;\n+\tthis.reporter.api = this.api;\n+};\n \n-\tif (props.skip) {\n-\t\tlog.write('  ' + chalk.cyan('- ' + props.title));\n+Logger.prototype.start = function () {\n+\tif (!this.reporter.start) {\n \t\treturn;\n \t}\n \n-\t// display duration only over a threshold\n-\tvar threshold = 100;\n-\tvar dur = props.duration > threshold ? chalk.gray.dim(' (' + prettyMs(props.duration) + ')') : '';\n-\tlog.success(props.title + dur);\n+\tthis.write(this.reporter.start());\n };\n \n-x.errors = function (tests) {\n-\tvar i = 0;\n+Logger.prototype.test = function (test) {\n+\tthis.write(this.reporter.test(test));\n+};\n \n-\ttests.forEach(function (test) {\n-\t\ti++;\n+Logger.prototype.unhandledError = function (err) {\n+\tif (!this.reporter.unhandledError) {\n+\t\treturn;\n+\t}\n \n-\t\tlog.writelpad(chalk.red(i + '.', test.title));\n-\t\tlog.writelpad(chalk.red(beautifyStack(test.error.stack)));\n-\t\tlog.write();\n-\t});\n+\tthis.write(this.reporter.unhandledError(err));\n };\n \n-x.report = function (passed, failed, unhandled, uncaught) {\n-\tif (failed > 0) {\n-\t\tlog.writelpad(chalk.red(failed, plur('test', failed), 'failed'));\n-\t} else {\n-\t\tlog.writelpad(chalk.green(passed, plur('test', passed), 'passed'));\n+Logger.prototype.finish = function () {\n+\tif (!this.reporter.finish) {\n+\t\treturn;\n \t}\n \n-\tif (unhandled > 0) {\n-\t\tlog.writelpad(chalk.red(unhandled, 'unhandled', plur('rejection', unhandled)));\n-\t}\n+\tthis.write(this.reporter.finish());\n+};\n \n-\tif (uncaught > 0) {\n-\t\tlog.writelpad(chalk.red(uncaught, 'uncaught', plur('exception', uncaught)));\n+Logger.prototype.write = function (str) {\n+\tif (typeof str === 'undefined') {\n+\t\treturn;\n \t}\n-};\n \n-var types = {\n-\trejection: 'Unhandled Rejection',\n-\texception: 'Uncaught Exception'\n+\tthis.reporter.write(str);\n };\n \n-x.unhandledError = function (type, file, error) {\n-\tlog.write(chalk.red(types[type] + ':', file));\n-\n-\tif (error.stack) {\n-\t\tlog.writelpad(chalk.red(beautifyStack(error.stack)));\n-\t} else {\n-\t\tlog.writelpad(chalk.red(JSON.stringify(error)));\n-\t}\n+Logger.prototype.exit = function (code) {\n+\t// TODO: figure out why this needs to be here to\n+\t// correctly flush the output when multiple test files\n+\tprocess.stdout.write('');\n+\tprocess.stderr.write('');\n \n-\tlog.write();\n+\t// timeout required to correctly flush IO on Node.js 0.10 on Windows\n+\tsetTimeout(function () {\n+\t\tprocess.exit(code);\n+\t}, process.env.AVA_APPVEYOR ? 500 : 0);\n };"
      },
      {
        "sha": "831dadac15d4093de103d97c915188e8326d9963",
        "filename": "lib/reporters/tap.js",
        "status": "renamed",
        "additions": 25,
        "deletions": 13,
        "changes": 38,
        "blob_url": "https://github.com/avajs/ava/blob/2fab4b1e5330d61e445a8fb3b8ba8a71574b144d/lib%2Freporters%2Ftap.js",
        "raw_url": "https://github.com/avajs/ava/raw/2fab4b1e5330d61e445a8fb3b8ba8a71574b144d/lib%2Freporters%2Ftap.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Ftap.js?ref=2fab4b1e5330d61e445a8fb3b8ba8a71574b144d",
        "patch": "@@ -10,19 +10,27 @@ function getSourceFromStack(stack, index) {\n \t\t.replace(/^\\s+at /, '');\n }\n \n-exports.start = function () {\n+function TapReporter() {\n+\tif (!(this instanceof TapReporter)) {\n+\t\treturn new TapReporter();\n+\t}\n+\n+\tthis.i = 0;\n+}\n+\n+module.exports = TapReporter;\n+\n+TapReporter.prototype.start = function () {\n \treturn 'TAP version 13';\n };\n \n-var i = 0;\n-\n-exports.test = function (test) {\n+TapReporter.prototype.test = function (test) {\n \tvar output;\n \n \tif (test.error) {\n \t\toutput = [\n \t\t\t'# ' + test.title,\n-\t\t\tformat('not ok %d - %s', ++i, test.error.message),\n+\t\t\tformat('not ok %d - %s', ++this.i, test.error.message),\n \t\t\t'  ---',\n \t\t\t'    operator: ' + test.error.operator,\n \t\t\t'    expected: ' + test.error.expected,\n@@ -33,17 +41,17 @@ exports.test = function (test) {\n \t} else {\n \t\toutput = [\n \t\t\t'# ' + test.title,\n-\t\t\tformat('ok %d - %s', ++i, test.title)\n+\t\t\tformat('ok %d - %s', ++this.i, test.title)\n \t\t];\n \t}\n \n \treturn output.join('\\n');\n };\n \n-exports.unhandledError = function (err) {\n+TapReporter.prototype.unhandledError = function (err) {\n \tvar output = [\n \t\t'# ' + err.message,\n-\t\tformat('not ok %d - %s', ++i, err.message),\n+\t\tformat('not ok %d - %s', ++this.i, err.message),\n \t\t'  ---',\n \t\t'    name: ' + err.name,\n \t\t'    at: ' + getSourceFromStack(err.stack, 1),\n@@ -53,15 +61,19 @@ exports.unhandledError = function (err) {\n \treturn output.join('\\n');\n };\n \n-exports.finish = function (passCount, failCount, rejectionCount, exceptionCount) {\n+TapReporter.prototype.finish = function () {\n \tvar output = [\n \t\t'',\n-\t\t'1..' + (passCount + failCount),\n-\t\t'# tests ' + (passCount + failCount),\n-\t\t'# pass ' + passCount,\n-\t\t'# fail ' + (failCount + rejectionCount + exceptionCount),\n+\t\t'1..' + (this.api.passCount + this.api.failCount),\n+\t\t'# tests ' + (this.api.passCount + this.api.failCount),\n+\t\t'# pass ' + this.api.passCount,\n+\t\t'# fail ' + (this.api.failCount + this.api.rejectionCount + this.api.exceptionCount),\n \t\t''\n \t];\n \n \treturn output.join('\\n');\n };\n+\n+TapReporter.prototype.write = function (str) {\n+\tconsole.log(str);\n+};",
        "previous_filename": "lib/tap.js"
      },
      {
        "sha": "17d46b3293ce480df8d0c2fb2a6fae78ce8b5ed6",
        "filename": "lib/reporters/verbose.js",
        "status": "added",
        "additions": 109,
        "deletions": 0,
        "changes": 109,
        "blob_url": "https://github.com/avajs/ava/blob/2fab4b1e5330d61e445a8fb3b8ba8a71574b144d/lib%2Freporters%2Fverbose.js",
        "raw_url": "https://github.com/avajs/ava/raw/2fab4b1e5330d61e445a8fb3b8ba8a71574b144d/lib%2Freporters%2Fverbose.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/lib%2Freporters%2Fverbose.js?ref=2fab4b1e5330d61e445a8fb3b8ba8a71574b144d",
        "patch": "@@ -0,0 +1,109 @@\n+'use strict';\n+var prettyMs = require('pretty-ms');\n+var figures = require('figures');\n+var chalk = require('chalk');\n+var plur = require('plur');\n+\n+function beautifyStack(stack) {\n+\tvar re = /(?:^(?! {4}at\\b).{6})|(?:\\((?:[A-Z]:)?(?:[\\\\\\/](?:(?!node_modules[\\\\\\/]ava[\\\\\\/])[^:\\\\\\/])+)+:\\d+:\\d+\\))/;\n+\tvar found = false;\n+\n+\treturn stack.split('\\n').filter(function (line) {\n+\t\tvar relevant = re.test(line);\n+\t\tfound = found || relevant;\n+\t\treturn !found || relevant;\n+\t}).join('\\n');\n+}\n+\n+function VerboseReporter() {\n+\tif (!(this instanceof VerboseReporter)) {\n+\t\treturn new VerboseReporter();\n+\t}\n+}\n+\n+module.exports = VerboseReporter;\n+module.exports._beautifyStack = beautifyStack;\n+\n+VerboseReporter.prototype.start = function () {\n+\treturn '';\n+};\n+\n+VerboseReporter.prototype.test = function (test) {\n+\tif (test.error) {\n+\t\treturn '  ' + chalk.red(figures.cross) + ' ' + test.title + ' ' + chalk.red(test.error.message);\n+\t}\n+\n+\tif (test.skip) {\n+\t\treturn '  ' + chalk.cyan('- ' + test.title);\n+\t}\n+\n+\tif (this.api.fileCount === 1 && this.api.testCount === 1 && test.title === '[anonymous]') {\n+\t\treturn null;\n+\t}\n+\n+\t// display duration only over a threshold\n+\tvar threshold = 100;\n+\tvar duration = test.duration > threshold ? chalk.gray.dim(' (' + prettyMs(test.duration) + ')') : '';\n+\n+\treturn '  ' + chalk.green(figures.tick) + ' ' + test.title + duration;\n+};\n+\n+VerboseReporter.prototype.unhandledError = function (err) {\n+\tvar types = {\n+\t\trejection: 'Unhandled Rejection',\n+\t\texception: 'Uncaught Exception'\n+\t};\n+\n+\tvar output = chalk.red(types[err.type] + ':', err.file) + '\\n';\n+\n+\tif (err.stack) {\n+\t\toutput += '  ' + chalk.red(beautifyStack(err.stack)) + '\\n';\n+\t} else {\n+\t\toutput += '  ' + chalk.red(JSON.stringify(err)) + '\\n';\n+\t}\n+\n+\toutput += '\\n';\n+\n+\treturn output;\n+};\n+\n+VerboseReporter.prototype.finish = function () {\n+\tvar output = '\\n';\n+\n+\tif (this.api.failCount > 0) {\n+\t\toutput += '  ' + chalk.red(this.api.failCount, plur('test', this.api.failCount), 'failed') + '\\n';\n+\t} else {\n+\t\toutput += '  ' + chalk.green(this.api.passCount, plur('test', this.api.passCount), 'passed') + '\\n';\n+\t}\n+\n+\tif (this.api.rejectionCount > 0) {\n+\t\toutput += '  ' + chalk.red(this.api.rejectionCount, 'unhandled', plur('rejection', this.api.rejectionCount)) + '\\n';\n+\t}\n+\n+\tif (this.api.exceptionCount > 0) {\n+\t\toutput += '  ' + chalk.red(this.api.exceptionCount, 'uncaught', plur('exception', this.api.exceptionCount)) + '\\n';\n+\t}\n+\n+\tif (this.api.failCount > 0) {\n+\t\toutput += '\\n';\n+\n+\t\tvar i = 0;\n+\n+\t\tthis.api.tests.forEach(function (test) {\n+\t\t\tif (!test.error.message) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\ti++;\n+\n+\t\t\toutput += '  ' + chalk.red(i + '.', test.title) + '\\n';\n+\t\t\toutput += '  ' + chalk.red(beautifyStack(test.error.stack)) + '\\n';\n+\t\t});\n+\t}\n+\n+\treturn output;\n+};\n+\n+VerboseReporter.prototype.write = function (str) {\n+\tconsole.error(str);\n+};"
      },
      {
        "sha": "a54e0737f8957f76c97288c59e6a3cf4a6753f81",
        "filename": "test/cli.js",
        "status": "modified",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/avajs/ava/blob/2fab4b1e5330d61e445a8fb3b8ba8a71574b144d/test%2Fcli.js",
        "raw_url": "https://github.com/avajs/ava/raw/2fab4b1e5330d61e445a8fb3b8ba8a71574b144d/test%2Fcli.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Fcli.js?ref=2fab4b1e5330d61e445a8fb3b8ba8a71574b144d",
        "patch": "@@ -19,16 +19,6 @@ function execCli(args, cb) {\n \t}, cb);\n }\n \n-test('don\\'t display test title if there is only one anonymous test', function (t) {\n-\tt.plan(2);\n-\n-\texecCli(['fixture/es2015.js'], function (err, stdout, stderr) {\n-\t\tt.ifError(err);\n-\t\tt.is(stderr.trim(), '1 test passed');\n-\t\tt.end();\n-\t});\n-});\n-\n test('throwing a named function will report the to the console', function (t) {\n \texecCli('fixture/throw-named-function.js', function (err, stdout, stderr) {\n \t\tt.ok(err);"
      },
      {
        "sha": "fee554e59bfb2c6372f3072cb54ecc20920d47c5",
        "filename": "test/logger.js",
        "status": "removed",
        "additions": 0,
        "deletions": 261,
        "changes": 261,
        "blob_url": "https://github.com/avajs/ava/blob/65ae07c76b2a5927e6bcc00630a691c98f6e7c46/test%2Flogger.js",
        "raw_url": "https://github.com/avajs/ava/raw/65ae07c76b2a5927e6bcc00630a691c98f6e7c46/test%2Flogger.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Flogger.js?ref=65ae07c76b2a5927e6bcc00630a691c98f6e7c46",
        "patch": "@@ -1,261 +0,0 @@\n-'use strict';\n-var test = require('tap').test;\n-var logger = require('../lib/logger');\n-var figures = require('figures');\n-var hookStd = require('hook-std');\n-\n-test('beautify stack - removes uninteresting lines', function (t) {\n-\ttry {\n-\t\tfooFunc();\n-\t} catch (err) {\n-\t\tvar stack = logger._beautifyStack(err.stack);\n-\t\tt.match(stack, /fooFunc/);\n-\t\tt.match(stack, /barFunc/);\n-\t\tt.match(err.stack, /Module._compile/);\n-\t\tt.notMatch(stack, /Module\\._compile/);\n-\t\tt.end();\n-\t}\n-});\n-\n-test('logger.write', function (t) {\n-\tt.plan(1);\n-\n-\tvar unhook = hookStd.stderr({silent: true}, function (output) {\n-\t\tunhook();\n-\n-\t\tt.is(output.toString(), 'Test');\n-\t\tt.end();\n-\t});\n-\n-\tlogger.write('Test');\n-});\n-\n-test('logger.writelpad', function (t) {\n-\tt.plan(1);\n-\n-\tvar unhook = hookStd.stderr({silent: true}, function (output) {\n-\t\tunhook();\n-\n-\t\tt.is(output.toString(), '  Test');\n-\t\tt.end();\n-\t});\n-\n-\tlogger.writelpad('Test');\n-});\n-\n-test('logger.success', function (t) {\n-\tt.plan(1);\n-\n-\tvar unhook = hookStd.stderr({silent: true}, function (output) {\n-\t\tunhook();\n-\n-\t\tt.is(output.toString(), '  ' + figures.tick + ' Test');\n-\t\tt.end();\n-\t});\n-\n-\tlogger.success('Test');\n-});\n-\n-test('logger.error', function (t) {\n-\tt.plan(1);\n-\n-\tvar unhook = hookStd.stderr({silent: true}, function (output) {\n-\t\tunhook();\n-\n-\t\tt.is(output.toString(), '  ' + figures.cross + ' Test');\n-\t\tt.end();\n-\t});\n-\n-\tlogger.error('Test');\n-});\n-\n-test('logger.test with passing test and duration less than threshold', function (t) {\n-\tt.plan(1);\n-\n-\tvar passingTest = {\n-\t\ttitle: 'Passed',\n-\t\tduration: 90\n-\t};\n-\n-\tvar unhook = hookStd.stderr({silent: true}, function (output) {\n-\t\tunhook();\n-\n-\t\tt.is(output.toString(), '  ' + figures.tick + ' Passed');\n-\t\tt.end();\n-\t});\n-\n-\tlogger.test(passingTest);\n-});\n-\n-test('logger.test with passing test and duration greater than threshold', function (t) {\n-\tt.plan(1);\n-\n-\tvar passingTest = {\n-\t\ttitle: 'Passed',\n-\t\tduration: 150\n-\t};\n-\n-\tvar unhook = hookStd.stderr({silent: true}, function (output) {\n-\t\tunhook();\n-\n-\t\tt.is(output.toString(), '  ' + figures.tick + ' Passed (150ms)');\n-\t\tt.end();\n-\t});\n-\n-\tlogger.test(passingTest);\n-});\n-\n-test('logger.test with failing test', function (t) {\n-\tt.plan(1);\n-\n-\tvar passingTest = {\n-\t\ttitle: 'Failed',\n-\t\terr: {\n-\t\t\tmessage: 'Assertion failed'\n-\t\t}\n-\t};\n-\n-\tvar unhook = hookStd.stderr({silent: true}, function (output) {\n-\t\tunhook();\n-\n-\t\tt.is(output.toString(), '  ' + figures.cross + ' Failed Assertion failed');\n-\t\tt.end();\n-\t});\n-\n-\tlogger.test(passingTest);\n-});\n-\n-test('logger.test with skipped test', function (t) {\n-\tt.plan(1);\n-\n-\tvar skippedTest = {\n-\t\ttitle: 'Skipped',\n-\t\tskipped: true\n-\t};\n-\n-\tvar unhook = hookStd.stderr({silent: true}, function (output) {\n-\t\tunhook();\n-\n-\t\tt.is(output.toString(), '  ' + figures.tick + ' Skipped');\n-\t\tt.end();\n-\t});\n-\n-\tlogger.test(skippedTest);\n-});\n-\n-test('logger.errors', function (t) {\n-\tt.plan(1);\n-\n-\tvar lines = [];\n-\tvar failedTest = {\n-\t\ttitle: 'Failed',\n-\t\terror: {\n-\t\t\tstack: 'Unexpected token'\n-\t\t}\n-\t};\n-\n-\thookStd.stderr({silent: true}, function (output) {\n-\t\tonLine(lines, output);\n-\t});\n-\n-\tlogger.errors([failedTest]);\n-\n-\tt.is(lines.join(''), '1. Failed\\nUnexpected token\\n');\n-});\n-\n-test('logger.report', function (t) {\n-\tt.plan(1);\n-\n-\tvar lines = [];\n-\n-\thookStd.stderr({silent: true}, function (output) {\n-\t\tonLine(lines, output);\n-\t});\n-\n-\tlogger.report(1, 2, 1, 2);\n-\n-\tt.is(lines.join(''), '2 tests failed\\n1 unhandled rejection\\n2 uncaught exceptions\\n');\n-});\n-\n-test('logger.unhandledError with exception with stack', function (t) {\n-\tt.plan(3);\n-\n-\tvar lines = [];\n-\n-\thookStd.stderr({silent: true}, function (output) {\n-\t\tonLine(lines, output);\n-\t});\n-\n-\tlogger.unhandledError('exception', 'test.js', new Error('Unexpected token'));\n-\n-\tt.is(lines[0], 'Uncaught Exception: test.js\\n');\n-\tt.match(lines[1], /Error: Unexpected token\\n/);\n-\tt.match(lines[1], /at Test.test/);\n-});\n-\n-test('logger.unhandledError with exception without stack', function (t) {\n-\tt.plan(2);\n-\n-\tvar lines = [];\n-\tvar error = {\n-\t\tmessage: 'Unexpected token'\n-\t};\n-\n-\thookStd.stderr({silent: true}, function (output) {\n-\t\tonLine(lines, output);\n-\t});\n-\n-\tlogger.unhandledError('exception', 'test.js', error);\n-\n-\tt.is(lines[0], 'Uncaught Exception: test.js\\n');\n-\tt.is(lines[1], '{\"message\":\"Unexpected token\"}\\n');\n-});\n-\n-test('logger.unhandledError rejection with stack', function (t) {\n-\tt.plan(3);\n-\n-\tvar lines = [];\n-\n-\thookStd.stderr({silent: true}, function (output) {\n-\t\tonLine(lines, output);\n-\t});\n-\n-\tlogger.unhandledError('rejection', 'test.js', new Error('I have been rejected'));\n-\n-\tt.is(lines[0], 'Unhandled Rejection: test.js\\n');\n-\tt.match(lines[1], /Error: I have been rejected\\n/);\n-\tt.match(lines[1], /at Test.test/);\n-});\n-\n-test('logger.unhandledError rejection without stack', function (t) {\n-\tt.plan(2);\n-\n-\tvar lines = [];\n-\tvar error = {\n-\t\tmessage: 'I have been rejected'\n-\t};\n-\n-\thookStd.stderr({silent: true}, function (output) {\n-\t\tonLine(lines, output);\n-\t});\n-\n-\tlogger.unhandledError('rejection', 'test.js', error);\n-\n-\tt.is(lines[0], 'Unhandled Rejection: test.js\\n');\n-\tt.is(lines[1], '{\"message\":\"I have been rejected\"}\\n');\n-});\n-\n-function fooFunc() {\n-\tbarFunc();\n-}\n-\n-function barFunc() {\n-\tthrow new Error();\n-}\n-\n-function onLine(lines, line) {\n-\tvar trimmed = line.trim();\n-\tif (trimmed.length) {\n-\t\tlines.push(line.trim() + '\\n');\n-\t}\n-}"
      },
      {
        "sha": "3b14bdedcab78aef05c7797c32754dbb73bf3ab5",
        "filename": "test/reporters/tap.js",
        "status": "renamed",
        "additions": 29,
        "deletions": 16,
        "changes": 45,
        "blob_url": "https://github.com/avajs/ava/blob/2fab4b1e5330d61e445a8fb3b8ba8a71574b144d/test%2Freporters%2Ftap.js",
        "raw_url": "https://github.com/avajs/ava/raw/2fab4b1e5330d61e445a8fb3b8ba8a71574b144d/test%2Freporters%2Ftap.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Freporters%2Ftap.js?ref=2fab4b1e5330d61e445a8fb3b8ba8a71574b144d",
        "patch": "@@ -1,14 +1,18 @@\n 'use strict';\n var test = require('tap').test;\n-var tap = require('../lib/tap');\n+var tapReporter = require('../../lib/reporters/tap');\n \n test('start', function (t) {\n-\tt.is(tap.start(), 'TAP version 13');\n+\tvar reporter = tapReporter();\n+\n+\tt.is(reporter.start(), 'TAP version 13');\n \tt.end();\n });\n \n test('passing test', function (t) {\n-\tvar actualOutput = tap.test({\n+\tvar reporter = tapReporter();\n+\n+\tvar actualOutput = reporter.test({\n \t\ttitle: 'passing'\n \t});\n \n@@ -22,7 +26,9 @@ test('passing test', function (t) {\n });\n \n test('failing test', function (t) {\n-\tvar actualOutput = tap.test({\n+\tvar reporter = tapReporter();\n+\n+\tvar actualOutput = reporter.test({\n \t\ttitle: 'failing',\n \t\terror: {\n \t\t\tmessage: 'false == true',\n@@ -35,7 +41,7 @@ test('failing test', function (t) {\n \n \tvar expectedOutput = [\n \t\t'# failing',\n-\t\t'not ok 2 - false == true',\n+\t\t'not ok 1 - false == true',\n \t\t'  ---',\n \t\t'    operator: ==',\n \t\t'    expected: true',\n@@ -49,15 +55,17 @@ test('failing test', function (t) {\n });\n \n test('unhandled error', function (t) {\n-\tvar actualOutput = tap.unhandledError({\n+\tvar reporter = tapReporter();\n+\n+\tvar actualOutput = reporter.unhandledError({\n \t\tmessage: 'unhandled',\n \t\tname: 'TypeError',\n \t\tstack: ['', ' at Test.fn (test.js:1:2)'].join('\\n')\n \t});\n \n \tvar expectedOutput = [\n \t\t'# unhandled',\n-\t\t'not ok 3 - unhandled',\n+\t\t'not ok 1 - unhandled',\n \t\t'  ---',\n \t\t'    name: TypeError',\n \t\t'    at: Test.fn (test.js:1:2)',\n@@ -69,18 +77,23 @@ test('unhandled error', function (t) {\n });\n \n test('results', function (t) {\n-\tvar passCount = 1;\n-\tvar failCount = 2;\n-\tvar rejectionCount = 3;\n-\tvar exceptionCount = 4;\n+\tvar reporter = tapReporter();\n+\tvar api = {\n+\t\tpassCount: 1,\n+\t\tfailCount: 2,\n+\t\trejectionCount: 3,\n+\t\texceptionCount: 4\n+\t};\n+\n+\treporter.api = api;\n \n-\tvar actualOutput = tap.finish(passCount, failCount, rejectionCount, exceptionCount);\n+\tvar actualOutput = reporter.finish();\n \tvar expectedOutput = [\n \t\t'',\n-\t\t'1..' + (passCount + failCount),\n-\t\t'# tests ' + (passCount + failCount),\n-\t\t'# pass ' + passCount,\n-\t\t'# fail ' + (failCount + rejectionCount + exceptionCount),\n+\t\t'1..' + (api.passCount + api.failCount),\n+\t\t'# tests ' + (api.passCount + api.failCount),\n+\t\t'# pass ' + api.passCount,\n+\t\t'# fail ' + (api.failCount + api.rejectionCount + api.exceptionCount),\n \t\t''\n \t].join('\\n');\n ",
        "previous_filename": "test/tap.js"
      },
      {
        "sha": "4992d559b3ffa02584f491ada12ccbcb320b8b40",
        "filename": "test/reporters/verbose.js",
        "status": "added",
        "additions": 243,
        "deletions": 0,
        "changes": 243,
        "blob_url": "https://github.com/avajs/ava/blob/2fab4b1e5330d61e445a8fb3b8ba8a71574b144d/test%2Freporters%2Fverbose.js",
        "raw_url": "https://github.com/avajs/ava/raw/2fab4b1e5330d61e445a8fb3b8ba8a71574b144d/test%2Freporters%2Fverbose.js",
        "contents_url": "https://api.github.com/repos/avajs/ava/contents/test%2Freporters%2Fverbose.js?ref=2fab4b1e5330d61e445a8fb3b8ba8a71574b144d",
        "patch": "@@ -0,0 +1,243 @@\n+'use strict';\n+var figures = require('figures');\n+var chalk = require('chalk');\n+var test = require('tap').test;\n+var verboseReporter = require('../../lib/reporters/verbose');\n+\n+function createReporter() {\n+\tvar reporter = verboseReporter();\n+\treporter.api = {\n+\t\tfileCount: 1,\n+\t\ttestCount: 1\n+\t};\n+\n+\treturn reporter;\n+}\n+\n+test('beautify stack - removes uninteresting lines', function (t) {\n+\ttry {\n+\t\tfooFunc();\n+\t} catch (err) {\n+\t\tvar stack = verboseReporter._beautifyStack(err.stack);\n+\t\tt.match(stack, /fooFunc/);\n+\t\tt.match(stack, /barFunc/);\n+\t\tt.match(err.stack, /Module._compile/);\n+\t\tt.notMatch(stack, /Module\\._compile/);\n+\t\tt.end();\n+\t}\n+});\n+\n+test('start', function (t) {\n+\tvar reporter = createReporter();\n+\n+\tt.is(reporter.start(), '');\n+\tt.end();\n+});\n+\n+test('passing test and duration less than threshold', function (t) {\n+\tvar reporter = createReporter();\n+\n+\tvar actualOutput = reporter.test({\n+\t\ttitle: 'passed',\n+\t\tduration: 90\n+\t});\n+\n+\tvar expectedOutput = '  ' + chalk.green(figures.tick) + ' passed';\n+\n+\tt.is(actualOutput, expectedOutput);\n+\tt.end();\n+});\n+\n+test('passing test and duration greater than threshold', function (t) {\n+\tvar reporter = createReporter();\n+\n+\tvar actualOutput = reporter.test({\n+\t\ttitle: 'passed',\n+\t\tduration: 150\n+\t});\n+\n+\tvar expectedOutput = '  ' + chalk.green(figures.tick) + ' passed' + chalk.grey.dim(' (150ms)');\n+\n+\tt.is(actualOutput, expectedOutput);\n+\tt.end();\n+});\n+\n+test('don\\'t display test title if there is only one anonymous test', function (t) {\n+\tvar reporter = createReporter();\n+\n+\tvar output = reporter.test({\n+\t\ttitle: '[anonymous]'\n+\t});\n+\n+\tt.is(output, undefined);\n+\tt.end();\n+});\n+\n+test('failing test', function (t) {\n+\tvar reporter = createReporter();\n+\n+\tvar actualOutput = reporter.test({\n+\t\ttitle: 'failed',\n+\t\terr: {\n+\t\t\tmessage: 'assertion failed'\n+\t\t}\n+\t});\n+\n+\tvar expectedOutput = '  ' + chalk.red(figures.cross) + ' failed ' + chalk.red('assertion failed');\n+\n+\tt.is(actualOutput, expectedOutput);\n+\tt.end();\n+});\n+\n+test('skipped test', function (t) {\n+\tvar reporter = createReporter();\n+\n+\tvar actualOutput = reporter.test({\n+\t\ttitle: 'skipped',\n+\t\tskip: true\n+\t});\n+\n+\tvar expectedOutput = '  ' + chalk.cyan('- skipped');\n+\n+\tt.is(actualOutput, expectedOutput);\n+\tt.end();\n+});\n+\n+test('uncaught exception', function (t) {\n+\tvar reporter = createReporter();\n+\n+\tvar output = reporter.unhandledError({\n+\t\ttype: 'exception',\n+\t\tfile: 'test.js',\n+\t\tstack: new Error('Unexpected token').stack\n+\t}).split('\\n');\n+\n+\tt.is(output[0], chalk.red('Uncaught Exception: test.js'));\n+\tt.match(output[1], /Error: Unexpected token/);\n+\tt.match(output[2], /at Test\\.test/);\n+\tt.end();\n+});\n+\n+test('unhandled rejection', function (t) {\n+\tvar reporter = createReporter();\n+\n+\tvar output = reporter.unhandledError({\n+\t\ttype: 'rejection',\n+\t\tfile: 'test.js',\n+\t\tstack: new Error('Unexpected token').stack\n+\t}).split('\\n');\n+\n+\tt.is(output[0], chalk.red('Unhandled Rejection: test.js'));\n+\tt.match(output[1], /Error: Unexpected token/);\n+\tt.match(output[2], /at Test\\.test/);\n+\tt.end();\n+});\n+\n+test('unhandled error without stack', function (t) {\n+\tvar reporter = createReporter();\n+\n+\tvar err = {\n+\t\ttype: 'exception',\n+\t\tfile: 'test.js',\n+\t\tmessage: 'test'\n+\t};\n+\n+\tvar output = reporter.unhandledError(err).split('\\n');\n+\n+\tt.is(output[0], chalk.red('Uncaught Exception: test.js'));\n+\tt.is(output[1], '  ' + chalk.red(JSON.stringify(err)));\n+\tt.end();\n+});\n+\n+test('results with passing tests', function (t) {\n+\tvar reporter = createReporter();\n+\treporter.api.passCount = 1;\n+\n+\tvar actualOutput = reporter.finish();\n+\tvar expectedOutput = [\n+\t\t'',\n+\t\t'  ' + chalk.green('1 test passed'),\n+\t\t''\n+\t].join('\\n');\n+\n+\tt.is(actualOutput, expectedOutput);\n+\tt.end();\n+});\n+\n+test('results with passing tests and rejections', function (t) {\n+\tvar reporter = createReporter();\n+\treporter.api.passCount = 1;\n+\treporter.api.rejectionCount = 1;\n+\n+\tvar actualOutput = reporter.finish();\n+\tvar expectedOutput = [\n+\t\t'',\n+\t\t'  ' + chalk.green('1 test passed'),\n+\t\t'  ' + chalk.red('1 unhandled rejection'),\n+\t\t''\n+\t].join('\\n');\n+\n+\tt.is(actualOutput, expectedOutput);\n+\tt.end();\n+});\n+\n+test('results with passing tests and exceptions', function (t) {\n+\tvar reporter = createReporter();\n+\treporter.api.passCount = 1;\n+\treporter.api.exceptionCount = 1;\n+\n+\tvar actualOutput = reporter.finish();\n+\tvar expectedOutput = [\n+\t\t'',\n+\t\t'  ' + chalk.green('1 test passed'),\n+\t\t'  ' + chalk.red('1 uncaught exception'),\n+\t\t''\n+\t].join('\\n');\n+\n+\tt.is(actualOutput, expectedOutput);\n+\tt.end();\n+});\n+\n+test('results with passing tests, rejections and exceptions', function (t) {\n+\tvar reporter = createReporter();\n+\treporter.api.passCount = 1;\n+\treporter.api.exceptionCount = 1;\n+\treporter.api.rejectionCount = 1;\n+\n+\tvar actualOutput = reporter.finish();\n+\tvar expectedOutput = [\n+\t\t'',\n+\t\t'  ' + chalk.green('1 test passed'),\n+\t\t'  ' + chalk.red('1 unhandled rejection'),\n+\t\t'  ' + chalk.red('1 uncaught exception'),\n+\t\t''\n+\t].join('\\n');\n+\n+\tt.is(actualOutput, expectedOutput);\n+\tt.end();\n+});\n+\n+test('results with errors', function (t) {\n+\tvar reporter = createReporter();\n+\treporter.api.failCount = 1;\n+\treporter.api.tests = [{\n+\t\ttitle: 'fail',\n+\t\terror: new Error('error message')\n+\t}];\n+\n+\tvar output = reporter.finish().split('\\n');\n+\n+\tt.is(output[1], '  ' + chalk.red('1 test failed'));\n+\tt.is(output[3], '  ' + chalk.red('1. fail'));\n+\tt.match(output[4], /Error: error message/);\n+\tt.match(output[5], /Test\\.test/);\n+\tt.end();\n+});\n+\n+function fooFunc() {\n+\tbarFunc();\n+}\n+\n+function barFunc() {\n+\tthrow new Error();\n+}"
      }
    ]
  }
]
