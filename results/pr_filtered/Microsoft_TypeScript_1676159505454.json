[{"url":"https://api.github.com/repos/microsoft/TypeScript/issues/48426","repository_url":"https://api.github.com/repos/microsoft/TypeScript","labels_url":"https://api.github.com/repos/microsoft/TypeScript/issues/48426/labels{/name}","comments_url":"https://api.github.com/repos/microsoft/TypeScript/issues/48426/comments","events_url":"https://api.github.com/repos/microsoft/TypeScript/issues/48426/events","html_url":"https://github.com/microsoft/TypeScript/pull/48426","id":1181021554,"node_id":"PR_kwDOAT9aAc41B4nv","number":48426,"title":"Revert \"Fix contextual discrimination for omitted members (#43937)\"","user":{"login":"amcasey","id":10508071,"node_id":"MDQ6VXNlcjEwNTA4MDcx","avatar_url":"https://avatars.githubusercontent.com/u/10508071?v=4","gravatar_id":"","url":"https://api.github.com/users/amcasey","html_url":"https://github.com/amcasey","followers_url":"https://api.github.com/users/amcasey/followers","following_url":"https://api.github.com/users/amcasey/following{/other_user}","gists_url":"https://api.github.com/users/amcasey/gists{/gist_id}","starred_url":"https://api.github.com/users/amcasey/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/amcasey/subscriptions","organizations_url":"https://api.github.com/users/amcasey/orgs","repos_url":"https://api.github.com/users/amcasey/repos","events_url":"https://api.github.com/users/amcasey/events{/privacy}","received_events_url":"https://api.github.com/users/amcasey/received_events","type":"User","site_admin":false},"labels":[{"id":1503029093,"node_id":"MDU6TGFiZWwxNTAzMDI5MDkz","url":"https://api.github.com/repos/microsoft/TypeScript/labels/Author:%20Team","name":"Author: Team","color":"3178C6","default":false,"description":""},{"id":1883362416,"node_id":"MDU6TGFiZWwxODgzMzYyNDE2","url":"https://api.github.com/repos/microsoft/TypeScript/labels/For%20Uncommitted%20Bug","name":"For Uncommitted Bug","color":"ededed","default":false,"description":"PR for untriaged, rejected, closed or missing bug"}],"state":"closed","locked":false,"assignee":{"login":"amcasey","id":10508071,"node_id":"MDQ6VXNlcjEwNTA4MDcx","avatar_url":"https://avatars.githubusercontent.com/u/10508071?v=4","gravatar_id":"","url":"https://api.github.com/users/amcasey","html_url":"https://github.com/amcasey","followers_url":"https://api.github.com/users/amcasey/followers","following_url":"https://api.github.com/users/amcasey/following{/other_user}","gists_url":"https://api.github.com/users/amcasey/gists{/gist_id}","starred_url":"https://api.github.com/users/amcasey/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/amcasey/subscriptions","organizations_url":"https://api.github.com/users/amcasey/orgs","repos_url":"https://api.github.com/users/amcasey/repos","events_url":"https://api.github.com/users/amcasey/events{/privacy}","received_events_url":"https://api.github.com/users/amcasey/received_events","type":"User","site_admin":false},"assignees":[{"login":"amcasey","id":10508071,"node_id":"MDQ6VXNlcjEwNTA4MDcx","avatar_url":"https://avatars.githubusercontent.com/u/10508071?v=4","gravatar_id":"","url":"https://api.github.com/users/amcasey","html_url":"https://github.com/amcasey","followers_url":"https://api.github.com/users/amcasey/followers","following_url":"https://api.github.com/users/amcasey/following{/other_user}","gists_url":"https://api.github.com/users/amcasey/gists{/gist_id}","starred_url":"https://api.github.com/users/amcasey/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/amcasey/subscriptions","organizations_url":"https://api.github.com/users/amcasey/orgs","repos_url":"https://api.github.com/users/amcasey/repos","events_url":"https://api.github.com/users/amcasey/events{/privacy}","received_events_url":"https://api.github.com/users/amcasey/received_events","type":"User","site_admin":false}],"milestone":null,"comments":4,"created_at":"2022-03-25T16:53:53Z","updated_at":"2022-03-25T20:09:23Z","closed_at":"2022-03-25T20:09:20Z","author_association":"MEMBER","active_lock_reason":null,"draft":false,"pull_request":{"url":"https://api.github.com/repos/microsoft/TypeScript/pulls/48426","html_url":"https://github.com/microsoft/TypeScript/pull/48426","diff_url":"https://github.com/microsoft/TypeScript/pull/48426.diff","patch_url":"https://github.com/microsoft/TypeScript/pull/48426.patch","merged_at":"2022-03-25T20:09:20Z"},"body":"This reverts commit 751c11412618e8b2a504380135bc2f0b2505e18f, which caused check time for our MUI benchmark to increase by ~25%.\r\n\r\nSee #48298","reactions":{"url":"https://api.github.com/repos/microsoft/TypeScript/issues/48426/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/microsoft/TypeScript/issues/48426/timeline","performed_via_github_app":null,"state_reason":null,"score":1,"files":[{"sha":"31d21cbc9e778f57319d9b0d128566f35e0e71e0","filename":"src/compiler/checker.ts","status":"modified","additions":4,"deletions":21,"changes":25,"blob_url":"https://github.com/microsoft/TypeScript/blob/07a684587dd93b07079d5fd55d9b92e0335e78eb/src%2Fcompiler%2Fchecker.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/07a684587dd93b07079d5fd55d9b92e0335e78eb/src%2Fcompiler%2Fchecker.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Fchecker.ts?ref=07a684587dd93b07079d5fd55d9b92e0335e78eb","patch":"@@ -26813,13 +26813,6 @@ namespace ts {\n             return false;\r\n         }\r\n \r\n-        function uniqueStrings(strings: readonly __String[]): __String[] {\r\n-            const unique = new Set(strings);\r\n-            const result: __String[] = [];\r\n-            unique.forEach(str => result.push(str));\r\n-            return result;\r\n-        }\r\n-\r\n         function discriminateContextualTypeByObjectMembers(node: ObjectLiteralExpression, contextualType: UnionType) {\r\n             return getMatchingUnionConstituentForObjectLiteral(contextualType, node) || discriminateTypeByDiscriminableItems(contextualType,\r\n                 concatenate(\r\n@@ -26828,13 +26821,8 @@ namespace ts {\n                         prop => ([() => getContextFreeTypeOfExpression((prop as PropertyAssignment).initializer), prop.symbol.escapedName] as [() => Type, __String])\r\n                     ),\r\n                     map(\r\n-                        uniqueStrings(flatMap(contextualType.types, memberType =>\r\n-                            map(\r\n-                                filter(getPropertiesOfType(memberType), s => !!(s.flags & SymbolFlags.Optional) && !!node?.symbol?.members && !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName)),\r\n-                                s => s.escapedName\r\n-                            )\r\n-                        )),\r\n-                        name => [() => undefinedType, name] as [() => Type, __String]\r\n+                        filter(getPropertiesOfType(contextualType), s => !!(s.flags & SymbolFlags.Optional) && !!node?.symbol?.members && !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName)),\r\n+                        s => [() => undefinedType, s.escapedName] as [() => Type, __String]\r\n                     )\r\n                 ),\r\n                 isTypeAssignableTo,\r\n@@ -26850,13 +26838,8 @@ namespace ts {\n                         prop => ([!(prop as JsxAttribute).initializer ? (() => trueType) : (() => getContextFreeTypeOfExpression((prop as JsxAttribute).initializer!)), prop.symbol.escapedName] as [() => Type, __String])\r\n                     ),\r\n                     map(\r\n-                        uniqueStrings(flatMap(contextualType.types, memberType =>\r\n-                            map(\r\n-                                filter(getPropertiesOfType(memberType), s => !!(s.flags & SymbolFlags.Optional) && !!node?.symbol?.members && !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName)),\r\n-                                s => s.escapedName\r\n-                            )\r\n-                        )),\r\n-                        name => [() => undefinedType, name] as [() => Type, __String]\r\n+                        filter(getPropertiesOfType(contextualType), s => !!(s.flags & SymbolFlags.Optional) && !!node?.symbol?.members && !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName)),\r\n+                        s => [() => undefinedType, s.escapedName] as [() => Type, __String]\r\n                     )\r\n                 ),\r\n                 isTypeAssignableTo,\r"},{"sha":"96f6a106a11365b1a2779487f6fe539de1ef2cbe","filename":"tests/baselines/reference/discriminantPropertyInference.js","status":"modified","additions":1,"deletions":15,"changes":16,"blob_url":"https://github.com/microsoft/TypeScript/blob/07a684587dd93b07079d5fd55d9b92e0335e78eb/tests%2Fbaselines%2Freference%2FdiscriminantPropertyInference.js","raw_url":"https://github.com/microsoft/TypeScript/raw/07a684587dd93b07079d5fd55d9b92e0335e78eb/tests%2Fbaselines%2Freference%2FdiscriminantPropertyInference.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FdiscriminantPropertyInference.js?ref=07a684587dd93b07079d5fd55d9b92e0335e78eb","patch":"@@ -11,9 +11,7 @@ type DiscriminatorFalse = {\n     cb: (x: number) => void;\n }\n \n-type Unrelated = {\n-    val: number;\n-}\n+type Props = DiscriminatorTrue | DiscriminatorFalse;\n \n declare function f(options: DiscriminatorTrue | DiscriminatorFalse): any;\n \n@@ -39,14 +37,6 @@ f({\n f({\n     cb: n => n.toFixed()\n });\n-\n-\n-declare function g(options: DiscriminatorTrue | DiscriminatorFalse | Unrelated): any;\n-\n-// requires checking properties of all types, rather than properties of just the union type (e.g. only intersection)\n-g({\n-    cb: n => n.toFixed()\n-});\n \r\n \r\n //// [discriminantPropertyInference.js]\r\n@@ -70,7 +60,3 @@ f({\n f({\r\n     cb: function (n) { return n.toFixed(); }\r\n });\r\n-// requires checking properties of all types, rather than properties of just the union type (e.g. only intersection)\r\n-g({\r\n-    cb: function (n) { return n.toFixed(); }\r\n-});\r"},{"sha":"1908bdd98432108e58bfdf96acc147513861450d","filename":"tests/baselines/reference/discriminantPropertyInference.symbols","status":"modified","additions":25,"deletions":48,"changes":73,"blob_url":"https://github.com/microsoft/TypeScript/blob/07a684587dd93b07079d5fd55d9b92e0335e78eb/tests%2Fbaselines%2Freference%2FdiscriminantPropertyInference.symbols","raw_url":"https://github.com/microsoft/TypeScript/raw/07a684587dd93b07079d5fd55d9b92e0335e78eb/tests%2Fbaselines%2Freference%2FdiscriminantPropertyInference.symbols","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FdiscriminantPropertyInference.symbols?ref=07a684587dd93b07079d5fd55d9b92e0335e78eb","patch":"@@ -23,97 +23,74 @@ type DiscriminatorFalse = {\n >x : Symbol(x, Decl(discriminantPropertyInference.ts, 9, 9))\r\n }\r\n \r\n-type Unrelated = {\r\n->Unrelated : Symbol(Unrelated, Decl(discriminantPropertyInference.ts, 10, 1))\r\n-\r\n-    val: number;\r\n->val : Symbol(val, Decl(discriminantPropertyInference.ts, 12, 18))\r\n-}\r\n+type Props = DiscriminatorTrue | DiscriminatorFalse;\r\n+>Props : Symbol(Props, Decl(discriminantPropertyInference.ts, 10, 1))\r\n+>DiscriminatorTrue : Symbol(DiscriminatorTrue, Decl(discriminantPropertyInference.ts, 0, 0))\r\n+>DiscriminatorFalse : Symbol(DiscriminatorFalse, Decl(discriminantPropertyInference.ts, 5, 1))\r\n \r\n declare function f(options: DiscriminatorTrue | DiscriminatorFalse): any;\r\n->f : Symbol(f, Decl(discriminantPropertyInference.ts, 14, 1))\r\n->options : Symbol(options, Decl(discriminantPropertyInference.ts, 16, 19))\r\n+>f : Symbol(f, Decl(discriminantPropertyInference.ts, 12, 52))\r\n+>options : Symbol(options, Decl(discriminantPropertyInference.ts, 14, 19))\r\n >DiscriminatorTrue : Symbol(DiscriminatorTrue, Decl(discriminantPropertyInference.ts, 0, 0))\r\n >DiscriminatorFalse : Symbol(DiscriminatorFalse, Decl(discriminantPropertyInference.ts, 5, 1))\r\n \r\n // simple inference\r\n f({\r\n->f : Symbol(f, Decl(discriminantPropertyInference.ts, 14, 1))\r\n+>f : Symbol(f, Decl(discriminantPropertyInference.ts, 12, 52))\r\n \r\n     disc: true,\r\n->disc : Symbol(disc, Decl(discriminantPropertyInference.ts, 19, 3))\r\n+>disc : Symbol(disc, Decl(discriminantPropertyInference.ts, 17, 3))\r\n \r\n     cb: s => parseInt(s)\r\n->cb : Symbol(cb, Decl(discriminantPropertyInference.ts, 20, 15))\r\n->s : Symbol(s, Decl(discriminantPropertyInference.ts, 21, 7))\r\n+>cb : Symbol(cb, Decl(discriminantPropertyInference.ts, 18, 15))\r\n+>s : Symbol(s, Decl(discriminantPropertyInference.ts, 19, 7))\r\n >parseInt : Symbol(parseInt, Decl(lib.es5.d.ts, --, --))\r\n->s : Symbol(s, Decl(discriminantPropertyInference.ts, 21, 7))\r\n+>s : Symbol(s, Decl(discriminantPropertyInference.ts, 19, 7))\r\n \r\n });\r\n \r\n // simple inference\r\n f({\r\n->f : Symbol(f, Decl(discriminantPropertyInference.ts, 14, 1))\r\n+>f : Symbol(f, Decl(discriminantPropertyInference.ts, 12, 52))\r\n \r\n     disc: false,\r\n->disc : Symbol(disc, Decl(discriminantPropertyInference.ts, 25, 3))\r\n+>disc : Symbol(disc, Decl(discriminantPropertyInference.ts, 23, 3))\r\n \r\n     cb: n => n.toFixed()\r\n->cb : Symbol(cb, Decl(discriminantPropertyInference.ts, 26, 16))\r\n->n : Symbol(n, Decl(discriminantPropertyInference.ts, 27, 7))\r\n+>cb : Symbol(cb, Decl(discriminantPropertyInference.ts, 24, 16))\r\n+>n : Symbol(n, Decl(discriminantPropertyInference.ts, 25, 7))\r\n >n.toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))\r\n->n : Symbol(n, Decl(discriminantPropertyInference.ts, 27, 7))\r\n+>n : Symbol(n, Decl(discriminantPropertyInference.ts, 25, 7))\r\n >toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))\r\n \r\n });\r\n \r\n // simple inference when strict-null-checks are enabled\r\n f({\r\n->f : Symbol(f, Decl(discriminantPropertyInference.ts, 14, 1))\r\n+>f : Symbol(f, Decl(discriminantPropertyInference.ts, 12, 52))\r\n \r\n     disc: undefined,\r\n->disc : Symbol(disc, Decl(discriminantPropertyInference.ts, 31, 3))\r\n+>disc : Symbol(disc, Decl(discriminantPropertyInference.ts, 29, 3))\r\n >undefined : Symbol(undefined)\r\n \r\n     cb: n => n.toFixed()\r\n->cb : Symbol(cb, Decl(discriminantPropertyInference.ts, 32, 20))\r\n->n : Symbol(n, Decl(discriminantPropertyInference.ts, 33, 7))\r\n+>cb : Symbol(cb, Decl(discriminantPropertyInference.ts, 30, 20))\r\n+>n : Symbol(n, Decl(discriminantPropertyInference.ts, 31, 7))\r\n >n.toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))\r\n->n : Symbol(n, Decl(discriminantPropertyInference.ts, 33, 7))\r\n+>n : Symbol(n, Decl(discriminantPropertyInference.ts, 31, 7))\r\n >toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))\r\n \r\n });\r\n \r\n // requires checking type information since discriminator is missing from object\r\n f({\r\n->f : Symbol(f, Decl(discriminantPropertyInference.ts, 14, 1))\r\n-\r\n-    cb: n => n.toFixed()\r\n->cb : Symbol(cb, Decl(discriminantPropertyInference.ts, 37, 3))\r\n->n : Symbol(n, Decl(discriminantPropertyInference.ts, 38, 7))\r\n->n.toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))\r\n->n : Symbol(n, Decl(discriminantPropertyInference.ts, 38, 7))\r\n->toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))\r\n-\r\n-});\r\n-\r\n-\r\n-declare function g(options: DiscriminatorTrue | DiscriminatorFalse | Unrelated): any;\r\n->g : Symbol(g, Decl(discriminantPropertyInference.ts, 39, 3))\r\n->options : Symbol(options, Decl(discriminantPropertyInference.ts, 42, 19))\r\n->DiscriminatorTrue : Symbol(DiscriminatorTrue, Decl(discriminantPropertyInference.ts, 0, 0))\r\n->DiscriminatorFalse : Symbol(DiscriminatorFalse, Decl(discriminantPropertyInference.ts, 5, 1))\r\n->Unrelated : Symbol(Unrelated, Decl(discriminantPropertyInference.ts, 10, 1))\r\n-\r\n-// requires checking properties of all types, rather than properties of just the union type (e.g. only intersection)\r\n-g({\r\n->g : Symbol(g, Decl(discriminantPropertyInference.ts, 39, 3))\r\n+>f : Symbol(f, Decl(discriminantPropertyInference.ts, 12, 52))\r\n \r\n     cb: n => n.toFixed()\r\n->cb : Symbol(cb, Decl(discriminantPropertyInference.ts, 45, 3))\r\n->n : Symbol(n, Decl(discriminantPropertyInference.ts, 46, 7))\r\n+>cb : Symbol(cb, Decl(discriminantPropertyInference.ts, 35, 3))\r\n+>n : Symbol(n, Decl(discriminantPropertyInference.ts, 36, 7))\r\n >n.toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))\r\n->n : Symbol(n, Decl(discriminantPropertyInference.ts, 46, 7))\r\n+>n : Symbol(n, Decl(discriminantPropertyInference.ts, 36, 7))\r\n >toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))\r\n \r\n });\r"},{"sha":"2ebc6c6a373fe3db947453f5f55b43504b95b3e6","filename":"tests/baselines/reference/discriminantPropertyInference.types","status":"modified","additions":2,"deletions":28,"changes":30,"blob_url":"https://github.com/microsoft/TypeScript/blob/07a684587dd93b07079d5fd55d9b92e0335e78eb/tests%2Fbaselines%2Freference%2FdiscriminantPropertyInference.types","raw_url":"https://github.com/microsoft/TypeScript/raw/07a684587dd93b07079d5fd55d9b92e0335e78eb/tests%2Fbaselines%2Freference%2FdiscriminantPropertyInference.types","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FdiscriminantPropertyInference.types?ref=07a684587dd93b07079d5fd55d9b92e0335e78eb","patch":"@@ -25,12 +25,8 @@ type DiscriminatorFalse = {\n >x : number\r\n }\r\n \r\n-type Unrelated = {\r\n->Unrelated : Unrelated\r\n-\r\n-    val: number;\r\n->val : number\r\n-}\r\n+type Props = DiscriminatorTrue | DiscriminatorFalse;\r\n+>Props : Props\r\n \r\n declare function f(options: DiscriminatorTrue | DiscriminatorFalse): any;\r\n >f : (options: DiscriminatorTrue | DiscriminatorFalse) => any\r\n@@ -115,25 +111,3 @@ f({\n \r\n });\r\n \r\n-\r\n-declare function g(options: DiscriminatorTrue | DiscriminatorFalse | Unrelated): any;\r\n->g : (options: DiscriminatorTrue | DiscriminatorFalse | Unrelated) => any\r\n->options : DiscriminatorTrue | DiscriminatorFalse | Unrelated\r\n-\r\n-// requires checking properties of all types, rather than properties of just the union type (e.g. only intersection)\r\n-g({\r\n->g({    cb: n => n.toFixed()}) : any\r\n->g : (options: DiscriminatorTrue | DiscriminatorFalse | Unrelated) => any\r\n->{    cb: n => n.toFixed()} : { cb: (n: number) => string; }\r\n-\r\n-    cb: n => n.toFixed()\r\n->cb : (n: number) => string\r\n->n => n.toFixed() : (n: number) => string\r\n->n : number\r\n->n.toFixed() : string\r\n->n.toFixed : (fractionDigits?: number | undefined) => string\r\n->n : number\r\n->toFixed : (fractionDigits?: number | undefined) => string\r\n-\r\n-});\r\n-\r"},{"sha":"b374f4690b0a46a1fbee64e2aa8f0f40c8f2a649","filename":"tests/baselines/reference/tsxDiscriminantPropertyInference.js","status":"modified","additions":1,"deletions":14,"changes":15,"blob_url":"https://github.com/microsoft/TypeScript/blob/07a684587dd93b07079d5fd55d9b92e0335e78eb/tests%2Fbaselines%2Freference%2FtsxDiscriminantPropertyInference.js","raw_url":"https://github.com/microsoft/TypeScript/raw/07a684587dd93b07079d5fd55d9b92e0335e78eb/tests%2Fbaselines%2Freference%2FtsxDiscriminantPropertyInference.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FtsxDiscriminantPropertyInference.js?ref=07a684587dd93b07079d5fd55d9b92e0335e78eb","patch":"@@ -14,15 +14,9 @@ type DiscriminatorFalse = {\n     cb: (x: number) => void;\n }\n \n-type Unrelated = {\n-    val: number;\n-}\n-\n type Props = DiscriminatorTrue | DiscriminatorFalse;\n \n-type UnrelatedProps = Props | Unrelated;\n-\n-declare function Comp(props: Props): JSX.Element;\n+declare function Comp(props: DiscriminatorTrue | DiscriminatorFalse): JSX.Element;\n \n // simple inference\n void (<Comp disc cb={s => parseInt(s)} />);\n@@ -35,11 +29,6 @@ void (<Comp disc={undefined} cb={n => n.toFixed()} />);\n \n // requires checking type information since discriminator is missing from object\n void (<Comp cb={n => n.toFixed()} />);\n-\n-declare function UnrelatedComp(props: UnrelatedProps): JSX.Element;\n-\n-// requires checking properties of all types, rather than properties of just the union type (e.g. only intersection)\n-void (<Comp cb={n => n.toFixed()} />);\n \r\n \r\n //// [tsxDiscriminantPropertyInference.jsx]\r\n@@ -51,5 +40,3 @@ void (<Comp disc={false} cb={function (n) { return n.toFixed(); }}/>);\n void (<Comp disc={undefined} cb={function (n) { return n.toFixed(); }}/>);\r\n // requires checking type information since discriminator is missing from object\r\n void (<Comp cb={function (n) { return n.toFixed(); }}/>);\r\n-// requires checking properties of all types, rather than properties of just the union type (e.g. only intersection)\r\n-void (<Comp cb={function (n) { return n.toFixed(); }}/>);\r"},{"sha":"4b74166e91b63dd9ddf9fe3eaf67ceb25a8038b3","filename":"tests/baselines/reference/tsxDiscriminantPropertyInference.symbols","status":"modified","additions":25,"deletions":52,"changes":77,"blob_url":"https://github.com/microsoft/TypeScript/blob/07a684587dd93b07079d5fd55d9b92e0335e78eb/tests%2Fbaselines%2Freference%2FtsxDiscriminantPropertyInference.symbols","raw_url":"https://github.com/microsoft/TypeScript/raw/07a684587dd93b07079d5fd55d9b92e0335e78eb/tests%2Fbaselines%2Freference%2FtsxDiscriminantPropertyInference.symbols","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FtsxDiscriminantPropertyInference.symbols?ref=07a684587dd93b07079d5fd55d9b92e0335e78eb","patch":"@@ -29,82 +29,55 @@ type DiscriminatorFalse = {\n >x : Symbol(x, Decl(tsxDiscriminantPropertyInference.tsx, 12, 9))\r\n }\r\n \r\n-type Unrelated = {\r\n->Unrelated : Symbol(Unrelated, Decl(tsxDiscriminantPropertyInference.tsx, 13, 1))\r\n-\r\n-    val: number;\r\n->val : Symbol(val, Decl(tsxDiscriminantPropertyInference.tsx, 15, 18))\r\n-}\r\n-\r\n type Props = DiscriminatorTrue | DiscriminatorFalse;\r\n->Props : Symbol(Props, Decl(tsxDiscriminantPropertyInference.tsx, 17, 1))\r\n+>Props : Symbol(Props, Decl(tsxDiscriminantPropertyInference.tsx, 13, 1))\r\n >DiscriminatorTrue : Symbol(DiscriminatorTrue, Decl(tsxDiscriminantPropertyInference.tsx, 3, 1))\r\n >DiscriminatorFalse : Symbol(DiscriminatorFalse, Decl(tsxDiscriminantPropertyInference.tsx, 8, 1))\r\n \r\n-type UnrelatedProps = Props | Unrelated;\r\n->UnrelatedProps : Symbol(UnrelatedProps, Decl(tsxDiscriminantPropertyInference.tsx, 19, 52))\r\n->Props : Symbol(Props, Decl(tsxDiscriminantPropertyInference.tsx, 17, 1))\r\n->Unrelated : Symbol(Unrelated, Decl(tsxDiscriminantPropertyInference.tsx, 13, 1))\r\n-\r\n-declare function Comp(props: Props): JSX.Element;\r\n->Comp : Symbol(Comp, Decl(tsxDiscriminantPropertyInference.tsx, 21, 40))\r\n->props : Symbol(props, Decl(tsxDiscriminantPropertyInference.tsx, 23, 22))\r\n->Props : Symbol(Props, Decl(tsxDiscriminantPropertyInference.tsx, 17, 1))\r\n+declare function Comp(props: DiscriminatorTrue | DiscriminatorFalse): JSX.Element;\r\n+>Comp : Symbol(Comp, Decl(tsxDiscriminantPropertyInference.tsx, 15, 52))\r\n+>props : Symbol(props, Decl(tsxDiscriminantPropertyInference.tsx, 17, 22))\r\n+>DiscriminatorTrue : Symbol(DiscriminatorTrue, Decl(tsxDiscriminantPropertyInference.tsx, 3, 1))\r\n+>DiscriminatorFalse : Symbol(DiscriminatorFalse, Decl(tsxDiscriminantPropertyInference.tsx, 8, 1))\r\n >JSX : Symbol(JSX, Decl(tsxDiscriminantPropertyInference.tsx, 0, 0))\r\n >Element : Symbol(JSX.Element, Decl(tsxDiscriminantPropertyInference.tsx, 1, 15))\r\n \r\n // simple inference\r\n void (<Comp disc cb={s => parseInt(s)} />);\r\n->Comp : Symbol(Comp, Decl(tsxDiscriminantPropertyInference.tsx, 21, 40))\r\n->disc : Symbol(disc, Decl(tsxDiscriminantPropertyInference.tsx, 26, 11))\r\n->cb : Symbol(cb, Decl(tsxDiscriminantPropertyInference.tsx, 26, 16))\r\n->s : Symbol(s, Decl(tsxDiscriminantPropertyInference.tsx, 26, 21))\r\n+>Comp : Symbol(Comp, Decl(tsxDiscriminantPropertyInference.tsx, 15, 52))\r\n+>disc : Symbol(disc, Decl(tsxDiscriminantPropertyInference.tsx, 20, 11))\r\n+>cb : Symbol(cb, Decl(tsxDiscriminantPropertyInference.tsx, 20, 16))\r\n+>s : Symbol(s, Decl(tsxDiscriminantPropertyInference.tsx, 20, 21))\r\n >parseInt : Symbol(parseInt, Decl(lib.es5.d.ts, --, --))\r\n->s : Symbol(s, Decl(tsxDiscriminantPropertyInference.tsx, 26, 21))\r\n+>s : Symbol(s, Decl(tsxDiscriminantPropertyInference.tsx, 20, 21))\r\n \r\n // simple inference\r\n void (<Comp disc={false} cb={n => n.toFixed()} />);\r\n->Comp : Symbol(Comp, Decl(tsxDiscriminantPropertyInference.tsx, 21, 40))\r\n->disc : Symbol(disc, Decl(tsxDiscriminantPropertyInference.tsx, 29, 11))\r\n->cb : Symbol(cb, Decl(tsxDiscriminantPropertyInference.tsx, 29, 24))\r\n->n : Symbol(n, Decl(tsxDiscriminantPropertyInference.tsx, 29, 29))\r\n+>Comp : Symbol(Comp, Decl(tsxDiscriminantPropertyInference.tsx, 15, 52))\r\n+>disc : Symbol(disc, Decl(tsxDiscriminantPropertyInference.tsx, 23, 11))\r\n+>cb : Symbol(cb, Decl(tsxDiscriminantPropertyInference.tsx, 23, 24))\r\n+>n : Symbol(n, Decl(tsxDiscriminantPropertyInference.tsx, 23, 29))\r\n >n.toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))\r\n->n : Symbol(n, Decl(tsxDiscriminantPropertyInference.tsx, 29, 29))\r\n+>n : Symbol(n, Decl(tsxDiscriminantPropertyInference.tsx, 23, 29))\r\n >toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))\r\n \r\n // simple inference when strict-null-checks are enabled\r\n void (<Comp disc={undefined} cb={n => n.toFixed()} />);\r\n->Comp : Symbol(Comp, Decl(tsxDiscriminantPropertyInference.tsx, 21, 40))\r\n->disc : Symbol(disc, Decl(tsxDiscriminantPropertyInference.tsx, 32, 11))\r\n+>Comp : Symbol(Comp, Decl(tsxDiscriminantPropertyInference.tsx, 15, 52))\r\n+>disc : Symbol(disc, Decl(tsxDiscriminantPropertyInference.tsx, 26, 11))\r\n >undefined : Symbol(undefined)\r\n->cb : Symbol(cb, Decl(tsxDiscriminantPropertyInference.tsx, 32, 28))\r\n->n : Symbol(n, Decl(tsxDiscriminantPropertyInference.tsx, 32, 33))\r\n+>cb : Symbol(cb, Decl(tsxDiscriminantPropertyInference.tsx, 26, 28))\r\n+>n : Symbol(n, Decl(tsxDiscriminantPropertyInference.tsx, 26, 33))\r\n >n.toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))\r\n->n : Symbol(n, Decl(tsxDiscriminantPropertyInference.tsx, 32, 33))\r\n+>n : Symbol(n, Decl(tsxDiscriminantPropertyInference.tsx, 26, 33))\r\n >toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))\r\n \r\n // requires checking type information since discriminator is missing from object\r\n void (<Comp cb={n => n.toFixed()} />);\r\n->Comp : Symbol(Comp, Decl(tsxDiscriminantPropertyInference.tsx, 21, 40))\r\n->cb : Symbol(cb, Decl(tsxDiscriminantPropertyInference.tsx, 35, 11))\r\n->n : Symbol(n, Decl(tsxDiscriminantPropertyInference.tsx, 35, 16))\r\n->n.toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))\r\n->n : Symbol(n, Decl(tsxDiscriminantPropertyInference.tsx, 35, 16))\r\n->toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))\r\n-\r\n-declare function UnrelatedComp(props: UnrelatedProps): JSX.Element;\r\n->UnrelatedComp : Symbol(UnrelatedComp, Decl(tsxDiscriminantPropertyInference.tsx, 35, 38))\r\n->props : Symbol(props, Decl(tsxDiscriminantPropertyInference.tsx, 37, 31))\r\n->UnrelatedProps : Symbol(UnrelatedProps, Decl(tsxDiscriminantPropertyInference.tsx, 19, 52))\r\n->JSX : Symbol(JSX, Decl(tsxDiscriminantPropertyInference.tsx, 0, 0))\r\n->Element : Symbol(JSX.Element, Decl(tsxDiscriminantPropertyInference.tsx, 1, 15))\r\n-\r\n-// requires checking properties of all types, rather than properties of just the union type (e.g. only intersection)\r\n-void (<Comp cb={n => n.toFixed()} />);\r\n->Comp : Symbol(Comp, Decl(tsxDiscriminantPropertyInference.tsx, 21, 40))\r\n->cb : Symbol(cb, Decl(tsxDiscriminantPropertyInference.tsx, 40, 11))\r\n->n : Symbol(n, Decl(tsxDiscriminantPropertyInference.tsx, 40, 16))\r\n+>Comp : Symbol(Comp, Decl(tsxDiscriminantPropertyInference.tsx, 15, 52))\r\n+>cb : Symbol(cb, Decl(tsxDiscriminantPropertyInference.tsx, 29, 11))\r\n+>n : Symbol(n, Decl(tsxDiscriminantPropertyInference.tsx, 29, 16))\r\n >n.toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))\r\n->n : Symbol(n, Decl(tsxDiscriminantPropertyInference.tsx, 40, 16))\r\n+>n : Symbol(n, Decl(tsxDiscriminantPropertyInference.tsx, 29, 16))\r\n >toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))\r\n \r"},{"sha":"63932bd18d9630765b05e7d1b74a6e40c89edfea","filename":"tests/baselines/reference/tsxDiscriminantPropertyInference.types","status":"modified","additions":7,"deletions":36,"changes":43,"blob_url":"https://github.com/microsoft/TypeScript/blob/07a684587dd93b07079d5fd55d9b92e0335e78eb/tests%2Fbaselines%2Freference%2FtsxDiscriminantPropertyInference.types","raw_url":"https://github.com/microsoft/TypeScript/raw/07a684587dd93b07079d5fd55d9b92e0335e78eb/tests%2Fbaselines%2Freference%2FtsxDiscriminantPropertyInference.types","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FtsxDiscriminantPropertyInference.types?ref=07a684587dd93b07079d5fd55d9b92e0335e78eb","patch":"@@ -28,30 +28,20 @@ type DiscriminatorFalse = {\n >x : number\r\n }\r\n \r\n-type Unrelated = {\r\n->Unrelated : Unrelated\r\n-\r\n-    val: number;\r\n->val : number\r\n-}\r\n-\r\n type Props = DiscriminatorTrue | DiscriminatorFalse;\r\n >Props : Props\r\n \r\n-type UnrelatedProps = Props | Unrelated;\r\n->UnrelatedProps : UnrelatedProps\r\n-\r\n-declare function Comp(props: Props): JSX.Element;\r\n->Comp : (props: Props) => JSX.Element\r\n->props : Props\r\n+declare function Comp(props: DiscriminatorTrue | DiscriminatorFalse): JSX.Element;\r\n+>Comp : (props: DiscriminatorTrue | DiscriminatorFalse) => JSX.Element\r\n+>props : DiscriminatorTrue | DiscriminatorFalse\r\n >JSX : any\r\n \r\n // simple inference\r\n void (<Comp disc cb={s => parseInt(s)} />);\r\n >void (<Comp disc cb={s => parseInt(s)} />) : undefined\r\n >(<Comp disc cb={s => parseInt(s)} />) : JSX.Element\r\n ><Comp disc cb={s => parseInt(s)} /> : JSX.Element\r\n->Comp : (props: Props) => JSX.Element\r\n+>Comp : (props: DiscriminatorTrue | DiscriminatorFalse) => JSX.Element\r\n >disc : true\r\n >cb : (s: string) => number\r\n >s => parseInt(s) : (s: string) => number\r\n@@ -65,7 +55,7 @@ void (<Comp disc={false} cb={n => n.toFixed()} />);\n >void (<Comp disc={false} cb={n => n.toFixed()} />) : undefined\r\n >(<Comp disc={false} cb={n => n.toFixed()} />) : JSX.Element\r\n ><Comp disc={false} cb={n => n.toFixed()} /> : JSX.Element\r\n->Comp : (props: Props) => JSX.Element\r\n+>Comp : (props: DiscriminatorTrue | DiscriminatorFalse) => JSX.Element\r\n >disc : false\r\n >false : false\r\n >cb : (n: number) => string\r\n@@ -81,7 +71,7 @@ void (<Comp disc={undefined} cb={n => n.toFixed()} />);\n >void (<Comp disc={undefined} cb={n => n.toFixed()} />) : undefined\r\n >(<Comp disc={undefined} cb={n => n.toFixed()} />) : JSX.Element\r\n ><Comp disc={undefined} cb={n => n.toFixed()} /> : JSX.Element\r\n->Comp : (props: Props) => JSX.Element\r\n+>Comp : (props: DiscriminatorTrue | DiscriminatorFalse) => JSX.Element\r\n >disc : undefined\r\n >undefined : undefined\r\n >cb : (n: number) => string\r\n@@ -97,26 +87,7 @@ void (<Comp cb={n => n.toFixed()} />);\n >void (<Comp cb={n => n.toFixed()} />) : undefined\r\n >(<Comp cb={n => n.toFixed()} />) : JSX.Element\r\n ><Comp cb={n => n.toFixed()} /> : JSX.Element\r\n->Comp : (props: Props) => JSX.Element\r\n->cb : (n: number) => string\r\n->n => n.toFixed() : (n: number) => string\r\n->n : number\r\n->n.toFixed() : string\r\n->n.toFixed : (fractionDigits?: number | undefined) => string\r\n->n : number\r\n->toFixed : (fractionDigits?: number | undefined) => string\r\n-\r\n-declare function UnrelatedComp(props: UnrelatedProps): JSX.Element;\r\n->UnrelatedComp : (props: UnrelatedProps) => JSX.Element\r\n->props : UnrelatedProps\r\n->JSX : any\r\n-\r\n-// requires checking properties of all types, rather than properties of just the union type (e.g. only intersection)\r\n-void (<Comp cb={n => n.toFixed()} />);\r\n->void (<Comp cb={n => n.toFixed()} />) : undefined\r\n->(<Comp cb={n => n.toFixed()} />) : JSX.Element\r\n-><Comp cb={n => n.toFixed()} /> : JSX.Element\r\n->Comp : (props: Props) => JSX.Element\r\n+>Comp : (props: DiscriminatorTrue | DiscriminatorFalse) => JSX.Element\r\n >cb : (n: number) => string\r\n >n => n.toFixed() : (n: number) => string\r\n >n : number\r"},{"sha":"5aeb0dd0c0d7afa337af5ba18dd05c505df6ffcc","filename":"tests/cases/compiler/discriminantPropertyInference.ts","status":"modified","additions":1,"deletions":11,"changes":12,"blob_url":"https://github.com/microsoft/TypeScript/blob/07a684587dd93b07079d5fd55d9b92e0335e78eb/tests%2Fcases%2Fcompiler%2FdiscriminantPropertyInference.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/07a684587dd93b07079d5fd55d9b92e0335e78eb/tests%2Fcases%2Fcompiler%2FdiscriminantPropertyInference.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fcases%2Fcompiler%2FdiscriminantPropertyInference.ts?ref=07a684587dd93b07079d5fd55d9b92e0335e78eb","patch":"@@ -13,9 +13,7 @@ type DiscriminatorFalse = {\n     cb: (x: number) => void;\r\n }\r\n \r\n-type Unrelated = {\r\n-    val: number;\r\n-}\r\n+type Props = DiscriminatorTrue | DiscriminatorFalse;\r\n \r\n declare function f(options: DiscriminatorTrue | DiscriminatorFalse): any;\r\n \r\n@@ -41,11 +39,3 @@ f({\n f({\r\n     cb: n => n.toFixed()\r\n });\r\n-\r\n-\r\n-declare function g(options: DiscriminatorTrue | DiscriminatorFalse | Unrelated): any;\r\n-\r\n-// requires checking properties of all types, rather than properties of just the union type (e.g. only intersection)\r\n-g({\r\n-    cb: n => n.toFixed()\r\n-});\r"},{"sha":"d4db0f82d50a04db73f4628d233ee5bbfeb01832","filename":"tests/cases/compiler/tsxDiscriminantPropertyInference.tsx","status":"modified","additions":1,"deletions":12,"changes":13,"blob_url":"https://github.com/microsoft/TypeScript/blob/07a684587dd93b07079d5fd55d9b92e0335e78eb/tests%2Fcases%2Fcompiler%2FtsxDiscriminantPropertyInference.tsx","raw_url":"https://github.com/microsoft/TypeScript/raw/07a684587dd93b07079d5fd55d9b92e0335e78eb/tests%2Fcases%2Fcompiler%2FtsxDiscriminantPropertyInference.tsx","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fcases%2Fcompiler%2FtsxDiscriminantPropertyInference.tsx?ref=07a684587dd93b07079d5fd55d9b92e0335e78eb","patch":"@@ -17,15 +17,9 @@ type DiscriminatorFalse = {\n     cb: (x: number) => void;\n }\n \n-type Unrelated = {\n-    val: number;\n-}\n-\n type Props = DiscriminatorTrue | DiscriminatorFalse;\n \n-type UnrelatedProps = Props | Unrelated;\n-\n-declare function Comp(props: Props): JSX.Element;\n+declare function Comp(props: DiscriminatorTrue | DiscriminatorFalse): JSX.Element;\n \n // simple inference\n void (<Comp disc cb={s => parseInt(s)} />);\n@@ -38,8 +32,3 @@ void (<Comp disc={undefined} cb={n => n.toFixed()} />);\n \n // requires checking type information since discriminator is missing from object\n void (<Comp cb={n => n.toFixed()} />);\n-\n-declare function UnrelatedComp(props: UnrelatedProps): JSX.Element;\n-\n-// requires checking properties of all types, rather than properties of just the union type (e.g. only intersection)\n-void (<Comp cb={n => n.toFixed()} />);"}]},{"url":"https://api.github.com/repos/microsoft/TypeScript/issues/30259","repository_url":"https://api.github.com/repos/microsoft/TypeScript","labels_url":"https://api.github.com/repos/microsoft/TypeScript/issues/30259/labels{/name}","comments_url":"https://api.github.com/repos/microsoft/TypeScript/issues/30259/comments","events_url":"https://api.github.com/repos/microsoft/TypeScript/issues/30259/events","html_url":"https://github.com/microsoft/TypeScript/pull/30259","id":418462996,"node_id":"MDExOlB1bGxSZXF1ZXN0MjU5MjMwNzQ1","number":30259,"title":"Transform flag cleanup","user":{"login":"rbuckton","id":3902892,"node_id":"MDQ6VXNlcjM5MDI4OTI=","avatar_url":"https://avatars.githubusercontent.com/u/3902892?v=4","gravatar_id":"","url":"https://api.github.com/users/rbuckton","html_url":"https://github.com/rbuckton","followers_url":"https://api.github.com/users/rbuckton/followers","following_url":"https://api.github.com/users/rbuckton/following{/other_user}","gists_url":"https://api.github.com/users/rbuckton/gists{/gist_id}","starred_url":"https://api.github.com/users/rbuckton/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rbuckton/subscriptions","organizations_url":"https://api.github.com/users/rbuckton/orgs","repos_url":"https://api.github.com/users/rbuckton/repos","events_url":"https://api.github.com/users/rbuckton/events{/privacy}","received_events_url":"https://api.github.com/users/rbuckton/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2019-03-07T18:57:23Z","updated_at":"2019-03-08T23:08:30Z","closed_at":"2019-03-08T23:08:27Z","author_association":"MEMBER","active_lock_reason":null,"draft":false,"pull_request":{"url":"https://api.github.com/repos/microsoft/TypeScript/pulls/30259","html_url":"https://github.com/microsoft/TypeScript/pull/30259","diff_url":"https://github.com/microsoft/TypeScript/pull/30259.diff","patch_url":"https://github.com/microsoft/TypeScript/pull/30259.patch","merged_at":"2019-03-08T23:08:27Z"},"body":"With the recent change to add a `ContainsES2019` flag to the `TransformFlags` enum, we have now run out of space for additional flags. This PR removes a number of entries in the `TransformFlags` enum in favor of some simple checks. Benchmark comparisons against `master` indicate no noticeable regression in performance.\r\n","reactions":{"url":"https://api.github.com/repos/microsoft/TypeScript/issues/30259/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/microsoft/TypeScript/issues/30259/timeline","performed_via_github_app":null,"state_reason":null,"score":1,"files":[{"sha":"11c8773718a9f6b094fe623185467ef4089df564","filename":"src/compiler/binder.ts","status":"modified","additions":18,"deletions":101,"changes":119,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Fbinder.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Fbinder.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Fbinder.ts?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -3093,32 +3093,24 @@ namespace ts {\n \r\n     function computeCallExpression(node: CallExpression, subtreeFlags: TransformFlags) {\r\n         let transformFlags = subtreeFlags;\r\n+        const callee = skipOuterExpressions(node.expression);\r\n         const expression = node.expression;\r\n \r\n         if (node.typeArguments) {\r\n             transformFlags |= TransformFlags.AssertTypeScript;\r\n         }\r\n \r\n-        if (subtreeFlags & TransformFlags.ContainsRestOrSpread\r\n-            || (expression.transformFlags & (TransformFlags.Super | TransformFlags.ContainsSuper))) {\r\n+        if (subtreeFlags & TransformFlags.ContainsRestOrSpread || isSuperOrSuperProperty(callee)) {\r\n             // If the this node contains a SpreadExpression, or is a super call, then it is an ES6\r\n             // node.\r\n             transformFlags |= TransformFlags.AssertES2015;\r\n-            // super property or element accesses could be inside lambdas, etc, and need a captured `this`,\r\n-            // while super keyword for super calls (indicated by TransformFlags.Super) does not (since it can only be top-level in a constructor)\r\n-            if (expression.transformFlags & TransformFlags.ContainsSuper) {\r\n+            if (isSuperProperty(callee)) {\r\n                 transformFlags |= TransformFlags.ContainsLexicalThis;\r\n             }\r\n         }\r\n \r\n         if (expression.kind === SyntaxKind.ImportKeyword) {\r\n             transformFlags |= TransformFlags.ContainsDynamicImport;\r\n-\r\n-            // A dynamic 'import()' call that contains a lexical 'this' will\r\n-            // require a captured 'this' when emitting down-level.\r\n-            if (subtreeFlags & TransformFlags.ContainsLexicalThis) {\r\n-                transformFlags |= TransformFlags.ContainsCapturedLexicalThis;\r\n-            }\r\n         }\r\n \r\n         node.transformFlags = transformFlags | TransformFlags.HasComputedFlags;\r\n@@ -3191,7 +3183,7 @@ namespace ts {\n         // If a parameter has an initializer, a binding pattern or a dotDotDot token, then\r\n         // it is ES6 syntax and its container must emit default value assignments or parameter destructuring downlevel.\r\n         if (subtreeFlags & TransformFlags.ContainsBindingPattern || initializer || dotDotDotToken) {\r\n-            transformFlags |= TransformFlags.AssertES2015 | TransformFlags.ContainsDefaultValueAssignments;\r\n+            transformFlags |= TransformFlags.AssertES2015;\r\n         }\r\n \r\n         node.transformFlags = transformFlags | TransformFlags.HasComputedFlags;\r\n@@ -3202,7 +3194,6 @@ namespace ts {\n         let transformFlags = subtreeFlags;\r\n         const expression = node.expression;\r\n         const expressionKind = expression.kind;\r\n-        const expressionTransformFlags = expression.transformFlags;\r\n \r\n         // If the node is synthesized, it means the emitter put the parentheses there,\r\n         // not the user. If we didn't want them, the emitter would not have put them\r\n@@ -3212,12 +3203,6 @@ namespace ts {\n             transformFlags |= TransformFlags.AssertTypeScript;\r\n         }\r\n \r\n-        // If the expression of a ParenthesizedExpression is a destructuring assignment,\r\n-        // then the ParenthesizedExpression is a destructuring assignment.\r\n-        if (expressionTransformFlags & TransformFlags.DestructuringAssignment) {\r\n-            transformFlags |= TransformFlags.DestructuringAssignment;\r\n-        }\r\n-\r\n         node.transformFlags = transformFlags | TransformFlags.HasComputedFlags;\r\n         return transformFlags & ~TransformFlags.OuterExpressionExcludes;\r\n     }\r\n@@ -3241,12 +3226,6 @@ namespace ts {\n                 || node.typeParameters) {\r\n                 transformFlags |= TransformFlags.AssertTypeScript;\r\n             }\r\n-\r\n-            if (subtreeFlags & TransformFlags.ContainsLexicalThisInComputedPropertyName) {\r\n-                // A computed property name containing `this` might need to be rewritten,\r\n-                // so propagate the ContainsLexicalThis flag upward.\r\n-                transformFlags |= TransformFlags.ContainsLexicalThis;\r\n-            }\r\n         }\r\n \r\n         node.transformFlags = transformFlags | TransformFlags.HasComputedFlags;\r\n@@ -3264,12 +3243,6 @@ namespace ts {\n             transformFlags |= TransformFlags.AssertTypeScript;\r\n         }\r\n \r\n-        if (subtreeFlags & TransformFlags.ContainsLexicalThisInComputedPropertyName) {\r\n-            // A computed property name containing `this` might need to be rewritten,\r\n-            // so propagate the ContainsLexicalThis flag upward.\r\n-            transformFlags |= TransformFlags.ContainsLexicalThis;\r\n-        }\r\n-\r\n         node.transformFlags = transformFlags | TransformFlags.HasComputedFlags;\r\n         return transformFlags & ~TransformFlags.ClassExcludes;\r\n     }\r\n@@ -3374,7 +3347,7 @@ namespace ts {\n         }\r\n \r\n         node.transformFlags = transformFlags | TransformFlags.HasComputedFlags;\r\n-        return transformFlags & ~TransformFlags.MethodOrAccessorExcludes;\r\n+        return propagatePropertyNameFlags(node.name, transformFlags & ~TransformFlags.MethodOrAccessorExcludes);\r\n     }\r\n \r\n     function computeAccessor(node: AccessorDeclaration, subtreeFlags: TransformFlags) {\r\n@@ -3396,7 +3369,7 @@ namespace ts {\n         }\r\n \r\n         node.transformFlags = transformFlags | TransformFlags.HasComputedFlags;\r\n-        return transformFlags & ~TransformFlags.MethodOrAccessorExcludes;\r\n+        return propagatePropertyNameFlags(node.name, transformFlags & ~TransformFlags.MethodOrAccessorExcludes);\r\n     }\r\n \r\n     function computePropertyDeclaration(node: PropertyDeclaration, subtreeFlags: TransformFlags) {\r\n@@ -3410,7 +3383,7 @@ namespace ts {\n         }\r\n \r\n         node.transformFlags = transformFlags | TransformFlags.HasComputedFlags;\r\n-        return transformFlags & ~TransformFlags.NodeExcludes;\r\n+        return propagatePropertyNameFlags(node.name, transformFlags & ~TransformFlags.PropertyExcludes);\r\n     }\r\n \r\n     function computeFunctionDeclaration(node: FunctionDeclaration, subtreeFlags: TransformFlags) {\r\n@@ -3444,13 +3417,6 @@ namespace ts {\n                 transformFlags |= TransformFlags.AssertES2018;\r\n             }\r\n \r\n-            // If a FunctionDeclaration's subtree has marked the container as needing to capture the\r\n-            // lexical this, or the function contains parameters with initializers, then this node is\r\n-            // ES6 syntax.\r\n-            if (subtreeFlags & TransformFlags.ES2015FunctionSyntaxMask) {\r\n-                transformFlags |= TransformFlags.AssertES2015;\r\n-            }\r\n-\r\n             // If a FunctionDeclaration is generator function and is the body of a\r\n             // transformed async function, then this node can be transformed to a\r\n             // down-level generator.\r\n@@ -3486,14 +3452,6 @@ namespace ts {\n             transformFlags |= TransformFlags.AssertES2018;\r\n         }\r\n \r\n-\r\n-        // If a FunctionExpression's subtree has marked the container as needing to capture the\r\n-        // lexical this, or the function contains parameters with initializers, then this node is\r\n-        // ES6 syntax.\r\n-        if (subtreeFlags & TransformFlags.ES2015FunctionSyntaxMask) {\r\n-            transformFlags |= TransformFlags.AssertES2015;\r\n-        }\r\n-\r\n         // If a FunctionExpression is generator function and is the body of a\r\n         // transformed async function, then this node can be transformed to a\r\n         // down-level generator.\r\n@@ -3527,11 +3485,6 @@ namespace ts {\n             transformFlags |= TransformFlags.AssertES2018;\r\n         }\r\n \r\n-        // If an ArrowFunction contains a lexical this, its container must capture the lexical this.\r\n-        if (subtreeFlags & TransformFlags.ContainsLexicalThis) {\r\n-            transformFlags |= TransformFlags.ContainsCapturedLexicalThis;\r\n-        }\r\n-\r\n         node.transformFlags = transformFlags | TransformFlags.HasComputedFlags;\r\n         return transformFlags & ~TransformFlags.ArrowFunctionExcludes;\r\n     }\r\n@@ -3541,11 +3494,10 @@ namespace ts {\n \r\n         // If a PropertyAccessExpression starts with a super keyword, then it is\r\n         // ES6 syntax, and requires a lexical `this` binding.\r\n-        if (transformFlags & TransformFlags.Super) {\r\n-            transformFlags ^= TransformFlags.Super;\r\n+        if (node.expression.kind === SyntaxKind.SuperKeyword) {\r\n             // super inside of an async function requires hoisting the super access (ES2017).\r\n             // same for super inside of an async generator, which is ES2018.\r\n-            transformFlags |= TransformFlags.ContainsSuper | TransformFlags.ContainsES2017 | TransformFlags.ContainsES2018;\r\n+            transformFlags |= TransformFlags.ContainsES2017 | TransformFlags.ContainsES2018;\r\n         }\r\n \r\n         node.transformFlags = transformFlags | TransformFlags.HasComputedFlags;\r\n@@ -3554,16 +3506,13 @@ namespace ts {\n \r\n     function computeElementAccess(node: ElementAccessExpression, subtreeFlags: TransformFlags) {\r\n         let transformFlags = subtreeFlags;\r\n-        const expression = node.expression;\r\n-        const expressionFlags = expression.transformFlags; // We do not want to aggregate flags from the argument expression for super/this capturing\r\n \r\n         // If an ElementAccessExpression starts with a super keyword, then it is\r\n         // ES6 syntax, and requires a lexical `this` binding.\r\n-        if (expressionFlags & TransformFlags.Super) {\r\n-            transformFlags &= ~TransformFlags.Super;\r\n+        if (node.expression.kind === SyntaxKind.SuperKeyword) {\r\n             // super inside of an async function requires hoisting the super access (ES2017).\r\n             // same for super inside of an async generator, which is ES2018.\r\n-            transformFlags |= TransformFlags.ContainsSuper | TransformFlags.ContainsES2017 | TransformFlags.ContainsES2018;\r\n+            transformFlags |= TransformFlags.ContainsES2017 | TransformFlags.ContainsES2018;\r\n         }\r\n \r\n         node.transformFlags = transformFlags | TransformFlags.HasComputedFlags;\r\n@@ -3572,7 +3521,7 @@ namespace ts {\n \r\n     function computeVariableDeclaration(node: VariableDeclaration, subtreeFlags: TransformFlags) {\r\n         let transformFlags = subtreeFlags;\r\n-        transformFlags |= TransformFlags.AssertES2015 | TransformFlags.ContainsBindingPattern;\r\n+        transformFlags |= TransformFlags.AssertES2015 | TransformFlags.ContainsBindingPattern; // TODO(rbuckton): Why are these set unconditionally?\r\n \r\n         // A VariableDeclaration containing ObjectRest is ES2018 syntax\r\n         if (subtreeFlags & TransformFlags.ContainsObjectRestOrSpread) {\r\n@@ -3634,15 +3583,7 @@ namespace ts {\n     }\r\n \r\n     function computeExpressionStatement(node: ExpressionStatement, subtreeFlags: TransformFlags) {\r\n-        let transformFlags = subtreeFlags;\r\n-\r\n-        // If the expression of an expression statement is a destructuring assignment,\r\n-        // then we treat the statement as ES6 so that we can indicate that we do not\r\n-        // need to hold on to the right-hand side.\r\n-        if (node.expression.transformFlags & TransformFlags.DestructuringAssignment) {\r\n-            transformFlags |= TransformFlags.AssertES2015;\r\n-        }\r\n-\r\n+        const transformFlags = subtreeFlags;\r\n         node.transformFlags = transformFlags | TransformFlags.HasComputedFlags;\r\n         return transformFlags & ~TransformFlags.NodeExcludes;\r\n     }\r\n@@ -3815,17 +3756,6 @@ namespace ts {\n                 // This is so that they can flow through PropertyName transforms unaffected.\r\n                 // Instead, we mark the container as ES6, so that it can properly handle the transform.\r\n                 transformFlags |= TransformFlags.ContainsComputedPropertyName;\r\n-                if (subtreeFlags & TransformFlags.ContainsLexicalThis) {\r\n-                    // A computed method name like `[this.getName()](x: string) { ... }` needs to\r\n-                    // distinguish itself from the normal case of a method body containing `this`:\r\n-                    // `this` inside a method doesn't need to be rewritten (the method provides `this`),\r\n-                    // whereas `this` inside a computed name *might* need to be rewritten if the class/object\r\n-                    // is inside an arrow function:\r\n-                    // `_this = this; () => class K { [_this.getName()]() { ... } }`\r\n-                    // To make this distinction, use ContainsLexicalThisInComputedPropertyName\r\n-                    // instead of ContainsLexicalThis for computed property names\r\n-                    transformFlags |= TransformFlags.ContainsLexicalThisInComputedPropertyName;\r\n-                }\r\n                 break;\r\n \r\n             case SyntaxKind.SpreadElement:\r\n@@ -3838,7 +3768,7 @@ namespace ts {\n \r\n             case SyntaxKind.SuperKeyword:\r\n                 // This node is ES6 syntax.\r\n-                transformFlags |= TransformFlags.AssertES2015 | TransformFlags.Super;\r\n+                transformFlags |= TransformFlags.AssertES2015;\r\n                 excludeFlags = TransformFlags.OuterExpressionExcludes; // must be set to persist `Super`\r\n                 break;\r\n \r\n@@ -3880,12 +3810,6 @@ namespace ts {\n                     transformFlags |= TransformFlags.AssertES2015;\r\n                 }\r\n \r\n-                if (subtreeFlags & TransformFlags.ContainsLexicalThisInComputedPropertyName) {\r\n-                    // A computed property name containing `this` might need to be rewritten,\r\n-                    // so propagate the ContainsLexicalThis flag upward.\r\n-                    transformFlags |= TransformFlags.ContainsLexicalThis;\r\n-                }\r\n-\r\n                 if (subtreeFlags & TransformFlags.ContainsObjectRestOrSpread) {\r\n                     // If an ObjectLiteralExpression contains a spread element, then it\r\n                     // is an ES2018 node.\r\n@@ -3895,14 +3819,7 @@ namespace ts {\n                 break;\r\n \r\n             case SyntaxKind.ArrayLiteralExpression:\r\n-            case SyntaxKind.NewExpression:\r\n                 excludeFlags = TransformFlags.ArrayLiteralOrCallOrNewExcludes;\r\n-                if (subtreeFlags & TransformFlags.ContainsRestOrSpread) {\r\n-                    // If the this node contains a SpreadExpression, then it is an ES6\r\n-                    // node.\r\n-                    transformFlags |= TransformFlags.AssertES2015;\r\n-                }\r\n-\r\n                 break;\r\n \r\n             case SyntaxKind.DoStatement:\r\n@@ -3917,10 +3834,6 @@ namespace ts {\n                 break;\r\n \r\n             case SyntaxKind.SourceFile:\r\n-                if (subtreeFlags & TransformFlags.ContainsCapturedLexicalThis) {\r\n-                    transformFlags |= TransformFlags.AssertES2015;\r\n-                }\r\n-\r\n                 break;\r\n \r\n             case SyntaxKind.ReturnStatement:\r\n@@ -3938,6 +3851,10 @@ namespace ts {\n         return transformFlags & ~excludeFlags;\r\n     }\r\n \r\n+    function propagatePropertyNameFlags(node: PropertyName, transformFlags: TransformFlags) {\r\n+        return transformFlags | (node.transformFlags & TransformFlags.PropertyNamePropagatingFlags);\r\n+    }\r\n+\r\n     /**\r\n      * Gets the transform flags to exclude when unioning the transform flags of a subtree.\r\n      *\r"},{"sha":"610e527451daadd89e4ec41fc0e9d2cd91c72152","filename":"src/compiler/transformers/es2015.ts","status":"modified","additions":257,"deletions":302,"changes":559,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Ftransformers%2Fes2015.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Ftransformers%2Fes2015.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ftransformers%2Fes2015.ts?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -145,30 +145,6 @@ namespace ts {\n         loopOutParameters: LoopOutParameter[];\r\n     }\r\n \r\n-    const enum SuperCaptureResult {\r\n-        /**\r\n-         * A capture may have been added for calls to 'super', but\r\n-         * the caller should emit subsequent statements normally.\r\n-         */\r\n-        NoReplacement,\r\n-        /**\r\n-         * A call to 'super()' got replaced with a capturing statement like:\r\n-         *\r\n-         *  var _this = _super.call(...) || this;\r\n-         *\r\n-         * Callers should skip the current statement.\r\n-         */\r\n-        ReplaceSuperCapture,\r\n-        /**\r\n-         * A call to 'super()' got replaced with a capturing statement like:\r\n-         *\r\n-         *  return _super.call(...) || this;\r\n-         *\r\n-         * Callers should skip the current statement and avoid any returns of '_this'.\r\n-         */\r\n-        ReplaceWithReturn,\r\n-    }\r\n-\r\n     type LoopConverter = (node: IterationStatement, outermostLabeledStatement: LabeledStatement | undefined, convertedLoopBodyStatements: Statement[] | undefined) => Statement;\r\n \r\n     // Facts we track as we traverse the tree\r\n@@ -192,14 +168,14 @@ namespace ts {\n         ForStatement = 1 << 10,                 // Enclosing block-scoped container is a ForStatement\r\n         ForInOrForOfStatement = 1 << 11,        // Enclosing block-scoped container is a ForInStatement or ForOfStatement\r\n         ConstructorWithCapturedSuper = 1 << 12, // Enclosed in a constructor that captures 'this' for use with 'super'\r\n-        ComputedPropertyName = 1 << 13,         // Enclosed in a computed property name\r\n         // NOTE: do not add more ancestor flags without also updating AncestorFactsMask below.\r\n+        // NOTE: when adding a new ancestor flag, be sure to update the subtree flags below.\r\n \r\n         //\r\n         // Ancestor masks\r\n         //\r\n \r\n-        AncestorFactsMask = (ComputedPropertyName << 1) - 1,\r\n+        AncestorFactsMask = (ConstructorWithCapturedSuper << 1) - 1,\r\n \r\n         // We are always in *some* kind of block scope, but only specific block-scope containers are\r\n         // top-level or Blocks.\r\n@@ -212,14 +188,14 @@ namespace ts {\n \r\n         // Functions, methods, and accessors are both new lexical scopes and new block scopes.\r\n         FunctionIncludes = Function | TopLevel,\r\n-        FunctionExcludes = BlockScopeExcludes & ~TopLevel | ArrowFunction | AsyncFunctionBody | CapturesThis | NonStaticClassElement | ConstructorWithCapturedSuper | ComputedPropertyName,\r\n+        FunctionExcludes = BlockScopeExcludes & ~TopLevel | ArrowFunction | AsyncFunctionBody | CapturesThis | NonStaticClassElement | ConstructorWithCapturedSuper,\r\n \r\n         AsyncFunctionBodyIncludes = FunctionIncludes | AsyncFunctionBody,\r\n         AsyncFunctionBodyExcludes = FunctionExcludes & ~NonStaticClassElement,\r\n \r\n         // Arrow functions are lexically scoped to their container, but are new block scopes.\r\n         ArrowFunctionIncludes = ArrowFunction | TopLevel,\r\n-        ArrowFunctionExcludes = BlockScopeExcludes & ~TopLevel | ConstructorWithCapturedSuper | ComputedPropertyName,\r\n+        ArrowFunctionExcludes = BlockScopeExcludes & ~TopLevel | ConstructorWithCapturedSuper,\r\n \r\n         // Constructors are both new lexical scopes and new block scopes. Constructors are also\r\n         // always considered non-static members of a class.\r\n@@ -248,23 +224,21 @@ namespace ts {\n         IterationStatementBlockIncludes = IterationStatementBlock,\r\n         IterationStatementBlockExcludes = BlockScopeExcludes,\r\n \r\n-        // Computed property names track subtree flags differently than their containing members.\r\n-        ComputedPropertyNameIncludes = ComputedPropertyName,\r\n-        ComputedPropertyNameExcludes = None,\r\n-\r\n         //\r\n         // Subtree facts\r\n         //\r\n-        NewTarget = 1 << 14,                        // Contains a 'new.target' meta-property\r\n-        NewTargetInComputedPropertyName = 1 << 15,  // Contains a 'new.target' meta-property in a computed property name.\r\n \r\n+        NewTarget = 1 << 13,                            // Contains a 'new.target' meta-property\r\n+        CapturedLexicalThis = 1 << 14,                  // Contains a lexical `this` reference captured by an arrow function.\r\n \r\n         //\r\n         // Subtree masks\r\n         //\r\n \r\n         SubtreeFactsMask = ~AncestorFactsMask,\r\n-        PropagateNewTargetMask = NewTarget | NewTargetInComputedPropertyName,\r\n+\r\n+        ArrowFunctionSubtreeExcludes = None,\r\n+        FunctionSubtreeExcludes = NewTarget | CapturedLexicalThis,\r\n     }\r\n \r\n     export function transformES2015(context: TransformationContext) {\r\n@@ -370,13 +344,6 @@ namespace ts {\n             }\r\n         }\r\n \r\n-        function functionBodyVisitor(node: Block): Block {\r\n-            if (shouldVisitNode(node)) {\r\n-                return visitBlock(node, /*isFunctionBody*/ true);\r\n-            }\r\n-            return node;\r\n-        }\r\n-\r\n         function callExpressionVisitor(node: Node): VisitResult<Node> {\r\n             if (node.kind === SyntaxKind.SuperKeyword) {\r\n                 return visitSuperKeyword(/*isExpressionOfCall*/ true);\r\n@@ -528,22 +495,23 @@ namespace ts {\n \r\n         function visitSourceFile(node: SourceFile): SourceFile {\r\n             const ancestorFacts = enterSubtree(HierarchyFacts.SourceFileExcludes, HierarchyFacts.SourceFileIncludes);\r\n+            const prologue: Statement[] = [];\r\n             const statements: Statement[] = [];\r\n             startLexicalEnvironment();\r\n-            let statementOffset: number | undefined = addStandardPrologue(statements, node.statements, /*ensureUseStrict*/ false);\r\n-            addCaptureThisForNodeIfNeeded(statements, node);\r\n-            statementOffset = addCustomPrologue(statements, node.statements, statementOffset, visitor);\r\n+            let statementOffset = addStandardPrologue(prologue, node.statements, /*ensureUseStrict*/ false);\r\n+            statementOffset = addCustomPrologue(prologue, node.statements, statementOffset, visitor);\r\n             addRange(statements, visitNodes(node.statements, visitor, isStatement, statementOffset));\r\n             if (taggedTemplateStringDeclarations) {\r\n                 statements.push(\r\n                     createVariableStatement(/*modifiers*/ undefined,\r\n                         createVariableDeclarationList(taggedTemplateStringDeclarations)));\r\n             }\r\n-            addStatementsAfterPrologue(statements, endLexicalEnvironment());\r\n+            mergeLexicalEnvironment(prologue, endLexicalEnvironment());\r\n+            insertCaptureThisForNodeIfNeeded(prologue, node);\r\n             exitSubtree(ancestorFacts, HierarchyFacts.None, HierarchyFacts.None);\r\n             return updateSourceFileNode(\r\n                 node,\r\n-                setTextRange(createNodeArray(statements), node.statements)\r\n+                setTextRange(createNodeArray(concatenate(prologue, statements)), node.statements)\r\n             );\r\n         }\r\n \r\n@@ -596,6 +564,9 @@ namespace ts {\n         }\r\n \r\n         function visitThisKeyword(node: Node): Node {\r\n+            if (hierarchyFacts & HierarchyFacts.ArrowFunction) {\r\n+                hierarchyFacts |= HierarchyFacts.CapturedLexicalThis;\r\n+            }\r\n             if (convertedLoopState) {\r\n                 if (hierarchyFacts & HierarchyFacts.ArrowFunction) {\r\n                     // if the enclosing function is an ArrowFunction then we use the captured 'this' keyword.\r\n@@ -847,7 +818,7 @@ namespace ts {\n             setEmitFlags(statement, EmitFlags.NoComments | EmitFlags.NoTokenSourceMaps);\r\n             statements.push(statement);\r\n \r\n-            addStatementsAfterPrologue(statements, endLexicalEnvironment());\r\n+            insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());\r\n \r\n             const block = createBlock(setTextRange(createNodeArray(statements), /*location*/ node.members), /*multiLine*/ true);\r\n             setEmitFlags(block, EmitFlags.NoComments);\r\n@@ -904,7 +875,7 @@ namespace ts {\n             }\r\n \r\n             statements.push(constructorFunction);\r\n-            exitSubtree(ancestorFacts, HierarchyFacts.PropagateNewTargetMask, HierarchyFacts.None);\r\n+            exitSubtree(ancestorFacts, HierarchyFacts.FunctionSubtreeExcludes, HierarchyFacts.None);\r\n             convertedLoopState = savedConvertedLoopState;\r\n         }\r\n \r\n@@ -925,6 +896,28 @@ namespace ts {\n                 || <ParameterDeclaration[]>[];\r\n         }\r\n \r\n+        function createDefaultConstructorBody(node: ClassDeclaration | ClassExpression, isDerivedClass: boolean) {\r\n+            // We must be here because the user didn't write a constructor\r\n+            // but we needed to call 'super(...args)' anyway as per 14.5.14 of the ES2016 spec.\r\n+            // If that's the case we can just immediately return the result of a 'super()' call.\r\n+            const statements: Statement[] = [];\r\n+            resumeLexicalEnvironment();\r\n+            mergeLexicalEnvironment(statements, endLexicalEnvironment());\r\n+\r\n+            if (isDerivedClass) {\r\n+                // return _super !== null && _super.apply(this, arguments) || this;\r\n+                statements.push(createReturn(createDefaultSuperCallOrThis()));\r\n+            }\r\n+\r\n+            const statementsArray = createNodeArray(statements);\r\n+            setTextRange(statementsArray, node.members);\r\n+\r\n+            const block = createBlock(statementsArray, /*multiLine*/ true);\r\n+            setTextRange(block, node);\r\n+            setEmitFlags(block, EmitFlags.NoComments);\r\n+            return block;\r\n+        }\r\n+\r\n         /**\r\n          * Transforms the body of a constructor declaration of a class.\r\n          *\r\n@@ -934,82 +927,153 @@ namespace ts {\n          * @param hasSynthesizedSuper A value indicating whether the constructor starts with a\r\n          *                            synthesized `super` call.\r\n          */\r\n-        function transformConstructorBody(constructor: ConstructorDeclaration | undefined, node: ClassDeclaration | ClassExpression, extendsClauseElement: ExpressionWithTypeArguments | undefined, hasSynthesizedSuper: boolean) {\r\n+        function transformConstructorBody(constructor: ConstructorDeclaration & { body: FunctionBody } | undefined, node: ClassDeclaration | ClassExpression, extendsClauseElement: ExpressionWithTypeArguments | undefined, hasSynthesizedSuper: boolean) {\r\n+            // determine whether the class is known syntactically to be a derived class (e.g. a\r\n+            // class that extends a value that is not syntactically known to be `null`).\r\n+            const isDerivedClass = !!extendsClauseElement && skipOuterExpressions(extendsClauseElement.expression).kind !== SyntaxKind.NullKeyword;\r\n+\r\n+            // When the subclass does not have a constructor, we synthesize a *default* constructor using the following\r\n+            // representation:\r\n+            //\r\n+            // ```\r\n+            // // es2015 (source)\r\n+            // class C extends Base { }\r\n+            //\r\n+            // // es5 (transformed)\r\n+            // var C = (function (_super) {\r\n+            //     function C() {\r\n+            //         return _super.apply(this, arguments) || this;\r\n+            //     }\r\n+            //     return C;\r\n+            // })(Base);\r\n+            // ```\r\n+            if (!constructor) return createDefaultConstructorBody(node, isDerivedClass);\r\n+\r\n+            // The prologue will contain all leading standard and custom prologue statements added by this transform\r\n+            const prologue: Statement[] = [];\r\n             const statements: Statement[] = [];\r\n             resumeLexicalEnvironment();\r\n \r\n-            let statementOffset = -1;\r\n+            // If a super call has already been synthesized,\r\n+            // we're going to assume that we should just transform everything after that.\r\n+            // The assumption is that no prior step in the pipeline has added any prologue directives.\r\n+            let statementOffset = 0;\r\n+            if (!hasSynthesizedSuper) statementOffset = addStandardPrologue(prologue, constructor.body.statements, /*ensureUseStrict*/ false);\r\n+            addDefaultValueAssignmentsIfNeeded(statements, constructor);\r\n+            addRestParameterIfNeeded(statements, constructor, hasSynthesizedSuper);\r\n+            if (!hasSynthesizedSuper) statementOffset = addCustomPrologue(statements, constructor.body.statements, statementOffset, visitor);\r\n+\r\n+            // If the first statement is a call to `super()`, visit the statement directly\r\n+            let superCallExpression: Expression | undefined;\r\n             if (hasSynthesizedSuper) {\r\n-                // If a super call has already been synthesized,\r\n-                // we're going to assume that we should just transform everything after that.\r\n-                // The assumption is that no prior step in the pipeline has added any prologue directives.\r\n-                statementOffset = 0;\r\n-            }\r\n-            else if (constructor) {\r\n-                statementOffset = addStandardPrologue(statements, constructor.body!.statements, /*ensureUseStrict*/ false);\r\n+                superCallExpression = createDefaultSuperCallOrThis();\r\n             }\r\n-\r\n-            if (constructor) {\r\n-                addDefaultValueAssignmentsIfNeeded(statements, constructor);\r\n-                addRestParameterIfNeeded(statements, constructor, hasSynthesizedSuper);\r\n-                if (!hasSynthesizedSuper) {\r\n-                    // If no super call has been synthesized, emit custom prologue directives.\r\n-                    statementOffset = addCustomPrologue(statements, constructor.body!.statements, statementOffset, visitor);\r\n+            else if (isDerivedClass && statementOffset < constructor.body.statements.length) {\r\n+                const firstStatement = constructor.body.statements[statementOffset];\r\n+                if (isExpressionStatement(firstStatement) && isSuperCall(firstStatement.expression)) {\r\n+                    superCallExpression = visitImmediateSuperCallInBody(firstStatement.expression);\r\n                 }\r\n-                Debug.assert(statementOffset >= 0, \"statementOffset not initialized correctly!\");\r\n-\r\n             }\r\n \r\n-            // determine whether the class is known syntactically to be a derived class (e.g. a\r\n-            // class that extends a value that is not syntactically known to be `null`).\r\n-            const isDerivedClass = !!extendsClauseElement && skipOuterExpressions(extendsClauseElement.expression).kind !== SyntaxKind.NullKeyword;\r\n-            const superCaptureStatus = declareOrCaptureOrReturnThisForConstructorIfNeeded(statements, constructor, isDerivedClass, hasSynthesizedSuper, statementOffset);\r\n-\r\n-            // The last statement expression was replaced. Skip it.\r\n-            if (superCaptureStatus === SuperCaptureResult.ReplaceSuperCapture || superCaptureStatus === SuperCaptureResult.ReplaceWithReturn) {\r\n-                statementOffset++;\r\n+            if (superCallExpression) {\r\n+                hierarchyFacts |= HierarchyFacts.ConstructorWithCapturedSuper;\r\n+                statementOffset++; // skip this statement, we will add it after visiting the rest of the body.\r\n             }\r\n \r\n-            if (constructor) {\r\n-                if (superCaptureStatus === SuperCaptureResult.ReplaceSuperCapture) {\r\n-                    hierarchyFacts |= HierarchyFacts.ConstructorWithCapturedSuper;\r\n-                }\r\n+            // visit the remaining statements\r\n+            addRange(statements, visitNodes(constructor.body.statements, visitor, isStatement, /*start*/ statementOffset));\r\n \r\n-                addRange(statements, visitNodes(constructor.body!.statements, visitor, isStatement, /*start*/ statementOffset));\r\n-            }\r\n+            mergeLexicalEnvironment(prologue, endLexicalEnvironment());\r\n+            insertCaptureNewTargetIfNeeded(prologue, constructor, /*copyOnWrite*/ false);\r\n \r\n-            // Return `_this` unless we're sure enough that it would be pointless to add a return statement.\r\n-            // If there's a constructor that we can tell returns in enough places, then we *do not* want to add a return.\r\n-            if (isDerivedClass\r\n-                && superCaptureStatus !== SuperCaptureResult.ReplaceWithReturn\r\n-                && !(constructor && isSufficientlyCoveredByReturnStatements(constructor.body!))) {\r\n-                statements.push(\r\n-                    createReturn(\r\n-                        createFileLevelUniqueName(\"_this\")\r\n-                    )\r\n-                );\r\n+            if (isDerivedClass) {\r\n+                if (superCallExpression && statementOffset === constructor.body.statements.length && !(constructor.body.transformFlags & TransformFlags.ContainsLexicalThis)) {\r\n+                    // If the subclass constructor does *not* contain `this` and *ends* with a `super()` call, we will use the\r\n+                    // following representation:\r\n+                    //\r\n+                    // ```\r\n+                    // // es2015 (source)\r\n+                    // class C extends Base {\r\n+                    //     constructor() {\r\n+                    //         super(\"foo\");\r\n+                    //     }\r\n+                    // }\r\n+                    //\r\n+                    // // es5 (transformed)\r\n+                    // var C = (function (_super) {\r\n+                    //     function C() {\r\n+                    //         return _super.call(this, \"foo\") || this;\r\n+                    //     }\r\n+                    //     return C;\r\n+                    // })(Base);\r\n+                    // ```\r\n+                    const superCall = cast(cast(superCallExpression, isBinaryExpression).left, isCallExpression);\r\n+                    const returnStatement = createReturn(superCallExpression);\r\n+                    setCommentRange(returnStatement, getCommentRange(superCall));\r\n+                    setEmitFlags(superCall, EmitFlags.NoComments);\r\n+                    statements.push(returnStatement);\r\n+                }\r\n+                else {\r\n+                    // Otherwise, we will use the following transformed representation for calls to `super()` in a constructor:\r\n+                    //\r\n+                    // ```\r\n+                    // // es2015 (source)\r\n+                    // class C extends Base {\r\n+                    //     constructor() {\r\n+                    //         super(\"foo\");\r\n+                    //         this.x = 1;\r\n+                    //     }\r\n+                    // }\r\n+                    //\r\n+                    // // es5 (transformed)\r\n+                    // var C = (function (_super) {\r\n+                    //     function C() {\r\n+                    //         var _this = _super.call(this, \"foo\") || this;\r\n+                    //         _this.x = 1;\r\n+                    //         return _this;\r\n+                    //     }\r\n+                    //     return C;\r\n+                    // })(Base);\r\n+                    // ```\r\n+\r\n+                    // Since the `super()` call was the first statement, we insert the `this` capturing call to\r\n+                    // `super()` at the top of the list of `statements` (after any pre-existing custom prologues).\r\n+                    insertCaptureThisForNode(statements, constructor, superCallExpression || createActualThis());\r\n+\r\n+                    if (!isSufficientlyCoveredByReturnStatements(constructor.body)) {\r\n+                        statements.push(createReturn(createFileLevelUniqueName(\"_this\")));\r\n+                    }\r\n+                }\r\n             }\r\n-\r\n-            addStatementsAfterPrologue(statements, endLexicalEnvironment());\r\n-\r\n-            if (constructor) {\r\n-                prependCaptureNewTargetIfNeeded(statements, constructor, /*copyOnWrite*/ false);\r\n+            else {\r\n+                // If a class is not derived from a base class or does not have a call to `super()`, `this` is only\r\n+                // captured when necessitated by an arrow function capturing the lexical `this`:\r\n+                //\r\n+                // ```\r\n+                // // es2015\r\n+                // class C {}\r\n+                //\r\n+                // // es5\r\n+                // var C = (function () {\r\n+                //     function C() {\r\n+                //     }\r\n+                //     return C;\r\n+                // })();\r\n+                // ```\r\n+                insertCaptureThisForNodeIfNeeded(prologue, constructor);\r\n             }\r\n \r\n             const block = createBlock(\r\n                 setTextRange(\r\n                     createNodeArray(\r\n-                        statements\r\n+                        concatenate(prologue, statements)\r\n                     ),\r\n-                    /*location*/ constructor ? constructor.body!.statements : node.members\r\n+                    /*location*/ constructor.body.statements\r\n                 ),\r\n                 /*multiLine*/ true\r\n             );\r\n \r\n-            setTextRange(block, constructor ? constructor.body : node);\r\n-            if (!constructor) {\r\n-                setEmitFlags(block, EmitFlags.NoComments);\r\n-            }\r\n+            setTextRange(block, constructor.body);\r\n \r\n             return block;\r\n         }\r\n@@ -1043,104 +1107,6 @@ namespace ts {\n             return false;\r\n         }\r\n \r\n-        /**\r\n-         * Declares a `_this` variable for derived classes and for when arrow functions capture `this`.\r\n-         *\r\n-         * @returns The new statement offset into the `statements` array.\r\n-         */\r\n-        function declareOrCaptureOrReturnThisForConstructorIfNeeded(\r\n-                    statements: Statement[],\r\n-                    ctor: ConstructorDeclaration | undefined,\r\n-                    isDerivedClass: boolean,\r\n-                    hasSynthesizedSuper: boolean,\r\n-                    statementOffset: number) {\r\n-            // If this isn't a derived class, just capture 'this' for arrow functions if necessary.\r\n-            if (!isDerivedClass) {\r\n-                if (ctor) {\r\n-                    addCaptureThisForNodeIfNeeded(statements, ctor);\r\n-                }\r\n-                return SuperCaptureResult.NoReplacement;\r\n-            }\r\n-\r\n-            // We must be here because the user didn't write a constructor\r\n-            // but we needed to call 'super(...args)' anyway as per 14.5.14 of the ES2016 spec.\r\n-            // If that's the case we can just immediately return the result of a 'super()' call.\r\n-            if (!ctor) {\r\n-                statements.push(createReturn(createDefaultSuperCallOrThis()));\r\n-                return SuperCaptureResult.ReplaceWithReturn;\r\n-            }\r\n-\r\n-            // The constructor exists, but it and the 'super()' call it contains were generated\r\n-            // for something like property initializers.\r\n-            // Create a captured '_this' variable and assume it will subsequently be used.\r\n-            if (hasSynthesizedSuper) {\r\n-                captureThisForNode(statements, ctor, createDefaultSuperCallOrThis());\r\n-                enableSubstitutionsForCapturedThis();\r\n-                return SuperCaptureResult.ReplaceSuperCapture;\r\n-            }\r\n-\r\n-            // Most of the time, a 'super' call will be the first real statement in a constructor body.\r\n-            // In these cases, we'd like to transform these into a *single* statement instead of a declaration\r\n-            // followed by an assignment statement for '_this'. For instance, if we emitted without an initializer,\r\n-            // we'd get:\r\n-            //\r\n-            //      var _this;\r\n-            //      _this = _super.call(...) || this;\r\n-            //\r\n-            // instead of\r\n-            //\r\n-            //      var _this = _super.call(...) || this;\r\n-            //\r\n-            // Additionally, if the 'super()' call is the last statement, we should just avoid capturing\r\n-            // entirely and immediately return the result like so:\r\n-            //\r\n-            //      return _super.call(...) || this;\r\n-            //\r\n-            let firstStatement: Statement | undefined;\r\n-            let superCallExpression: Expression | undefined;\r\n-\r\n-            const ctorStatements = ctor.body!.statements;\r\n-            if (statementOffset < ctorStatements.length) {\r\n-                firstStatement = ctorStatements[statementOffset];\r\n-\r\n-                if (firstStatement.kind === SyntaxKind.ExpressionStatement && isSuperCall((firstStatement as ExpressionStatement).expression)) {\r\n-                    superCallExpression = visitImmediateSuperCallInBody((firstStatement as ExpressionStatement).expression as CallExpression);\r\n-                }\r\n-            }\r\n-\r\n-            // Return the result if we have an immediate super() call on the last statement,\r\n-            // but only if the constructor itself doesn't use 'this' elsewhere.\r\n-            if (superCallExpression\r\n-                && statementOffset === ctorStatements.length - 1\r\n-                && !(ctor.transformFlags & (TransformFlags.ContainsLexicalThis | TransformFlags.ContainsCapturedLexicalThis))) {\r\n-                const returnStatement = createReturn(superCallExpression);\r\n-\r\n-                if (superCallExpression.kind !== SyntaxKind.BinaryExpression\r\n-                    || (superCallExpression as BinaryExpression).left.kind !== SyntaxKind.CallExpression) {\r\n-                    Debug.fail(\"Assumed generated super call would have form 'super.call(...) || this'.\");\r\n-                }\r\n-\r\n-                // Shift comments from the original super call to the return statement.\r\n-                setCommentRange(returnStatement, getCommentRange(\r\n-                    setEmitFlags(\r\n-                        (superCallExpression as BinaryExpression).left,\r\n-                        EmitFlags.NoComments)));\r\n-\r\n-                statements.push(returnStatement);\r\n-                return SuperCaptureResult.ReplaceWithReturn;\r\n-            }\r\n-\r\n-            // Perform the capture.\r\n-            captureThisForNode(statements, ctor, superCallExpression || createActualThis());\r\n-\r\n-            // If we're actually replacing the original statement, we need to signal this to the caller.\r\n-            if (superCallExpression) {\r\n-                return SuperCaptureResult.ReplaceSuperCapture;\r\n-            }\r\n-\r\n-            return SuperCaptureResult.NoReplacement;\r\n-        }\r\n-\r\n         function createActualThis() {\r\n             return setEmitFlags(createThis(), EmitFlags.NoSubstitution);\r\n         }\r\n@@ -1214,14 +1180,9 @@ namespace ts {\n             }\r\n         }\r\n \r\n-        /**\r\n-         * Gets a value indicating whether we need to add default value assignments for a\r\n-         * function-like node.\r\n-         *\r\n-         * @param node A function-like node.\r\n-         */\r\n-        function shouldAddDefaultValueAssignments(node: FunctionLikeDeclaration): boolean {\r\n-            return (node.transformFlags & TransformFlags.ContainsDefaultValueAssignments) !== 0;\r\n+        function hasDefaultValueOrBindingPattern(node: ParameterDeclaration) {\r\n+            return node.initializer !== undefined\r\n+                || isBindingPattern(node.name);\r\n         }\r\n \r\n         /**\r\n@@ -1231,11 +1192,12 @@ namespace ts {\n          * @param statements The statements for the new function body.\r\n          * @param node A function-like node.\r\n          */\r\n-        function addDefaultValueAssignmentsIfNeeded(statements: Statement[], node: FunctionLikeDeclaration): void {\r\n-            if (!shouldAddDefaultValueAssignments(node)) {\r\n-                return;\r\n+        function addDefaultValueAssignmentsIfNeeded(statements: Statement[], node: FunctionLikeDeclaration): boolean {\r\n+            if (!some(node.parameters, hasDefaultValueOrBindingPattern)) {\r\n+                return false;\r\n             }\r\n \r\n+            let added = false;\r\n             for (const parameter of node.parameters) {\r\n                 const { name, initializer, dotDotDotToken } = parameter;\r\n \r\n@@ -1246,12 +1208,14 @@ namespace ts {\n                 }\r\n \r\n                 if (isBindingPattern(name)) {\r\n-                    addDefaultValueAssignmentForBindingPattern(statements, parameter, name, initializer);\r\n+                    added = insertDefaultValueAssignmentForBindingPattern(statements, parameter, name, initializer) || added;\r\n                 }\r\n                 else if (initializer) {\r\n-                    addDefaultValueAssignmentForInitializer(statements, parameter, name, initializer);\r\n+                    insertDefaultValueAssignmentForInitializer(statements, parameter, name, initializer);\r\n+                    added = true;\r\n                 }\r\n             }\r\n+            return added;\r\n         }\r\n \r\n         /**\r\n@@ -1262,14 +1226,13 @@ namespace ts {\n          * @param name The name of the parameter.\r\n          * @param initializer The initializer for the parameter.\r\n          */\r\n-        function addDefaultValueAssignmentForBindingPattern(statements: Statement[], parameter: ParameterDeclaration, name: BindingPattern, initializer: Expression | undefined): void {\r\n-            const temp = getGeneratedNameForNode(parameter);\r\n-\r\n+        function insertDefaultValueAssignmentForBindingPattern(statements: Statement[], parameter: ParameterDeclaration, name: BindingPattern, initializer: Expression | undefined): boolean {\r\n             // In cases where a binding pattern is simply '[]' or '{}',\r\n             // we usually don't want to emit a var declaration; however, in the presence\r\n             // of an initializer, we must emit that expression to preserve side effects.\r\n             if (name.elements.length > 0) {\r\n-                statements.push(\r\n+                insertStatementAfterCustomPrologue(\r\n+                    statements,\r\n                     setEmitFlags(\r\n                         createVariableStatement(\r\n                             /*modifiers*/ undefined,\r\n@@ -1279,27 +1242,31 @@ namespace ts {\n                                     visitor,\r\n                                     context,\r\n                                     FlattenLevel.All,\r\n-                                    temp\r\n+                                    getGeneratedNameForNode(parameter)\r\n                                 )\r\n                             )\r\n                         ),\r\n                         EmitFlags.CustomPrologue\r\n                     )\r\n                 );\r\n+                return true;\r\n             }\r\n             else if (initializer) {\r\n-                statements.push(\r\n+                insertStatementAfterCustomPrologue(\r\n+                    statements,\r\n                     setEmitFlags(\r\n                         createExpressionStatement(\r\n                             createAssignment(\r\n-                                temp,\r\n+                                getGeneratedNameForNode(parameter),\r\n                                 visitNode(initializer, visitor, isExpression)\r\n                             )\r\n                         ),\r\n                         EmitFlags.CustomPrologue\r\n                     )\r\n                 );\r\n+                return true;\r\n             }\r\n+            return false;\r\n         }\r\n \r\n         /**\r\n@@ -1310,7 +1277,7 @@ namespace ts {\n          * @param name The name of the parameter.\r\n          * @param initializer The initializer for the parameter.\r\n          */\r\n-        function addDefaultValueAssignmentForInitializer(statements: Statement[], parameter: ParameterDeclaration, name: Identifier, initializer: Expression): void {\r\n+        function insertDefaultValueAssignmentForInitializer(statements: Statement[], parameter: ParameterDeclaration, name: Identifier, initializer: Expression): void {\r\n             initializer = visitNode(initializer, visitor, isExpression);\r\n             const statement = createIf(\r\n                 createTypeCheck(getSynthesizedClone(name), \"undefined\"),\r\n@@ -1339,7 +1306,7 @@ namespace ts {\n             startOnNewLine(statement);\r\n             setTextRange(statement, parameter);\r\n             setEmitFlags(statement, EmitFlags.NoTokenSourceMaps | EmitFlags.NoTrailingSourceMap | EmitFlags.CustomPrologue | EmitFlags.NoComments);\r\n-            statements.push(statement);\r\n+            insertStatementAfterCustomPrologue(statements, statement);\r\n         }\r\n \r\n         /**\r\n@@ -1363,10 +1330,11 @@ namespace ts {\n          *                                          part of a constructor declaration with a\r\n          *                                          synthesized call to `super`\r\n          */\r\n-        function addRestParameterIfNeeded(statements: Statement[], node: FunctionLikeDeclaration, inConstructorWithSynthesizedSuper: boolean): void {\r\n+        function addRestParameterIfNeeded(statements: Statement[], node: FunctionLikeDeclaration, inConstructorWithSynthesizedSuper: boolean): boolean {\r\n+            const prologueStatements: Statement[] = [];\r\n             const parameter = lastOrUndefined(node.parameters);\r\n             if (!shouldAddRestParameter(parameter, inConstructorWithSynthesizedSuper)) {\r\n-                return;\r\n+                return false;\r\n             }\r\n \r\n             // `declarationName` is the name of the local declaration for the parameter.\r\n@@ -1379,7 +1347,7 @@ namespace ts {\n             const temp = createLoopVariable();\r\n \r\n             // var param = [];\r\n-            statements.push(\r\n+            prologueStatements.push(\r\n                 setEmitFlags(\r\n                     setTextRange(\r\n                         createVariableStatement(\r\n@@ -1438,11 +1406,11 @@ namespace ts {\n \r\n             setEmitFlags(forStatement, EmitFlags.CustomPrologue);\r\n             startOnNewLine(forStatement);\r\n-            statements.push(forStatement);\r\n+            prologueStatements.push(forStatement);\r\n \r\n             if (parameter.name.kind !== SyntaxKind.Identifier) {\r\n                 // do the actual destructuring of the rest parameter if necessary\r\n-                statements.push(\r\n+                prologueStatements.push(\r\n                     setEmitFlags(\r\n                         setTextRange(\r\n                             createVariableStatement(\r\n@@ -1457,21 +1425,27 @@ namespace ts {\n                     )\r\n                 );\r\n             }\r\n+\r\n+            insertStatementsAfterCustomPrologue(statements, prologueStatements);\r\n+            return true;\r\n         }\r\n \r\n         /**\r\n          * Adds a statement to capture the `this` of a function declaration if it is needed.\r\n+         * NOTE: This must be executed *after* the subtree has been visited.\r\n          *\r\n          * @param statements The statements for the new function body.\r\n          * @param node A node.\r\n          */\r\n-        function addCaptureThisForNodeIfNeeded(statements: Statement[], node: Node): void {\r\n-            if (node.transformFlags & TransformFlags.ContainsCapturedLexicalThis && node.kind !== SyntaxKind.ArrowFunction) {\r\n-                captureThisForNode(statements, node, createThis());\r\n+        function insertCaptureThisForNodeIfNeeded(statements: Statement[], node: Node): boolean {\r\n+            if (hierarchyFacts & HierarchyFacts.CapturedLexicalThis && node.kind !== SyntaxKind.ArrowFunction) {\r\n+                insertCaptureThisForNode(statements, node, createThis());\r\n+                return true;\r\n             }\r\n+            return false;\r\n         }\r\n \r\n-        function captureThisForNode(statements: Statement[], node: Node, initializer: Expression | undefined): void {\r\n+        function insertCaptureThisForNode(statements: Statement[], node: Node, initializer: Expression | undefined): void {\r\n             enableSubstitutionsForCapturedThis();\r\n             const captureThisStatement = createVariableStatement(\r\n                 /*modifiers*/ undefined,\r\n@@ -1485,10 +1459,10 @@ namespace ts {\n             );\r\n             setEmitFlags(captureThisStatement, EmitFlags.NoComments | EmitFlags.CustomPrologue);\r\n             setSourceMapRange(captureThisStatement, node);\r\n-            statements.push(captureThisStatement);\r\n+            insertStatementAfterCustomPrologue(statements, captureThisStatement);\r\n         }\r\n \r\n-        function prependCaptureNewTargetIfNeeded(statements: Statement[], node: FunctionLikeDeclaration, copyOnWrite: boolean): Statement[] {\r\n+        function insertCaptureNewTargetIfNeeded(statements: Statement[], node: FunctionLikeDeclaration, copyOnWrite: boolean): Statement[] {\r\n             if (hierarchyFacts & HierarchyFacts.NewTarget) {\r\n                 let newTarget: Expression;\r\n                 switch (node.kind) {\r\n@@ -1548,11 +1522,13 @@ namespace ts {\n                     ])\r\n                 );\r\n \r\n+                setEmitFlags(captureNewTargetStatement, EmitFlags.NoComments | EmitFlags.CustomPrologue);\r\n+\r\n                 if (copyOnWrite) {\r\n-                    return [captureNewTargetStatement, ...statements];\r\n+                    statements = statements.slice();\r\n                 }\r\n \r\n-                statements.unshift(captureNewTargetStatement);\r\n+                insertStatementAfterCustomPrologue(statements, captureNewTargetStatement);\r\n             }\r\n \r\n             return statements;\r\n@@ -1612,7 +1588,6 @@ namespace ts {\n          * @param member The MethodDeclaration node.\r\n          */\r\n         function transformClassMethodDeclarationToStatement(receiver: LeftHandSideExpression, member: MethodDeclaration, container: Node) {\r\n-            const ancestorFacts = enterSubtree(HierarchyFacts.None, HierarchyFacts.None);\r\n             const commentRange = getCommentRange(member);\r\n             const sourceMapRange = getSourceMapRange(member);\r\n             const memberName = createMemberAccessForPropertyName(receiver, visitNode(member.name, visitor, isPropertyName), /*location*/ member.name);\r\n@@ -1634,8 +1609,6 @@ namespace ts {\n             // No source map should be emitted for this statement to align with the\r\n             // old emitter.\r\n             setEmitFlags(statement, EmitFlags.NoSourceMap);\r\n-\r\n-            exitSubtree(ancestorFacts, HierarchyFacts.PropagateNewTargetMask, hierarchyFacts & HierarchyFacts.PropagateNewTargetMask ? HierarchyFacts.NewTarget : HierarchyFacts.None);\r\n             return statement;\r\n         }\r\n \r\n@@ -1662,8 +1635,6 @@ namespace ts {\n          * @param receiver The receiver for the member.\r\n          */\r\n         function transformAccessorsToExpression(receiver: LeftHandSideExpression, { firstAccessor, getAccessor, setAccessor }: AllAccessorDeclarations, container: Node, startsOnNewLine: boolean): Expression {\r\n-            const ancestorFacts = enterSubtree(HierarchyFacts.None, HierarchyFacts.None);\r\n-\r\n             // To align with source maps in the old emitter, the receiver and property name\r\n             // arguments are both mapped contiguously to the accessor name.\r\n             const target = getMutableClone(receiver);\r\n@@ -1711,7 +1682,6 @@ namespace ts {\n                 startOnNewLine(call);\r\n             }\r\n \r\n-            exitSubtree(ancestorFacts, HierarchyFacts.PropagateNewTargetMask, hierarchyFacts & HierarchyFacts.PropagateNewTargetMask ? HierarchyFacts.NewTarget : HierarchyFacts.None);\r\n             return call;\r\n         }\r\n \r\n@@ -1722,8 +1692,9 @@ namespace ts {\n          */\r\n         function visitArrowFunction(node: ArrowFunction) {\r\n             if (node.transformFlags & TransformFlags.ContainsLexicalThis) {\r\n-                enableSubstitutionsForCapturedThis();\r\n+                hierarchyFacts |= HierarchyFacts.CapturedLexicalThis;\r\n             }\r\n+\r\n             const savedConvertedLoopState = convertedLoopState;\r\n             convertedLoopState = undefined;\r\n             const ancestorFacts = enterSubtree(HierarchyFacts.ArrowFunctionExcludes, HierarchyFacts.ArrowFunctionIncludes);\r\n@@ -1739,7 +1710,14 @@ namespace ts {\n             setTextRange(func, node);\r\n             setOriginalNode(func, node);\r\n             setEmitFlags(func, EmitFlags.CapturesThis);\r\n-            exitSubtree(ancestorFacts, HierarchyFacts.None, HierarchyFacts.None);\r\n+\r\n+            if (hierarchyFacts & HierarchyFacts.CapturedLexicalThis) {\r\n+                enableSubstitutionsForCapturedThis();\r\n+            }\r\n+\r\n+            // If an arrow function contains\r\n+            exitSubtree(ancestorFacts, HierarchyFacts.ArrowFunctionSubtreeExcludes, HierarchyFacts.None);\r\n+\r\n             convertedLoopState = savedConvertedLoopState;\r\n             return func;\r\n         }\r\n@@ -1757,14 +1735,12 @@ namespace ts {\n             convertedLoopState = undefined;\r\n \r\n             const parameters = visitParameterList(node.parameters, visitor, context);\r\n-            const body = node.transformFlags & TransformFlags.ES2015\r\n-                ? transformFunctionBody(node)\r\n-                : visitFunctionBodyDownLevel(node);\r\n+            const body = transformFunctionBody(node);\r\n             const name = hierarchyFacts & HierarchyFacts.NewTarget\r\n                 ? getLocalName(node)\r\n                 : node.name;\r\n \r\n-            exitSubtree(ancestorFacts, HierarchyFacts.PropagateNewTargetMask, HierarchyFacts.None);\r\n+            exitSubtree(ancestorFacts, HierarchyFacts.FunctionSubtreeExcludes, HierarchyFacts.None);\r\n             convertedLoopState = savedConvertedLoopState;\r\n             return updateFunctionExpression(\r\n                 node,\r\n@@ -1788,14 +1764,12 @@ namespace ts {\n             convertedLoopState = undefined;\r\n             const ancestorFacts = enterSubtree(HierarchyFacts.FunctionExcludes, HierarchyFacts.FunctionIncludes);\r\n             const parameters = visitParameterList(node.parameters, visitor, context);\r\n-            const body = node.transformFlags & TransformFlags.ES2015\r\n-                ? transformFunctionBody(node)\r\n-                : visitFunctionBodyDownLevel(node);\r\n+            const body = transformFunctionBody(node);\r\n             const name = hierarchyFacts & HierarchyFacts.NewTarget\r\n                 ? getLocalName(node)\r\n                 : node.name;\r\n \r\n-            exitSubtree(ancestorFacts, HierarchyFacts.PropagateNewTargetMask, HierarchyFacts.None);\r\n+            exitSubtree(ancestorFacts, HierarchyFacts.FunctionSubtreeExcludes, HierarchyFacts.None);\r\n             convertedLoopState = savedConvertedLoopState;\r\n             return updateFunctionDeclaration(\r\n                 node,\r\n@@ -1829,7 +1803,7 @@ namespace ts {\n                 name = getGeneratedNameForNode(node);\r\n             }\r\n \r\n-            exitSubtree(ancestorFacts, HierarchyFacts.PropagateNewTargetMask, HierarchyFacts.None);\r\n+            exitSubtree(ancestorFacts, HierarchyFacts.FunctionSubtreeExcludes, HierarchyFacts.None);\r\n             convertedLoopState = savedConvertedLoopState;\r\n             return setOriginalNode(\r\n                 setTextRange(\r\n@@ -1859,7 +1833,7 @@ namespace ts {\n             let statementsLocation: TextRange;\r\n             let closeBraceLocation: TextRange | undefined;\r\n \r\n-            const leadingStatements: Statement[] = [];\r\n+            const prologue: Statement[] = [];\r\n             const statements: Statement[] = [];\r\n             const body = node.body!;\r\n             let statementOffset: number | undefined;\r\n@@ -1868,16 +1842,15 @@ namespace ts {\n             if (isBlock(body)) {\r\n                 // ensureUseStrict is false because no new prologue-directive should be added.\r\n                 // addStandardPrologue will put already-existing directives at the beginning of the target statement-array\r\n-                statementOffset = addStandardPrologue(leadingStatements, body.statements, /*ensureUseStrict*/ false);\r\n+                statementOffset = addStandardPrologue(prologue, body.statements, /*ensureUseStrict*/ false);\r\n             }\r\n \r\n-            addCaptureThisForNodeIfNeeded(leadingStatements, node);\r\n-            addDefaultValueAssignmentsIfNeeded(leadingStatements, node);\r\n-            addRestParameterIfNeeded(leadingStatements, node, /*inConstructorWithSynthesizedSuper*/ false);\r\n+            multiLine = addDefaultValueAssignmentsIfNeeded(statements, node) || multiLine;\r\n+            multiLine = addRestParameterIfNeeded(statements, node, /*inConstructorWithSynthesizedSuper*/ false) || multiLine;\r\n \r\n             if (isBlock(body)) {\r\n                 // addCustomPrologue puts already-existing directives at the beginning of the target statement-array\r\n-                statementOffset = addCustomPrologue(leadingStatements, body.statements, statementOffset, visitor);\r\n+                statementOffset = addCustomPrologue(statements, body.statements, statementOffset, visitor);\r\n \r\n                 statementsLocation = body.statements;\r\n                 addRange(statements, visitNodes(body.statements, visitor, isStatement, statementOffset));\r\n@@ -1918,16 +1891,22 @@ namespace ts {\n                 closeBraceLocation = body;\r\n             }\r\n \r\n-            const lexicalEnvironment = context.endLexicalEnvironment();\r\n-            addStatementsAfterPrologue(statements, lexicalEnvironment);\r\n-            prependCaptureNewTargetIfNeeded(statements, node, /*copyOnWrite*/ false);\r\n+            mergeLexicalEnvironment(prologue, endLexicalEnvironment());\r\n+            insertCaptureNewTargetIfNeeded(prologue, node, /*copyOnWrite*/ false);\r\n+            insertCaptureThisForNodeIfNeeded(prologue, node);\r\n \r\n             // If we added any final generated statements, this must be a multi-line block\r\n-            if (some(leadingStatements) || some(lexicalEnvironment)) {\r\n+            if (some(prologue)) {\r\n                 multiLine = true;\r\n             }\r\n \r\n-            const block = createBlock(setTextRange(createNodeArray([...leadingStatements, ...statements]), statementsLocation), multiLine);\r\n+            statements.unshift(...prologue);\r\n+            if (isBlock(body) && arrayIsEqualTo(statements, body.statements)) {\r\n+                // no changes were made, preserve the tree\r\n+                return body;\r\n+            }\r\n+\r\n+            const block = createBlock(setTextRange(createNodeArray(statements), statementsLocation), multiLine);\r\n             setTextRange(block, node.body);\r\n             if (!multiLine && singleLine) {\r\n                 setEmitFlags(block, EmitFlags.SingleLine);\r\n@@ -1941,19 +1920,6 @@ namespace ts {\n             return block;\r\n         }\r\n \r\n-        function visitFunctionBodyDownLevel(node: FunctionDeclaration | FunctionExpression | AccessorDeclaration) {\r\n-            const updated = visitFunctionBody(node.body, functionBodyVisitor, context)!;\r\n-            return updateBlock(\r\n-                updated,\r\n-                setTextRange(\r\n-                    createNodeArray(\r\n-                        prependCaptureNewTargetIfNeeded(updated.statements as MutableNodeArray<Statement>, node, /*copyOnWrite*/ true)\r\n-                    ),\r\n-                    /*location*/ updated.statements\r\n-                )\r\n-            );\r\n-        }\r\n-\r\n         function visitBlock(node: Block, isFunctionBody: boolean): Block {\r\n             if (isFunctionBody) {\r\n                 // A function body is not a block scope.\r\n@@ -2074,7 +2040,7 @@ namespace ts {\n          * @param node A VariableDeclarationList node.\r\n          */\r\n         function visitVariableDeclarationList(node: VariableDeclarationList): VariableDeclarationList {\r\n-            if (node.transformFlags & TransformFlags.ES2015) {\r\n+            if (node.flags & NodeFlags.BlockScoped || node.transformFlags & TransformFlags.ContainsBindingPattern) {\r\n                 if (node.flags & NodeFlags.BlockScoped) {\r\n                     enableSubstitutionsForBlockScopedBindings();\r\n                 }\r\n@@ -3104,7 +3070,7 @@ namespace ts {\n             }\r\n \r\n             copyOutParameters(currentState.loopOutParameters, LoopOutParameterFlags.Body, CopyDirection.ToOutParameter, statements);\r\n-            addStatementsAfterPrologue(statements, lexicalEnvironment);\r\n+            insertStatementsAfterStandardPrologue(statements, lexicalEnvironment);\r\n \r\n             const loopBody = createBlock(statements, /*multiLine*/ true);\r\n             if (isBlock(statement)) setOriginalNode(loopBody, statement);\r\n@@ -3426,7 +3392,6 @@ namespace ts {\n          * @param receiver The receiver for the assignment.\r\n          */\r\n         function transformObjectLiteralMethodDeclarationToExpression(method: MethodDeclaration, receiver: Expression, container: Node, startsOnNewLine: boolean) {\r\n-            const ancestorFacts = enterSubtree(HierarchyFacts.None, HierarchyFacts.None);\r\n             const expression = createAssignment(\r\n                 createMemberAccessForPropertyName(\r\n                     receiver,\r\n@@ -3438,7 +3403,6 @@ namespace ts {\n             if (startsOnNewLine) {\r\n                 startOnNewLine(expression);\r\n             }\r\n-            exitSubtree(ancestorFacts, HierarchyFacts.PropagateNewTargetMask, hierarchyFacts & HierarchyFacts.PropagateNewTargetMask ? HierarchyFacts.NewTarget : HierarchyFacts.None);\r\n             return expression;\r\n         }\r\n \r\n@@ -3509,16 +3473,14 @@ namespace ts {\n             const ancestorFacts = enterSubtree(HierarchyFacts.FunctionExcludes, HierarchyFacts.FunctionIncludes);\r\n             let updated: AccessorDeclaration;\r\n             const parameters = visitParameterList(node.parameters, visitor, context);\r\n-            const body = node.transformFlags & (TransformFlags.ContainsCapturedLexicalThis | TransformFlags.ContainsES2015)\r\n-                ? transformFunctionBody(node)\r\n-                : visitFunctionBodyDownLevel(node);\r\n+            const body = transformFunctionBody(node);\r\n             if (node.kind === SyntaxKind.GetAccessor) {\r\n                 updated = updateGetAccessor(node, node.decorators, node.modifiers, node.name, parameters, node.type, body);\r\n             }\r\n             else {\r\n                 updated = updateSetAccessor(node, node.decorators, node.modifiers, node.name, parameters, body);\r\n             }\r\n-            exitSubtree(ancestorFacts, HierarchyFacts.PropagateNewTargetMask, HierarchyFacts.None);\r\n+            exitSubtree(ancestorFacts, HierarchyFacts.FunctionSubtreeExcludes, HierarchyFacts.None);\r\n             convertedLoopState = savedConvertedLoopState;\r\n             return updated;\r\n         }\r\n@@ -3539,10 +3501,7 @@ namespace ts {\n         }\r\n \r\n         function visitComputedPropertyName(node: ComputedPropertyName) {\r\n-            const ancestorFacts = enterSubtree(HierarchyFacts.ComputedPropertyNameExcludes, HierarchyFacts.ComputedPropertyNameIncludes);\r\n-            const updated = visitEachChild(node, visitor, context);\r\n-            exitSubtree(ancestorFacts, HierarchyFacts.PropagateNewTargetMask, hierarchyFacts & HierarchyFacts.PropagateNewTargetMask ? HierarchyFacts.NewTargetInComputedPropertyName : HierarchyFacts.None);\r\n-            return updated;\r\n+            return visitEachChild(node, visitor, context);\r\n         }\r\n \r\n         /**\r\n@@ -3561,7 +3520,7 @@ namespace ts {\n          * @param node An ArrayLiteralExpression node.\r\n          */\r\n         function visitArrayLiteralExpression(node: ArrayLiteralExpression): Expression {\r\n-            if (node.transformFlags & TransformFlags.ES2015) {\r\n+            if (some(node.elements, isSpreadElement)) {\r\n                 // We are here because we contain a SpreadElementExpression.\r\n                 return transformAndSpreadElements(node.elements, /*needsUniqueCopy*/ true, !!node.multiLine, /*hasTrailingComma*/ !!node.elements.hasTrailingComma);\r\n             }\r\n@@ -3578,7 +3537,10 @@ namespace ts {\n                 return visitTypeScriptClassWrapper(node);\r\n             }\r\n \r\n-            if (node.transformFlags & TransformFlags.ES2015) {\r\n+            const expression = skipOuterExpressions(node.expression);\r\n+            if (expression.kind === SyntaxKind.SuperKeyword ||\r\n+                isSuperProperty(expression) ||\r\n+                some(node.arguments, isSpreadElement)) {\r\n                 return visitCallExpressionWithPotentialCapturedThisAssignment(node, /*assignToCapturedThis*/ true);\r\n             }\r\n \r\n@@ -3774,7 +3736,7 @@ namespace ts {\n \r\n                     resultingCall = createFunctionApply(\r\n                         visitNode(target, callExpressionVisitor, isExpression),\r\n-                        visitNode(thisArg, visitor, isExpression),\r\n+                        node.expression.kind === SyntaxKind.SuperKeyword ? thisArg : visitNode(thisArg, visitor, isExpression),\r\n                         transformAndSpreadElements(node.arguments, /*needsUniqueCopy*/ false, /*multiLine*/ false, /*hasTrailingComma*/ false)\r\n                     );\r\n                 }\r\n@@ -3790,19 +3752,17 @@ namespace ts {\n                     //      _super.prototype.m.call(this, a)\r\n                     resultingCall = createFunctionCall(\r\n                         visitNode(target, callExpressionVisitor, isExpression),\r\n-                        visitNode(thisArg, visitor, isExpression),\r\n+                        node.expression.kind === SyntaxKind.SuperKeyword ? thisArg : visitNode(thisArg, visitor, isExpression),\r\n                         visitNodes(node.arguments, visitor, isExpression),\r\n                         /*location*/ node\r\n                     );\r\n                 }\r\n \r\n                 if (node.expression.kind === SyntaxKind.SuperKeyword) {\r\n-                    const actualThis = createThis();\r\n-                    setEmitFlags(actualThis, EmitFlags.NoSubstitution);\r\n                     const initializer =\r\n                         createLogicalOr(\r\n                             resultingCall,\r\n-                            actualThis\r\n+                            createActualThis()\r\n                         );\r\n                     resultingCall = assignToCapturedThis\r\n                         ? createAssignment(createFileLevelUniqueName(\"_this\"), initializer)\r\n@@ -3820,7 +3780,7 @@ namespace ts {\n          * @param node A NewExpression node.\r\n          */\r\n         function visitNewExpression(node: NewExpression): LeftHandSideExpression {\r\n-            if (node.transformFlags & TransformFlags.ContainsRestOrSpread) {\r\n+            if (some(node.arguments, isSpreadElement)) {\r\n                 // We are here because we contain a SpreadElementExpression.\r\n                 // [source]\r\n                 //      new C(...a)\r\n@@ -4132,12 +4092,7 @@ namespace ts {\n \r\n         function visitMetaProperty(node: MetaProperty) {\r\n             if (node.keywordToken === SyntaxKind.NewKeyword && node.name.escapedText === \"target\") {\r\n-                if (hierarchyFacts & HierarchyFacts.ComputedPropertyName) {\r\n-                    hierarchyFacts |= HierarchyFacts.NewTargetInComputedPropertyName;\r\n-                }\r\n-                else {\r\n-                    hierarchyFacts |= HierarchyFacts.NewTarget;\r\n-                }\r\n+                hierarchyFacts |= HierarchyFacts.NewTarget;\r\n                 return createFileLevelUniqueName(\"_newTarget\");\r\n             }\r\n             return node;\r"},{"sha":"c1e586085cffbf6e8fb3a4970f96c9b3be8fad73","filename":"src/compiler/transformers/es2017.ts","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Ftransformers%2Fes2017.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Ftransformers%2Fes2017.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ftransformers%2Fes2017.ts?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -438,7 +438,7 @@ namespace ts {\n                     )\r\n                 );\r\n \r\n-                addStatementsAfterPrologue(statements, endLexicalEnvironment());\r\n+                insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());\r\n \r\n                 // Minor optimization, emit `_super` helper to capture `super` access in an arrow.\r\n                 // This step isn't needed if we eventually transform this to ES5.\r\n@@ -448,7 +448,7 @@ namespace ts {\n                     enableSubstitutionForAsyncMethodsWithSuper();\r\n                     const variableStatement = createSuperAccessVariableStatement(resolver, node, capturedSuperProperties);\r\n                     substitutedSuperAccessors[getNodeId(variableStatement)] = true;\r\n-                    addStatementsAfterPrologue(statements, [variableStatement]);\r\n+                    insertStatementsAfterStandardPrologue(statements, [variableStatement]);\r\n                 }\r\n \r\n                 const block = createBlock(statements, /*multiLine*/ true);\r"},{"sha":"77fa79c6c450a74b4f54d86b55f45e4aecdda66e","filename":"src/compiler/transformers/es2018.ts","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Ftransformers%2Fes2018.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Ftransformers%2Fes2018.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ftransformers%2Fes2018.ts?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -689,12 +689,12 @@ namespace ts {\n                 enableSubstitutionForAsyncMethodsWithSuper();\r\n                 const variableStatement = createSuperAccessVariableStatement(resolver, node, capturedSuperProperties);\r\n                 substitutedSuperAccessors[getNodeId(variableStatement)] = true;\r\n-                addStatementsAfterPrologue(statements, [variableStatement]);\r\n+                insertStatementsAfterStandardPrologue(statements, [variableStatement]);\r\n             }\r\n \r\n             statements.push(returnStatement);\r\n \r\n-            addStatementsAfterPrologue(statements, endLexicalEnvironment());\r\n+            insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());\r\n             const block = updateBlock(node.body!, statements);\r\n \r\n             if (emitSuperHelpers && hasSuperElementAccess) {\r\n@@ -726,7 +726,7 @@ namespace ts {\n             const leadingStatements = endLexicalEnvironment();\r\n             if (statementOffset > 0 || some(statements) || some(leadingStatements)) {\r\n                 const block = convertToFunctionBody(body, /*multiLine*/ true);\r\n-                addStatementsAfterPrologue(statements, leadingStatements);\r\n+                insertStatementsAfterStandardPrologue(statements, leadingStatements);\r\n                 addRange(statements, block.statements.slice(statementOffset));\r\n                 return updateBlock(block, setTextRange(createNodeArray(statements), block.statements));\r\n             }\r"},{"sha":"97cc1d5b06216b610f9769c56de06ac70cde70bd","filename":"src/compiler/transformers/generators.ts","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Ftransformers%2Fgenerators.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Ftransformers%2Fgenerators.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ftransformers%2Fgenerators.ts?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -316,7 +316,7 @@ namespace ts {\n             else if (inGeneratorFunctionBody) {\r\n                 return visitJavaScriptInGeneratorFunctionBody(node);\r\n             }\r\n-            else if (transformFlags & TransformFlags.Generator) {\r\n+            else if (isFunctionLikeDeclaration(node) && node.asteriskToken) {\r\n                 return visitGenerator(node);\r\n             }\r\n             else if (transformFlags & TransformFlags.ContainsGenerator) {\r\n@@ -587,7 +587,7 @@ namespace ts {\n             transformAndEmitStatements(body.statements, statementOffset);\r\n \r\n             const buildResult = build();\r\n-            addStatementsAfterPrologue(statements, endLexicalEnvironment());\r\n+            insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());\r\n             statements.push(createReturn(buildResult));\r\n \r\n             // Restore previous generator state\r"},{"sha":"621012ebc3b6f0b9eec3707a6608cd6969723f84","filename":"src/compiler/transformers/module/module.ts","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Ftransformers%2Fmodule%2Fmodule.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Ftransformers%2Fmodule%2Fmodule.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ftransformers%2Fmodule%2Fmodule.ts?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -100,7 +100,7 @@ namespace ts {\n             append(statements, visitNode(currentModuleInfo.externalHelpersImportDeclaration, sourceElementVisitor, isStatement));\r\n             addRange(statements, visitNodes(node.statements, sourceElementVisitor, isStatement, statementOffset));\r\n             addExportEqualsIfNeeded(statements, /*emitAsReturn*/ false);\r\n-            addStatementsAfterPrologue(statements, endLexicalEnvironment());\r\n+            insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());\r\n \r\n             const updated = updateSourceFileNode(node, setTextRange(createNodeArray(statements), node.statements));\r\n             if (currentModuleInfo.hasExportStarsToExportValues && !compilerOptions.importHelpers) {\r\n@@ -432,7 +432,7 @@ namespace ts {\n \r\n             // End the lexical environment for the module body\r\n             // and merge any new lexical declarations.\r\n-            addStatementsAfterPrologue(statements, endLexicalEnvironment());\r\n+            insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());\r\n \r\n             const body = createBlock(statements, /*multiLine*/ true);\r\n             if (currentModuleInfo.hasExportStarsToExportValues && !compilerOptions.importHelpers) {\r\n@@ -537,8 +537,8 @@ namespace ts {\n             if (isImportCall(node)) {\r\n                 return visitImportCallExpression(node);\r\n             }\r\n-            else if (node.transformFlags & TransformFlags.DestructuringAssignment && isBinaryExpression(node)) {\r\n-                return visitDestructuringAssignment(node as DestructuringAssignment);\r\n+            else if (isDestructuringAssignment(node)) {\r\n+                return visitDestructuringAssignment(node);\r\n             }\r\n             else {\r\n                 return visitEachChild(node, moduleExpressionElementVisitor, context);\r"},{"sha":"ae303440bc1556ba7b0840af0003bf26136e0021","filename":"src/compiler/transformers/module/system.ts","status":"modified","additions":3,"deletions":4,"changes":7,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Ftransformers%2Fmodule%2Fsystem.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Ftransformers%2Fmodule%2Fsystem.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ftransformers%2Fmodule%2Fsystem.ts?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -257,7 +257,7 @@ namespace ts {\n             // We emit hoisted variables early to align roughly with our previous emit output.\r\n             // Two key differences in this approach are:\r\n             // - Temporary variables will appear at the top rather than at the bottom of the file\r\n-            addStatementsAfterPrologue(statements, endLexicalEnvironment());\r\n+            insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());\r\n \r\n             const exportStarFunction = addExportStarIfNeeded(statements)!; // TODO: GH#18217\r\n             const moduleObject = createObjectLiteral([\r\n@@ -1463,9 +1463,8 @@ namespace ts {\n          * @param node The node to visit.\r\n          */\r\n         function destructuringAndImportCallVisitor(node: Node): VisitResult<Node> {\r\n-            if (node.transformFlags & TransformFlags.DestructuringAssignment\r\n-                && node.kind === SyntaxKind.BinaryExpression) {\r\n-                return visitDestructuringAssignment(<DestructuringAssignment>node);\r\n+            if (isDestructuringAssignment(node)) {\r\n+                return visitDestructuringAssignment(node);\r\n             }\r\n             else if (isImportCall(node)) {\r\n                 return visitImportCallExpression(node);\r"},{"sha":"5774ff8d0fc728731ab03c43a3c87077c37752b3","filename":"src/compiler/transformers/ts.ts","status":"modified","additions":47,"deletions":140,"changes":187,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Ftransformers%2Fts.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Ftransformers%2Fts.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ftransformers%2Fts.ts?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -208,15 +208,9 @@ namespace ts {\n          * @param node The node to visit.\r\n          */\r\n         function visitorWorker(node: Node): VisitResult<Node> {\r\n-            if (node.transformFlags & TransformFlags.TypeScript) {\r\n-                // This node is explicitly marked as TypeScript, so we should transform the node.\r\n+            if (node.transformFlags & TransformFlags.ContainsTypeScript) {\r\n                 return visitTypeScript(node);\r\n             }\r\n-            else if (node.transformFlags & TransformFlags.ContainsTypeScript) {\r\n-                // This node contains TypeScript, so we should visit its children.\r\n-                return visitEachChild(node, visitor, context);\r\n-            }\r\n-\r\n             return node;\r\n         }\r\n \r\n@@ -296,15 +290,9 @@ namespace ts {\n                  (<ImportEqualsDeclaration>node).moduleReference.kind === SyntaxKind.ExternalModuleReference)) {\r\n                 // do not emit ES6 imports and exports since they are illegal inside a namespace\r\n                 return undefined;\r\n-           }\r\n-           else if (node.transformFlags & TransformFlags.TypeScript || hasModifier(node, ModifierFlags.Export)) {\r\n-                // This node is explicitly marked as TypeScript, or is exported at the namespace\r\n-                // level, so we should transform the node.\r\n-                return visitTypeScript(node);\r\n             }\r\n-            else if (node.transformFlags & TransformFlags.ContainsTypeScript) {\r\n-                // This node contains TypeScript, so we should visit its children.\r\n-                return visitEachChild(node, visitor, context);\r\n+            else if (node.transformFlags & TransformFlags.ContainsTypeScript || hasModifier(node, ModifierFlags.Export)) {\r\n+                return visitTypeScript(node);\r\n             }\r\n \r\n             return node;\r\n@@ -365,7 +353,7 @@ namespace ts {\n          * @param node The node to visit.\r\n          */\r\n         function visitTypeScript(node: Node): VisitResult<Node> {\r\n-            if (hasModifier(node, ModifierFlags.Ambient) && isStatement(node)) {\r\n+            if (isStatement(node) && hasModifier(node, ModifierFlags.Ambient)) {\r\n                 // TypeScript ambient declarations are elided, but some comments may be preserved.\r\n                 // See the implementation of `getLeadingComments` in comments.ts for more details.\r\n                 return createNotEmittedStatement(node);\r\n@@ -443,7 +431,7 @@ namespace ts {\n                     return createNotEmittedStatement(node);\r\n \r\n                 case SyntaxKind.ClassDeclaration:\r\n-                    // This is a class declaration with TypeScript syntax extensions.\r\n+                    // This may be a class declaration with TypeScript syntax extensions.\r\n                     //\r\n                     // TypeScript class syntax extensions include:\r\n                     // - decorators\r\n@@ -455,7 +443,7 @@ namespace ts {\n                     return visitClassDeclaration(<ClassDeclaration>node);\r\n \r\n                 case SyntaxKind.ClassExpression:\r\n-                    // This is a class expression with TypeScript syntax extensions.\r\n+                    // This may be a class expression with TypeScript syntax extensions.\r\n                     //\r\n                     // TypeScript class syntax extensions include:\r\n                     // - decorators\r\n@@ -467,7 +455,7 @@ namespace ts {\n                     return visitClassExpression(<ClassExpression>node);\r\n \r\n                 case SyntaxKind.HeritageClause:\r\n-                    // This is a heritage clause with TypeScript syntax extensions.\r\n+                    // This may be a heritage clause with TypeScript syntax extensions.\r\n                     //\r\n                     // TypeScript heritage clause extensions include:\r\n                     // - `implements` clause\r\n@@ -503,7 +491,7 @@ namespace ts {\n                     return visitArrowFunction(<ArrowFunction>node);\r\n \r\n                 case SyntaxKind.Parameter:\r\n-                    // This is a parameter declaration with TypeScript syntax extensions.\r\n+                    // This may be a parameter declaration with TypeScript syntax extensions.\r\n                     //\r\n                     // TypeScript parameter declaration syntax extensions include:\r\n                     // - decorators\r\n@@ -556,7 +544,8 @@ namespace ts {\n                     return visitImportEqualsDeclaration(<ImportEqualsDeclaration>node);\r\n \r\n                 default:\r\n-                    return Debug.failBadSyntaxKind(node);\r\n+                    // node contains some other TypeScript syntax\r\n+                    return visitEachChild(node, visitor, context);\r\n             }\r\n         }\r\n \r\n@@ -607,18 +596,22 @@ namespace ts {\n             return facts;\r\n         }\r\n \r\n-        /**\r\n-         * Transforms a class declaration with TypeScript syntax into compatible ES6.\r\n-         *\r\n-         * This function will only be called when one of the following conditions are met:\r\n-         * - The class has decorators.\r\n-         * - The class has property declarations with initializers.\r\n-         * - The class contains a constructor that contains parameters with accessibility modifiers.\r\n-         * - The class is an export in a TypeScript namespace.\r\n-         *\r\n-         * @param node The node to transform.\r\n-         */\r\n+        function hasTypeScriptClassSyntax(node: Node) {\r\n+            return !!(node.transformFlags & TransformFlags.ContainsTypeScriptClassSyntax);\r\n+        }\r\n+\r\n+        function isClassLikeDeclarationWithTypeScriptSyntax(node: ClassLikeDeclaration) {\r\n+            return some(node.decorators)\r\n+                || some(node.typeParameters)\r\n+                || some(node.heritageClauses, hasTypeScriptClassSyntax)\r\n+                || some(node.members, hasTypeScriptClassSyntax);\r\n+        }\r\n+\r\n         function visitClassDeclaration(node: ClassDeclaration): VisitResult<Statement> {\r\n+            if (!isClassLikeDeclarationWithTypeScriptSyntax(node) && !(currentNamespace && hasModifier(node, ModifierFlags.Export))) {\r\n+                return visitEachChild(node, visitor, context);\r\n+            }\r\n+\r\n             const savedPendingExpressions = pendingExpressions;\r\n             pendingExpressions = undefined;\r\n \r\n@@ -682,7 +675,7 @@ namespace ts {\n                 setEmitFlags(statement, EmitFlags.NoComments | EmitFlags.NoTokenSourceMaps);\r\n                 statements.push(statement);\r\n \r\n-                addStatementsAfterPrologue(statements, context.endLexicalEnvironment());\r\n+                insertStatementsAfterStandardPrologue(statements, context.endLexicalEnvironment());\r\n \r\n                 const iife = createImmediatelyInvokedArrowFunction(statements);\r\n                 setEmitFlags(iife, EmitFlags.TypeScriptClassWrapper);\r\n@@ -890,16 +883,11 @@ namespace ts {\n             return statement;\r\n         }\r\n \r\n-        /**\r\n-         * Transforms a class expression with TypeScript syntax into compatible ES6.\r\n-         *\r\n-         * This function will only be called when one of the following conditions are met:\r\n-         * - The class has property declarations with initializers.\r\n-         * - The class contains a constructor that contains parameters with accessibility modifiers.\r\n-         *\r\n-         * @param node The node to transform.\r\n-         */\r\n         function visitClassExpression(node: ClassExpression): Expression {\r\n+            if (!isClassLikeDeclarationWithTypeScriptSyntax(node)) {\r\n+                return visitEachChild(node, visitor, context);\r\n+            }\r\n+\r\n             const savedPendingExpressions = pendingExpressions;\r\n             pendingExpressions = undefined;\r\n \r\n@@ -2237,18 +2225,11 @@ namespace ts {\n          * @param node The HeritageClause to transform.\r\n          */\r\n         function visitHeritageClause(node: HeritageClause): HeritageClause | undefined {\r\n-            if (node.token === SyntaxKind.ExtendsKeyword) {\r\n-                const types = visitNodes(node.types, visitor, isExpressionWithTypeArguments, 0, 1);\r\n-                return setTextRange(\r\n-                    createHeritageClause(\r\n-                        SyntaxKind.ExtendsKeyword,\r\n-                        types\r\n-                    ),\r\n-                    node\r\n-                );\r\n+            if (node.token === SyntaxKind.ImplementsKeyword) {\r\n+                // implements clauses are elided\r\n+                return undefined;\r\n             }\r\n-\r\n-            return undefined;\r\n+            return visitEachChild(node, visitor, context);\r\n         }\r\n \r\n         /**\r\n@@ -2299,16 +2280,6 @@ namespace ts {\n             );\r\n         }\r\n \r\n-        /**\r\n-         * Visits a method declaration of a class.\r\n-         *\r\n-         * This function will be called when one of the following conditions are met:\r\n-         * - The node is an overload\r\n-         * - The node is marked as abstract, public, private, protected, or readonly\r\n-         * - The node has a computed property name\r\n-         *\r\n-         * @param node The method node.\r\n-         */\r\n         function visitMethodDeclaration(node: MethodDeclaration) {\r\n             if (!shouldEmitFunctionLikeDeclaration(node)) {\r\n                 return undefined;\r\n@@ -2344,15 +2315,6 @@ namespace ts {\n             return !(nodeIsMissing(node.body) && hasModifier(node, ModifierFlags.Abstract));\r\n         }\r\n \r\n-        /**\r\n-         * Visits a get accessor declaration of a class.\r\n-         *\r\n-         * This function will be called when one of the following conditions are met:\r\n-         * - The node is marked as abstract, public, private, or protected\r\n-         * - The node has a computed property name\r\n-         *\r\n-         * @param node The get accessor node.\r\n-         */\r\n         function visitGetAccessor(node: GetAccessorDeclaration) {\r\n             if (!shouldEmitAccessorDeclaration(node)) {\r\n                 return undefined;\r\n@@ -2375,15 +2337,6 @@ namespace ts {\n             return updated;\r\n         }\r\n \r\n-        /**\r\n-         * Visits a set accessor declaration of a class.\r\n-         *\r\n-         * This function will be called when one of the following conditions are met:\r\n-         * - The node is marked as abstract, public, private, or protected\r\n-         * - The node has a computed property name\r\n-         *\r\n-         * @param node The set accessor node.\r\n-         */\r\n         function visitSetAccessor(node: SetAccessorDeclaration) {\r\n             if (!shouldEmitAccessorDeclaration(node)) {\r\n                 return undefined;\r\n@@ -2405,16 +2358,6 @@ namespace ts {\n             return updated;\r\n         }\r\n \r\n-        /**\r\n-         * Visits a function declaration.\r\n-         *\r\n-         * This function will be called when one of the following conditions are met:\r\n-         * - The node is an overload\r\n-         * - The node is exported from a TypeScript namespace\r\n-         * - The node has decorators\r\n-         *\r\n-         * @param node The function node.\r\n-         */\r\n         function visitFunctionDeclaration(node: FunctionDeclaration): VisitResult<Statement> {\r\n             if (!shouldEmitFunctionLikeDeclaration(node)) {\r\n                 return createNotEmittedStatement(node);\r\n@@ -2438,14 +2381,6 @@ namespace ts {\n             return updated;\r\n         }\r\n \r\n-        /**\r\n-         * Visits a function expression node.\r\n-         *\r\n-         * This function will be called when one of the following conditions are met:\r\n-         * - The node has type annotations\r\n-         *\r\n-         * @param node The function expression node.\r\n-         */\r\n         function visitFunctionExpression(node: FunctionExpression): Expression {\r\n             if (!shouldEmitFunctionLikeDeclaration(node)) {\r\n                 return createOmittedExpression();\r\n@@ -2463,11 +2398,6 @@ namespace ts {\n             return updated;\r\n         }\r\n \r\n-        /**\r\n-         * @remarks\r\n-         * This function will be called when one of the following conditions are met:\r\n-         * - The node has type annotations\r\n-         */\r\n         function visitArrowFunction(node: ArrowFunction) {\r\n             const updated = updateArrowFunction(\r\n                 node,\r\n@@ -2481,22 +2411,12 @@ namespace ts {\n             return updated;\r\n         }\r\n \r\n-        /**\r\n-         * Visits a parameter declaration node.\r\n-         *\r\n-         * This function will be called when one of the following conditions are met:\r\n-         * - The node has an accessibility modifier.\r\n-         * - The node has a questionToken.\r\n-         * - The node's kind is ThisKeyword.\r\n-         *\r\n-         * @param node The parameter declaration node.\r\n-         */\r\n         function visitParameter(node: ParameterDeclaration) {\r\n             if (parameterIsThisKeyword(node)) {\r\n                 return undefined;\r\n             }\r\n-\r\n-            const parameter = createParameter(\r\n+            const updated = updateParameter(\r\n+                node,\r\n                 /*decorators*/ undefined,\r\n                 /*modifiers*/ undefined,\r\n                 node.dotDotDotToken,\r\n@@ -2505,24 +2425,17 @@ namespace ts {\n                 /*type*/ undefined,\r\n                 visitNode(node.initializer, visitor, isExpression)\r\n             );\r\n-\r\n-            // While we emit the source map for the node after skipping decorators and modifiers,\r\n-            // we need to emit the comments for the original range.\r\n-            setOriginalNode(parameter, node);\r\n-            setTextRange(parameter, moveRangePastModifiers(node));\r\n-            setCommentRange(parameter, node);\r\n-            setSourceMapRange(parameter, moveRangePastModifiers(node));\r\n-            setEmitFlags(parameter.name, EmitFlags.NoTrailingSourceMap);\r\n-\r\n-            return parameter;\r\n+            if (updated !== node) {\r\n+                // While we emit the source map for the node after skipping decorators and modifiers,\r\n+                // we need to emit the comments for the original range.\r\n+                setCommentRange(updated, node);\r\n+                setTextRange(updated, moveRangePastModifiers(node));\r\n+                setSourceMapRange(updated, moveRangePastModifiers(node));\r\n+                setEmitFlags(updated.name, EmitFlags.NoTrailingSourceMap);\r\n+            }\r\n+            return updated;\r\n         }\r\n \r\n-        /**\r\n-         * Visits a variable statement in a namespace.\r\n-         *\r\n-         * This function will be called when one of the following conditions are met:\r\n-         * - The node is exported from a TypeScript namespace.\r\n-         */\r\n         function visitVariableStatement(node: VariableStatement): Statement | undefined {\r\n             if (isExportOfNamespace(node)) {\r\n                 const variables = getInitializedVariables(node.declarationList);\r\n@@ -2576,12 +2489,6 @@ namespace ts {\n                 visitNode(node.initializer, visitor, isExpression));\r\n         }\r\n \r\n-        /**\r\n-         * Visits a parenthesized expression that contains either a type assertion or an `as`\r\n-         * expression.\r\n-         *\r\n-         * @param node The parenthesized expression node.\r\n-         */\r\n         function visitParenthesizedExpression(node: ParenthesizedExpression): Expression {\r\n             const innerExpression = skipOuterExpressions(node.expression, ~OuterExpressionKinds.Assertions);\r\n             if (isAssertionExpression(innerExpression)) {\r\n@@ -2765,7 +2672,7 @@ namespace ts {\n             const statements: Statement[] = [];\r\n             startLexicalEnvironment();\r\n             const members = map(node.members, transformEnumMember);\r\n-            addStatementsAfterPrologue(statements, endLexicalEnvironment());\r\n+            insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());\r\n             addRange(statements, members);\r\n \r\n             currentNamespaceContainerName = savedCurrentNamespaceLocalName;\r\n@@ -3086,7 +2993,7 @@ namespace ts {\n                 statementsLocation = moveRangePos(moduleBlock.statements, -1);\r\n             }\r\n \r\n-            addStatementsAfterPrologue(statements, endLexicalEnvironment());\r\n+            insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());\r\n             currentNamespaceContainerName = savedCurrentNamespaceContainerName;\r\n             currentNamespace = savedCurrentNamespace;\r\n             currentScopeFirstDeclarationsOfName = savedCurrentScopeFirstDeclarationsOfName;\r"},{"sha":"45801a4d59e890977ba40260032454cb72a418f0","filename":"src/compiler/types.ts","status":"modified","additions":38,"deletions":43,"changes":81,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Ftypes.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Ftypes.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ftypes.ts?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -5063,38 +5063,29 @@ namespace ts {\n \r\n         // Facts\r\n         // - Flags used to indicate that a node or subtree contains syntax that requires transformation.\r\n-        TypeScript = 1 << 0,\r\n-        ContainsTypeScript = 1 << 1,\r\n-        ContainsJsx = 1 << 2,\r\n-        ContainsESNext = 1 << 3,\r\n-        ContainsES2017 = 1 << 4,\r\n-        ContainsES2016 = 1 << 5,\r\n-        ES2015 = 1 << 6,\r\n+        ContainsTypeScript = 1 << 0,\r\n+        ContainsJsx = 1 << 1,\r\n+        ContainsESNext = 1 << 2,\r\n+        ContainsES2019 = 1 << 3,\r\n+        ContainsES2018 = 1 << 4,\r\n+        ContainsES2017 = 1 << 5,\r\n+        ContainsES2016 = 1 << 6,\r\n         ContainsES2015 = 1 << 7,\r\n-        Generator = 1 << 8,\r\n-        ContainsGenerator = 1 << 9,\r\n-        DestructuringAssignment = 1 << 10,\r\n-        ContainsDestructuringAssignment = 1 << 11,\r\n+        ContainsGenerator = 1 << 8,\r\n+        ContainsDestructuringAssignment = 1 << 9,\r\n \r\n         // Markers\r\n         // - Flags used to indicate that a subtree contains a specific transformation.\r\n-        ContainsTypeScriptClassSyntax = 1 << 12,                // Decorators, Property Initializers, Parameter Property Initializers\r\n-        ContainsLexicalThis = 1 << 13,\r\n-        ContainsCapturedLexicalThis = 1 << 14,\r\n-        ContainsLexicalThisInComputedPropertyName = 1 << 15,\r\n-        ContainsDefaultValueAssignments = 1 << 16,\r\n-        ContainsRestOrSpread = 1 << 17,\r\n-        ContainsObjectRestOrSpread = 1 << 18,\r\n-        ContainsComputedPropertyName = 1 << 19,\r\n-        ContainsBlockScopedBinding = 1 << 20,\r\n-        ContainsBindingPattern = 1 << 21,\r\n-        ContainsYield = 1 << 22,\r\n-        ContainsHoistedDeclarationOrCompletion = 1 << 23,\r\n-        ContainsDynamicImport = 1 << 24,\r\n-        Super = 1 << 25,\r\n-        ContainsSuper = 1 << 26,\r\n-        ContainsES2018 = 1 << 27,\r\n-        ContainsES2019 = 1 << 28,\r\n+        ContainsTypeScriptClassSyntax = 1 << 10, // Decorators, Property Initializers, Parameter Property Initializers\r\n+        ContainsLexicalThis = 1 << 11,\r\n+        ContainsRestOrSpread = 1 << 12,\r\n+        ContainsObjectRestOrSpread = 1 << 13,\r\n+        ContainsComputedPropertyName = 1 << 14,\r\n+        ContainsBlockScopedBinding = 1 << 15,\r\n+        ContainsBindingPattern = 1 << 16,\r\n+        ContainsYield = 1 << 17,\r\n+        ContainsHoistedDeclarationOrCompletion = 1 << 18,\r\n+        ContainsDynamicImport = 1 << 19,\r\n \r\n         // Please leave this as 1 << 29.\r\n         // It is the maximum bit we can set before we outgrow the size of a v8 small integer (SMI) on an x86 system.\r\n@@ -5103,40 +5094,44 @@ namespace ts {\n \r\n         // Assertions\r\n         // - Bitmasks that are used to assert facts about the syntax of a node and its subtree.\r\n-        AssertTypeScript = TypeScript | ContainsTypeScript,\r\n+        AssertTypeScript = ContainsTypeScript,\r\n         AssertJsx = ContainsJsx,\r\n         AssertESNext = ContainsESNext,\r\n         AssertES2019 = ContainsES2019,\r\n         AssertES2018 = ContainsES2018,\r\n         AssertES2017 = ContainsES2017,\r\n         AssertES2016 = ContainsES2016,\r\n-        AssertES2015 = ES2015 | ContainsES2015,\r\n-        AssertGenerator = Generator | ContainsGenerator,\r\n-        AssertDestructuringAssignment = DestructuringAssignment | ContainsDestructuringAssignment,\r\n+        AssertES2015 = ContainsES2015,\r\n+        AssertGenerator = ContainsGenerator,\r\n+        AssertDestructuringAssignment = ContainsDestructuringAssignment,\r\n \r\n         // Scope Exclusions\r\n         // - Bitmasks that exclude flags from propagating out of a specific context\r\n         //   into the subtree flags of their container.\r\n-        OuterExpressionExcludes = TypeScript | ES2015 | DestructuringAssignment | Generator | HasComputedFlags,\r\n-        PropertyAccessExcludes = OuterExpressionExcludes | Super,\r\n-        NodeExcludes = PropertyAccessExcludes | ContainsSuper,\r\n-        ArrowFunctionExcludes = NodeExcludes | ContainsTypeScriptClassSyntax | ContainsDefaultValueAssignments | ContainsLexicalThis | ContainsBlockScopedBinding | ContainsYield | ContainsHoistedDeclarationOrCompletion | ContainsBindingPattern | ContainsObjectRestOrSpread,\r\n-        FunctionExcludes = NodeExcludes | ContainsTypeScriptClassSyntax | ContainsDefaultValueAssignments | ContainsCapturedLexicalThis | ContainsLexicalThis | ContainsBlockScopedBinding | ContainsYield | ContainsHoistedDeclarationOrCompletion | ContainsBindingPattern | ContainsObjectRestOrSpread,\r\n-        ConstructorExcludes = NodeExcludes | ContainsDefaultValueAssignments | ContainsLexicalThis | ContainsCapturedLexicalThis | ContainsBlockScopedBinding | ContainsYield | ContainsHoistedDeclarationOrCompletion | ContainsBindingPattern | ContainsObjectRestOrSpread,\r\n-        MethodOrAccessorExcludes = NodeExcludes | ContainsDefaultValueAssignments | ContainsLexicalThis | ContainsCapturedLexicalThis | ContainsBlockScopedBinding | ContainsYield | ContainsHoistedDeclarationOrCompletion | ContainsBindingPattern | ContainsObjectRestOrSpread,\r\n-        ClassExcludes = NodeExcludes | ContainsTypeScriptClassSyntax | ContainsLexicalThis | ContainsCapturedLexicalThis | ContainsComputedPropertyName | ContainsLexicalThisInComputedPropertyName,\r\n-        ModuleExcludes = NodeExcludes | ContainsTypeScriptClassSyntax | ContainsLexicalThis | ContainsCapturedLexicalThis | ContainsBlockScopedBinding | ContainsHoistedDeclarationOrCompletion,\r\n+        OuterExpressionExcludes = HasComputedFlags,\r\n+        PropertyAccessExcludes = OuterExpressionExcludes,\r\n+        NodeExcludes = PropertyAccessExcludes,\r\n+        ArrowFunctionExcludes = NodeExcludes | ContainsTypeScriptClassSyntax | ContainsBlockScopedBinding | ContainsYield | ContainsHoistedDeclarationOrCompletion | ContainsBindingPattern | ContainsObjectRestOrSpread,\r\n+        FunctionExcludes = NodeExcludes | ContainsTypeScriptClassSyntax | ContainsLexicalThis | ContainsBlockScopedBinding | ContainsYield | ContainsHoistedDeclarationOrCompletion | ContainsBindingPattern | ContainsObjectRestOrSpread,\r\n+        ConstructorExcludes = NodeExcludes | ContainsLexicalThis | ContainsBlockScopedBinding | ContainsYield | ContainsHoistedDeclarationOrCompletion | ContainsBindingPattern | ContainsObjectRestOrSpread,\r\n+        MethodOrAccessorExcludes = NodeExcludes | ContainsLexicalThis | ContainsBlockScopedBinding | ContainsYield | ContainsHoistedDeclarationOrCompletion | ContainsBindingPattern | ContainsObjectRestOrSpread,\r\n+        PropertyExcludes = NodeExcludes | ContainsLexicalThis,\r\n+        ClassExcludes = NodeExcludes | ContainsTypeScriptClassSyntax | ContainsComputedPropertyName,\r\n+        ModuleExcludes = NodeExcludes | ContainsTypeScriptClassSyntax | ContainsLexicalThis | ContainsBlockScopedBinding | ContainsHoistedDeclarationOrCompletion,\r\n         TypeExcludes = ~ContainsTypeScript,\r\n-        ObjectLiteralExcludes = NodeExcludes | ContainsTypeScriptClassSyntax | ContainsComputedPropertyName | ContainsLexicalThisInComputedPropertyName | ContainsObjectRestOrSpread,\r\n+        ObjectLiteralExcludes = NodeExcludes | ContainsTypeScriptClassSyntax | ContainsComputedPropertyName | ContainsObjectRestOrSpread,\r\n         ArrayLiteralOrCallOrNewExcludes = NodeExcludes | ContainsRestOrSpread,\r\n         VariableDeclarationListExcludes = NodeExcludes | ContainsBindingPattern | ContainsObjectRestOrSpread,\r\n         ParameterExcludes = NodeExcludes,\r\n         CatchClauseExcludes = NodeExcludes | ContainsObjectRestOrSpread,\r\n         BindingPatternExcludes = NodeExcludes | ContainsRestOrSpread,\r\n \r\n+        // Propagating flags\r\n+        // - Bitmasks for flags that should propagate from a child\r\n+        PropertyNamePropagatingFlags = ContainsLexicalThis,\r\n+\r\n         // Masks\r\n         // - Additional bitmasks\r\n-        ES2015FunctionSyntaxMask = ContainsCapturedLexicalThis | ContainsDefaultValueAssignments,\r\n     }\r\n \r\n     export interface SourceMapRange extends TextRange {\r"},{"sha":"7cfacbb33eb95d999d0ea73d2881be887416c76c","filename":"src/compiler/utilities.ts","status":"modified","additions":48,"deletions":6,"changes":54,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Futilities.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Futilities.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Futilities.ts?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -401,10 +401,7 @@ namespace ts {\n         return !nodeIsMissing(node);\r\n     }\r\n \r\n-    /**\r\n-     * Prepends statements to an array while taking care of prologue directives.\r\n-     */\r\n-    export function addStatementsAfterPrologue<T extends Statement>(to: T[], from: ReadonlyArray<T> | undefined): T[] {\r\n+    function insertStatementsAfterPrologue<T extends Statement>(to: T[], from: ReadonlyArray<T> | undefined, isPrologueDirective: (node: Node) => boolean): T[] {\r\n         if (from === undefined || from.length === 0) return to;\r\n         let statementIndex = 0;\r\n         // skip all prologue directives to insert at the correct position\r\n@@ -417,6 +414,46 @@ namespace ts {\n         return to;\r\n     }\r\n \r\n+    function insertStatementAfterPrologue<T extends Statement>(to: T[], statement: T | undefined, isPrologueDirective: (node: Node) => boolean): T[] {\r\n+        if (statement === undefined) return to;\r\n+        let statementIndex = 0;\r\n+        // skip all prologue directives to insert at the correct position\r\n+        for (; statementIndex < to.length; ++statementIndex) {\r\n+            if (!isPrologueDirective(to[statementIndex])) {\r\n+                break;\r\n+            }\r\n+        }\r\n+        to.splice(statementIndex, 0, statement);\r\n+        return to;\r\n+    }\r\n+\r\n+\r\n+    function isAnyPrologueDirective(node: Node) {\r\n+        return isPrologueDirective(node) || !!(getEmitFlags(node) & EmitFlags.CustomPrologue);\r\n+    }\r\n+\r\n+    /**\r\n+     * Prepends statements to an array while taking care of prologue directives.\r\n+     */\r\n+    export function insertStatementsAfterStandardPrologue<T extends Statement>(to: T[], from: ReadonlyArray<T> | undefined): T[] {\r\n+        return insertStatementsAfterPrologue(to, from, isPrologueDirective);\r\n+    }\r\n+\r\n+    export function insertStatementsAfterCustomPrologue<T extends Statement>(to: T[], from: ReadonlyArray<T> | undefined): T[] {\r\n+        return insertStatementsAfterPrologue(to, from, isAnyPrologueDirective);\r\n+    }\r\n+\r\n+    /**\r\n+     * Prepends statements to an array while taking care of prologue directives.\r\n+     */\r\n+    export function insertStatementAfterStandardPrologue<T extends Statement>(to: T[], statement: T | undefined): T[] {\r\n+        return insertStatementAfterPrologue(to, statement, isPrologueDirective);\r\n+    }\r\n+\r\n+    export function insertStatementAfterCustomPrologue<T extends Statement>(to: T[], statement: T | undefined): T[] {\r\n+        return insertStatementAfterPrologue(to, statement, isAnyPrologueDirective);\r\n+    }\r\n+\r\n     /**\r\n      * Determine if the given comment is a triple-slash\r\n      *\r\n@@ -1436,6 +1473,11 @@ namespace ts {\n         }\r\n     }\r\n \r\n+    export function isSuperOrSuperProperty(node: Node): node is SuperExpression | SuperProperty {\r\n+        return node.kind === SyntaxKind.SuperKeyword\r\n+            || isSuperProperty(node);\r\n+    }\r\n+\r\n     /**\r\n      * Determines whether a node is a property or element access expression for `super`.\r\n      */\r\n@@ -3418,8 +3460,8 @@ namespace ts {\n         return computeLineAndCharacterOfPosition(lineMap, pos).line;\r\n     }\r\n \r\n-    export function getFirstConstructorWithBody(node: ClassLikeDeclaration): ConstructorDeclaration | undefined {\r\n-        return find(node.members, (member): member is ConstructorDeclaration => isConstructorDeclaration(member) && nodeIsPresent(member.body));\r\n+    export function getFirstConstructorWithBody(node: ClassLikeDeclaration): ConstructorDeclaration & { body: FunctionBody } | undefined {\r\n+        return find(node.members, (member): member is ConstructorDeclaration & { body: FunctionBody } => isConstructorDeclaration(member) && nodeIsPresent(member.body));\r\n     }\r\n \r\n     function getSetAccessorValueParameter(accessor: SetAccessorDeclaration): ParameterDeclaration | undefined {\r"},{"sha":"0d4d0d9482d6ab818ecdbd97331c2272dbdcdb50","filename":"src/compiler/visitor.ts","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Fvisitor.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/src%2Fcompiler%2Fvisitor.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Fvisitor.ts?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -1478,8 +1478,8 @@ namespace ts {\n         }\r\n \r\n         return isNodeArray(statements)\r\n-            ? setTextRange(createNodeArray(addStatementsAfterPrologue(statements.slice(), declarations)), statements)\r\n-            : addStatementsAfterPrologue(statements, declarations);\r\n+            ? setTextRange(createNodeArray(insertStatementsAfterStandardPrologue(statements.slice(), declarations)), statements)\r\n+            : insertStatementsAfterStandardPrologue(statements, declarations);\r\n     }\r\n \r\n     /**\r"},{"sha":"c097ccf0d50e703fb50d10c12a7d63cbc41066d8","filename":"tests/baselines/reference/arrowFunctionWithObjectLiteralBody5.js","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FarrowFunctionWithObjectLiteralBody5.js","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FarrowFunctionWithObjectLiteralBody5.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FarrowFunctionWithObjectLiteralBody5.js?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -11,4 +11,4 @@ var d = () => ((<Error>({ name: \"foo\", message: \"bar\" })));\n var a = function () { return ({ name: \"foo\", message: \"bar\" }); };\r\n var b = function () { return ({ name: \"foo\", message: \"bar\" }); };\r\n var c = function () { return ({ name: \"foo\", message: \"bar\" }); };\r\n-var d = function () { return (({ name: \"foo\", message: \"bar\" })); };\r\n+var d = function () { return ({ name: \"foo\", message: \"bar\" }); };\r"},{"sha":"270a9927835a9e6da2f7daf4694d156df8ac4d80","filename":"tests/baselines/reference/arrowFunctionWithObjectLiteralBody6.js","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FarrowFunctionWithObjectLiteralBody6.js","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FarrowFunctionWithObjectLiteralBody6.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FarrowFunctionWithObjectLiteralBody6.js?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -11,4 +11,4 @@ var d = () => ((<Error>({ name: \"foo\", message: \"bar\" })));\n var a = () => ({ name: \"foo\", message: \"bar\" });\r\n var b = () => ({ name: \"foo\", message: \"bar\" });\r\n var c = () => ({ name: \"foo\", message: \"bar\" });\r\n-var d = () => (({ name: \"foo\", message: \"bar\" }));\r\n+var d = () => ({ name: \"foo\", message: \"bar\" });\r"},{"sha":"2600681c64746b429ca399e0fd568ca3064c62b4","filename":"tests/baselines/reference/decoratorOnClassMethod11.js","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FdecoratorOnClassMethod11.js","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FdecoratorOnClassMethod11.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FdecoratorOnClassMethod11.js?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -17,7 +17,6 @@ var __decorate = (this && this.__decorate) || function (decorators, target, key,\n };\r\n var M;\r\n (function (M) {\r\n-    var _this = this;\r\n     var C = /** @class */ (function () {\r\n         function C() {\r\n         }\r"},{"sha":"81cbcc78e4eb0086167657748696aeb1d4435178","filename":"tests/baselines/reference/dynamicImportWithNestedThis_es5.js","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FdynamicImportWithNestedThis_es5.js","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FdynamicImportWithNestedThis_es5.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FdynamicImportWithNestedThis_es5.js?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -30,7 +30,6 @@ c.dynamic();\n         }\r\n         C.prototype.dynamic = function () {\r\n             var _a;\r\n-            var _this = this;\r\n             return _a = this._path, __syncRequire ? Promise.resolve().then(function () { return require(_a); }) : new Promise(function (resolve_1, reject_1) { require([_a], resolve_1, reject_1); });\r\n         };\r\n         return C;\r"},{"sha":"56278dc56df1941adc2a4940a19503cbca073520","filename":"tests/baselines/reference/invalidNewTarget.es5.js","status":"modified","additions":36,"deletions":9,"changes":45,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FinvalidNewTarget.es5.js","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FinvalidNewTarget.es5.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FinvalidNewTarget.es5.js?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -34,26 +34,44 @@ var C = /** @class */ (function () {\n         this.f = function () { return _newTarget; };\r\n     }\r\n     C.prototype[_newTarget] = function () { };\r\n-    C.prototype.c = function () { var _newTarget = void 0; return _newTarget; };\r\n+    C.prototype.c = function () {\r\n+        var _newTarget = void 0;\r\n+        return _newTarget;\r\n+    };\r\n     Object.defineProperty(C.prototype, \"d\", {\r\n-        get: function () { var _newTarget = void 0; return _newTarget; },\r\n+        get: function () {\r\n+            var _newTarget = void 0;\r\n+            return _newTarget;\r\n+        },\r\n         enumerable: true,\r\n         configurable: true\r\n     });\r\n     Object.defineProperty(C.prototype, \"e\", {\r\n-        set: function (_) { var _newTarget = void 0; _ = _newTarget; },\r\n+        set: function (_) {\r\n+            var _newTarget = void 0;\r\n+            _ = _newTarget;\r\n+        },\r\n         enumerable: true,\r\n         configurable: true\r\n     });\r\n     C[_newTarget] = function () { };\r\n-    C.g = function () { var _newTarget = void 0; return _newTarget; };\r\n+    C.g = function () {\r\n+        var _newTarget = void 0;\r\n+        return _newTarget;\r\n+    };\r\n     Object.defineProperty(C, \"h\", {\r\n-        get: function () { var _newTarget = void 0; return _newTarget; },\r\n+        get: function () {\r\n+            var _newTarget = void 0;\r\n+            return _newTarget;\r\n+        },\r\n         enumerable: true,\r\n         configurable: true\r\n     });\r\n     Object.defineProperty(C, \"i\", {\r\n-        set: function (_) { var _newTarget = void 0; _ = _newTarget; },\r\n+        set: function (_) {\r\n+            var _newTarget = void 0;\r\n+            _ = _newTarget;\r\n+        },\r\n         enumerable: true,\r\n         configurable: true\r\n     });\r\n@@ -62,14 +80,23 @@ var C = /** @class */ (function () {\n }());\r\n var O = (_a = {},\r\n     _a[_newTarget] = undefined,\r\n-    _a.k = function () { var _newTarget = void 0; return _newTarget; },\r\n+    _a.k = function () {\r\n+        var _newTarget = void 0;\r\n+        return _newTarget;\r\n+    },\r\n     Object.defineProperty(_a, \"l\", {\r\n-        get: function () { var _newTarget = void 0; return _newTarget; },\r\n+        get: function () {\r\n+            var _newTarget = void 0;\r\n+            return _newTarget;\r\n+        },\r\n         enumerable: true,\r\n         configurable: true\r\n     }),\r\n     Object.defineProperty(_a, \"m\", {\r\n-        set: function (_) { var _newTarget = void 0; _ = _newTarget; },\r\n+        set: function (_) {\r\n+            var _newTarget = void 0;\r\n+            _ = _newTarget;\r\n+        },\r\n         enumerable: true,\r\n         configurable: true\r\n     }),\r"},{"sha":"7fa733880b4b45026e973c68fa208110fe96c816","filename":"tests/baselines/reference/newTarget.es5.js","status":"modified","additions":12,"deletions":3,"changes":15,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FnewTarget.es5.js","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FnewTarget.es5.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FnewTarget.es5.js?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -49,11 +49,17 @@ var __extends = (this && this.__extends) || (function () {\n var A = /** @class */ (function () {\r\n     function A() {\r\n         var _newTarget = this.constructor;\r\n-        this.d = function _a() { var _newTarget = this && this instanceof _a ? this.constructor : void 0; return _newTarget; };\r\n+        this.d = function _a() {\r\n+            var _newTarget = this && this instanceof _a ? this.constructor : void 0;\r\n+            return _newTarget;\r\n+        };\r\n         var a = _newTarget;\r\n         var b = function () { return _newTarget; };\r\n     }\r\n-    A.c = function _a() { var _newTarget = this && this instanceof _a ? this.constructor : void 0; return _newTarget; };\r\n+    A.c = function _a() {\r\n+        var _newTarget = this && this instanceof _a ? this.constructor : void 0;\r\n+        return _newTarget;\r\n+    };\r\n     return A;\r\n }());\r\n var B = /** @class */ (function (_super) {\r\n@@ -78,5 +84,8 @@ var f2 = function _b() {\n     var j = function () { return _newTarget; };\r\n };\r\n var O = {\r\n-    k: function k() { var _newTarget = this && this instanceof k ? this.constructor : void 0; return _newTarget; }\r\n+    k: function k() {\r\n+        var _newTarget = this && this instanceof k ? this.constructor : void 0;\r\n+        return _newTarget;\r\n+    }\r\n };\r"},{"sha":"ec4f5a6f5ff546421e3b8a10a9711b63f6d2f9b0","filename":"tests/baselines/reference/noUnusedLocals_writeOnly.js","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FnoUnusedLocals_writeOnly.js","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FnoUnusedLocals_writeOnly.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FnoUnusedLocals_writeOnly.js?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -25,9 +25,9 @@ function f2(_: ReadonlyArray<number>): void {}\n //// [noUnusedLocals_writeOnly.js]\r\n \"use strict\";\r\n function f(x, b) {\r\n+    var _a, _b;\r\n     if (x === void 0) { x = 0; }\r\n     if (b === void 0) { b = false; }\r\n-    var _a, _b;\r\n     // None of these statements read from 'x', so it will be marked unused.\r\n     x = 1;\r\n     x++;\r"},{"sha":"52a6fcf25cc996c69b537cd221f4719fecdc8ccf","filename":"tests/baselines/reference/parseErrorIncorrectReturnToken.js","status":"modified","additions":1,"deletions":3,"changes":4,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FparseErrorIncorrectReturnToken.js","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FparseErrorIncorrectReturnToken.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FparseErrorIncorrectReturnToken.js?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -17,9 +17,7 @@ let o = {\n string; // should be => not :\r\n // doesn't work in non-type contexts, where the return type is optional\r\n var f = function (n) { return function (string) { return n.toString(); }; };\r\n-var o = {\r\n-    m: function (n) { }\r\n-};\r\n+var o = {};\r\n string;\r\n {\r\n     return n.toString();\r"},{"sha":"5b4b71cab1f2243b9c999278ca8202d6e553fd5f","filename":"tests/baselines/reference/parserErrantEqualsGreaterThanAfterFunction2.js","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FparserErrantEqualsGreaterThanAfterFunction2.js","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FparserErrantEqualsGreaterThanAfterFunction2.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FparserErrantEqualsGreaterThanAfterFunction2.js?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -2,5 +2,4 @@\n function f(p: A) => p;\r\n \r\n //// [parserErrantEqualsGreaterThanAfterFunction2.js]\r\n-function f(p) { }\r\n p;\r"},{"sha":"4356793d3d24cd6b36cf03dcc487206636a311a5","filename":"tests/baselines/reference/strictModeInConstructor.js","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FstrictModeInConstructor.js","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FstrictModeInConstructor.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FstrictModeInConstructor.js?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -123,8 +123,8 @@ var Bs = /** @class */ (function (_super) {\n var Cs = /** @class */ (function (_super) {\r\n     __extends(Cs, _super);\r\n     function Cs() {\r\n-        var _this = _super.call(this) || this;\r\n         \"use strict\";\r\n+        var _this = _super.call(this) || this;\r\n         return _this;\r\n     }\r\n     Cs.s = 9;\r"},{"sha":"df2f22b8ae7bd89ac791c8e56740b9fa908daa1c","filename":"tests/baselines/reference/thisInConstructorParameter2.js","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FthisInConstructorParameter2.js","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FthisInConstructorParameter2.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FthisInConstructorParameter2.js?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -12,16 +12,15 @@ class P {\n }\r\n \r\n //// [thisInConstructorParameter2.js]\r\n-var _this = this;\r\n var P = /** @class */ (function () {\r\n     function P(z, zz, zzz) {\r\n+        var _this = this;\r\n         if (z === void 0) { z = this; }\r\n         if (zz === void 0) { zz = this; }\r\n         if (zzz === void 0) { zzz = function (p) {\r\n             if (p === void 0) { p = _this; }\r\n             return _this;\r\n         }; }\r\n-        var _this = this;\r\n         this.z = z;\r\n         this.x = this;\r\n         zzz = function (p) {\r"},{"sha":"71c0a408c45ff32851e75f54d2c95746a05f78aa","filename":"tests/baselines/reference/thisInInvalidContexts.js","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FthisInInvalidContexts.js","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FthisInInvalidContexts.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FthisInInvalidContexts.js?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -62,7 +62,6 @@ var __extends = (this && this.__extends) || (function () {\n         d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n     };\r\n })();\r\n-var _this = this;\r\n //'this' in static member initializer\r\n var ErrClass1 = /** @class */ (function () {\r\n     function ErrClass1() {\r"},{"sha":"e295c49074b0d5fd78db04a81a847d77a1312134","filename":"tests/baselines/reference/thisInInvalidContextsExternalModule.js","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FthisInInvalidContextsExternalModule.js","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FthisInInvalidContextsExternalModule.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FthisInInvalidContextsExternalModule.js?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -63,7 +63,6 @@ var __extends = (this && this.__extends) || (function () {\n         d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n     };\r\n })();\r\n-var _this = this;\r\n //'this' in static member initializer\r\n var ErrClass1 = /** @class */ (function () {\r\n     function ErrClass1() {\r"},{"sha":"2b4e3a1aabdb6870ea1ffead71fdd4c509f44aae","filename":"tests/baselines/reference/thisInOuterClassBody.js","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FthisInOuterClassBody.js","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FthisInOuterClassBody.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FthisInOuterClassBody.js?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -21,7 +21,6 @@ class Foo {\n }\r\n \r\n //// [thisInOuterClassBody.js]\r\n-var _this = this;\r\n var Foo = /** @class */ (function () {\r\n     function Foo() {\r\n         this.x = this;\r"},{"sha":"ed454ee8b7027d1a59d85fefa36a485f768daaa8","filename":"tests/baselines/reference/thisTypeInFunctionsNegative.js","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FthisTypeInFunctionsNegative.js","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FthisTypeInFunctionsNegative.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FthisTypeInFunctionsNegative.js?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -321,7 +321,6 @@ function modifiers() { return this.n; }\n function restParam(...) { return this.n; }\r\n function optional() { return this.n; }\r\n function decorated() { return this.n; }\r\n-function initializer(, C) { }\r\n ();\r\n number;\r\n {\r"},{"sha":"72243cdd3e6196b64b3764abf51503dabab8db28","filename":"tests/baselines/reference/typeOfThisInStaticMembers2.js","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/microsoft/TypeScript/blob/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FtypeOfThisInStaticMembers2.js","raw_url":"https://github.com/microsoft/TypeScript/raw/1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d/tests%2Fbaselines%2Freference%2FtypeOfThisInStaticMembers2.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tests%2Fbaselines%2Freference%2FtypeOfThisInStaticMembers2.js?ref=1c0f9a8ce339c2c10cb6cf5106579320c2d75c9d","patch":"@@ -8,7 +8,6 @@ class C2<T> {\n }\r\n \r\n //// [typeOfThisInStaticMembers2.js]\r\n-var _this = this;\r\n var C = /** @class */ (function () {\r\n     function C() {\r\n     }\r"}]},{"url":"https://api.github.com/repos/microsoft/TypeScript/issues/11354","repository_url":"https://api.github.com/repos/microsoft/TypeScript","labels_url":"https://api.github.com/repos/microsoft/TypeScript/issues/11354/labels{/name}","comments_url":"https://api.github.com/repos/microsoft/TypeScript/issues/11354/comments","events_url":"https://api.github.com/repos/microsoft/TypeScript/issues/11354/events","html_url":"https://github.com/microsoft/TypeScript/pull/11354","id":180911734,"node_id":"MDExOlB1bGxSZXF1ZXN0ODc5MDcyNzI=","number":11354,"title":"Use native maps when they're available","user":{"login":"andy-ms","id":19274678,"node_id":"MDQ6VXNlcjE5Mjc0Njc4","avatar_url":"https://avatars.githubusercontent.com/u/19274678?v=4","gravatar_id":"","url":"https://api.github.com/users/andy-ms","html_url":"https://github.com/andy-ms","followers_url":"https://api.github.com/users/andy-ms/followers","following_url":"https://api.github.com/users/andy-ms/following{/other_user}","gists_url":"https://api.github.com/users/andy-ms/gists{/gist_id}","starred_url":"https://api.github.com/users/andy-ms/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/andy-ms/subscriptions","organizations_url":"https://api.github.com/users/andy-ms/orgs","repos_url":"https://api.github.com/users/andy-ms/repos","events_url":"https://api.github.com/users/andy-ms/events{/privacy}","received_events_url":"https://api.github.com/users/andy-ms/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":true,"assignee":null,"assignees":[],"milestone":null,"comments":6,"created_at":"2016-10-04T14:38:45Z","updated_at":"2018-06-19T23:36:55Z","closed_at":"2016-10-27T20:27:47Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"draft":false,"pull_request":{"url":"https://api.github.com/repos/microsoft/TypeScript/pulls/11354","html_url":"https://github.com/microsoft/TypeScript/pull/11354","diff_url":"https://github.com/microsoft/TypeScript/pull/11354.diff","patch_url":"https://github.com/microsoft/TypeScript/pull/11354.patch","merged_at":"2016-10-27T20:27:47Z"},"body":"The summary is that using native maps, the compiler works 5% faster and uses 5% less memory. Using shims, the performance is surprisingly less than 5% worse.\n\nI was able to achieve good baseline performance by disabling Windows Defender in my work directory and using \"High Performance\" in Control Panel -> Hardware and Sound -> Power Options. There is much less variance this time around.\n### Benchmark numbers\n\nThis is from using our internal `ts-perf` tool.\n### map4\n#### Monaco\n##### tsc (x86)\n\n| Project | Baseline | Current | Delta | Best | Worst |\n| --- | --- | --- | --- | --- | --- |\n| Parse Time | 1.79s (±  0.95%) | 1.72s (±  1.10%) | -0.07s (-  4.08%) | 1.70s | 1.74s |\n| Bind Time | 0.69s (±  4.74%) | 0.52s (±  3.50%) | -0.17s (- 24.86%) | 0.50s | 0.54s |\n| Check Time | 3.37s (±  1.66%) | 2.91s (±  3.16%) | -0.46s (- 13.69%) | 2.78s | 2.98s |\n| Emit Time | 5.01s (±  4.73%) | 4.87s (±  1.35%) | -0.14s (-  2.77%) | 4.79s | 4.94s |\n| Total Time | 10.87s (±  2.34%) | 10.02s (±  1.18%) | -0.84s (-  7.77%) | 9.86s | 10.12s |\n##### node (v6.7.0, x64)\n\n| Project | Baseline | Current | Delta | Best | Worst |\n| --- | --- | --- | --- | --- | --- |\n| Memory used | 379,924k (±  0.00%) | 356,928k (±  0.01%) | -22,996k (-  6.05%) | 356,890k | 356,956k |\n| Parse Time | 2.40s (±  0.75%) | 2.32s (±  2.13%) | -0.08s (-  3.37%) | 2.28s | 2.39s |\n| Bind Time | 0.92s (±  1.79%) | 0.71s (±  1.84%) | -0.21s (- 22.52%) | 0.70s | 0.73s |\n| Check Time | 4.26s (±  1.36%) | 3.84s (±  6.33%) | -0.42s (-  9.94%) | 3.66s | 4.18s |\n| Emit Time | 1.87s (±  2.44%) | 1.82s (±  3.16%) | -0.05s (-  2.80%) | 1.77s | 1.89s |\n| Total Time | 9.46s (±  1.19%) | 8.69s (±  3.96%) | -0.77s (-  8.12%) | 8.42s | 9.16s |\n##### node (v6.7.0, x86)\n\n| Project | Baseline | Current | Delta | Best | Worst |\n| --- | --- | --- | --- | --- | --- |\n| Memory used | 201,971k (±  0.00%) | 190,504k (±  0.01%) | -11,467k (-  5.68%) | 190,474k | 190,538k |\n| Parse Time | 2.30s (±  0.89%) | 2.20s (±  2.07%) | -0.09s (-  4.09%) | 2.17s | 2.27s |\n| Bind Time | 0.72s (±  0.99%) | 0.57s (±  4.73%) | -0.15s (- 21.33%) | 0.55s | 0.61s |\n| Check Time | 3.48s (±  1.73%) | 3.27s (±  4.68%) | -0.21s (-  6.08%) | 3.08s | 3.38s |\n| Emit Time | 1.91s (±  3.15%) | 1.78s (±  8.00%) | -0.13s (-  6.94%) | 1.65s | 1.94s |\n| Total Time | 8.41s (±  0.61%) | 7.82s (±  1.68%) | -0.59s (-  7.03%) | 7.71s | 7.99s |\n#### TFS\n##### tsc (x86)\n\n| Project | Baseline | Current | Delta | Best | Worst |\n| --- | --- | --- | --- | --- | --- |\n| Parse Time | 1.22s (±  2.62%) | 1.15s (±  1.31%) | -0.07s (-  6.06%) | 1.13s | 1.16s |\n| Bind Time | 0.56s (±  2.96%) | 0.54s (±  4.08%) | -0.02s (-  3.13%) | 0.52s | 0.57s |\n| Check Time | 2.81s (±  1.48%) | 2.46s (±  1.85%) | -0.35s (- 12.34%) | 2.43s | 2.53s |\n| Emit Time | 3.11s (±  0.85%) | 3.19s (±  0.91%) | +0.07s (+  2.33%) | 3.15s | 3.22s |\n| Total Time | 7.70s (±  0.84%) | 7.34s (±  1.14%) | -0.37s (-  4.78%) | 7.28s | 7.46s |\n##### node (v6.7.0, x64)\n\n| Project | Baseline | Current | Delta | Best | Worst |\n| --- | --- | --- | --- | --- | --- |\n| Memory used | 328,005k (±  0.00%) | 309,449k (±  0.02%) | -18,556k (-  5.66%) | 309,386k | 309,516k |\n| Parse Time | 1.50s (±  1.02%) | 1.44s (±  0.88%) | -0.07s (-  4.32%) | 1.42s | 1.45s |\n| Bind Time | 0.73s (±  0.73%) | 0.58s (±  1.65%) | -0.14s (- 19.89%) | 0.57s | 0.59s |\n| Check Time | 3.89s (±  0.65%) | 3.56s (±  4.42%) | -0.32s (-  8.27%) | 3.42s | 3.74s |\n| Emit Time | 1.54s (±  0.91%) | 1.57s (±  4.86%) | +0.03s (+  2.25%) | 1.51s | 1.67s |\n| Total Time | 7.65s (±  0.65%) | 7.16s (±  3.13%) | -0.50s (-  6.48%) | 6.96s | 7.42s |\n##### node (v6.7.0, x86)\n\n| Project | Baseline | Current | Delta | Best | Worst |\n| --- | --- | --- | --- | --- | --- |\n| Memory used | 174,749k (±  0.00%) | 165,316k (±  0.01%) | -9,433k (-  5.40%) | 165,292k | 165,344k |\n| Parse Time | 1.41s (±  1.63%) | 1.33s (±  0.77%) | -0.08s (-  5.36%) | 1.33s | 1.35s |\n| Bind Time | 0.62s (±  5.95%) | 0.50s (±  3.40%) | -0.12s (- 19.68%) | 0.48s | 0.52s |\n| Check Time | 2.98s (±  0.64%) | 2.75s (±  0.96%) | -0.23s (-  7.73%) | 2.71s | 2.77s |\n| Emit Time | 1.35s (±  0.83%) | 1.35s (±  1.29%) | +0.01s (+  0.45%) | 1.33s | 1.37s |\n| Total Time | 6.36s (±  1.07%) | 5.94s (±  0.82%) | -0.42s (-  6.60%) | 5.88s | 5.98s |\n### map4 with `usingNativeMaps = false` and `usingNativeSets = false`\n#### Monaco\n##### tsc (x86)\n\n| Project | Baseline | Current | Delta | Best | Worst |\n| --- | --- | --- | --- | --- | --- |\n| Parse Time | 1.79s (±  0.95%) | 1.80s (±  1.47%) | +0.01s (+  0.73%) | 1.77s | 1.82s |\n| Bind Time | 0.69s (±  4.74%) | 0.71s (± 13.45%) | +0.02s (+  3.18%) | 0.66s | 0.86s |\n| Check Time | 3.37s (±  1.66%) | 3.43s (±  3.44%) | +0.06s (+  1.68%) | 3.29s | 3.57s |\n| Emit Time | 5.01s (±  4.73%) | 5.04s (±  4.80%) | +0.03s (+  0.66%) | 4.93s | 5.42s |\n| Total Time | 10.87s (±  2.34%) | 10.98s (±  1.85%) | +0.12s (+  1.09%) | 10.83s | 11.29s |\n##### node (v6.7.0, x64)\n\n| Project | Baseline | Current | Delta | Best | Worst |\n| --- | --- | --- | --- | --- | --- |\n| Memory used | 379,924k (±  0.00%) | 383,279k (±  0.01%) | +3,355k (+  0.88%) | 383,241k | 383,338k |\n| Parse Time | 2.40s (±  0.75%) | 2.39s (±  2.42%) | -0.01s (-  0.29%) | 2.33s | 2.44s |\n| Bind Time | 0.92s (±  1.79%) | 0.90s (±  4.74%) | -0.02s (-  2.55%) | 0.86s | 0.96s |\n| Check Time | 4.26s (±  1.36%) | 4.29s (±  0.29%) | +0.03s (+  0.66%) | 4.28s | 4.31s |\n| Emit Time | 1.87s (±  2.44%) | 1.88s (±  1.90%) | +0.01s (+  0.51%) | 1.85s | 1.92s |\n| Total Time | 9.46s (±  1.19%) | 9.47s (±  0.86%) | +0.01s (+  0.11%) | 9.36s | 9.54s |\n##### node (v6.7.0, x86)\n\n| Project | Baseline | Current | Delta | Best | Worst |\n| --- | --- | --- | --- | --- | --- |\n| Memory used | 201,971k (±  0.00%) | 203,972k (±  0.01%) | +2,001k (+  0.99%) | 203,951k | 203,991k |\n| Parse Time | 2.30s (±  0.89%) | 2.29s (±  0.76%) | -0.01s (-  0.52%) | 2.27s | 2.31s |\n| Bind Time | 0.72s (±  0.99%) | 0.68s (±  1.41%) | -0.04s (-  5.87%) | 0.67s | 0.69s |\n| Check Time | 3.48s (±  1.73%) | 3.83s (±  1.77%) | +0.35s (+ 10.19%) | 3.78s | 3.92s |\n| Emit Time | 1.91s (±  3.15%) | 1.62s (±  3.72%) | -0.29s (- 15.12%) | 1.58s | 1.71s |\n| Total Time | 8.41s (±  0.61%) | 8.42s (±  1.66%) | +0.01s (+  0.12%) | 8.32s | 8.63s |\n#### TFS\n##### tsc (x86)\n\n| Project | Baseline | Current | Delta | Best | Worst |\n| --- | --- | --- | --- | --- | --- |\n| Parse Time | 1.22s (±  2.62%) | 1.22s (±  5.54%) | -0.01s (-  0.49%) | 1.17s | 1.28s |\n| Bind Time | 0.56s (±  2.96%) | 0.58s (±  5.13%) | +0.02s (+  4.38%) | 0.57s | 0.63s |\n| Check Time | 2.81s (±  1.48%) | 2.84s (±  3.00%) | +0.03s (+  1.03%) | 2.77s | 2.95s |\n| Emit Time | 3.11s (±  0.85%) | 3.16s (±  1.84%) | +0.05s (+  1.56%) | 3.08s | 3.21s |\n| Total Time | 7.70s (±  0.84%) | 7.81s (±  2.01%) | +0.10s (+  1.32%) | 7.60s | 7.94s |\n##### node (v6.7.0, x64)\n\n| Project | Baseline | Current | Delta | Best | Worst |\n| --- | --- | --- | --- | --- | --- |\n| Memory used | 328,005k (±  0.00%) | 329,980k (±  0.02%) | +1,975k (+  0.60%) | 329,913k | 330,079k |\n| Parse Time | 1.50s (±  1.02%) | 1.49s (±  0.69%) | -0.02s (-  1.13%) | 1.47s | 1.49s |\n| Bind Time | 0.73s (±  0.73%) | 0.71s (±  3.11%) | -0.01s (-  2.00%) | 0.68s | 0.73s |\n| Check Time | 3.89s (±  0.65%) | 4.04s (±  1.24%) | +0.15s (+  3.87%) | 3.96s | 4.06s |\n| Emit Time | 1.54s (±  0.91%) | 1.64s (±  0.63%) | +0.10s (+  6.55%) | 1.63s | 1.65s |\n| Total Time | 7.65s (±  0.65%) | 7.87s (±  0.76%) | +0.21s (+  2.80%) | 7.79s | 7.92s |\n##### node (v6.7.0, x86)\n\n| Project | Baseline | Current | Delta | Best | Worst |\n| --- | --- | --- | --- | --- | --- |\n| Memory used | 174,749k (±  0.00%) | 175,835k (±  0.01%) | +1,086k (+  0.62%) | 175,822k | 175,855k |\n| Parse Time | 1.41s (±  1.63%) | 1.39s (±  0.74%) | -0.02s (-  1.10%) | 1.39s | 1.41s |\n| Bind Time | 0.62s (±  5.95%) | 0.57s (±  3.30%) | -0.05s (-  8.48%) | 0.56s | 0.59s |\n| Check Time | 2.98s (±  0.64%) | 2.99s (±  1.14%) | +0.02s (+  0.60%) | 2.96s | 3.04s |\n| Emit Time | 1.35s (±  0.83%) | 1.38s (±  4.53%) | +0.03s (+  2.52%) | 1.33s | 1.45s |\n| Total Time | 6.36s (±  1.07%) | 6.34s (±  1.32%) | -0.02s (-  0.25%) | 6.25s | 6.43s |\n### Heap snapshot numbers\n\nThe memory usage tended to be about the same up until the `beforeEmit` event, AKA after checking.\n\nMaster had 365,935 KB total, map4 had 343,774 KB (94% as much), and map4 with shims had 368,978 KB (100% as much as master, 106% as much as map4).\n\n(I added an event `heapAfterBind` to test the effects of that; map4 used 97% as much memory as master, meaning the real memory savings are during checking.)\n\nFor map4, the chrome heap snaprhot viewer shows Maps as accounting for 2% of all objects, with a shallow size equal to their retained size at 1%. However, this is misleading because most of them are mere 32KB wrapper objects which have internal `_keys` and `_values` (or `table` in some cases), which is what really takes up space. I wish there were a way we could include the size of those.\n### VSCode numbers\n\nI also ran a simple test on the VSCode repo.\n#### master\n\n`tsc -p src --noEmit --diagnostics` (Run with `2.1.0-dev.20161005`)\n\n| Kind | Amount | Samples |\n| --- | --- | --- |\n| Memory used | 737211 K | 736716, 733971, 743103, 742334, 729932 |\n| I/O read | 0.17 s | 0.27, 0.12, 0.20, 0.14, 0.14 |\n| Parse time | 5.22 s | 5.21, 5.18, 5.22, 5.22, 5.29 |\n| Bind time | 1.74 s | 1.77, 1.72, 1.74, 1.72, 1.75 |\n| Check time | 8.57 s | 8.69, 8.48, 8.54, 8.50, 8.63 |\n| Total time | 15.54 s | 15.67, 15.38, 15.51, 15.45, 15.67 |\n#### map4\n\n`node ../TypeScript/built/local/tsc.js -p src --noEmit --diagnostics`\n\n| Kind | Relative | Amount | Samples |\n| --- | --- | --- | --- |\n| Memory used | 94% | 690972 K | 691500, 690621, 691097, 690872, 690772 |\n| I/O read: | 100% | 0.17 s | 0.16, 0.18, 0.20, 0.14, 0.16 |\n| Parse time | 96% | 5.02 s | 5.03, 4.95, 4.99, 4.96, 5.18 |\n| Bind time: | 83% | 1.44 s | 1.42, 1.40, 1.44, 1.42, 1.53 |\n| Check time | 97% | 8.34 s | 8.32, 8.27, 8.38, 8.42, 8.33 |\n| Total time | 95% | 14.81 s | 14.78, 14.62, 14.81, 14.80, 15.05 |\n#### map4 with shims\n\nSame command as for `map4`, after rebuilding with `usingNativeMaps = false` and `usingNativeSets = false`.\n\n| Kind | Relative | Amount | Samples |\n| --- | --- | --- | --- |\n| Memory used | 101% | 744718 K | 745408, 744639, 744845, 745511, 743185 |\n| I/O read | 106% | 0.18 s | 0.22, 0.19, 0.20, 0.14, 0.17 |\n| Parse time | 99% | 5.19 s | 5.28, 5.18, 5.20, 5.17, 5.13 |\n| Bind time | 98% | 1.71 s | 1.72, 1.69, 1.70, 1.73, 1.72 |\n| Check time | 101% | 8.68 s | 8.58, 8.72, 8.68, 8.72, 8.73 |\n| Total time | 100% | 15.59 s | 15.59, 15.59, 15.58, 15.62, 15.57 |\n","reactions":{"url":"https://api.github.com/repos/microsoft/TypeScript/issues/11354/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/microsoft/TypeScript/issues/11354/timeline","performed_via_github_app":null,"state_reason":null,"score":1,"files":[{"sha":"8425751c4d41c09b4519e79f17ae792016db1bec","filename":"Jakefile.js","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/Jakefile.js","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/Jakefile.js","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/Jakefile.js?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -57,6 +57,7 @@ function measure(marker) {\n }\r\n \r\n var compilerSources = [\r\n+    \"collections.ts\",\r\n     \"core.ts\",\r\n     \"performance.ts\",\r\n     \"sys.ts\",\r\n@@ -93,6 +94,7 @@ var compilerSources = [\n });\r\n \r\n var servicesSources = [\r\n+    \"collections.ts\",\r\n     \"core.ts\",\r\n     \"performance.ts\",\r\n     \"sys.ts\",\r"},{"sha":"a7e2f24fdb8858cb4049ae7d06a2516f86dddf99","filename":"scripts/processDiagnosticMessages.ts","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/scripts%2FprocessDiagnosticMessages.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/scripts%2FprocessDiagnosticMessages.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/scripts%2FprocessDiagnosticMessages.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -27,7 +27,7 @@ function main(): void {\n \r\n     var inputFilePath = sys.args[0].replace(/\\\\/g, \"/\");\r\n     var inputStr = sys.readFile(inputFilePath);\r\n-    \r\n+\r\n     var diagnosticMessages: InputDiagnosticMessageTable = JSON.parse(inputStr);\r\n \r\n     var names = Utilities.getObjectKeys(diagnosticMessages);\r\n@@ -44,7 +44,7 @@ function main(): void {\n function checkForUniqueCodes(messages: string[], diagnosticTable: InputDiagnosticMessageTable) {\r\n     const originalMessageForCode: string[] = [];\r\n     let numConflicts = 0;\r\n-    \r\n+\r\n     for (const currentMessage of messages) {\r\n         const code = diagnosticTable[currentMessage].code;\r\n \r\n@@ -68,19 +68,19 @@ function checkForUniqueCodes(messages: string[], diagnosticTable: InputDiagnosti\n     }\r\n }\r\n \r\n-function buildUniqueNameMap(names: string[]): ts.Map<string> {\r\n-    var nameMap = ts.createMap<string>();\r\n+function buildUniqueNameMap(names: string[]): ts.Map<string, string> {\r\n+    var nameMap = ts.createMap<string, string>();\r\n \r\n     var uniqueNames = NameGenerator.ensureUniqueness(names, /* isCaseSensitive */ false, /* isFixed */ undefined);\r\n \r\n     for (var i = 0; i < names.length; i++) {\r\n-        nameMap[names[i]] = uniqueNames[i];\r\n+        nameMap.set(names[i], uniqueNames[i]);\r\n     }\r\n \r\n     return nameMap;\r\n }\r\n \r\n-function buildInfoFileOutput(messageTable: InputDiagnosticMessageTable, nameMap: ts.Map<string>): string {\r\n+function buildInfoFileOutput(messageTable: InputDiagnosticMessageTable, nameMap: ts.Map<string, string>): string {\r\n     var result =\r\n         '// <auto-generated />\\r\\n' +\r\n         '/// <reference path=\"types.ts\" />\\r\\n' +\r\n@@ -91,7 +91,7 @@ function buildInfoFileOutput(messageTable: InputDiagnosticMessageTable, nameMap:\n     for (var i = 0; i < names.length; i++) {\r\n         var name = names[i];\r\n         var diagnosticDetails = messageTable[name];\r\n-        var propName = convertPropertyName(nameMap[name]);\r\n+        var propName = convertPropertyName(nameMap.get(name));\r\n \r\n         result +=\r\n         '        ' + propName +\r\n@@ -107,14 +107,14 @@ function buildInfoFileOutput(messageTable: InputDiagnosticMessageTable, nameMap:\n     return result;\r\n }\r\n \r\n-function buildDiagnosticMessageOutput(messageTable: InputDiagnosticMessageTable, nameMap: ts.Map<string>): string {\r\n+function buildDiagnosticMessageOutput(messageTable: InputDiagnosticMessageTable, nameMap: ts.Map<string, string>): string {\r\n     var result =\r\n         '{';\r\n     var names = Utilities.getObjectKeys(messageTable);\r\n     for (var i = 0; i < names.length; i++) {\r\n         var name = names[i];\r\n         var diagnosticDetails = messageTable[name];\r\n-        var propName = convertPropertyName(nameMap[name]);\r\n+        var propName = convertPropertyName(nameMap.get(name));\r\n \r\n         result += '\\r\\n  \"' + createKey(propName, diagnosticDetails.code) + '\"' + ' : \"' + name.replace(/[\\\"]/g, '\\\\\"') + '\"';\r\n         if (i !== names.length - 1) {\r"},{"sha":"9bf8d4846ce129306fe885465a52a66b1ae56b35","filename":"src/compiler/binder.ts","status":"modified","additions":22,"deletions":22,"changes":44,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fbinder.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fbinder.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Fbinder.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -133,7 +133,7 @@ namespace ts {\n \r\n         let symbolCount = 0;\r\n         let Symbol: { new (flags: SymbolFlags, name: string): Symbol };\r\n-        let classifiableNames: Map<string>;\r\n+        let classifiableNames: Set<string>;\r\n \r\n         const unreachableFlow: FlowNode = { flags: FlowFlags.Unreachable };\r\n         const reportedUnreachableFlow: FlowNode = { flags: FlowFlags.Unreachable };\r\n@@ -147,7 +147,7 @@ namespace ts {\n             options = opts;\r\n             languageVersion = getEmitScriptTarget(options);\r\n             inStrictMode = bindInStrictMode(file, opts);\r\n-            classifiableNames = createMap<string>();\r\n+            classifiableNames = createSet();\r\n             symbolCount = 0;\r\n             skipTransformFlagAggregation = isDeclarationFile(file);\r\n \r\n@@ -207,11 +207,11 @@ namespace ts {\n             symbol.declarations.push(node);\r\n \r\n             if (symbolFlags & SymbolFlags.HasExports && !symbol.exports) {\r\n-                symbol.exports = createMap<Symbol>();\r\n+                symbol.exports = createMap<string, Symbol>();\r\n             }\r\n \r\n             if (symbolFlags & SymbolFlags.HasMembers && !symbol.members) {\r\n-                symbol.members = createMap<Symbol>();\r\n+                symbol.members = createMap<string, Symbol>();\r\n             }\r\n \r\n             if (symbolFlags & SymbolFlags.Value) {\r\n@@ -349,17 +349,17 @@ namespace ts {\n                 // Otherwise, we'll be merging into a compatible existing symbol (for example when\r\n                 // you have multiple 'vars' with the same name in the same container).  In this case\r\n                 // just add this node into the declarations list of the symbol.\r\n-                symbol = symbolTable[name] || (symbolTable[name] = createSymbol(SymbolFlags.None, name));\r\n+                symbol = getOrUpdate(symbolTable, name, name => createSymbol(SymbolFlags.None, name));\r\n \r\n                 if (name && (includes & SymbolFlags.Classifiable)) {\r\n-                    classifiableNames[name] = name;\r\n+                    classifiableNames.add(name);\r\n                 }\r\n \r\n                 if (symbol.flags & excludes) {\r\n                     if (symbol.isReplaceableByMethod) {\r\n                         // Javascript constructor-declared symbols can be discarded in favor of\r\n                         // prototype symbols like methods.\r\n-                        symbol = symbolTable[name] = createSymbol(SymbolFlags.None, name);\r\n+                        symbol = setAndReturn(symbolTable, name, createSymbol(SymbolFlags.None, name));\r\n                     }\r\n                     else {\r\n                         if (node.name) {\r\n@@ -484,7 +484,7 @@ namespace ts {\n             if (containerFlags & ContainerFlags.IsContainer) {\r\n                 container = blockScopeContainer = node;\r\n                 if (containerFlags & ContainerFlags.HasLocals) {\r\n-                    container.locals = createMap<Symbol>();\r\n+                    container.locals = createMap<string, Symbol>();\r\n                 }\r\n                 addToContainerChain(container);\r\n             }\r\n@@ -1525,8 +1525,7 @@ namespace ts {\n \r\n             const typeLiteralSymbol = createSymbol(SymbolFlags.TypeLiteral, \"__type\");\r\n             addDeclarationToSymbol(typeLiteralSymbol, node, SymbolFlags.TypeLiteral);\r\n-            typeLiteralSymbol.members = createMap<Symbol>();\r\n-            typeLiteralSymbol.members[symbol.name] = symbol;\r\n+            typeLiteralSymbol.members = createMap([[symbol.name, symbol]]);\r\n         }\r\n \r\n         function bindObjectLiteralExpression(node: ObjectLiteralExpression) {\r\n@@ -1536,7 +1535,7 @@ namespace ts {\n             }\r\n \r\n             if (inStrictMode) {\r\n-                const seen = createMap<ElementKind>();\r\n+                const seen = createMap<string, ElementKind>();\r\n \r\n                 for (const prop of node.properties) {\r\n                     if (prop.name.kind !== SyntaxKind.Identifier) {\r\n@@ -1557,9 +1556,9 @@ namespace ts {\n                         ? ElementKind.Property\r\n                         : ElementKind.Accessor;\r\n \r\n-                    const existingKind = seen[identifier.text];\r\n+                    const existingKind = seen.get(identifier.text);\r\n                     if (!existingKind) {\r\n-                        seen[identifier.text] = currentKind;\r\n+                        seen.set(identifier.text, currentKind);\r\n                         continue;\r\n                     }\r\n \r\n@@ -1592,7 +1591,7 @@ namespace ts {\n                 // fall through.\r\n                 default:\r\n                     if (!blockScopeContainer.locals) {\r\n-                        blockScopeContainer.locals = createMap<Symbol>();\r\n+                        blockScopeContainer.locals = createMap<string, Symbol>();\r\n                         addToContainerChain(blockScopeContainer);\r\n                     }\r\n                     declareSymbol(blockScopeContainer.locals, undefined, node, symbolFlags, symbolExcludes);\r\n@@ -2072,7 +2071,7 @@ namespace ts {\n                 }\r\n             }\r\n \r\n-            file.symbol.globalExports = file.symbol.globalExports || createMap<Symbol>();\r\n+            file.symbol.globalExports = file.symbol.globalExports || createMap<string, Symbol>();\r\n             declareSymbol(file.symbol.globalExports, file.symbol, node, SymbolFlags.Alias, SymbolFlags.AliasExcludes);\r\n         }\r\n \r\n@@ -2119,7 +2118,7 @@ namespace ts {\n             Debug.assert(isInJavaScriptFile(node));\r\n             // Declare a 'member' if the container is an ES5 class or ES6 constructor\r\n             if (container.kind === SyntaxKind.FunctionDeclaration || container.kind === SyntaxKind.FunctionExpression) {\r\n-                container.symbol.members = container.symbol.members || createMap<Symbol>();\r\n+                container.symbol.members = container.symbol.members || createMap<string, Symbol>();\r\n                 // It's acceptable for multiple 'this' assignments of the same identifier to occur\r\n                 declareSymbol(container.symbol.members, container.symbol, node, SymbolFlags.Property, SymbolFlags.PropertyExcludes & ~SymbolFlags.Property);\r\n             }\r\n@@ -2151,14 +2150,14 @@ namespace ts {\n             constructorFunction.parent = classPrototype;\r\n             classPrototype.parent = leftSideOfAssignment;\r\n \r\n-            const funcSymbol = container.locals[constructorFunction.text];\r\n+            const funcSymbol = container.locals.get(constructorFunction.text);\r\n             if (!funcSymbol || !(funcSymbol.flags & SymbolFlags.Function || isDeclarationOfFunctionExpression(funcSymbol))) {\r\n                 return;\r\n             }\r\n \r\n             // Set up the members collection if it doesn't exist already\r\n             if (!funcSymbol.members) {\r\n-                funcSymbol.members = createMap<Symbol>();\r\n+                funcSymbol.members = createMap<string, Symbol>();\r\n             }\r\n \r\n             // Declare the method/property\r\n@@ -2191,7 +2190,7 @@ namespace ts {\n                 bindAnonymousDeclaration(node, SymbolFlags.Class, bindingName);\r\n                 // Add name of class expression into the map for semantic classifier\r\n                 if (node.name) {\r\n-                    classifiableNames[node.name.text] = node.name.text;\r\n+                    classifiableNames.add(node.name.text);\r\n                 }\r\n             }\r\n \r\n@@ -2207,14 +2206,15 @@ namespace ts {\n             // module might have an exported variable called 'prototype'.  We can't allow that as\r\n             // that would clash with the built-in 'prototype' for the class.\r\n             const prototypeSymbol = createSymbol(SymbolFlags.Property | SymbolFlags.Prototype, \"prototype\");\r\n-            if (symbol.exports[prototypeSymbol.name]) {\r\n+            const symbolExport = symbol.exports.get(prototypeSymbol.name);\r\n+            if (symbolExport) {\r\n                 if (node.name) {\r\n                     node.name.parent = node;\r\n                 }\r\n-                file.bindDiagnostics.push(createDiagnosticForNode(symbol.exports[prototypeSymbol.name].declarations[0],\r\n+                file.bindDiagnostics.push(createDiagnosticForNode(symbolExport.declarations[0],\r\n                     Diagnostics.Duplicate_identifier_0, prototypeSymbol.name));\r\n             }\r\n-            symbol.exports[prototypeSymbol.name] = prototypeSymbol;\r\n+            symbol.exports.set(prototypeSymbol.name, prototypeSymbol);\r\n             prototypeSymbol.parent = symbol;\r\n         }\r\n \r"},{"sha":"281190d325653ed5b6023c9c85b680865b222ad7","filename":"src/compiler/checker.ts","status":"modified","additions":246,"deletions":242,"changes":488,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fchecker.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fchecker.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Fchecker.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -47,7 +47,7 @@ namespace ts {\n         let symbolCount = 0;\r\n \r\n         const emptyArray: any[] = [];\r\n-        const emptySymbols = createMap<Symbol>();\r\n+        const emptySymbols = createMap<string, Symbol>();\r\n \r\n         const compilerOptions = host.getCompilerOptions();\r\n         const languageVersion = compilerOptions.target || ScriptTarget.ES3;\r\n@@ -111,10 +111,10 @@ namespace ts {\n         };\r\n \r\n         const tupleTypes: GenericType[] = [];\r\n-        const unionTypes = createMap<UnionType>();\r\n-        const intersectionTypes = createMap<IntersectionType>();\r\n-        const stringLiteralTypes = createMap<LiteralType>();\r\n-        const numericLiteralTypes = createMap<LiteralType>();\r\n+        const unionTypes = createMap<string, UnionType>();\r\n+        const intersectionTypes = createMap<string, IntersectionType>();\r\n+        const stringLiteralTypes = createMap<string, LiteralType>();\r\n+        const numericLiteralTypes = createMap<string, LiteralType>();\r\n         const evolvingArrayTypes: EvolvingArrayType[] = [];\r\n \r\n         const unknownSymbol = createSymbol(SymbolFlags.Property | SymbolFlags.Transient, \"unknown\");\r\n@@ -139,7 +139,7 @@ namespace ts {\n \r\n         const emptyObjectType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);\r\n         const emptyGenericType = <GenericType><ObjectType>createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);\r\n-        emptyGenericType.instantiations = createMap<TypeReference>();\r\n+        emptyGenericType.instantiations = createMap<string, TypeReference>();\r\n \r\n         const anyFunctionType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);\r\n         // The anyFunctionType contains the anyFunctionType by definition. The flag is further propagated\r\n@@ -155,7 +155,7 @@ namespace ts {\n \r\n         const enumNumberIndexInfo = createIndexInfo(stringType, /*isReadonly*/ true);\r\n \r\n-        const globals = createMap<Symbol>();\r\n+        const globals = createMap<string, Symbol>();\r\n         /**\r\n          * List of every ambient module with a \"*\" wildcard.\r\n          * Unlike other ambient modules, these can't be stored in `globals` because symbol tables only deal with exact matches.\r\n@@ -221,7 +221,7 @@ namespace ts {\n         const mergedSymbols: Symbol[] = [];\r\n         const symbolLinks: SymbolLinks[] = [];\r\n         const nodeLinks: NodeLinks[] = [];\r\n-        const flowLoopCaches: Map<Type>[] = [];\r\n+        const flowLoopCaches: Map<string, Type>[] = [];\r\n         const flowLoopNodes: FlowNode[] = [];\r\n         const flowLoopKeys: string[] = [];\r\n         const flowLoopTypes: Type[][] = [];\r\n@@ -295,7 +295,7 @@ namespace ts {\n             NullFacts = TypeofEQObject | TypeofNEString | TypeofNENumber | TypeofNEBoolean | TypeofNESymbol | TypeofNEFunction | TypeofNEHostObject | EQNull | EQUndefinedOrNull | NEUndefined | Falsy,\r\n         }\r\n \r\n-        const typeofEQFacts = createMap({\r\n+        const typeofEQFacts = mapOfMapLike({\r\n             \"string\": TypeFacts.TypeofEQString,\r\n             \"number\": TypeFacts.TypeofEQNumber,\r\n             \"boolean\": TypeFacts.TypeofEQBoolean,\r\n@@ -305,7 +305,7 @@ namespace ts {\n             \"function\": TypeFacts.TypeofEQFunction\r\n         });\r\n \r\n-        const typeofNEFacts = createMap({\r\n+        const typeofNEFacts = mapOfMapLike({\r\n             \"string\": TypeFacts.TypeofNEString,\r\n             \"number\": TypeFacts.TypeofNENumber,\r\n             \"boolean\": TypeFacts.TypeofNEBoolean,\r\n@@ -315,7 +315,7 @@ namespace ts {\n             \"function\": TypeFacts.TypeofNEFunction\r\n         });\r\n \r\n-        const typeofTypesByName = createMap<Type>({\r\n+        const typeofTypesByName = mapOfMapLike<Type>({\r\n             \"string\": stringType,\r\n             \"number\": numberType,\r\n             \"boolean\": booleanType,\r\n@@ -325,7 +325,7 @@ namespace ts {\n \r\n         let jsxElementType: Type;\r\n         /** Things we lazy load from the JSX namespace */\r\n-        const jsxTypes = createMap<Type>();\r\n+        const jsxTypes = createMap<string, Type>();\r\n         const JsxNames = {\r\n             JSX: \"JSX\",\r\n             IntrinsicElements: \"IntrinsicElements\",\r\n@@ -336,11 +336,11 @@ namespace ts {\n             IntrinsicClassAttributes: \"IntrinsicClassAttributes\"\r\n         };\r\n \r\n-        const subtypeRelation = createMap<RelationComparisonResult>();\r\n-        const assignableRelation = createMap<RelationComparisonResult>();\r\n-        const comparableRelation = createMap<RelationComparisonResult>();\r\n-        const identityRelation = createMap<RelationComparisonResult>();\r\n-        const enumRelation = createMap<boolean>();\r\n+        const subtypeRelation = createMap<string, RelationComparisonResult>();\r\n+        const assignableRelation = createMap<string, RelationComparisonResult>();\r\n+        const comparableRelation = createMap<string, RelationComparisonResult>();\r\n+        const identityRelation = createMap<string, RelationComparisonResult>();\r\n+        const enumRelation = createMap<string, boolean>();\r\n \r\n         // This is for caching the result of getSymbolDisplayBuilder. Do not access directly.\r\n         let _displayBuilder: SymbolDisplayBuilder;\r\n@@ -354,8 +354,7 @@ namespace ts {\n             ResolvedReturnType\r\n         }\r\n \r\n-        const builtinGlobals = createMap<Symbol>();\r\n-        builtinGlobals[undefinedSymbol.name] = undefinedSymbol;\r\n+        const builtinGlobals = createMap([[undefinedSymbol.name, undefinedSymbol]]);\r\n \r\n         initializeTypeChecker();\r\n \r\n@@ -438,11 +437,11 @@ namespace ts {\n                     target.declarations.push(node);\r\n                 });\r\n                 if (source.members) {\r\n-                    if (!target.members) target.members = createMap<Symbol>();\r\n+                    if (!target.members) target.members = createMap<string, Symbol>();\r\n                     mergeSymbolTable(target.members, source.members);\r\n                 }\r\n                 if (source.exports) {\r\n-                    if (!target.exports) target.exports = createMap<Symbol>();\r\n+                    if (!target.exports) target.exports = createMap<string, Symbol>();\r\n                     mergeSymbolTable(target.exports, source.exports);\r\n                 }\r\n                 recordMergedSymbol(target, source);\r\n@@ -460,18 +459,18 @@ namespace ts {\n         }\r\n \r\n         function mergeSymbolTable(target: SymbolTable, source: SymbolTable) {\r\n-            for (const id in source) {\r\n-                let targetSymbol = target[id];\r\n+            source.forEach((sourceSymbol, id) => {\r\n+                let targetSymbol = target.get(id);\r\n                 if (!targetSymbol) {\r\n-                    target[id] = source[id];\r\n+                    target.set(id, sourceSymbol);\r\n                 }\r\n                 else {\r\n                     if (!(targetSymbol.flags & SymbolFlags.Merged)) {\r\n-                        target[id] = targetSymbol = cloneSymbol(targetSymbol);\r\n+                        target.set(id, targetSymbol = cloneSymbol(targetSymbol));\r\n                     }\r\n-                    mergeSymbol(targetSymbol, source[id]);\r\n+                    mergeSymbol(targetSymbol, sourceSymbol);\r\n                 }\r\n-            }\r\n+            });\r\n         }\r\n \r\n         function mergeModuleAugmentation(moduleName: LiteralExpression): void {\r\n@@ -512,15 +511,16 @@ namespace ts {\n         }\r\n \r\n         function addToSymbolTable(target: SymbolTable, source: SymbolTable, message: DiagnosticMessage) {\r\n-            for (const id in source) {\r\n-                if (target[id]) {\r\n+            source.forEach((sourceSymbol, id) => {\r\n+                const symbol = target.get(id);\r\n+                if (symbol) {\r\n                     // Error on redeclarations\r\n-                    forEach(target[id].declarations, addDeclarationDiagnostic(id, message));\r\n+                    forEach(symbol.declarations, addDeclarationDiagnostic(id, message));\r\n                 }\r\n                 else {\r\n-                    target[id] = source[id];\r\n+                    target.set(id, sourceSymbol);\r\n                 }\r\n-            }\r\n+            });\r\n \r\n             function addDeclarationDiagnostic(id: string, message: DiagnosticMessage) {\r\n                 return (declaration: Declaration) => diagnostics.add(createDiagnosticForNode(declaration, message, id));\r\n@@ -548,7 +548,7 @@ namespace ts {\n \r\n         function getSymbol(symbols: SymbolTable, name: string, meaning: SymbolFlags): Symbol {\r\n             if (meaning) {\r\n-                const symbol = symbols[name];\r\n+                const symbol = symbols.get(name);\r\n                 if (symbol) {\r\n                     Debug.assert((symbol.flags & SymbolFlags.Instantiated) === 0, \"Should never get an instantiated symbol here.\");\r\n                     if (symbol.flags & meaning) {\r\n@@ -733,7 +733,7 @@ namespace ts {\n \r\n                             // It's an external module. First see if the module has an export default and if the local\r\n                             // name of that export default matches.\r\n-                            if (result = moduleExports[\"default\"]) {\r\n+                            if (result = moduleExports.get(\"default\")) {\r\n                                 const localSymbol = getLocalSymbolForExportDefault(result);\r\n                                 if (localSymbol && (result.flags & meaning) && localSymbol.name === name) {\r\n                                     break loop;\r\n@@ -752,9 +752,10 @@ namespace ts {\n                             //     2. We check === SymbolFlags.Alias in order to check that the symbol is *purely*\r\n                             //        an alias. If we used &, we'd be throwing out symbols that have non alias aspects,\r\n                             //        which is not the desired behavior.\r\n-                            if (moduleExports[name] &&\r\n-                                moduleExports[name].flags === SymbolFlags.Alias &&\r\n-                                getDeclarationOfKind(moduleExports[name], SyntaxKind.ExportSpecifier)) {\r\n+                            const moduleExport = moduleExports.get(name);\r\n+                            if (moduleExport &&\r\n+                                moduleExport.flags === SymbolFlags.Alias &&\r\n+                                getDeclarationOfKind(moduleExport, SyntaxKind.ExportSpecifier)) {\r\n                                 break;\r\n                             }\r\n                         }\r\n@@ -1069,11 +1070,16 @@ namespace ts {\n             const moduleSymbol = resolveExternalModuleName(node, (<ImportDeclaration>node.parent).moduleSpecifier);\r\n \r\n             if (moduleSymbol) {\r\n-                const exportDefaultSymbol = isUntypedModuleSymbol(moduleSymbol) ?\r\n-                    moduleSymbol :\r\n-                    moduleSymbol.exports[\"export=\"] ?\r\n-                        getPropertyOfType(getTypeOfSymbol(moduleSymbol.exports[\"export=\"]), \"default\") :\r\n-                        resolveSymbol(moduleSymbol.exports[\"default\"]);\r\n+                let exportDefaultSymbol: Symbol;\r\n+                if (isUntypedModuleSymbol(moduleSymbol)) {\r\n+                    exportDefaultSymbol = moduleSymbol;\r\n+                }\r\n+                else {\r\n+                    const exportValue = moduleSymbol.exports.get(\"export=\");\r\n+                    exportDefaultSymbol = exportValue\r\n+                        ? getPropertyOfType(getTypeOfSymbol(exportValue), \"default\")\r\n+                        : resolveSymbol(moduleSymbol.exports.get(\"default\"));\r\n+                }\r\n \r\n                 if (!exportDefaultSymbol && !allowSyntheticDefaultImports) {\r\n                     error(node.name, Diagnostics.Module_0_has_no_default_export, symbolToString(moduleSymbol));\r\n@@ -1123,7 +1129,7 @@ namespace ts {\n \r\n         function getExportOfModule(symbol: Symbol, name: string): Symbol {\r\n             if (symbol.flags & SymbolFlags.Module) {\r\n-                const exportedSymbol = getExportsOfSymbol(symbol)[name];\r\n+                const exportedSymbol = getExportsOfSymbol(symbol).get(name);\r\n                 if (exportedSymbol) {\r\n                     return resolveSymbol(exportedSymbol);\r\n                 }\r\n@@ -1151,7 +1157,7 @@ namespace ts {\n \r\n                     let symbolFromVariable: Symbol;\r\n                     // First check if module was specified with \"export=\". If so, get the member from the resolved type\r\n-                    if (moduleSymbol && moduleSymbol.exports && moduleSymbol.exports[\"export=\"]) {\r\n+                    if (moduleSymbol && moduleSymbol.exports && moduleSymbol.exports.get(\"export=\")) {\r\n                         symbolFromVariable = getPropertyOfType(getTypeOfSymbol(targetSymbol), name.text);\r\n                     }\r\n                     else {\r\n@@ -1412,9 +1418,9 @@ namespace ts {\n                 // This provides a name to the module. See the test tests/cases/fourslash/untypedModuleImport.ts\r\n                 const newSymbol = createSymbol(SymbolFlags.ValueModule, quotedName);\r\n                 // Module symbols are expected to have 'exports', although since this is an untyped module it can be empty.\r\n-                newSymbol.exports = createMap<Symbol>();\r\n+                newSymbol.exports = createMap<string, Symbol>();\r\n                 // Cache it so subsequent accesses will return the same module.\r\n-                globals[quotedName] = newSymbol;\r\n+                globals.set(quotedName, newSymbol);\r\n                 return newSymbol;\r\n             }\r\n \r\n@@ -1440,7 +1446,7 @@ namespace ts {\n         // An external module with an 'export =' declaration resolves to the target of the 'export =' declaration,\r\n         // and an external module with no 'export =' declaration resolves to the module itself.\r\n         function resolveExternalModuleSymbol(moduleSymbol: Symbol): Symbol {\r\n-            return moduleSymbol && getMergedSymbol(resolveSymbol(moduleSymbol.exports[\"export=\"])) || moduleSymbol;\r\n+            return moduleSymbol && getMergedSymbol(resolveSymbol(moduleSymbol.exports.get(\"export=\"))) || moduleSymbol;\r\n         }\r\n \r\n         // An external module with an 'export =' declaration may be referenced as an ES6 module provided the 'export ='\r\n@@ -1456,7 +1462,7 @@ namespace ts {\n         }\r\n \r\n         function hasExportAssignmentSymbol(moduleSymbol: Symbol): boolean {\r\n-            return moduleSymbol.exports[\"export=\"] !== undefined;\r\n+            return moduleSymbol.exports.get(\"export=\") !== undefined;\r\n         }\r\n \r\n         function getExportsOfModuleAsArray(moduleSymbol: Symbol): Symbol[] {\r\n@@ -1481,25 +1487,29 @@ namespace ts {\n          * Extends one symbol table with another while collecting information on name collisions for error message generation into the `lookupTable` argument\r\n          * Not passing `lookupTable` and `exportNode` disables this collection, and just extends the tables\r\n          */\r\n-        function extendExportSymbols(target: SymbolTable, source: SymbolTable, lookupTable?: Map<ExportCollisionTracker>, exportNode?: ExportDeclaration) {\r\n-            for (const id in source) {\r\n-                if (id !== \"default\" && !target[id]) {\r\n-                    target[id] = source[id];\r\n+        function extendExportSymbols(target: SymbolTable, source: SymbolTable, lookupTable?: Map<string, ExportCollisionTracker>, exportNode?: ExportDeclaration) {\r\n+            if (!source) return;\r\n+\r\n+            source.forEach((sourceSymbol, id) => {\r\n+                const targetSymbol = target.get(id);\r\n+                if (id !== \"default\" && !targetSymbol) {\r\n+                    target.set(id, sourceSymbol);\r\n                     if (lookupTable && exportNode) {\r\n-                        lookupTable[id] = {\r\n+                        lookupTable.set(id, {\r\n                             specifierText: getTextOfNode(exportNode.moduleSpecifier)\r\n-                        } as ExportCollisionTracker;\r\n+                        } as ExportCollisionTracker);\r\n                     }\r\n                 }\r\n-                else if (lookupTable && exportNode && id !== \"default\" && target[id] && resolveSymbol(target[id]) !== resolveSymbol(source[id])) {\r\n-                    if (!lookupTable[id].exportsWithDuplicate) {\r\n-                        lookupTable[id].exportsWithDuplicate = [exportNode];\r\n+                else if (lookupTable && exportNode && id !== \"default\" && targetSymbol && resolveSymbol(targetSymbol) !== resolveSymbol(sourceSymbol)) {\r\n+                    const collisionTracker = lookupTable.get(id);\r\n+                    if (!collisionTracker.exportsWithDuplicate) {\r\n+                        collisionTracker.exportsWithDuplicate = [exportNode];\r\n                     }\r\n                     else {\r\n-                        lookupTable[id].exportsWithDuplicate.push(exportNode);\r\n+                        collisionTracker.exportsWithDuplicate.push(exportNode);\r\n                     }\r\n                 }\r\n-            }\r\n+            });\r\n         }\r\n \r\n         function getExportsForModule(moduleSymbol: Symbol): SymbolTable {\r\n@@ -1519,10 +1529,10 @@ namespace ts {\n                 visitedSymbols.push(symbol);\r\n                 const symbols = cloneMap(symbol.exports);\r\n                 // All export * declarations are collected in an __export symbol by the binder\r\n-                const exportStars = symbol.exports[\"__export\"];\r\n+                const exportStars = symbol.exports.get(\"__export\");\r\n                 if (exportStars) {\r\n-                    const nestedSymbols = createMap<Symbol>();\r\n-                    const lookupTable = createMap<ExportCollisionTracker>();\r\n+                    const nestedSymbols = createMap<string, Symbol>();\r\n+                    const lookupTable = createMap<string, ExportCollisionTracker>();\r\n                     for (const node of exportStars.declarations) {\r\n                         const resolvedModule = resolveExternalModuleName(node, (node as ExportDeclaration).moduleSpecifier);\r\n                         const exportedSymbols = visit(resolvedModule);\r\n@@ -1533,21 +1543,20 @@ namespace ts {\n                             node as ExportDeclaration\r\n                         );\r\n                     }\r\n-                    for (const id in lookupTable) {\r\n-                        const { exportsWithDuplicate } = lookupTable[id];\r\n+                    lookupTable.forEach(({ exportsWithDuplicate }, id) => {\r\n                         // It's not an error if the file with multiple `export *`s with duplicate names exports a member with that name itself\r\n-                        if (id === \"export=\" || !(exportsWithDuplicate && exportsWithDuplicate.length) || symbols[id]) {\r\n-                            continue;\r\n+                        if (id === \"export=\" || !(exportsWithDuplicate && exportsWithDuplicate.length) || symbols.get(id)) {\r\n+                            return;\r\n                         }\r\n                         for (const node of exportsWithDuplicate) {\r\n                             diagnostics.add(createDiagnosticForNode(\r\n                                 node,\r\n                                 Diagnostics.Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity,\r\n-                                lookupTable[id].specifierText,\r\n+                                lookupTable.get(id).specifierText,\r\n                                 id\r\n                             ));\r\n                         }\r\n-                    }\r\n+                    });\r\n                     extendExportSymbols(symbols, nestedSymbols);\r\n                 }\r\n                 return symbols;\r\n@@ -1642,15 +1651,14 @@ namespace ts {\n \r\n         function getNamedMembers(members: SymbolTable): Symbol[] {\r\n             let result: Symbol[];\r\n-            for (const id in members) {\r\n+            members.forEach((symbol, id) => {\r\n                 if (!isReservedMemberName(id)) {\r\n                     if (!result) result = [];\r\n-                    const symbol = members[id];\r\n                     if (symbolIsValue(symbol)) {\r\n                         result.push(symbol);\r\n                     }\r\n                 }\r\n-            }\r\n+            });\r\n             return result || emptyArray;\r\n         }\r\n \r\n@@ -1723,12 +1731,12 @@ namespace ts {\n                 }\r\n \r\n                 // If symbol is directly available by its name in the symbol table\r\n-                if (isAccessible(symbols[symbol.name])) {\r\n+                if (isAccessible(symbols.get(symbol.name))) {\r\n                     return [symbol];\r\n                 }\r\n \r\n                 // Check if symbol is any of the alias\r\n-                return forEachProperty(symbols, symbolFromSymbolTable => {\r\n+                return findInMap(symbols, symbolFromSymbolTable => {\r\n                     if (symbolFromSymbolTable.flags & SymbolFlags.Alias\r\n                         && symbolFromSymbolTable.name !== \"export=\"\r\n                         && !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKind.ExportSpecifier)) {\r\n@@ -1763,7 +1771,7 @@ namespace ts {\n             let qualify = false;\r\n             forEachSymbolTableInScope(enclosingDeclaration, symbolTable => {\r\n                 // If symbol of this name is not available in the symbol table we are ok\r\n-                let symbolFromSymbolTable = symbolTable[symbol.name];\r\n+                let symbolFromSymbolTable = symbolTable.get(symbol.name);\r\n                 if (!symbolFromSymbolTable) {\r\n                     // Continue to the next symbol table\r\n                     return false;\r\n@@ -2500,7 +2508,7 @@ namespace ts {\n                     }\r\n                     writeIndexSignature(resolved.stringIndexInfo, SyntaxKind.StringKeyword);\r\n                     writeIndexSignature(resolved.numberIndexInfo, SyntaxKind.NumberKeyword);\r\n-                    for (const p of resolved.properties) {\r\n+                    for (const p of sortInV8ObjectInsertionOrder(resolved.properties, p => p.name)) {\r\n                         const t = getTypeOfSymbol(p);\r\n                         if (p.flags & (SymbolFlags.Function | SymbolFlags.Method) && !getPropertiesOfObjectType(t).length) {\r\n                             const signatures = getSignaturesOfType(t, SignatureKind.Call);\r\n@@ -3229,7 +3237,7 @@ namespace ts {\n \r\n         // Return the type implied by an object binding pattern\r\n         function getTypeFromObjectBindingPattern(pattern: ObjectBindingPattern, includePatternInType: boolean, reportErrors: boolean): Type {\r\n-            const members = createMap<Symbol>();\r\n+            const members = createMap<string, Symbol>();\r\n             let hasComputedProperties = false;\r\n             forEach(pattern.elements, e => {\r\n                 const name = e.propertyName || <Identifier>e.name;\r\n@@ -3244,7 +3252,7 @@ namespace ts {\n                 const symbol = <TransientSymbol>createSymbol(flags, text);\r\n                 symbol.type = getTypeFromBindingElement(e, includePatternInType, reportErrors);\r\n                 symbol.bindingElement = e;\r\n-                members[symbol.name] = symbol;\r\n+                members.set(symbol.name, symbol);\r\n             });\r\n             const result = createAnonymousType(undefined, members, emptyArray, emptyArray, undefined, undefined);\r\n             if (includePatternInType) {\r\n@@ -3834,8 +3842,7 @@ namespace ts {\n                     type.typeParameters = concatenate(outerTypeParameters, localTypeParameters);\r\n                     type.outerTypeParameters = outerTypeParameters;\r\n                     type.localTypeParameters = localTypeParameters;\r\n-                    (<GenericType>type).instantiations = createMap<TypeReference>();\r\n-                    (<GenericType>type).instantiations[getTypeListId(type.typeParameters)] = <GenericType>type;\r\n+                    (<GenericType>type).instantiations = createMap([[getTypeListId(type.typeParameters), <GenericType>type]]);\r\n                     (<GenericType>type).target = <GenericType>type;\r\n                     (<GenericType>type).typeArguments = type.typeParameters;\r\n                     type.thisType = <TypeParameter>createType(TypeFlags.TypeParameter);\r\n@@ -3877,8 +3884,7 @@ namespace ts {\n                     if (typeParameters) {\r\n                         // Initialize the instantiation cache for generic type aliases. The declared type corresponds to\r\n                         // an instantiation of the type alias with the type parameters supplied as type arguments.\r\n-                        links.instantiations = createMap<Type>();\r\n-                        links.instantiations[getTypeListId(links.typeParameters)] = type;\r\n+                        links.instantiations = createMap([[getTypeListId(links.typeParameters), type]]);\r\n                     }\r\n                 }\r\n                 else {\r\n@@ -3898,7 +3904,7 @@ namespace ts {\n             return expr.kind === SyntaxKind.NumericLiteral ||\r\n                 expr.kind === SyntaxKind.PrefixUnaryExpression && (<PrefixUnaryExpression>expr).operator === SyntaxKind.MinusToken &&\r\n                 (<PrefixUnaryExpression>expr).operand.kind === SyntaxKind.NumericLiteral ||\r\n-                expr.kind === SyntaxKind.Identifier && !!symbol.exports[(<Identifier>expr).text];\r\n+                expr.kind === SyntaxKind.Identifier && !!symbol.exports.get((<Identifier>expr).text);\r\n         }\r\n \r\n         function enumHasLiteralMembers(symbol: Symbol) {\r\n@@ -3929,16 +3935,15 @@ namespace ts {\n                 enumType.symbol = symbol;\r\n                 if (enumHasLiteralMembers(symbol)) {\r\n                     const memberTypeList: Type[] = [];\r\n-                    const memberTypes = createMap<EnumLiteralType>();\r\n+                    const memberTypes: { [enumMemberValue: number]: EnumLiteralType } = [];\r\n                     for (const declaration of enumType.symbol.declarations) {\r\n                         if (declaration.kind === SyntaxKind.EnumDeclaration) {\r\n                             computeEnumMemberValues(<EnumDeclaration>declaration);\r\n                             for (const member of (<EnumDeclaration>declaration).members) {\r\n                                 const memberSymbol = getSymbolOfNode(member);\r\n                                 const value = getEnumMemberValue(member);\r\n                                 if (!memberTypes[value]) {\r\n-                                    const memberType = memberTypes[value] = createEnumLiteralType(memberSymbol, enumType, \"\" + value);\r\n-                                    memberTypeList.push(memberType);\r\n+                                    memberTypeList.push(memberTypes[value] = createEnumLiteralType(memberSymbol, enumType, \"\" + value));\r\n                                 }\r\n                             }\r\n                         }\r\n@@ -3947,7 +3952,7 @@ namespace ts {\n                     if (memberTypeList.length > 1) {\r\n                         enumType.flags |= TypeFlags.Union;\r\n                         (<EnumType & UnionType>enumType).types = memberTypeList;\r\n-                        unionTypes[getTypeListId(memberTypeList)] = <EnumType & UnionType>enumType;\r\n+                        unionTypes.set(getTypeListId(memberTypeList), <EnumType & UnionType>enumType);\r\n                     }\r\n                 }\r\n             }\r\n@@ -4089,27 +4094,19 @@ namespace ts {\n         }\r\n \r\n         function createSymbolTable(symbols: Symbol[]): SymbolTable {\r\n-            const result = createMap<Symbol>();\r\n-            for (const symbol of symbols) {\r\n-                result[symbol.name] = symbol;\r\n-            }\r\n-            return result;\r\n+            return arrayToMap(symbols, symbol => symbol.name);\r\n         }\r\n \r\n         // The mappingThisOnly flag indicates that the only type parameter being mapped is \"this\". When the flag is true,\r\n         // we check symbols to see if we can quickly conclude they are free of \"this\" references, thus needing no instantiation.\r\n         function createInstantiatedSymbolTable(symbols: Symbol[], mapper: TypeMapper, mappingThisOnly: boolean): SymbolTable {\r\n-            const result = createMap<Symbol>();\r\n-            for (const symbol of symbols) {\r\n-                result[symbol.name] = mappingThisOnly && isIndependentMember(symbol) ? symbol : instantiateSymbol(symbol, mapper);\r\n-            }\r\n-            return result;\r\n+            return arrayToMap(symbols, symbol => symbol.name, symbol => mappingThisOnly && isIndependentMember(symbol) ? symbol : instantiateSymbol(symbol, mapper));\r\n         }\r\n \r\n         function addInheritedMembers(symbols: SymbolTable, baseSymbols: Symbol[]) {\r\n             for (const s of baseSymbols) {\r\n-                if (!symbols[s.name]) {\r\n-                    symbols[s.name] = s;\r\n+                if (!symbols.get(s.name)) {\r\n+                    symbols.set(s.name, s);\r\n                 }\r\n             }\r\n         }\r\n@@ -4118,8 +4115,8 @@ namespace ts {\n             if (!(<InterfaceTypeWithDeclaredMembers>type).declaredProperties) {\r\n                 const symbol = type.symbol;\r\n                 (<InterfaceTypeWithDeclaredMembers>type).declaredProperties = getNamedMembers(symbol.members);\r\n-                (<InterfaceTypeWithDeclaredMembers>type).declaredCallSignatures = getSignaturesOfSymbol(symbol.members[\"__call\"]);\r\n-                (<InterfaceTypeWithDeclaredMembers>type).declaredConstructSignatures = getSignaturesOfSymbol(symbol.members[\"__new\"]);\r\n+                (<InterfaceTypeWithDeclaredMembers>type).declaredCallSignatures = getSignaturesOfSymbol(symbol.members.get(\"__call\"));\r\n+                (<InterfaceTypeWithDeclaredMembers>type).declaredConstructSignatures = getSignaturesOfSymbol(symbol.members.get(\"__new\"));\r\n                 (<InterfaceTypeWithDeclaredMembers>type).declaredStringIndexInfo = getIndexInfoOfSymbol(symbol, IndexKind.String);\r\n                 (<InterfaceTypeWithDeclaredMembers>type).declaredNumberIndexInfo = getIndexInfoOfSymbol(symbol, IndexKind.Number);\r\n             }\r\n@@ -4359,8 +4356,8 @@ namespace ts {\n             }\r\n             else if (symbol.flags & SymbolFlags.TypeLiteral) {\r\n                 const members = symbol.members;\r\n-                const callSignatures = getSignaturesOfSymbol(members[\"__call\"]);\r\n-                const constructSignatures = getSignaturesOfSymbol(members[\"__new\"]);\r\n+                const callSignatures = getSignaturesOfSymbol(members.get(\"__call\"));\r\n+                const constructSignatures = getSignaturesOfSymbol(members.get(\"__new\"));\r\n                 const stringIndexInfo = getIndexInfoOfSymbol(symbol, IndexKind.String);\r\n                 const numberIndexInfo = getIndexInfoOfSymbol(symbol, IndexKind.Number);\r\n                 setStructuredTypeMembers(type, members, callSignatures, constructSignatures, stringIndexInfo, numberIndexInfo);\r\n@@ -4374,7 +4371,7 @@ namespace ts {\n                 }\r\n                 if (symbol.flags & SymbolFlags.Class) {\r\n                     const classType = getDeclaredTypeOfClassOrInterface(symbol);\r\n-                    constructSignatures = getSignaturesOfSymbol(symbol.members[\"__constructor\"]);\r\n+                    constructSignatures = getSignaturesOfSymbol(symbol.members.get(\"__constructor\"));\r\n                     if (!constructSignatures.length) {\r\n                         constructSignatures = getDefaultConstructSignatures(classType);\r\n                     }\r\n@@ -4432,7 +4429,7 @@ namespace ts {\n         function getPropertyOfObjectType(type: Type, name: string): Symbol {\r\n             if (type.flags & TypeFlags.Object) {\r\n                 const resolved = resolveStructuredTypeMembers(<ObjectType>type);\r\n-                const symbol = resolved.members[name];\r\n+                const symbol = resolved.members.get(name);\r\n                 if (symbol && symbolIsValue(symbol)) {\r\n                     return symbol;\r\n                 }\r\n@@ -4453,13 +4450,12 @@ namespace ts {\n             const props = type.resolvedProperties;\r\n             if (props) {\r\n                 const result: Symbol[] = [];\r\n-                for (const key in props) {\r\n-                    const prop = props[key];\r\n+                props.forEach(prop =>  {\r\n                     // We need to filter out partial properties in union types\r\n                     if (!(prop.flags & SymbolFlags.SyntheticProperty && (<TransientSymbol>prop).isPartial)) {\r\n                         result.push(prop);\r\n                     }\r\n-                }\r\n+                });\r\n                 return result;\r\n             }\r\n             return emptyArray;\r\n@@ -4576,12 +4572,12 @@ namespace ts {\n         // these partial properties when identifying discriminant properties, but otherwise they are filtered out\r\n         // and do not appear to be present in the union type.\r\n         function getUnionOrIntersectionProperty(type: UnionOrIntersectionType, name: string): Symbol {\r\n-            const properties = type.resolvedProperties || (type.resolvedProperties = createMap<Symbol>());\r\n-            let property = properties[name];\r\n+            const properties = type.resolvedProperties || (type.resolvedProperties = createMap<string, Symbol>());\r\n+            let property = properties.get(name);\r\n             if (!property) {\r\n                 property = createUnionOrIntersectionProperty(type, name);\r\n                 if (property) {\r\n-                    properties[name] = property;\r\n+                    properties.set(name, property);\r\n                 }\r\n             }\r\n             return property;\r\n@@ -4605,7 +4601,7 @@ namespace ts {\n             type = getApparentType(type);\r\n             if (type.flags & TypeFlags.Object) {\r\n                 const resolved = resolveStructuredTypeMembers(<ObjectType>type);\r\n-                const symbol = resolved.members[name];\r\n+                const symbol = resolved.members.get(name);\r\n                 if (symbol && symbolIsValue(symbol)) {\r\n                     return symbol;\r\n                 }\r\n@@ -4704,11 +4700,11 @@ namespace ts {\n \r\n         function symbolsToArray(symbols: SymbolTable): Symbol[] {\r\n             const result: Symbol[] = [];\r\n-            for (const id in symbols) {\r\n+            symbols.forEach((symbol, id) => {\r\n                 if (!isReservedMemberName(id)) {\r\n-                    result.push(symbols[id]);\r\n+                    result.push(symbol);\r\n                 }\r\n-            }\r\n+            });\r\n             return result;\r\n         }\r\n \r\n@@ -5000,7 +4996,7 @@ namespace ts {\n         }\r\n \r\n         function getIndexSymbol(symbol: Symbol): Symbol {\r\n-            return symbol.members[\"__index\"];\r\n+            return symbol.members.get(\"__index\");\r\n         }\r\n \r\n         function getIndexDeclarationOfSymbol(symbol: Symbol, kind: IndexKind): SignatureDeclaration {\r\n@@ -5114,9 +5110,9 @@ namespace ts {\n \r\n         function createTypeReference(target: GenericType, typeArguments: Type[]): TypeReference {\r\n             const id = getTypeListId(typeArguments);\r\n-            let type = target.instantiations[id];\r\n+            let type = target.instantiations.get(id);\r\n             if (!type) {\r\n-                type = target.instantiations[id] = <TypeReference>createObjectType(ObjectFlags.Reference, target.symbol);\r\n+                type = setAndReturn(target.instantiations, id, <TypeReference>createObjectType(ObjectFlags.Reference, target.symbol));\r\n                 type.flags |= typeArguments ? getPropagatingFlagsOfTypes(typeArguments, /*excludeKinds*/ 0) : 0;\r\n                 type.target = target;\r\n                 type.typeArguments = typeArguments;\r\n@@ -5172,7 +5168,7 @@ namespace ts {\n                 }\r\n                 const typeArguments = map(node.typeArguments, getTypeFromTypeNodeNoAlias);\r\n                 const id = getTypeListId(typeArguments);\r\n-                return links.instantiations[id] || (links.instantiations[id] = instantiateType(type, createTypeMapper(typeParameters, typeArguments)));\r\n+                return links.instantiations.get(id) || setAndReturn(links.instantiations, id, instantiateType(type, createTypeMapper(typeParameters, typeArguments)));\r\n             }\r\n             if (node.typeArguments) {\r\n                 error(node, Diagnostics.Type_0_is_not_generic, symbolToString(symbol));\r\n@@ -5397,8 +5393,7 @@ namespace ts {\n             type.typeParameters = typeParameters;\r\n             type.outerTypeParameters = undefined;\r\n             type.localTypeParameters = typeParameters;\r\n-            type.instantiations = createMap<TypeReference>();\r\n-            type.instantiations[getTypeListId(type.typeParameters)] = <GenericType>type;\r\n+            type.instantiations = createMap([[getTypeListId(type.typeParameters), <GenericType>type]]);\r\n             type.target = <GenericType>type;\r\n             type.typeArguments = type.typeParameters;\r\n             type.thisType = <TypeParameter>createType(TypeFlags.TypeParameter);\r\n@@ -5602,10 +5597,10 @@ namespace ts {\n                 return types[0];\r\n             }\r\n             const id = getTypeListId(types);\r\n-            let type = unionTypes[id];\r\n+            let type = unionTypes.get(id);\r\n             if (!type) {\r\n                 const propagatedFlags = getPropagatingFlagsOfTypes(types, /*excludeKinds*/ TypeFlags.Nullable);\r\n-                type = unionTypes[id] = <UnionType>createType(TypeFlags.Union | propagatedFlags);\r\n+                type = setAndReturn(unionTypes, id, <UnionType>createType(TypeFlags.Union | propagatedFlags));\r\n                 type.types = types;\r\n                 type.aliasSymbol = aliasSymbol;\r\n                 type.aliasTypeArguments = aliasTypeArguments;\r\n@@ -5673,10 +5668,10 @@ namespace ts {\n                 return typeSet[0];\r\n             }\r\n             const id = getTypeListId(typeSet);\r\n-            let type = intersectionTypes[id];\r\n+            let type = intersectionTypes.get(id);\r\n             if (!type) {\r\n                 const propagatedFlags = getPropagatingFlagsOfTypes(typeSet, /*excludeKinds*/ TypeFlags.Nullable);\r\n-                type = intersectionTypes[id] = <IntersectionType>createType(TypeFlags.Intersection | propagatedFlags);\r\n+                type = setAndReturn(intersectionTypes, id, <IntersectionType>createType(TypeFlags.Intersection | propagatedFlags));\r\n                 type.types = typeSet;\r\n                 type.aliasSymbol = aliasSymbol;\r\n                 type.aliasTypeArguments = aliasTypeArguments;\r\n@@ -5728,7 +5723,7 @@ namespace ts {\n \r\n         function getLiteralTypeForText(flags: TypeFlags, text: string) {\r\n             const map = flags & TypeFlags.StringLiteral ? stringLiteralTypes : numericLiteralTypes;\r\n-            return map[text] || (map[text] = createLiteralType(flags, text));\r\n+            return map.get(text) || setAndReturn(map, text, createLiteralType(flags, text));\r\n         }\r\n \r\n         function getTypeFromLiteralTypeNode(node: LiteralTypeNode): Type {\r\n@@ -6424,13 +6419,14 @@ namespace ts {\n                 return true;\r\n             }\r\n             const id = source.id + \",\" + target.id;\r\n-            if (enumRelation[id] !== undefined) {\r\n-                return enumRelation[id];\r\n+            const relation = enumRelation.get(id);\r\n+            if (relation !== undefined) {\r\n+                return relation;\r\n             }\r\n             if (source.symbol.name !== target.symbol.name ||\r\n                 !(source.symbol.flags & SymbolFlags.RegularEnum) || !(target.symbol.flags & SymbolFlags.RegularEnum) ||\r\n                 (source.flags & TypeFlags.Union) !== (target.flags & TypeFlags.Union)) {\r\n-                return enumRelation[id] = false;\r\n+                return setAndReturn(enumRelation, id, false);\r\n             }\r\n             const targetEnumType = getTypeOfSymbol(target.symbol);\r\n             for (const property of getPropertiesOfType(getTypeOfSymbol(source.symbol))) {\r\n@@ -6441,14 +6437,14 @@ namespace ts {\n                             errorReporter(Diagnostics.Property_0_is_missing_in_type_1, property.name,\r\n                                 typeToString(target, /*enclosingDeclaration*/ undefined, TypeFormatFlags.UseFullyQualifiedType));\r\n                         }\r\n-                        return enumRelation[id] = false;\r\n+                        return setAndReturn(enumRelation, id, false);\r\n                     }\r\n                 }\r\n             }\r\n-            return enumRelation[id] = true;\r\n+            return setAndReturn(enumRelation, id, true);\r\n         }\r\n \r\n-        function isSimpleTypeRelatedTo(source: Type, target: Type, relation: Map<RelationComparisonResult>, errorReporter?: ErrorReporter) {\r\n+        function isSimpleTypeRelatedTo(source: Type, target: Type, relation: Map<string, RelationComparisonResult>, errorReporter?: ErrorReporter) {\r\n             if (target.flags & TypeFlags.Never) return false;\r\n             if (target.flags & TypeFlags.Any || source.flags & TypeFlags.Never) return true;\r\n             if (source.flags & TypeFlags.StringLike && target.flags & TypeFlags.String) return true;\r\n@@ -6476,7 +6472,7 @@ namespace ts {\n             return false;\r\n         }\r\n \r\n-        function isTypeRelatedTo(source: Type, target: Type, relation: Map<RelationComparisonResult>) {\r\n+        function isTypeRelatedTo(source: Type, target: Type, relation: Map<string, RelationComparisonResult>) {\r\n             if (source.flags & TypeFlags.StringOrNumberLiteral && source.flags & TypeFlags.FreshLiteral) {\r\n                 source = (<LiteralType>source).regularType;\r\n             }\r\n@@ -6488,7 +6484,7 @@ namespace ts {\n             }\r\n             if (source.flags & TypeFlags.Object && target.flags & TypeFlags.Object) {\r\n                 const id = relation !== identityRelation || source.id < target.id ? source.id + \",\" + target.id : target.id + \",\" + source.id;\r\n-                const related = relation[id];\r\n+                const related = relation.get(id);\r\n                 if (related !== undefined) {\r\n                     return related === RelationComparisonResult.Succeeded;\r\n                 }\r\n@@ -6512,15 +6508,15 @@ namespace ts {\n         function checkTypeRelatedTo(\r\n             source: Type,\r\n             target: Type,\r\n-            relation: Map<RelationComparisonResult>,\r\n+            relation: Map<string, RelationComparisonResult>,\r\n             errorNode: Node,\r\n             headMessage?: DiagnosticMessage,\r\n             containingMessageChain?: DiagnosticMessageChain): boolean {\r\n \r\n             let errorInfo: DiagnosticMessageChain;\r\n             let sourceStack: Type[];\r\n             let targetStack: Type[];\r\n-            let maybeStack: Map<RelationComparisonResult>[];\r\n+            let maybeStack: Map<string, RelationComparisonResult>[];\r\n             let expandingFlags: number;\r\n             let depth = 0;\r\n             let overflow = false;\r\n@@ -6879,12 +6875,12 @@ namespace ts {\n                     return Ternary.False;\r\n                 }\r\n                 const id = relation !== identityRelation || source.id < target.id ? source.id + \",\" + target.id : target.id + \",\" + source.id;\r\n-                const related = relation[id];\r\n+                const related = relation.get(id);\r\n                 if (related !== undefined) {\r\n                     if (reportErrors && related === RelationComparisonResult.Failed) {\r\n                         // We are elaborating errors and the cached result is an unreported failure. Record the result as a reported\r\n                         // failure and continue computing the relation such that errors get reported.\r\n-                        relation[id] = RelationComparisonResult.FailedAndReported;\r\n+                        relation.set(id, RelationComparisonResult.FailedAndReported);\r\n                     }\r\n                     else {\r\n                         return related === RelationComparisonResult.Succeeded ? Ternary.True : Ternary.False;\r\n@@ -6893,7 +6889,7 @@ namespace ts {\n                 if (depth > 0) {\r\n                     for (let i = 0; i < depth; i++) {\r\n                         // If source and target are already being compared, consider them related with assumptions\r\n-                        if (maybeStack[i][id]) {\r\n+                        if (maybeStack[i].get(id)) {\r\n                             return Ternary.Maybe;\r\n                         }\r\n                     }\r\n@@ -6910,8 +6906,7 @@ namespace ts {\n                 }\r\n                 sourceStack[depth] = source;\r\n                 targetStack[depth] = target;\r\n-                maybeStack[depth] = createMap<RelationComparisonResult>();\r\n-                maybeStack[depth][id] = RelationComparisonResult.Succeeded;\r\n+                maybeStack[depth] = createMap([[id, RelationComparisonResult.Succeeded]]);\r\n                 depth++;\r\n                 const saveExpandingFlags = expandingFlags;\r\n                 if (!(expandingFlags & 1) && isDeeplyNestedGeneric(source, sourceStack, depth)) expandingFlags |= 1;\r\n@@ -6941,12 +6936,12 @@ namespace ts {\n                     const maybeCache = maybeStack[depth];\r\n                     // If result is definitely true, copy assumptions to global cache, else copy to next level up\r\n                     const destinationCache = (result === Ternary.True || depth === 0) ? relation : maybeStack[depth - 1];\r\n-                    copyProperties(maybeCache, destinationCache);\r\n+                    copyMapEntriesFromTo(maybeCache, destinationCache);\r\n                 }\r\n                 else {\r\n                     // A false result goes straight into global cache (when something is false under assumptions it\r\n                     // will also be false without assumptions)\r\n-                    relation[id] = reportErrors ? RelationComparisonResult.FailedAndReported : RelationComparisonResult.Failed;\r\n+                    relation.set(id, reportErrors ? RelationComparisonResult.FailedAndReported : RelationComparisonResult.Failed);\r\n                 }\r\n                 return result;\r\n             }\r\n@@ -7135,14 +7130,29 @@ namespace ts {\n                 return result;\r\n             }\r\n \r\n-            function eachPropertyRelatedTo(source: Type, target: Type, kind: IndexKind, reportErrors: boolean): Ternary {\r\n+            /**\r\n+             * For consistency we report the first error in V8 object insertion order.\r\n+             * Since that's slow and there usually isn't an error, we only sort properties the second time around.\r\n+             */\r\n+            function eachPropertyRelatedTo(source: Type, target: Type, kind: IndexKind, reportErrors: boolean, redoingInV8ObjectInsertionOrder?: boolean): Ternary {\r\n                 let result = Ternary.True;\r\n-                for (const prop of getPropertiesOfObjectType(source)) {\r\n+                let properties = getPropertiesOfObjectType(source);\r\n+                if (redoingInV8ObjectInsertionOrder) {\r\n+                    properties = sortInV8ObjectInsertionOrder(properties, prop => prop.name);\r\n+                }\r\n+                for (const prop of properties) {\r\n                     if (kind === IndexKind.String || isNumericLiteralName(prop.name)) {\r\n-                        const related = isRelatedTo(getTypeOfSymbol(prop), target, reportErrors);\r\n+                        const related = isRelatedTo(getTypeOfSymbol(prop), target, reportErrors && redoingInV8ObjectInsertionOrder);\r\n                         if (!related) {\r\n                             if (reportErrors) {\r\n-                                reportError(Diagnostics.Property_0_is_incompatible_with_index_signature, symbolToString(prop));\r\n+                                // For consistency, if we report errors we make sure to report the first error in V8's object insertion order.\r\n+                                if (!redoingInV8ObjectInsertionOrder) {\r\n+                                    const related = eachPropertyRelatedTo(source,  target, kind, reportErrors, /*redoingInV8ObjectInsertionOrder*/ true);\r\n+                                    Debug.assert(related === Ternary.False);\r\n+                                }\r\n+                                else {\r\n+                                    reportError(Diagnostics.Property_0_is_incompatible_with_index_signature, symbolToString(prop));\r\n+                                }\r\n                             }\r\n                             return Ternary.False;\r\n                         }\r\n@@ -7581,11 +7591,11 @@ namespace ts {\n         }\r\n \r\n         function transformTypeOfMembers(type: Type, f: (propertyType: Type) => Type) {\r\n-            const members = createMap<Symbol>();\r\n+            const members = createMap<string, Symbol>();\r\n             for (const property of getPropertiesOfObjectType(type)) {\r\n                 const original = getTypeOfSymbol(property);\r\n                 const updated = f(original);\r\n-                members[property.name] = updated === original ? property : createTransientSymbol(property, updated);\r\n+                members.set(property.name, updated === original ? property : createTransientSymbol(property, updated));\r\n             };\r\n             return members;\r\n         }\r\n@@ -7804,7 +7814,7 @@ namespace ts {\n             let targetStack: Type[];\r\n             let depth = 0;\r\n             let inferiority = 0;\r\n-            const visited = createMap<boolean>();\r\n+            const visited = createSet();\r\n             inferFromTypes(originalSource, originalTarget);\r\n \r\n             function isInProcess(source: Type, target: Type) {\r\n@@ -7940,10 +7950,10 @@ namespace ts {\n                             return;\r\n                         }\r\n                         const key = source.id + \",\" + target.id;\r\n-                        if (visited[key]) {\r\n+                        if (visited.has(key)) {\r\n                             return;\r\n                         }\r\n-                        visited[key] = true;\r\n+                        visited.add(key);\r\n                         if (depth === 0) {\r\n                             sourceStack = [];\r\n                             targetStack = [];\r\n@@ -8294,7 +8304,7 @@ namespace ts {\n             // check. This gives us a quicker out in the common case where an object type is not a function.\r\n             const resolved = resolveStructuredTypeMembers(type);\r\n             return !!(resolved.callSignatures.length || resolved.constructSignatures.length ||\r\n-                resolved.members[\"bind\"] && isTypeSubtypeOf(type, globalFunctionType));\r\n+                resolved.members.get(\"bind\") && isTypeSubtypeOf(type, globalFunctionType));\r\n         }\r\n \r\n         function getTypeFacts(type: Type): TypeFacts {\r\n@@ -8884,12 +8894,13 @@ namespace ts {\n                 // If we have previously computed the control flow type for the reference at\r\n                 // this flow loop junction, return the cached type.\r\n                 const id = getFlowNodeId(flow);\r\n-                const cache = flowLoopCaches[id] || (flowLoopCaches[id] = createMap<Type>());\r\n+                const cache = flowLoopCaches[id] || (flowLoopCaches[id] = createMap<string, Type>());\r\n                 if (!key) {\r\n                     key = getFlowCacheKey(reference);\r\n                 }\r\n-                if (cache[key]) {\r\n-                    return cache[key];\r\n+                const cached = cache.get(key);\r\n+                if (cached) {\r\n+                    return cached;\r\n                 }\r\n                 // If this flow loop junction and reference are already being processed, return\r\n                 // the union of the types computed for each branch so far, marked as incomplete.\r\n@@ -8923,8 +8934,9 @@ namespace ts {\n                     // If we see a value appear in the cache it is a sign that control flow  analysis\r\n                     // was restarted and completed by checkExpressionCached. We can simply pick up\r\n                     // the resulting type and bail out.\r\n-                    if (cache[key]) {\r\n-                        return cache[key];\r\n+                    const cached = cache.get(key);\r\n+                    if (cached) {\r\n+                        return cached;\r\n                     }\r\n                     if (!contains(antecedentTypes, type)) {\r\n                         antecedentTypes.push(type);\r\n@@ -8948,7 +8960,7 @@ namespace ts {\n                 if (isIncomplete(firstAntecedentType)) {\r\n                     return createFlowType(result, /*incomplete*/ true);\r\n                 }\r\n-                return cache[key] = result;\r\n+                return setAndReturn(cache, key, result);\r\n             }\r\n \r\n             function isMatchingReferenceDiscriminant(expr: Expression) {\r\n@@ -9071,14 +9083,14 @@ namespace ts {\n                     // We narrow a non-union type to an exact primitive type if the non-union type\r\n                     // is a supertype of that primitive type. For example, type 'any' can be narrowed\r\n                     // to one of the primitive types.\r\n-                    const targetType = typeofTypesByName[literal.text];\r\n+                    const targetType = typeofTypesByName.get(literal.text);\r\n                     if (targetType && isTypeSubtypeOf(targetType, type)) {\r\n                         return targetType;\r\n                     }\r\n                 }\r\n                 const facts = assumeTrue ?\r\n-                    typeofEQFacts[literal.text] || TypeFacts.TypeofEQHostObject :\r\n-                    typeofNEFacts[literal.text] || TypeFacts.TypeofNEHostObject;\r\n+                    typeofEQFacts.get(literal.text) || TypeFacts.TypeofEQHostObject :\r\n+                    typeofNEFacts.get(literal.text) || TypeFacts.TypeofNEHostObject;\r\n                 return getTypeWithFacts(type, facts);\r\n             }\r\n \r\n@@ -10582,7 +10594,7 @@ namespace ts {\n             // Grammar checking\r\n             checkGrammarObjectLiteralExpression(node, inDestructuringPattern);\r\n \r\n-            const propertiesTable = createMap<Symbol>();\r\n+            const propertiesTable = createMap<string, Symbol>();\r\n             const propertiesArray: Symbol[] = [];\r\n             const contextualType = getApparentTypeOfContextualType(node);\r\n             const contextualTypeHasPattern = contextualType && contextualType.pattern &&\r\n@@ -10664,7 +10676,7 @@ namespace ts {\n                     }\r\n                 }\r\n                 else {\r\n-                    propertiesTable[member.name] = member;\r\n+                    propertiesTable.set(member.name, member);\r\n                 }\r\n                 propertiesArray.push(member);\r\n             }\r\n@@ -10673,12 +10685,12 @@ namespace ts {\n             // type with those properties for which the binding pattern specifies a default value.\r\n             if (contextualTypeHasPattern) {\r\n                 for (const prop of getPropertiesOfType(contextualType)) {\r\n-                    if (!propertiesTable[prop.name]) {\r\n+                    if (!propertiesTable.get(prop.name)) {\r\n                         if (!(prop.flags & SymbolFlags.Optional)) {\r\n                             error(prop.valueDeclaration || (<TransientSymbol>prop).bindingElement,\r\n                                 Diagnostics.Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value);\r\n                         }\r\n-                        propertiesTable[prop.name] = prop;\r\n+                        propertiesTable.set(prop.name, prop);\r\n                         propertiesArray.push(prop);\r\n                     }\r\n                 }\r\n@@ -10755,7 +10767,7 @@ namespace ts {\n             }\r\n         }\r\n \r\n-        function checkJsxAttribute(node: JsxAttribute, elementAttributesType: Type, nameTable: Map<boolean>) {\r\n+        function checkJsxAttribute(node: JsxAttribute, elementAttributesType: Type, nameTable: Set<string>) {\r\n             let correspondingPropType: Type = undefined;\r\n \r\n             // Look up the corresponding property for this attribute\r\n@@ -10794,34 +10806,35 @@ namespace ts {\n                 checkTypeAssignableTo(exprType, correspondingPropType, node);\r\n             }\r\n \r\n-            nameTable[node.name.text] = true;\r\n+            nameTable.add(node.name.text);\r\n             return exprType;\r\n         }\r\n \r\n-        function checkJsxSpreadAttribute(node: JsxSpreadAttribute, elementAttributesType: Type, nameTable: Map<boolean>) {\r\n+        function checkJsxSpreadAttribute(node: JsxSpreadAttribute, elementAttributesType: Type, nameTable: Set<string>) {\r\n             const type = checkExpression(node.expression);\r\n             const props = getPropertiesOfType(type);\r\n             for (const prop of props) {\r\n                 // Is there a corresponding property in the element attributes type? Skip checking of properties\r\n                 // that have already been assigned to, as these are not actually pushed into the resulting type\r\n-                if (!nameTable[prop.name]) {\r\n+                if (!nameTable.has(prop.name)) {\r\n                     const targetPropSym = getPropertyOfType(elementAttributesType, prop.name);\r\n                     if (targetPropSym) {\r\n                         const msg = chainDiagnosticMessages(undefined, Diagnostics.Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property, prop.name);\r\n                         checkTypeAssignableTo(getTypeOfSymbol(prop), getTypeOfSymbol(targetPropSym), node, undefined, msg);\r\n                     }\r\n \r\n-                    nameTable[prop.name] = true;\r\n+                    nameTable.add(prop.name);\r\n                 }\r\n             }\r\n             return type;\r\n         }\r\n \r\n         function getJsxType(name: string) {\r\n-            if (jsxTypes[name] === undefined) {\r\n-                return jsxTypes[name] = getExportedTypeFromNamespace(JsxNames.JSX, name) || unknownType;\r\n+            const jsxType = jsxTypes.get(name);\r\n+            if (jsxType === undefined) {\r\n+                return setAndReturn(jsxTypes, name, getExportedTypeFromNamespace(JsxNames.JSX, name) || unknownType);\r\n             }\r\n-            return jsxTypes[name];\r\n+            return jsxType;\r\n         }\r\n \r\n         /**\r\n@@ -11132,7 +11145,7 @@ namespace ts {\n \r\n             const targetAttributesType = getJsxElementAttributesType(node);\r\n \r\n-            const nameTable = createMap<boolean>();\r\n+            const nameTable = createSet();\r\n             // Process this array in right-to-left order so we know which\r\n             // attributes (mostly from spreads) are being overwritten and\r\n             // thus should have their types ignored\r\n@@ -11156,7 +11169,7 @@ namespace ts {\n                 const targetProperties = getPropertiesOfType(targetAttributesType);\r\n                 for (let i = 0; i < targetProperties.length; i++) {\r\n                     if (!(targetProperties[i].flags & SymbolFlags.Optional) &&\r\n-                        !nameTable[targetProperties[i].name]) {\r\n+                        !nameTable.has(targetProperties[i].name)) {\r\n \r\n                         error(node, Diagnostics.Property_0_is_missing_in_type_1, targetProperties[i].name, typeToString(targetAttributesType));\r\n                     }\r\n@@ -11886,7 +11899,7 @@ namespace ts {\n             return typeArgumentsAreAssignable;\r\n         }\r\n \r\n-        function checkApplicableSignature(node: CallLikeExpression, args: Expression[], signature: Signature, relation: Map<RelationComparisonResult>, excludeArgument: boolean[], reportErrors: boolean) {\r\n+        function checkApplicableSignature(node: CallLikeExpression, args: Expression[], signature: Signature, relation: Map<string, RelationComparisonResult>, excludeArgument: boolean[], reportErrors: boolean) {\r\n             const thisType = getThisTypeOfSignature(signature);\r\n             if (thisType && thisType !== voidType && node.kind !== SyntaxKind.NewExpression) {\r\n                 // If the called expression is not of the form `x.f` or `x[\"f\"]`, then sourceType = voidType\r\n@@ -12420,7 +12433,7 @@ namespace ts {\n                 diagnostics.add(createDiagnosticForNodeFromMessageChain(node, errorInfo));\r\n             }\r\n \r\n-            function chooseOverload(candidates: Signature[], relation: Map<RelationComparisonResult>, signatureHelpTrailingComma = false) {\r\n+            function chooseOverload(candidates: Signature[], relation: Map<string, RelationComparisonResult>, signatureHelpTrailingComma = false) {\r\n                 for (const originalCandidate of candidates) {\r\n                     if (!hasCorrectArity(node, args, originalCandidate, signatureHelpTrailingComma)) {\r\n                         continue;\r\n@@ -14609,8 +14622,8 @@ namespace ts {\n                 Property = Getter | Setter\r\n             }\r\n \r\n-            const instanceNames = createMap<Accessor>();\r\n-            const staticNames = createMap<Accessor>();\r\n+            const instanceNames = createMap<string, Accessor>();\r\n+            const staticNames = createMap<string, Accessor>();\r\n             for (const member of node.members) {\r\n                 if (member.kind === SyntaxKind.Constructor) {\r\n                     for (const param of (member as ConstructorDeclaration).parameters) {\r\n@@ -14642,24 +14655,24 @@ namespace ts {\n                 }\r\n             }\r\n \r\n-            function addName(names: Map<Accessor>, location: Node, name: string, meaning: Accessor) {\r\n-                const prev = names[name];\r\n+            function addName(names: Map<string, Accessor>, location: Node, name: string, meaning: Accessor) {\r\n+                const prev = names.get(name);\r\n                 if (prev) {\r\n                     if (prev & meaning) {\r\n                         error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location));\r\n                     }\r\n                     else {\r\n-                        names[name] = prev | meaning;\r\n+                        names.set(name, prev | meaning);\r\n                     }\r\n                 }\r\n                 else {\r\n-                    names[name] = meaning;\r\n+                    names.set(name, meaning);\r\n                 }\r\n             }\r\n         }\r\n \r\n         function checkObjectTypeForDuplicateDeclarations(node: TypeLiteralNode | InterfaceDeclaration) {\r\n-            const names = createMap<boolean>();\r\n+            const names = createSet();\r\n             for (const member of node.members) {\r\n                 if (member.kind == SyntaxKind.PropertySignature) {\r\n                     let memberName: string;\r\n@@ -14673,12 +14686,12 @@ namespace ts {\n                             continue;\r\n                     }\r\n \r\n-                    if (names[memberName]) {\r\n+                    if (names.has(memberName)) {\r\n                         error(member.symbol.valueDeclaration.name, Diagnostics.Duplicate_identifier_0, memberName);\r\n                         error(member.name, Diagnostics.Duplicate_identifier_0, memberName);\r\n                     }\r\n                     else {\r\n-                        names[memberName] = true;\r\n+                        names.add(memberName);\r\n                     }\r\n                 }\r\n             }\r\n@@ -15883,8 +15896,7 @@ namespace ts {\n \r\n         function checkUnusedLocalsAndParameters(node: Node): void {\r\n             if (node.parent.kind !== SyntaxKind.InterfaceDeclaration && noUnusedIdentifiers && !isInAmbientContext(node)) {\r\n-                for (const key in node.locals) {\r\n-                    const local = node.locals[key];\r\n+                node.locals.forEach(local => {\r\n                     if (!local.isReferenced) {\r\n                         if (local.valueDeclaration && getRootDeclaration(local.valueDeclaration).kind === SyntaxKind.Parameter) {\r\n                             const parameter = <ParameterDeclaration>getRootDeclaration(local.valueDeclaration);\r\n@@ -15899,7 +15911,7 @@ namespace ts {\n                             forEach(local.declarations, d => errorUnusedLocal(d.name || d, local.name));\r\n                         }\r\n                     }\r\n-                }\r\n+                });\r\n             }\r\n         }\r\n \r\n@@ -15965,16 +15977,15 @@ namespace ts {\n \r\n         function checkUnusedModuleMembers(node: ModuleDeclaration | SourceFile): void {\r\n             if (compilerOptions.noUnusedLocals && !isInAmbientContext(node)) {\r\n-                for (const key in node.locals) {\r\n-                    const local = node.locals[key];\r\n+                node.locals.forEach(local => {\r\n                     if (!local.isReferenced && !local.exportSymbol) {\r\n                         for (const declaration of local.declarations) {\r\n                             if (!isAmbientModule(declaration)) {\r\n                                 error(declaration.name, Diagnostics._0_is_declared_but_never_used, local.name);\r\n                             }\r\n                         }\r\n                     }\r\n-                }\r\n+                });\r\n             }\r\n         }\r\n \r\n@@ -16991,12 +17002,12 @@ namespace ts {\n                     else {\r\n                         const blockLocals = catchClause.block.locals;\r\n                         if (blockLocals) {\r\n-                            for (const caughtName in catchClause.locals) {\r\n-                                const blockLocal = blockLocals[caughtName];\r\n+                            forEachKeyInMap(catchClause.locals, caughtName => {\r\n+                                const blockLocal = blockLocals.get(caughtName);\r\n                                 if (blockLocal && (blockLocal.flags & SymbolFlags.BlockScopedVariable) !== 0) {\r\n                                     grammarErrorOnNode(blockLocal.valueDeclaration, Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause, caughtName);\r\n                                 }\r\n-                            }\r\n+                            });\r\n                         }\r\n                     }\r\n                 }\r\n@@ -17415,16 +17426,15 @@ namespace ts {\n                 return true;\r\n             }\r\n \r\n-            const seen = createMap<{ prop: Symbol; containingType: Type }>();\r\n-            forEach(resolveDeclaredMembers(type).declaredProperties, p => { seen[p.name] = { prop: p, containingType: type }; });\r\n+            const seen: Map<string, { prop: Symbol; containingType: Type }> = arrayToMap(resolveDeclaredMembers(type).declaredProperties, p => p.name, p => ({ prop: p, containingType: type }));\r\n             let ok = true;\r\n \r\n             for (const base of baseTypes) {\r\n                 const properties = getPropertiesOfObjectType(getTypeWithThisArgument(base, type.thisType));\r\n                 for (const prop of properties) {\r\n-                    const existing = seen[prop.name];\r\n+                    const existing = seen.get(prop.name);\r\n                     if (!existing) {\r\n-                        seen[prop.name] = { prop: prop, containingType: base };\r\n+                        seen.set(prop.name, { prop, containingType: base });\r\n                     }\r\n                     else {\r\n                         const isInheritedProperty = existing.containingType !== type;\r\n@@ -18166,19 +18176,14 @@ namespace ts {\n         }\r\n \r\n         function hasExportedMembers(moduleSymbol: Symbol) {\r\n-            for (const id in moduleSymbol.exports) {\r\n-                if (id !== \"export=\") {\r\n-                    return true;\r\n-                }\r\n-            }\r\n-            return false;\r\n+            return someKeyInMap(moduleSymbol.exports, id => id !== \"export=\");\r\n         }\r\n \r\n         function checkExternalModuleExports(node: SourceFile | ModuleDeclaration) {\r\n             const moduleSymbol = getSymbolOfNode(node);\r\n             const links = getSymbolLinks(moduleSymbol);\r\n             if (!links.exportsChecked) {\r\n-                const exportEqualsSymbol = moduleSymbol.exports[\"export=\"];\r\n+                const exportEqualsSymbol = moduleSymbol.exports.get(\"export=\");\r\n                 if (exportEqualsSymbol && hasExportedMembers(moduleSymbol)) {\r\n                     const declaration = getDeclarationOfAliasSymbol(exportEqualsSymbol) || exportEqualsSymbol.valueDeclaration;\r\n                     if (!isTopLevelInExternalModuleAugmentation(declaration)) {\r\n@@ -18187,21 +18192,20 @@ namespace ts {\n                 }\r\n                 // Checks for export * conflicts\r\n                 const exports = getExportsOfModule(moduleSymbol);\r\n-                for (const id in exports) {\r\n+                exports && exports.forEach(({ declarations, flags }, id) => {\r\n                     if (id === \"__export\") {\r\n-                        continue;\r\n+                        return;\r\n                     }\r\n-                    const { declarations, flags } = exports[id];\r\n                     // ECMA262: 15.2.1.1 It is a Syntax Error if the ExportedNames of ModuleItemList contains any duplicate entries.\r\n                     // (TS Exceptions: namespaces, function overloads, enums, and interfaces)\r\n                     if (flags & (SymbolFlags.Namespace | SymbolFlags.Interface | SymbolFlags.Enum)) {\r\n-                        continue;\r\n+                        return;\r\n                     }\r\n                     const exportedDeclarationsCount = countWhere(declarations, isNotOverload);\r\n                     if (flags & SymbolFlags.TypeAlias && exportedDeclarationsCount <= 2) {\r\n                         // it is legal to merge type alias with other values\r\n                         // so count should be either 1 (just type alias) or 2 (type alias + merged value)\r\n-                        continue;\r\n+                        return;\r\n                     }\r\n                     if (exportedDeclarationsCount > 1) {\r\n                         for (const declaration of declarations) {\r\n@@ -18210,7 +18214,7 @@ namespace ts {\n                             }\r\n                         }\r\n                     }\r\n-                }\r\n+                });\r\n                 links.exportsChecked = true;\r\n             }\r\n \r\n@@ -18486,7 +18490,7 @@ namespace ts {\n         }\r\n \r\n         function getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[] {\r\n-            const symbols = createMap<Symbol>();\r\n+            const symbols = createMap<string, Symbol>();\r\n             let memberFlags: ModifierFlags = ModifierFlags.None;\r\n \r\n             if (isInsideWithStatementBody(location)) {\r\n@@ -18564,18 +18568,17 @@ namespace ts {\n                     // We will copy all symbol regardless of its reserved name because\r\n                     // symbolsToArray will check whether the key is a reserved name and\r\n                     // it will not copy symbol with reserved name to the array\r\n-                    if (!symbols[id]) {\r\n-                        symbols[id] = symbol;\r\n+                    if (!symbols.get(id)) {\r\n+                        symbols.set(id, symbol);\r\n                     }\r\n                 }\r\n             }\r\n \r\n             function copySymbols(source: SymbolTable, meaning: SymbolFlags): void {\r\n                 if (meaning) {\r\n-                    for (const id in source) {\r\n-                        const symbol = source[id];\r\n+                    source.forEach(symbol => {\r\n                         copySymbol(symbol, meaning);\r\n-                    }\r\n+                    });\r\n                 }\r\n             }\r\n         }\r\n@@ -18986,8 +18989,8 @@ namespace ts {\n             const propsByName = createSymbolTable(getPropertiesOfType(type));\r\n             if (getSignaturesOfType(type, SignatureKind.Call).length || getSignaturesOfType(type, SignatureKind.Construct).length) {\r\n                 forEach(getPropertiesOfType(globalFunctionType), p => {\r\n-                    if (!propsByName[p.name]) {\r\n-                        propsByName[p.name] = p;\r\n+                    if (!propsByName.get(p.name)) {\r\n+                        propsByName.set(p.name, p);\r\n                     }\r\n                 });\r\n             }\r\n@@ -19050,7 +19053,7 @@ namespace ts {\n                 // otherwise - check if at least one export is value\r\n                 symbolLinks.exportsSomeValue = hasExportAssignment\r\n                     ? !!(moduleSymbol.flags & SymbolFlags.Value)\r\n-                    : forEachProperty(getExportsOfModule(moduleSymbol), isValue);\r\n+                    : someValueInMap(getExportsOfModule(moduleSymbol), isValue);\r\n             }\r\n \r\n             return symbolLinks.exportsSomeValue;\r\n@@ -19400,7 +19403,7 @@ namespace ts {\n         }\r\n \r\n         function hasGlobalName(name: string): boolean {\r\n-            return !!globals[name];\r\n+            return !!globals.get(name);\r\n         }\r\n \r\n         function getReferencedValueSymbol(reference: Identifier, startInDeclarationContainer?: boolean): Symbol {\r\n@@ -19457,14 +19460,13 @@ namespace ts {\n             if (resolvedTypeReferenceDirectives) {\r\n                 // populate reverse mapping: file path -> type reference directive that was resolved to this file\r\n                 fileToDirective = createFileMap<string>();\r\n-                for (const key in resolvedTypeReferenceDirectives) {\r\n-                    const resolvedDirective = resolvedTypeReferenceDirectives[key];\r\n+                resolvedTypeReferenceDirectives.forEach((resolvedDirective, key) => {\r\n                     if (!resolvedDirective) {\r\n-                        continue;\r\n+                        return;\r\n                     }\r\n                     const file = host.getSourceFile(resolvedDirective.resolvedFileName);\r\n                     fileToDirective.set(file.path, key);\r\n-                }\r\n+                });\r\n             }\r\n             return {\r\n                 getReferencedExportContainer,\r\n@@ -19588,6 +19590,8 @@ namespace ts {\n \r\n         function initializeTypeChecker() {\r\n             // Bind all source files and propagate errors\r\n+            performance.mark(\"heapBeforeBind\");\r\n+\r\n             for (const file of host.getSourceFiles()) {\r\n                 bindSourceFile(file, compilerOptions);\r\n             }\r\n@@ -19609,11 +19613,9 @@ namespace ts {\n                 if (file.symbol && file.symbol.globalExports) {\r\n                     // Merge in UMD exports with first-in-wins semantics (see #9771)\r\n                     const source = file.symbol.globalExports;\r\n-                    for (const id in source) {\r\n-                        if (!(id in globals)) {\r\n-                            globals[id] = source[id];\r\n-                        }\r\n-                    }\r\n+                    source.forEach((sourceSymbol, id) => {\r\n+                        setIfNotSet(globals, id, sourceSymbol);\r\n+                    });\r\n                 }\r\n                 if ((compilerOptions.isolatedModules || isExternalModule(file)) && !file.isDeclarationFile) {\r\n                     const fileRequestedExternalEmitHelpers = file.flags & NodeFlags.EmitHelperFlags;\r\n@@ -19639,6 +19641,8 @@ namespace ts {\n             // Setup global builtins\r\n             addToSymbolTable(globals, builtinGlobals, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0);\r\n \r\n+            performance.mark(\"heapAfterBind\");\r\n+\r\n             getSymbolLinks(undefinedSymbol).type = undefinedWideningType;\r\n             getSymbolLinks(argumentsSymbol).type = getGlobalType(\"IArguments\");\r\n             getSymbolLinks(unknownSymbol).type = unknownType;\r\n@@ -20311,7 +20315,7 @@ namespace ts {\n         }\r\n \r\n         function checkGrammarObjectLiteralExpression(node: ObjectLiteralExpression, inDestructuring: boolean) {\r\n-            const seen = createMap<SymbolFlags>();\r\n+            const seen = createMap<string, SymbolFlags>();\r\n             const Property = 1;\r\n             const GetAccessor = 2;\r\n             const SetAccessor = 4;\r\n@@ -20374,17 +20378,17 @@ namespace ts {\n                     continue;\r\n                 }\r\n \r\n-                if (!seen[effectiveName]) {\r\n-                    seen[effectiveName] = currentKind;\r\n+                const existingKind = seen.get(effectiveName);\r\n+                if (!existingKind) {\r\n+                    seen.set(effectiveName, currentKind);\r\n                 }\r\n                 else {\r\n-                    const existingKind = seen[effectiveName];\r\n                     if (currentKind === Property && existingKind === Property) {\r\n                         grammarErrorOnNode(name, Diagnostics.Duplicate_identifier_0, getTextOfNode(name));\r\n                     }\r\n                     else if ((currentKind & GetOrSetAccessor) && (existingKind & GetOrSetAccessor)) {\r\n                         if (existingKind !== GetOrSetAccessor && currentKind !== existingKind) {\r\n-                            seen[effectiveName] = currentKind | existingKind;\r\n+                            seen.set(effectiveName, currentKind | existingKind);\r\n                         }\r\n                         else {\r\n                             return grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name);\r\n@@ -20398,16 +20402,16 @@ namespace ts {\n         }\r\n \r\n         function checkGrammarJsxElement(node: JsxOpeningLikeElement) {\r\n-            const seen = createMap<boolean>();\r\n+            const seen = createSet();\r\n             for (const attr of node.attributes) {\r\n                 if (attr.kind === SyntaxKind.JsxSpreadAttribute) {\r\n                     continue;\r\n                 }\r\n \r\n                 const jsxAttr = (<JsxAttribute>attr);\r\n                 const name = jsxAttr.name;\r\n-                if (!seen[name.text]) {\r\n-                    seen[name.text] = true;\r\n+                if (!seen.has(name.text)) {\r\n+                    seen.add(name.text);\r\n                 }\r\n                 else {\r\n                     return grammarErrorOnNode(name, Diagnostics.JSX_elements_cannot_have_multiple_attributes_with_the_same_name);\r\n@@ -20901,11 +20905,11 @@ namespace ts {\n \r\n         function getAmbientModules(): Symbol[] {\r\n             const result: Symbol[] = [];\r\n-            for (const sym in globals) {\r\n+            globals.forEach((global, sym) => {\r\n                 if (ambientModuleSymbolRegex.test(sym)) {\r\n-                    result.push(globals[sym]);\r\n+                    result.push(global);\r\n                 }\r\n-            }\r\n+            });\r\n             return result;\r\n         }\r\n     }\r"},{"sha":"01f3da2b9d342a5cdd6eacf5ebff62972c013ea9","filename":"src/compiler/collections.ts","status":"added","additions":609,"deletions":0,"changes":609,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fcollections.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fcollections.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Fcollections.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -0,0 +1,609 @@\n+// NumberMap, StringMap, and StringSet shims\r\n+/* @internal */\r\n+namespace ts {\r\n+    // The global Map object. This may not be available, so we must test for it.\r\n+    // Non-ES6 native maps don't support constructor arguments, so `createMap` must provide that functionality.\r\n+    declare const Map: { new<K, V>(): Map<K, V> } | undefined;\r\n+    const usingNativeMaps = typeof Map !== \"undefined\";\r\n+    // tslint:disable-next-line:no-in-operator\r\n+    const usingES6NativeMaps = usingNativeMaps && \"keys\" in Map.prototype && \"values\" in Map.prototype && \"entries\" in Map.prototype;\r\n+\r\n+    /** Extra Map methods that may not be available, so we must provide fallbacks. */\r\n+    interface ES6Map<K, V> extends Map<K, V> {\r\n+        keys(): Iterator<K>;\r\n+        values(): Iterator<V>;\r\n+        entries(): Iterator<[K, V]>;\r\n+    }\r\n+\r\n+    /** Simplified ES6 Iterator interface. */\r\n+    interface Iterator<T> {\r\n+        next(): { value: T, done: false } | { value: never, done: true };\r\n+    }\r\n+\r\n+    /**\r\n+     * Provides Map-like functionality for ES5 runtimes.\r\n+     * This is intentionally *not* a full Map shim, and doesn't provide iterators (which aren't available for IE Maps anyway).\r\n+     * We can only efficiently support strings and number keys, and iteration will always yield stringified keys.\r\n+     */\r\n+    class ShimMap<K extends string | number, V> implements Map<K, V> {\r\n+        private data = createDictionaryModeObject<V>();\r\n+\r\n+        /*\r\n+        So long as `K extends string | number`, we can cast `key as string` and insert it into the map.\r\n+        However, `forEach` will iterate over strings because values are stringified before being put in the map.\r\n+        */\r\n+\r\n+        constructor() {}\r\n+\r\n+        clear(): void {\r\n+            this.data = createDictionaryModeObject<V>();\r\n+        }\r\n+\r\n+        delete(key: K): boolean {\r\n+            const had = this.has(key);\r\n+            if (had) {\r\n+                delete this.data[key as string];\r\n+            }\r\n+            return had;\r\n+        }\r\n+\r\n+        get(key: K): V {\r\n+            return this.data[key as string];\r\n+        }\r\n+\r\n+        has(key: K): boolean {\r\n+            // tslint:disable-next-line:no-in-operator\r\n+            return (key as string) in this.data;\r\n+        }\r\n+\r\n+        set(key: K, value: V): void {\r\n+            this.data[key as string] = value;\r\n+        }\r\n+\r\n+        forEach(action: (value: V, key: string) => void): void {\r\n+            for (const key in this.data) {\r\n+                action(this.data[key], key);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    const MapCtr = usingNativeMaps ? Map : ShimMap;\r\n+    /**\r\n+     * In runtimes without Maps, this is implemented using an object.\r\n+     * `pairs` is an optional list of entries to add to the new map.\r\n+     */\r\n+    export function createMap<K extends string | number, V>(pairs?: [K, V][]): Map<K, V> {\r\n+        const map = new MapCtr<K, V>();\r\n+\r\n+        if (pairs) {\r\n+            for (const [key, value] of pairs) {\r\n+                map.set(key, value);\r\n+            }\r\n+        }\r\n+\r\n+        return map;\r\n+    }\r\n+\r\n+    const createObject = Object.create;\r\n+    function createDictionaryModeObject<T>(): MapLike<T> {\r\n+        const map = createObject(null); // tslint:disable-line:no-null-keyword\r\n+\r\n+        // Using 'delete' on an object causes V8 to put the object in dictionary mode.\r\n+        // This disables creation of hidden classes, which are expensive when an object is\r\n+        // constantly changing shape.\r\n+        map[\"__\"] = undefined;\r\n+        delete map[\"__\"];\r\n+\r\n+        return map;\r\n+    }\r\n+\r\n+    /**\r\n+     * Iterates over entries in the map, returning the first output of `getResult` that is not `undefined`.\r\n+     * Only works for strings because shims iterate with `for-in`.\r\n+     */\r\n+    export const findInMap: <V, U>(map: Map<string, V>, getResult: (value: V, key: string) => U | undefined) => U | undefined = usingES6NativeMaps\r\n+        ? <V, U>(map: ES6Map<string, V>, f: (value: V, key: string) => U | undefined) => {\r\n+            const iter = map.entries();\r\n+            while (true) {\r\n+                const { value: pair, done } = iter.next();\r\n+                if (done) {\r\n+                    return undefined;\r\n+                }\r\n+                const [key, value] = pair;\r\n+                const result = f(value, key);\r\n+                if (result !== undefined) {\r\n+                    return result;\r\n+                }\r\n+            }\r\n+        }\r\n+        : <V, U>(map: Map<string, V>, f: (value: V, key: string) => U | undefined) => {\r\n+            let result: U | undefined;\r\n+            map.forEach((value, key) => {\r\n+                if (result === undefined)\r\n+                    result = f(value, key);\r\n+            });\r\n+            return result;\r\n+        };\r\n+\r\n+    /**\r\n+     * Whether `predicate` is true for at least one entry in the map.\r\n+     * Only works for strings because shims iterate with `for-in`.\r\n+     */\r\n+    export const someInMap: <V>(map: Map<string, V>, predicate: (value: V, key: string) => boolean) => boolean = usingES6NativeMaps\r\n+        ? <V>(map: ES6Map<string, V>, predicate: (value: V, key: string) => boolean) =>\r\n+            someInIterator(map.entries(), ([key, value]) => predicate(value, key))\r\n+        : <V>(map: Map<string, V>, predicate: (value: V, key: string) => boolean) => {\r\n+            let found = false;\r\n+            map.forEach((value, key) => {\r\n+                found = found || predicate(value, key);\r\n+            });\r\n+            return found;\r\n+        };\r\n+\r\n+    /**\r\n+     * Whether `predicate` is true for at least one key in the map.\r\n+     * Only works for strings because shims iterate with `for-in`.\r\n+     */\r\n+    export const someKeyInMap: (map: Map<string, any>, predicate: (key: string) => boolean) => boolean = usingES6NativeMaps\r\n+        ? (map: ES6Map<string, any>, predicate: (key: string) => boolean) => someInIterator(map.keys(), predicate)\r\n+        : (map: Map<string, any>, predicate: (key: string) => boolean) =>\r\n+            someInMap(map, (_value, key) => predicate(key));\r\n+\r\n+    /** Whether `predicate` is true for at least one value in the map. */\r\n+    export const someValueInMap: <T>(map: Map<any, T>, predicate: (value: T) => boolean) => boolean = usingES6NativeMaps\r\n+        ? <T>(map: ES6Map<any, T>, predicate: (value: T) => boolean) =>\r\n+            someInIterator(map.values(), predicate)\r\n+        : someInMap;\r\n+\r\n+    function someInIterator<T>(iterator: Iterator<T>, predicate: (value: T) => boolean): boolean {\r\n+        while (true) {\r\n+            const { value, done } = iterator.next();\r\n+            if (done) {\r\n+                return false;\r\n+            }\r\n+            if (predicate(value)) {\r\n+                return true;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Equivalent to the ES6 code:\r\n+     * `for (const key of map.keys()) action(key);`\r\n+     * Only works for strings because shims iterate with `for-in`.\r\n+     */\r\n+    export const forEachKeyInMap: (map: Map<string, any>, action: (key: string) => void) => void = usingES6NativeMaps\r\n+        ? (map: ES6Map<string, any>, action: (key: string) => void) => {\r\n+            const iter: Iterator<string> = map.keys();\r\n+            while (true) {\r\n+                const { value: key, done } = iter.next();\r\n+                if (done) {\r\n+                    return;\r\n+                }\r\n+                action(key);\r\n+            }\r\n+        }\r\n+        : (map: Map<string, any>, action: (key: string) => void) => {\r\n+            map.forEach((_value, key) => action(key));\r\n+        };\r\n+\r\n+    /** Size of a map. */\r\n+    export const mapSize: (map: Map<any, any>) => number = usingNativeMaps\r\n+        ? map => (map as any).size\r\n+        : map => {\r\n+            let size = 0;\r\n+            map.forEach(() => { size++; });\r\n+            return size;\r\n+        };\r\n+\r\n+    /** Convert a Map to a MapLike. */\r\n+    export function mapLikeOfMap<T>(map: Map<string, T>): MapLike<T> {\r\n+        const obj = createDictionaryModeObject<T>();\r\n+        map.forEach((value, key) => {\r\n+            obj[key] = value;\r\n+        });\r\n+        return obj;\r\n+    }\r\n+\r\n+    /** Create a map from a MapLike. This is useful for writing large maps as object literals. */\r\n+    export function mapOfMapLike<T>(object: MapLike<T>): Map<string, T> {\r\n+        const map = createMap<string, T>();\r\n+        // Copies keys/values from template. Note that for..in will not throw if\r\n+        // template is undefined, and instead will just exit the loop.\r\n+        for (const key in object) if (hasProperty(object, key)) {\r\n+            map.set(key, object[key]);\r\n+        }\r\n+        return map;\r\n+    }\r\n+\r\n+    class ShimStringSet implements Set<string> {\r\n+        private data = createDictionaryModeObject<true>();\r\n+\r\n+        constructor() {}\r\n+\r\n+        add(value: string) {\r\n+            this.data[value] = true;\r\n+        }\r\n+\r\n+        clear() {\r\n+            this.data = createDictionaryModeObject<true>();\r\n+        }\r\n+\r\n+        delete(value: string): boolean {\r\n+            const had = this.has(value);\r\n+            if (had) {\r\n+                delete this.data[value];\r\n+            }\r\n+            return had;\r\n+        }\r\n+\r\n+        forEach(action: (value: string) => void) {\r\n+            for (const value in this.data) {\r\n+                action(value);\r\n+            }\r\n+        }\r\n+\r\n+        has(value: string) {\r\n+            // tslint:disable-next-line:no-in-operator\r\n+            return value in this.data;\r\n+        }\r\n+\r\n+        isEmpty() {\r\n+            for (const _ in this.data) {\r\n+                // TODO: GH#11734\r\n+                _;\r\n+                return false;\r\n+            }\r\n+            return true;\r\n+        }\r\n+    }\r\n+\r\n+    declare const Set: { new(): Set<string> } | undefined;\r\n+    const usingNativeSets = typeof Set !== \"undefined\";\r\n+\r\n+    const SetCtr = usingNativeSets ? Set : ShimStringSet;\r\n+    export function createSet(): Set<string> {\r\n+        return new SetCtr();\r\n+    }\r\n+\r\n+    /** False if there are any values in the set. */\r\n+    export const setIsEmpty: (set: Set<string>) => boolean = usingNativeSets\r\n+        ? set => (set as any).size === 0\r\n+        : (set: ShimStringSet) => set.isEmpty();\r\n+\r\n+    // Map utilities\r\n+\r\n+    /** Set a value in a map, then return that value. */\r\n+    export function setAndReturn<K, V>(map: Map<K, V>, key: K, value: V): V {\r\n+        map.set(key, value);\r\n+        return value;\r\n+    }\r\n+\r\n+    /** False if there are any entries in the map. */\r\n+    export function mapIsEmpty(map: Map<any, any>): boolean {\r\n+        return !someKeyInMap(map, () => true);\r\n+    }\r\n+\r\n+    /** Create a new copy of a Map. */\r\n+    export function cloneMap<T>(map: Map<string, T>) {\r\n+        const clone = createMap<string, T>();\r\n+        copyMapEntriesFromTo(map, clone);\r\n+        return clone;\r\n+    }\r\n+\r\n+    /**\r\n+     * Performs a shallow copy of the properties from a source Map to a target Map\r\n+     *\r\n+     * @param source A map from which properties should be copied.\r\n+     * @param target A map to which properties should be copied.\r\n+     */\r\n+    export function copyMapEntriesFromTo<K, V>(source: Map<K, V>, target: Map<K, V>): void {\r\n+        source.forEach((value: V, key: K) => {\r\n+            target.set(key, value);\r\n+        });\r\n+    }\r\n+\r\n+    /**\r\n+     * Equivalent to `Array.from(map.keys())`.\r\n+     * Only works for strings because shims iterate with `for-in`.\r\n+     */\r\n+    export function keysOfMap(map: Map<string, any>): string[] {\r\n+        const keys: string[] = [];\r\n+        forEachKeyInMap(map, key => { keys.push(key); });\r\n+        return keys;\r\n+    }\r\n+\r\n+    /** Equivalent to `Array.from(map.values())`. */\r\n+    export function valuesOfMap<V>(map: Map<any, V>): V[] {\r\n+        const values: V[] = [];\r\n+        map.forEach((value) => { values.push(value); });\r\n+        return values;\r\n+    }\r\n+\r\n+    /** Return a new map with each key transformed by `getNewKey`. */\r\n+    export function transformKeys<T>(map: Map<string, T>, getNewKey: (key: string) => string): Map<string, T> {\r\n+        const newMap = createMap<string, T>();\r\n+        map.forEach((value, key) => {\r\n+            newMap.set(getNewKey(key), value);\r\n+        });\r\n+        return newMap;\r\n+    }\r\n+\r\n+    /** Replace each value with the result of calling `getNewValue`. */\r\n+    export function updateMapValues<V>(map: Map<any, V>, getNewValue: (value: V) => V): void {\r\n+        map.forEach((value, key) => {\r\n+            map.set(key, getNewValue(value));\r\n+        });\r\n+    }\r\n+\r\n+    /**\r\n+     * Change the value at `key` by applying the given function to it.\r\n+     * If there is no value at `key` then `getNewValue` will be passed `undefined`.\r\n+     */\r\n+    export function modifyValue<K, V>(map: Map<K, V>, key: K, getNewValue: (value: V) => V) {\r\n+        map.set(key, getNewValue(map.get(key)));\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a value in the map, or if not already present, set and return it.\r\n+     * Treats entries set to `undefined` as equivalent to not being set (saving a call to `has`).\r\n+     */\r\n+    export function getOrUpdate<K, V>(map: Map<K, V>, key: K, getValue: (key: K) => V): V {\r\n+        const value = map.get(key);\r\n+        return value !== undefined ? value : setAndReturn(map, key, getValue(key));\r\n+    }\r\n+\r\n+    /** Like `getOrUpdate`, but recognizes `undefined` as having been already set. */\r\n+    export function getOrUpdateAndAllowUndefined<K, V>(map: Map<K, V>, key: K, getValue: (key: K) => V): V {\r\n+        return map.has(key) ? map.get(key) : setAndReturn(map, key, getValue(key));\r\n+    }\r\n+\r\n+    /**\r\n+     * Sets the the value if the key is not already in the map.\r\n+     * Returns whether the value was set.\r\n+     */\r\n+    export function setIfNotSet<K, V>(map: Map<K, V>, key: K, value: V): boolean {\r\n+        const shouldSet = !map.has(key);\r\n+        if (shouldSet) {\r\n+            map.set(key, value);\r\n+        }\r\n+        return shouldSet;\r\n+    }\r\n+\r\n+    /** Deletes an entry from a map and returns it; or returns undefined if the key was not in the map. */\r\n+    export function tryDelete<K, V>(map: Map<K, V>, key: K): V | undefined {\r\n+        const current = map.get(key);\r\n+        if (current !== undefined) {\r\n+            map.delete(key);\r\n+            return current;\r\n+        }\r\n+        else {\r\n+            return undefined;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Creates a map from the elements of an array.\r\n+     *\r\n+     * @param array the array of input elements.\r\n+     * @param makeKey a function that produces a key for a given element.\r\n+     *\r\n+     * This function makes no effort to avoid collisions; if any two elements produce\r\n+     * the same key with the given 'makeKey' function, then the element with the higher\r\n+     * index in the array will be the one associated with the produced key.\r\n+     */\r\n+    export function arrayToMap<T>(array: T[], makeKey: (value: T) => string): Map<string, T>;\r\n+    export function arrayToMap<T, U>(array: T[], makeKey: (value: T) => string, makeValue: (value: T) => U): Map<string, U>;\r\n+    export function arrayToMap<T, U>(array: T[], makeKey: (value: T) => string, makeValue?: (value: T) => U): Map<string, T | U> {\r\n+        const result = createMap<string, T | U>();\r\n+        for (const value of array) {\r\n+            result.set(makeKey(value), makeValue ? makeValue(value) : value);\r\n+        }\r\n+        return result;\r\n+    }\r\n+\r\n+    /**\r\n+     * Adds the value to an array of values associated with the key, and returns the array.\r\n+     * Creates the array if it does not already exist.\r\n+     */\r\n+    export function multiMapAdd<K, V>(map: Map<K, V[]>, key: K, value: V): V[] {\r\n+        const values = map.get(key);\r\n+        if (values) {\r\n+            values.push(value);\r\n+            return values;\r\n+        }\r\n+        else {\r\n+            return setAndReturn(map, key, [value]);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Removes a value from an array of values associated with the key.\r\n+     * Does not preserve the order of those values.\r\n+     * Does nothing if `key` is not in `map`, or `value` is not in `map[key]`.\r\n+     */\r\n+    export function multiMapRemove<K, V>(map: Map<K, V[]>, key: K, value: V): void {\r\n+        const values = map.get(key);\r\n+        if (values) {\r\n+            unorderedRemoveItem(values, value);\r\n+            if (!values.length) {\r\n+                map.delete(key);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /** True if the maps have the same keys and values. */\r\n+    export function mapsAreEqual<V>(left: Map<string, V>, right: Map<string, V>, valuesAreEqual?: (left: V, right: V) => boolean): boolean {\r\n+        if (left === right) return true;\r\n+        if (!left || !right) return false;\r\n+        const someInLeftHasNoMatch = someInMap(left, (leftValue, leftKey) => {\r\n+            if (!right.has(leftKey)) return true;\r\n+            const rightValue = right.get(leftKey);\r\n+            return !(valuesAreEqual ? valuesAreEqual(leftValue, rightValue) : leftValue === rightValue);\r\n+        });\r\n+        if (someInLeftHasNoMatch) return false;\r\n+        const someInRightHasNoMatch = someKeyInMap(right, rightKey => !left.has(rightKey));\r\n+        return !someInRightHasNoMatch;\r\n+    }\r\n+\r\n+    /**\r\n+     * Creates a sorted array of keys.\r\n+     * Sorts keys according to the iteration order they would have if they were in an object, instead of from a Map.\r\n+     * This is so that tests run consistently whether or not we have a Map shim in place.\r\n+     * The difference between Map iteration order and V8 object insertion order is that V8 moves natural-number-like keys to the front.\r\n+     */\r\n+    export function sortInV8ObjectInsertionOrder<T>(values: T[], toKey: (t: T) => string): T[] {\r\n+        const naturalNumberKeys: T[] = [];\r\n+        const allOtherKeys: T[] = [];\r\n+        for (const value of values) {\r\n+            // \"0\" looks like a natural but \"08\" doesn't.\r\n+            const looksLikeNatural = /^(0|([1-9]\\d*))$/.test(toKey(value));\r\n+            (looksLikeNatural ? naturalNumberKeys : allOtherKeys).push(value);\r\n+        }\r\n+        function toInt(value: T): number {\r\n+            return parseInt(toKey(value), 10);\r\n+        }\r\n+        naturalNumberKeys.sort((a, b) => toInt(a) - toInt(b));\r\n+        return naturalNumberKeys.concat(allOtherKeys);\r\n+    }\r\n+\r\n+    // Set utilities\r\n+\r\n+    /** Union of the `getSet` of each element in the array. */\r\n+    export function setAggregate<T>(array: T[], getSet: (t: T) => Set<string>): Set<string> {\r\n+        const result = createSet();\r\n+        for (const value of array) {\r\n+            copySetValuesFromTo(getSet(value), result);\r\n+        }\r\n+        return result;\r\n+    }\r\n+\r\n+    /** Adds all values in `source` to `target`. */\r\n+    function copySetValuesFromTo<T>(source: Set<T>, target: Set<T>): void {\r\n+        source.forEach(value => target.add(value));\r\n+    }\r\n+\r\n+    /** Returns the values in `set` satisfying `predicate`. */\r\n+    export function filterSetToArray<T>(set: Set<T>, predicate: (value: T) => boolean): T[] {\r\n+        const result: T[] = [];\r\n+        set.forEach(value => {\r\n+            if (predicate(value)) {\r\n+                result.push(value);\r\n+            }\r\n+        });\r\n+        return result;\r\n+    }\r\n+\r\n+    // MapLike utilities\r\n+\r\n+    const hasOwnProperty = Object.prototype.hasOwnProperty;\r\n+\r\n+    export function clone<T>(object: T): T {\r\n+        const result: any = {};\r\n+        for (const id in object) {\r\n+            if (hasOwnProperty.call(object, id)) {\r\n+                result[id] = (<any>object)[id];\r\n+            }\r\n+        }\r\n+        return result;\r\n+    }\r\n+\r\n+    /**\r\n+     * Indicates whether a map-like contains an own property with the specified key.\r\n+     *\r\n+     * NOTE: This is intended for use only with MapLike<T> objects. For Map<T> objects, use\r\n+     *       the 'in' operator.\r\n+     *\r\n+     * @param map A map-like.\r\n+     * @param key A property key.\r\n+     */\r\n+    export function hasProperty<T>(map: MapLike<T>, key: string): boolean {\r\n+        return hasOwnProperty.call(map, key);\r\n+    }\r\n+\r\n+    /**\r\n+     * Gets the value of an owned property in a map-like.\r\n+     *\r\n+     * NOTE: This is intended for use only with MapLike<T> objects. For Map<T> objects, use\r\n+     *       an indexer.\r\n+     *\r\n+     * @param map A map-like.\r\n+     * @param key A property key.\r\n+     */\r\n+    export function getProperty<T>(map: MapLike<T>, key: string): T | undefined {\r\n+        return hasOwnProperty.call(map, key) ? map[key] : undefined;\r\n+    }\r\n+\r\n+    /**\r\n+     * Gets the owned, enumerable property keys of a map-like.\r\n+     *\r\n+     * NOTE: This is intended for use with MapLike<T> objects. For Map<T> objects, use\r\n+     *       Object.keys instead as it offers better performance.\r\n+     *\r\n+     * @param map A map-like.\r\n+     */\r\n+    export function getOwnKeys<T>(map: MapLike<T>): string[] {\r\n+        const keys: string[] = [];\r\n+        for (const key in map) if (hasOwnProperty.call(map, key)) {\r\n+            keys.push(key);\r\n+        }\r\n+        return keys;\r\n+    }\r\n+\r\n+    export function assign<T1 extends MapLike<{}>, T2, T3>(t: T1, arg1: T2, arg2: T3): T1 & T2 & T3;\r\n+    export function assign<T1 extends MapLike<{}>, T2>(t: T1, arg1: T2): T1 & T2;\r\n+    export function assign<T1 extends MapLike<{}>>(t: T1, ...args: any[]): any;\r\n+    export function assign<T1 extends MapLike<{}>>(t: T1, ...args: any[]) {\r\n+        for (const arg of args) {\r\n+            for (const p of getOwnKeys(arg)) {\r\n+                t[p] = arg[p];\r\n+            }\r\n+        }\r\n+        return t;\r\n+    }\r\n+\r\n+    /**\r\n+     * Reduce the properties defined on a map-like (but not from its prototype chain).\r\n+     *\r\n+     * @param map The map-like to reduce\r\n+     * @param callback An aggregation function that is called for each entry in the map\r\n+     * @param initial The initial value for the reduction.\r\n+     */\r\n+    export function reduceOwnProperties<T, U>(map: MapLike<T>, callback: (aggregate: U, value: T, key: string) => U, initial: U): U {\r\n+        let result = initial;\r\n+        for (const key in map) if (hasOwnProperty.call(map, key)) {\r\n+            result = callback(result, map[key], String(key));\r\n+        }\r\n+        return result;\r\n+    }\r\n+\r\n+    /**\r\n+     * Performs a shallow equality comparison of the contents of two map-likes.\r\n+     *\r\n+     * @param left A map-like whose properties should be compared.\r\n+     * @param right A map-like whose properties should be compared.\r\n+     */\r\n+    export function equalOwnProperties<T>(left: MapLike<T>, right: MapLike<T>, equalityComparer?: (left: T, right: T) => boolean) {\r\n+        if (left === right) return true;\r\n+        if (!left || !right) return false;\r\n+        for (const key in left) if (hasOwnProperty.call(left, key)) {\r\n+            if (!hasOwnProperty.call(right, key) === undefined) return false;\r\n+            if (equalityComparer ? !equalityComparer(left[key], right[key]) : left[key] !== right[key]) return false;\r\n+        }\r\n+        for (const key in right) if (hasOwnProperty.call(right, key)) {\r\n+            if (!hasOwnProperty.call(left, key)) return false;\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    export function extend<T1, T2>(first: T1, second: T2): T1 & T2 {\r\n+        const result: T1 & T2 = <any>{};\r\n+        for (const id in second) if (hasOwnProperty.call(second, id)) {\r\n+            (result as any)[id] = (second as any)[id];\r\n+        }\r\n+        for (const id in first) if (hasOwnProperty.call(first, id)) {\r\n+            (result as any)[id] = (first as any)[id];\r\n+        }\r\n+        return result;\r\n+    }\r\n+}\r"},{"sha":"87337cb1e2e5cf7d9d3960087199fe83dadd3006","filename":"src/compiler/commandLineParser.ts","status":"modified","additions":58,"deletions":70,"changes":128,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2FcommandLineParser.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2FcommandLineParser.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2FcommandLineParser.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -65,7 +65,7 @@ namespace ts {\n         },\r\n         {\r\n             name: \"jsx\",\r\n-            type: createMap({\r\n+            type: mapOfMapLike({\r\n                 \"preserve\": JsxEmit.Preserve,\r\n                 \"react\": JsxEmit.React\r\n             }),\r\n@@ -95,7 +95,7 @@ namespace ts {\n         {\r\n             name: \"module\",\r\n             shortName: \"m\",\r\n-            type: createMap({\r\n+            type: mapOfMapLike({\r\n                 \"none\": ModuleKind.None,\r\n                 \"commonjs\": ModuleKind.CommonJS,\r\n                 \"amd\": ModuleKind.AMD,\r\n@@ -109,7 +109,7 @@ namespace ts {\n         },\r\n         {\r\n             name: \"newLine\",\r\n-            type: createMap({\r\n+            type: mapOfMapLike({\r\n                 \"crlf\": NewLineKind.CarriageReturnLineFeed,\r\n                 \"lf\": NewLineKind.LineFeed\r\n             }),\r\n@@ -258,7 +258,7 @@ namespace ts {\n         {\r\n             name: \"target\",\r\n             shortName: \"t\",\r\n-            type: createMap({\r\n+            type: mapOfMapLike({\r\n                 \"es3\": ScriptTarget.ES3,\r\n                 \"es5\": ScriptTarget.ES5,\r\n                 \"es6\": ScriptTarget.ES2015,\r\n@@ -294,7 +294,7 @@ namespace ts {\n         },\r\n         {\r\n             name: \"moduleResolution\",\r\n-            type: createMap({\r\n+            type: mapOfMapLike({\r\n                 \"node\": ModuleResolutionKind.NodeJs,\r\n                 \"classic\": ModuleResolutionKind.Classic,\r\n             }),\r\n@@ -403,7 +403,7 @@ namespace ts {\n             type: \"list\",\r\n             element: {\r\n                 name: \"lib\",\r\n-                type: createMap({\r\n+                type: mapOfMapLike({\r\n                     // JavaScript only\r\n                     \"es5\": \"lib.es5.d.ts\",\r\n                     \"es6\": \"lib.es2015.d.ts\",\r\n@@ -480,8 +480,8 @@ namespace ts {\n \r\n     /* @internal */\r\n     export interface OptionNameMap {\r\n-        optionNameMap: Map<CommandLineOption>;\r\n-        shortOptionNames: Map<string>;\r\n+        optionNameMap: Map<string, CommandLineOption>;\r\n+        shortOptionNames: Map<string, string>;\r\n     }\r\n \r\n     /* @internal */\r\n@@ -500,12 +500,12 @@ namespace ts {\n             return optionNameMapCache;\r\n         }\r\n \r\n-        const optionNameMap = createMap<CommandLineOption>();\r\n-        const shortOptionNames = createMap<string>();\r\n+        const optionNameMap = createMap<string, CommandLineOption>();\r\n+        const shortOptionNames = createMap<string, string>();\r\n         forEach(optionDeclarations, option => {\r\n-            optionNameMap[option.name.toLowerCase()] = option;\r\n+            optionNameMap.set(option.name.toLowerCase(), option);\r\n             if (option.shortName) {\r\n-                shortOptionNames[option.shortName] = option.name;\r\n+                shortOptionNames.set(option.shortName, option.name);\r\n             }\r\n         });\r\n \r\n@@ -515,16 +515,16 @@ namespace ts {\n \r\n     /* @internal */\r\n     export function createCompilerDiagnosticForInvalidCustomType(opt: CommandLineOptionOfCustomType): Diagnostic {\r\n-        const namesOfType = Object.keys(opt.type).map(key => `'${key}'`).join(\", \");\r\n+        const namesOfType = keysOfMap(opt.type).map(key => `'${key}'`).join(\", \");\r\n         return createCompilerDiagnostic(Diagnostics.Argument_for_0_option_must_be_Colon_1, `--${opt.name}`, namesOfType);\r\n     }\r\n \r\n     /* @internal */\r\n     export function parseCustomTypeOption(opt: CommandLineOptionOfCustomType, value: string, errors: Diagnostic[]) {\r\n         const key = trimString((value || \"\")).toLowerCase();\r\n-        const map = opt.type;\r\n-        if (key in map) {\r\n-            return map[key];\r\n+        const customType = opt.type.get(key);\r\n+        if (customType !== undefined) {\r\n+            return customType;\r\n         }\r\n         else {\r\n             errors.push(createCompilerDiagnosticForInvalidCustomType(opt));\r\n@@ -577,13 +577,13 @@ namespace ts {\n                     s = s.slice(s.charCodeAt(1) === CharacterCodes.minus ? 2 : 1).toLowerCase();\r\n \r\n                     // Try to translate short option names to their full equivalents.\r\n-                    if (s in shortOptionNames) {\r\n-                        s = shortOptionNames[s];\r\n+                    const short = shortOptionNames.get(s);\r\n+                    if (short !== undefined) {\r\n+                        s = short;\r\n                     }\r\n \r\n-                    if (s in optionNameMap) {\r\n-                        const opt = optionNameMap[s];\r\n-\r\n+                    const opt = optionNameMap.get(s);\r\n+                    if (opt !== undefined) {\r\n                         if (opt.isTSConfigOnly) {\r\n                             errors.push(createCompilerDiagnostic(Diagnostics.Option_0_can_only_be_specified_in_tsconfig_json_file, opt.name));\r\n                         }\r\n@@ -706,7 +706,7 @@ namespace ts {\n      * @param fileNames array of filenames to be generated into tsconfig.json\r\n      */\r\n     /* @internal */\r\n-    export function generateTSConfig(options: CompilerOptions, fileNames: string[]): { compilerOptions: Map<CompilerOptionsValue> } {\r\n+    export function generateTSConfig(options: CompilerOptions, fileNames: string[]): { compilerOptions: MapLike<CompilerOptionsValue> } {\r\n         const compilerOptions = extend(options, defaultInitCompilerOptions);\r\n         const configurations: any = {\r\n             compilerOptions: serializeCompilerOptions(compilerOptions)\r\n@@ -718,7 +718,7 @@ namespace ts {\n \r\n         return configurations;\r\n \r\n-        function getCustomTypeMapOfCommandLineOption(optionDefinition: CommandLineOption): Map<string | number> | undefined {\r\n+        function getCustomTypeMapOfCommandLineOption(optionDefinition: CommandLineOption): Map<string, string | number> | undefined {\r\n             if (optionDefinition.type === \"string\" || optionDefinition.type === \"number\" || optionDefinition.type === \"boolean\") {\r\n                 // this is of a type CommandLineOptionOfPrimitiveType\r\n                 return undefined;\r\n@@ -731,18 +731,17 @@ namespace ts {\n             }\r\n         }\r\n \r\n-        function getNameOfCompilerOptionValue(value: CompilerOptionsValue, customTypeMap: MapLike<string | number>): string | undefined {\r\n+        function getNameOfCompilerOptionValue(value: CompilerOptionsValue, customTypeMap: Map<string, string | number>): string | undefined {\r\n             // There is a typeMap associated with this command-line option so use it to map value back to its name\r\n-            for (const key in customTypeMap) {\r\n-                if (customTypeMap[key] === value) {\r\n+            return findInMap(customTypeMap, (customValue, key) => {\r\n+                if (customValue === value) {\r\n                     return key;\r\n                 }\r\n-            }\r\n-            return undefined;\r\n+            });\r\n         }\r\n \r\n-        function serializeCompilerOptions(options: CompilerOptions): Map<CompilerOptionsValue> {\r\n-            const result = createMap<CompilerOptionsValue>();\r\n+        function serializeCompilerOptions(options: CompilerOptions): MapLike<CompilerOptionsValue> {\r\n+            const result = createMap<string, CompilerOptionsValue>();\r\n             const optionsNameMap = getOptionNameMap().optionNameMap;\r\n \r\n             for (const name in options) {\r\n@@ -758,33 +757,33 @@ namespace ts {\n                             break;\r\n                         default:\r\n                             const value = options[name];\r\n-                            let optionDefinition = optionsNameMap[name.toLowerCase()];\r\n+                            let optionDefinition = optionsNameMap.get(name.toLowerCase());\r\n                             if (optionDefinition) {\r\n                                 const customTypeMap = getCustomTypeMapOfCommandLineOption(optionDefinition);\r\n                                 if (!customTypeMap) {\r\n                                     // There is no map associated with this compiler option then use the value as-is\r\n                                     // This is the case if the value is expect to be string, number, boolean or list of string\r\n-                                    result[name] = value;\r\n+                                    result.set(name, value);\r\n                                 }\r\n                                 else {\r\n                                     if (optionDefinition.type === \"list\") {\r\n                                         const convertedValue: string[] = [];\r\n                                         for (const element of value as (string | number)[]) {\r\n                                             convertedValue.push(getNameOfCompilerOptionValue(element, customTypeMap));\r\n                                         }\r\n-                                        result[name] = convertedValue;\r\n+                                        result.set(name, convertedValue);\r\n                                     }\r\n                                     else {\r\n                                         // There is a typeMap associated with this command-line option so use it to map value back to its name\r\n-                                        result[name] = getNameOfCompilerOptionValue(value, customTypeMap);\r\n+                                        result.set(name, getNameOfCompilerOptionValue(value, customTypeMap));\r\n                                     }\r\n                                 }\r\n                             }\r\n                             break;\r\n                     }\r\n                 }\r\n             }\r\n-            return result;\r\n+            return mapLikeOfMap(result);\r\n         }\r\n     }\r\n \r\n@@ -1025,8 +1024,8 @@ namespace ts {\n         const optionNameMap = arrayToMap(optionDeclarations, opt => opt.name);\r\n \r\n         for (const id in jsonOptions) {\r\n-            if (id in optionNameMap) {\r\n-                const opt = optionNameMap[id];\r\n+            const opt = optionNameMap.get(id);\r\n+            if (opt !== undefined) {\r\n                 defaultOptions[opt.name] = convertJsonOption(opt, jsonOptions[id], basePath, errors);\r\n             }\r\n             else {\r\n@@ -1062,8 +1061,9 @@ namespace ts {\n \r\n     function convertJsonOptionOfCustomType(opt: CommandLineOptionOfCustomType, value: string, errors: Diagnostic[]) {\r\n         const key = value.toLowerCase();\r\n-        if (key in opt.type) {\r\n-            return opt.type[key];\r\n+        const val = opt.type.get(key);\r\n+        if (val !== undefined) {\r\n+            return val;\r\n         }\r\n         else {\r\n             errors.push(createCompilerDiagnosticForInvalidCustomType(opt));\r\n@@ -1172,12 +1172,12 @@ namespace ts {\n         // Literal file names (provided via the \"files\" array in tsconfig.json) are stored in a\r\n         // file map with a possibly case insensitive key. We use this map later when when including\r\n         // wildcard paths.\r\n-        const literalFileMap = createMap<string>();\r\n+        const literalFileMap = createMap<string, string>();\r\n \r\n         // Wildcard paths (provided via the \"includes\" array in tsconfig.json) are stored in a\r\n         // file map with a possibly case insensitive key. We use this map to store paths matched\r\n         // via wildcard, and to handle extension priority.\r\n-        const wildcardFileMap = createMap<string>();\r\n+        const wildcardFileMap = createMap<string, string>();\r\n \r\n         if (include) {\r\n             include = validateSpecs(include, errors, /*allowTrailingRecursion*/ false);\r\n@@ -1191,7 +1191,7 @@ namespace ts {\n         // file map that marks whether it was a regular wildcard match (with a `*` or `?` token),\r\n         // or a recursive directory. This information is used by filesystem watchers to monitor for\r\n         // new entries in these paths.\r\n-        const wildcardDirectories: Map<WatchDirectoryFlags> = getWildcardDirectories(include, exclude, basePath, host.useCaseSensitiveFileNames);\r\n+        const wildcardDirectories: Map<string, WatchDirectoryFlags> = getWildcardDirectories(include, exclude, basePath, host.useCaseSensitiveFileNames);\r\n \r\n         // Rather than requery this for each file and filespec, we query the supported extensions\r\n         // once and store it on the expansion context.\r\n@@ -1202,7 +1202,7 @@ namespace ts {\n         if (fileNames) {\r\n             for (const fileName of fileNames) {\r\n                 const file = combinePaths(basePath, fileName);\r\n-                literalFileMap[keyMapper(file)] = file;\r\n+                literalFileMap.set(keyMapper(file), file);\r\n             }\r\n         }\r\n \r\n@@ -1225,18 +1225,17 @@ namespace ts {\n                 removeWildcardFilesWithLowerPriorityExtension(file, wildcardFileMap, supportedExtensions, keyMapper);\r\n \r\n                 const key = keyMapper(file);\r\n-                if (!(key in literalFileMap) && !(key in wildcardFileMap)) {\r\n-                    wildcardFileMap[key] = file;\r\n+                if (!literalFileMap.has(key)) {\r\n+                    setIfNotSet(wildcardFileMap, key, file);\r\n                 }\r\n             }\r\n         }\r\n \r\n-        const literalFiles = reduceProperties(literalFileMap, addFileToOutput, []);\r\n-        const wildcardFiles = reduceProperties(wildcardFileMap, addFileToOutput, []);\r\n-        wildcardFiles.sort(host.useCaseSensitiveFileNames ? compareStrings : compareStringsCaseInsensitive);\r\n+        const literalFiles = valuesOfMap(literalFileMap);\r\n+        const wildcardFiles = valuesOfMap(wildcardFileMap).sort(host.useCaseSensitiveFileNames ? compareStrings : compareStringsCaseInsensitive);\r\n         return {\r\n             fileNames: literalFiles.concat(wildcardFiles),\r\n-            wildcardDirectories\r\n+            wildcardDirectories: mapLikeOfMap(wildcardDirectories)\r\n         };\r\n     }\r\n \r\n@@ -1277,7 +1276,7 @@ namespace ts {\n         //  /a/b/a?z    - Watch /a/b directly to catch any new file matching a?z\r\n         const rawExcludeRegex = getRegularExpressionForWildcard(exclude, path, \"exclude\");\r\n         const excludeRegex = rawExcludeRegex && new RegExp(rawExcludeRegex, useCaseSensitiveFileNames ? \"\" : \"i\");\r\n-        const wildcardDirectories = createMap<WatchDirectoryFlags>();\r\n+        const wildcardDirectories = createMap<string, WatchDirectoryFlags>();\r\n         if (include !== undefined) {\r\n             const recursiveKeys: string[] = [];\r\n             for (const file of include) {\r\n@@ -1290,9 +1289,9 @@ namespace ts {\n                 if (match) {\r\n                     const key = useCaseSensitiveFileNames ? match[0] : match[0].toLowerCase();\r\n                     const flags = watchRecursivePattern.test(name) ? WatchDirectoryFlags.Recursive : WatchDirectoryFlags.None;\r\n-                    const existingFlags = wildcardDirectories[key];\r\n+                    const existingFlags = wildcardDirectories.get(key);\r\n                     if (existingFlags === undefined || existingFlags < flags) {\r\n-                        wildcardDirectories[key] = flags;\r\n+                        wildcardDirectories.set(key, flags);\r\n                         if (flags === WatchDirectoryFlags.Recursive) {\r\n                             recursiveKeys.push(key);\r\n                         }\r\n@@ -1301,13 +1300,13 @@ namespace ts {\n             }\r\n \r\n             // Remove any subpaths under an existing recursively watched directory.\r\n-            for (const key in wildcardDirectories) {\r\n+            forEachKeyInMap(wildcardDirectories, key => {\r\n                 for (const recursiveKey of recursiveKeys) {\r\n                     if (key !== recursiveKey && containsPath(recursiveKey, key, path, !useCaseSensitiveFileNames)) {\r\n-                        delete wildcardDirectories[key];\r\n+                        wildcardDirectories.delete(key);\r\n                     }\r\n                 }\r\n-            }\r\n+            });\r\n         }\r\n \r\n         return wildcardDirectories;\r\n@@ -1321,13 +1320,13 @@ namespace ts {\n      * @param extensionPriority The priority of the extension.\r\n      * @param context The expansion context.\r\n      */\r\n-    function hasFileWithHigherPriorityExtension(file: string, literalFiles: Map<string>, wildcardFiles: Map<string>, extensions: string[], keyMapper: (value: string) => string) {\r\n+    function hasFileWithHigherPriorityExtension(file: string, literalFiles: Map<string, string>, wildcardFiles: Map<string, string>, extensions: string[], keyMapper: (value: string) => string) {\r\n         const extensionPriority = getExtensionPriority(file, extensions);\r\n         const adjustedExtensionPriority = adjustExtensionPriority(extensionPriority);\r\n         for (let i = ExtensionPriority.Highest; i < adjustedExtensionPriority; i++) {\r\n             const higherPriorityExtension = extensions[i];\r\n             const higherPriorityPath = keyMapper(changeExtension(file, higherPriorityExtension));\r\n-            if (higherPriorityPath in literalFiles || higherPriorityPath in wildcardFiles) {\r\n+            if (literalFiles.has(higherPriorityPath) || wildcardFiles.has(higherPriorityPath)) {\r\n                 return true;\r\n             }\r\n         }\r\n@@ -1343,27 +1342,16 @@ namespace ts {\n      * @param extensionPriority The priority of the extension.\r\n      * @param context The expansion context.\r\n      */\r\n-    function removeWildcardFilesWithLowerPriorityExtension(file: string, wildcardFiles: Map<string>, extensions: string[], keyMapper: (value: string) => string) {\r\n+    function removeWildcardFilesWithLowerPriorityExtension(file: string, wildcardFiles: Map<string, string>, extensions: string[], keyMapper: (value: string) => string) {\r\n         const extensionPriority = getExtensionPriority(file, extensions);\r\n         const nextExtensionPriority = getNextLowestExtensionPriority(extensionPriority);\r\n         for (let i = nextExtensionPriority; i < extensions.length; i++) {\r\n             const lowerPriorityExtension = extensions[i];\r\n             const lowerPriorityPath = keyMapper(changeExtension(file, lowerPriorityExtension));\r\n-            delete wildcardFiles[lowerPriorityPath];\r\n+            wildcardFiles.delete(lowerPriorityPath);\r\n         }\r\n     }\r\n \r\n-    /**\r\n-     * Adds a file to an array of files.\r\n-     *\r\n-     * @param output The output array.\r\n-     * @param file The file path.\r\n-     */\r\n-    function addFileToOutput(output: string[], file: string) {\r\n-        output.push(file);\r\n-        return output;\r\n-    }\r\n-\r\n     /**\r\n      * Gets a case sensitive key.\r\n      *\r"},{"sha":"208b4d0931a82088109117fa12ee1d1ac0eacd28","filename":"src/compiler/core.ts","status":"modified","additions":13,"deletions":274,"changes":287,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fcore.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fcore.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Fcore.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -1,4 +1,5 @@\n-﻿/// <reference path=\"types.ts\"/>\r\n+/// <reference path=\"collections.ts\" />\r\n+/// <reference path=\"types.ts\"/>\r\n /// <reference path=\"performance.ts\" />\r\n \r\n /* @internal */\r\n@@ -18,31 +19,11 @@ namespace ts {\n         True = -1\r\n     }\r\n \r\n-    const createObject = Object.create;\r\n-\r\n     // More efficient to create a collator once and use its `compare` than to call `a.localeCompare(b)` many times.\r\n     export const collator: { compare(a: string, b: string): number } = typeof Intl === \"object\" && typeof Intl.Collator === \"function\" ? new Intl.Collator() : undefined;\r\n \r\n-    export function createMap<T>(template?: MapLike<T>): Map<T> {\r\n-        const map: Map<T> = createObject(null); // tslint:disable-line:no-null-keyword\r\n-\r\n-        // Using 'delete' on an object causes V8 to put the object in dictionary mode.\r\n-        // This disables creation of hidden classes, which are expensive when an object is\r\n-        // constantly changing shape.\r\n-        map[\"__\"] = undefined;\r\n-        delete map[\"__\"];\r\n-\r\n-        // Copies keys/values from template. Note that for..in will not throw if\r\n-        // template is undefined, and instead will just exit the loop.\r\n-        for (const key in template) if (hasOwnProperty.call(template, key)) {\r\n-            map[key] = template[key];\r\n-        }\r\n-\r\n-        return map;\r\n-    }\r\n-\r\n     export function createFileMap<T>(keyMapper?: (key: string) => string): FileMap<T> {\r\n-        let files = createMap<T>();\r\n+        const files = createMap<string, T>();\r\n         return {\r\n             get,\r\n             set,\r\n@@ -54,39 +35,33 @@ namespace ts {\n         };\r\n \r\n         function forEachValueInMap(f: (key: Path, value: T) => void) {\r\n-            for (const key in files) {\r\n-                f(<Path>key, files[key]);\r\n-            }\r\n+            files.forEach((value, key) => f(key as Path, value));\r\n         }\r\n \r\n-        function getKeys() {\r\n-            const keys: Path[] = [];\r\n-            for (const key in files) {\r\n-                keys.push(<Path>key);\r\n-            }\r\n-            return keys;\r\n+        function getKeys(): Path[] {\r\n+            return keysOfMap(files) as Path[];\r\n         }\r\n \r\n         // path should already be well-formed so it does not need to be normalized\r\n         function get(path: Path): T {\r\n-            return files[toKey(path)];\r\n+            return files.get(toKey(path));\r\n         }\r\n \r\n         function set(path: Path, value: T) {\r\n-            files[toKey(path)] = value;\r\n+            files.set(toKey(path), value);\r\n         }\r\n \r\n         function contains(path: Path) {\r\n-            return toKey(path) in files;\r\n+            return files.has(toKey(path));\r\n         }\r\n \r\n         function remove(path: Path) {\r\n             const key = toKey(path);\r\n-            delete files[key];\r\n+            files.delete(key);\r\n         }\r\n \r\n         function clear() {\r\n-            files = createMap<T>();\r\n+            files.clear();\r\n         }\r\n \r\n         function toKey(path: Path): string {\r\n@@ -707,242 +682,6 @@ namespace ts {\n         return initial;\r\n     }\r\n \r\n-    const hasOwnProperty = Object.prototype.hasOwnProperty;\r\n-\r\n-    /**\r\n-     * Indicates whether a map-like contains an own property with the specified key.\r\n-     *\r\n-     * NOTE: This is intended for use only with MapLike<T> objects. For Map<T> objects, use\r\n-     *       the 'in' operator.\r\n-     *\r\n-     * @param map A map-like.\r\n-     * @param key A property key.\r\n-     */\r\n-    export function hasProperty<T>(map: MapLike<T>, key: string): boolean {\r\n-        return hasOwnProperty.call(map, key);\r\n-    }\r\n-\r\n-    /**\r\n-     * Gets the value of an owned property in a map-like.\r\n-     *\r\n-     * NOTE: This is intended for use only with MapLike<T> objects. For Map<T> objects, use\r\n-     *       an indexer.\r\n-     *\r\n-     * @param map A map-like.\r\n-     * @param key A property key.\r\n-     */\r\n-    export function getProperty<T>(map: MapLike<T>, key: string): T | undefined {\r\n-        return hasOwnProperty.call(map, key) ? map[key] : undefined;\r\n-    }\r\n-\r\n-    /**\r\n-     * Gets the owned, enumerable property keys of a map-like.\r\n-     *\r\n-     * NOTE: This is intended for use with MapLike<T> objects. For Map<T> objects, use\r\n-     *       Object.keys instead as it offers better performance.\r\n-     *\r\n-     * @param map A map-like.\r\n-     */\r\n-    export function getOwnKeys<T>(map: MapLike<T>): string[] {\r\n-        const keys: string[] = [];\r\n-        for (const key in map) if (hasOwnProperty.call(map, key)) {\r\n-            keys.push(key);\r\n-        }\r\n-        return keys;\r\n-    }\r\n-\r\n-    /**\r\n-     * Enumerates the properties of a Map<T>, invoking a callback and returning the first truthy result.\r\n-     *\r\n-     * @param map A map for which properties should be enumerated.\r\n-     * @param callback A callback to invoke for each property.\r\n-     */\r\n-    export function forEachProperty<T, U>(map: Map<T>, callback: (value: T, key: string) => U): U {\r\n-        let result: U;\r\n-        for (const key in map) {\r\n-            if (result = callback(map[key], key)) break;\r\n-        }\r\n-        return result;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns true if a Map<T> has some matching property.\r\n-     *\r\n-     * @param map A map whose properties should be tested.\r\n-     * @param predicate An optional callback used to test each property.\r\n-     */\r\n-    export function someProperties<T>(map: Map<T>, predicate?: (value: T, key: string) => boolean) {\r\n-        for (const key in map) {\r\n-            if (!predicate || predicate(map[key], key)) return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    /**\r\n-     * Performs a shallow copy of the properties from a source Map<T> to a target MapLike<T>\r\n-     *\r\n-     * @param source A map from which properties should be copied.\r\n-     * @param target A map to which properties should be copied.\r\n-     */\r\n-    export function copyProperties<T>(source: Map<T>, target: MapLike<T>): void {\r\n-        for (const key in source) {\r\n-            target[key] = source[key];\r\n-        }\r\n-    }\r\n-\r\n-    export function assign<T1 extends MapLike<{}>, T2, T3>(t: T1, arg1: T2, arg2: T3): T1 & T2 & T3;\r\n-    export function assign<T1 extends MapLike<{}>, T2>(t: T1, arg1: T2): T1 & T2;\r\n-    export function assign<T1 extends MapLike<{}>>(t: T1, ...args: any[]): any;\r\n-    export function assign<T1 extends MapLike<{}>>(t: T1, ...args: any[]) {\r\n-        for (const arg of args) {\r\n-            for (const p of getOwnKeys(arg)) {\r\n-                t[p] = arg[p];\r\n-            }\r\n-        }\r\n-        return t;\r\n-    }\r\n-\r\n-    /**\r\n-     * Reduce the properties of a map.\r\n-     *\r\n-     * NOTE: This is intended for use with Map<T> objects. For MapLike<T> objects, use\r\n-     *       reduceOwnProperties instead as it offers better runtime safety.\r\n-     *\r\n-     * @param map The map to reduce\r\n-     * @param callback An aggregation function that is called for each entry in the map\r\n-     * @param initial The initial value for the reduction.\r\n-     */\r\n-    export function reduceProperties<T, U>(map: Map<T>, callback: (aggregate: U, value: T, key: string) => U, initial: U): U {\r\n-        let result = initial;\r\n-        for (const key in map) {\r\n-            result = callback(result, map[key], String(key));\r\n-        }\r\n-        return result;\r\n-    }\r\n-\r\n-    /**\r\n-     * Reduce the properties defined on a map-like (but not from its prototype chain).\r\n-     *\r\n-     * NOTE: This is intended for use with MapLike<T> objects. For Map<T> objects, use\r\n-     *       reduceProperties instead as it offers better performance.\r\n-     *\r\n-     * @param map The map-like to reduce\r\n-     * @param callback An aggregation function that is called for each entry in the map\r\n-     * @param initial The initial value for the reduction.\r\n-     */\r\n-    export function reduceOwnProperties<T, U>(map: MapLike<T>, callback: (aggregate: U, value: T, key: string) => U, initial: U): U {\r\n-        let result = initial;\r\n-        for (const key in map) if (hasOwnProperty.call(map, key)) {\r\n-            result = callback(result, map[key], String(key));\r\n-        }\r\n-        return result;\r\n-    }\r\n-\r\n-    /**\r\n-     * Performs a shallow equality comparison of the contents of two map-likes.\r\n-     *\r\n-     * @param left A map-like whose properties should be compared.\r\n-     * @param right A map-like whose properties should be compared.\r\n-     */\r\n-    export function equalOwnProperties<T>(left: MapLike<T>, right: MapLike<T>, equalityComparer?: (left: T, right: T) => boolean) {\r\n-        if (left === right) return true;\r\n-        if (!left || !right) return false;\r\n-        for (const key in left) if (hasOwnProperty.call(left, key)) {\r\n-            if (!hasOwnProperty.call(right, key) === undefined) return false;\r\n-            if (equalityComparer ? !equalityComparer(left[key], right[key]) : left[key] !== right[key]) return false;\r\n-        }\r\n-        for (const key in right) if (hasOwnProperty.call(right, key)) {\r\n-            if (!hasOwnProperty.call(left, key)) return false;\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a map from the elements of an array.\r\n-     *\r\n-     * @param array the array of input elements.\r\n-     * @param makeKey a function that produces a key for a given element.\r\n-     *\r\n-     * This function makes no effort to avoid collisions; if any two elements produce\r\n-     * the same key with the given 'makeKey' function, then the element with the higher\r\n-     * index in the array will be the one associated with the produced key.\r\n-     */\r\n-    export function arrayToMap<T>(array: T[], makeKey: (value: T) => string): Map<T>;\r\n-    export function arrayToMap<T, U>(array: T[], makeKey: (value: T) => string, makeValue: (value: T) => U): Map<U>;\r\n-    export function arrayToMap<T, U>(array: T[], makeKey: (value: T) => string, makeValue?: (value: T) => U): Map<T | U> {\r\n-        const result = createMap<T | U>();\r\n-        for (const value of array) {\r\n-            result[makeKey(value)] = makeValue ? makeValue(value) : value;\r\n-        }\r\n-        return result;\r\n-    }\r\n-\r\n-    export function isEmpty<T>(map: Map<T>) {\r\n-        for (const id in map) {\r\n-            if (hasProperty(map, id)) {\r\n-                return false;\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    export function cloneMap<T>(map: Map<T>) {\r\n-        const clone = createMap<T>();\r\n-        copyProperties(map, clone);\r\n-        return clone;\r\n-    }\r\n-\r\n-    export function clone<T>(object: T): T {\r\n-        const result: any = {};\r\n-        for (const id in object) {\r\n-            if (hasOwnProperty.call(object, id)) {\r\n-                result[id] = (<any>object)[id];\r\n-            }\r\n-        }\r\n-        return result;\r\n-    }\r\n-\r\n-    export function extend<T1, T2>(first: T1, second: T2): T1 & T2 {\r\n-        const result: T1 & T2 = <any>{};\r\n-        for (const id in second) if (hasOwnProperty.call(second, id)) {\r\n-            (result as any)[id] = (second as any)[id];\r\n-        }\r\n-        for (const id in first) if (hasOwnProperty.call(first, id)) {\r\n-            (result as any)[id] = (first as any)[id];\r\n-        }\r\n-        return result;\r\n-    }\r\n-\r\n-    /**\r\n-     * Adds the value to an array of values associated with the key, and returns the array.\r\n-     * Creates the array if it does not already exist.\r\n-     */\r\n-    export function multiMapAdd<V>(map: Map<V[]>, key: string | number, value: V): V[] {\r\n-        const values = map[key];\r\n-        if (values) {\r\n-            values.push(value);\r\n-            return values;\r\n-        }\r\n-        else {\r\n-            return map[key] = [value];\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Removes a value from an array of values associated with the key.\r\n-     * Does not preserve the order of those values.\r\n-     * Does nothing if `key` is not in `map`, or `value` is not in `map[key]`.\r\n-     */\r\n-    export function multiMapRemove<V>(map: Map<V[]>, key: string, value: V): void {\r\n-        const values = map[key];\r\n-        if (values) {\r\n-            unorderedRemoveItem(values, value);\r\n-            if (!values.length) {\r\n-                delete map[key];\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n     /**\r\n      * Tests whether a value is an array.\r\n      */\r\n@@ -1041,10 +780,10 @@ namespace ts {\n         return text.replace(/{(\\d+)}/g, (_match, index?) => args[+index + baseIndex]);\r\n     }\r\n \r\n-    export let localizedDiagnosticMessages: Map<string> = undefined;\r\n+    export let localizedDiagnosticMessages: Map<string, string> = undefined;\r\n \r\n     export function getLocaleSpecificMessage(message: DiagnosticMessage) {\r\n-        return localizedDiagnosticMessages && localizedDiagnosticMessages[message.key] || message.message;\r\n+        return localizedDiagnosticMessages && localizedDiagnosticMessages.get(message.key) || message.message;\r\n     }\r\n \r\n     export function createFileDiagnostic(file: SourceFile, start: number, length: number, message: DiagnosticMessage, ...args: (string | number)[]): Diagnostic;\r"},{"sha":"0c3b2abf3f04d61302e2ae22e197c7d09cf7407b","filename":"src/compiler/declarationEmitter.ts","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2FdeclarationEmitter.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2FdeclarationEmitter.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2FdeclarationEmitter.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -59,7 +59,7 @@ namespace ts {\n         let resultHasExternalModuleIndicator: boolean;\r\n         let currentText: string;\r\n         let currentLineMap: number[];\r\n-        let currentIdentifiers: Map<string>;\r\n+        let currentIdentifiers: Map<string, string>;\r\n         let isCurrentFileExternalModule: boolean;\r\n         let reportedDeclarationError = false;\r\n         let errorNameNode: DeclarationName;\r\n@@ -75,7 +75,7 @@ namespace ts {\n         // and we could be collecting these paths from multiple files into single one with --out option\r\n         let referencesOutput = \"\";\r\n \r\n-        let usedTypeDirectiveReferences: Map<string>;\r\n+        let usedTypeDirectiveReferences: Set<string>;\r\n \r\n         // Emit references corresponding to each file\r\n         const emittedReferencedFiles: SourceFile[] = [];\r\n@@ -156,9 +156,9 @@ namespace ts {\n         });\r\n \r\n         if (usedTypeDirectiveReferences) {\r\n-            for (const directive in usedTypeDirectiveReferences) {\r\n+            usedTypeDirectiveReferences.forEach(directive => {\r\n                 referencesOutput += `/// <reference types=\"${directive}\" />${newLine}`;\r\n-            }\r\n+            });\r\n         }\r\n \r\n         return {\r\n@@ -267,11 +267,11 @@ namespace ts {\n             }\r\n \r\n             if (!usedTypeDirectiveReferences) {\r\n-                usedTypeDirectiveReferences = createMap<string>();\r\n+                usedTypeDirectiveReferences = createSet();\r\n             }\r\n             for (const directive of typeReferenceDirectives) {\r\n-                if (!(directive in usedTypeDirectiveReferences)) {\r\n-                    usedTypeDirectiveReferences[directive] = directive;\r\n+                if (!usedTypeDirectiveReferences.has(directive)) {\r\n+                    usedTypeDirectiveReferences.add(directive);\r\n                 }\r\n             }\r\n         }\r\n@@ -535,14 +535,14 @@ namespace ts {\n         // do not need to keep track of created temp names.\r\n         function getExportDefaultTempVariableName(): string {\r\n             const baseName = \"_default\";\r\n-            if (!(baseName in currentIdentifiers)) {\r\n+            if (!currentIdentifiers.has(baseName)) {\r\n                 return baseName;\r\n             }\r\n             let count = 0;\r\n             while (true) {\r\n                 count++;\r\n                 const name = baseName + \"_\" + count;\r\n-                if (!(name in currentIdentifiers)) {\r\n+                if (!currentIdentifiers.has(name)) {\r\n                     return name;\r\n                 }\r\n             }\r"},{"sha":"d0568293eb7a5425564c1d73d5f1392f912a9f9c","filename":"src/compiler/emitter.ts","status":"modified","additions":10,"deletions":8,"changes":18,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Femitter.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Femitter.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Femitter.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -219,11 +219,11 @@ const _super = (function (geti, seti) {\n \r\n         let nodeIdToGeneratedName: string[];\r\n         let autoGeneratedIdToGeneratedName: string[];\r\n-        let generatedNameSet: Map<string>;\r\n+        let generatedNameSet: Set<string>;\r\n         let tempFlags: TempFlags;\r\n         let currentSourceFile: SourceFile;\r\n         let currentText: string;\r\n-        let currentFileIdentifiers: Map<string>;\r\n+        let currentFileIdentifiers: Map<string, string>;\r\n         let extendsEmitted: boolean;\r\n         let assignEmitted: boolean;\r\n         let decorateEmitted: boolean;\r\n@@ -292,7 +292,7 @@ const _super = (function (geti, seti) {\n             sourceMap.initialize(jsFilePath, sourceMapFilePath, sourceFiles, isBundledEmit);\r\n             nodeIdToGeneratedName = [];\r\n             autoGeneratedIdToGeneratedName = [];\r\n-            generatedNameSet = createMap<string>();\r\n+            generatedNameSet = createSet();\r\n             isOwnFileEmit = !isBundledEmit;\r\n \r\n             // Emit helpers from all the files\r\n@@ -2645,15 +2645,16 @@ const _super = (function (geti, seti) {\n \r\n         function isUniqueName(name: string): boolean {\r\n             return !resolver.hasGlobalName(name) &&\r\n-                !hasProperty(currentFileIdentifiers, name) &&\r\n-                !hasProperty(generatedNameSet, name);\r\n+                !currentFileIdentifiers.has(name) &&\r\n+                !generatedNameSet.has(name);\r\n         }\r\n \r\n         function isUniqueLocalName(name: string, container: Node): boolean {\r\n             for (let node = container; isNodeDescendantOf(node, container); node = node.nextContainer) {\r\n-                if (node.locals && hasProperty(node.locals, name)) {\r\n+                if (node.locals) {\r\n+                    const local = node.locals.get(name);\r\n                     // We conservatively include alias symbols to cover cases where they're emitted as locals\r\n-                    if (node.locals[name].flags & (SymbolFlags.Value | SymbolFlags.ExportValue | SymbolFlags.Alias)) {\r\n+                    if (local && local.flags & (SymbolFlags.Value | SymbolFlags.ExportValue | SymbolFlags.Alias)) {\r\n                         return false;\r\n                     }\r\n                 }\r\n@@ -2702,7 +2703,8 @@ const _super = (function (geti, seti) {\n             while (true) {\r\n                 const generatedName = baseName + i;\r\n                 if (isUniqueName(generatedName)) {\r\n-                    return generatedNameSet[generatedName] = generatedName;\r\n+                    generatedNameSet.add(generatedName);\r\n+                    return generatedName;\r\n                 }\r\n                 i++;\r\n             }\r"},{"sha":"13f1230896e84c8512edb14631252e4a1890b31f","filename":"src/compiler/factory.ts","status":"modified","additions":9,"deletions":11,"changes":20,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ffactory.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ffactory.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ffactory.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -1622,7 +1622,7 @@ namespace ts {\n         // flag and setting a parent node.\r\n         const react = createIdentifier(reactNamespace || \"React\");\r\n         react.flags &= ~NodeFlags.Synthesized;\r\n-        // Set the parent that is in parse tree \r\n+        // Set the parent that is in parse tree\r\n         // this makes sure that parent chain is intact for checker to traverse complete scope tree\r\n         react.parent = getParseTreeNode(parent);\r\n         return react;\r\n@@ -2805,9 +2805,9 @@ namespace ts {\n         return destEmitNode;\r\n     }\r\n \r\n-    function mergeTokenSourceMapRanges(sourceRanges: Map<TextRange>, destRanges: Map<TextRange>) {\r\n-        if (!destRanges) destRanges = createMap<TextRange>();\r\n-        copyProperties(sourceRanges, destRanges);\r\n+    function mergeTokenSourceMapRanges(sourceRanges: Map<SyntaxKind, TextRange>, destRanges: Map<SyntaxKind, TextRange>): Map<SyntaxKind, TextRange> {\r\n+        if (!destRanges) destRanges = createMap<SyntaxKind, TextRange>();\r\n+        copyMapEntriesFromTo(sourceRanges, destRanges);\r\n         return destRanges;\r\n     }\r\n \r\n@@ -2899,8 +2899,8 @@ namespace ts {\n      */\r\n     export function setTokenSourceMapRange<T extends Node>(node: T, token: SyntaxKind, range: TextRange) {\r\n         const emitNode = getOrCreateEmitNode(node);\r\n-        const tokenSourceMapRanges = emitNode.tokenSourceMapRanges || (emitNode.tokenSourceMapRanges = createMap<TextRange>());\r\n-        tokenSourceMapRanges[token] = range;\r\n+        const tokenSourceMapRanges = emitNode.tokenSourceMapRanges || (emitNode.tokenSourceMapRanges = createMap<SyntaxKind, TextRange>());\r\n+        tokenSourceMapRanges.set(token, range);\r\n         return node;\r\n     }\r\n \r\n@@ -2941,7 +2941,7 @@ namespace ts {\n     export function getTokenSourceMapRange(node: Node, token: SyntaxKind) {\r\n         const emitNode = node.emitNode;\r\n         const tokenSourceMapRanges = emitNode && emitNode.tokenSourceMapRanges;\r\n-        return tokenSourceMapRanges && tokenSourceMapRanges[token];\r\n+        return tokenSourceMapRanges && tokenSourceMapRanges.get(token);\r\n     }\r\n \r\n     /**\r\n@@ -3026,10 +3026,8 @@ namespace ts {\n      * Here we check if alternative name was provided for a given moduleName and return it if possible.\r\n      */\r\n     function tryRenameExternalModule(moduleName: LiteralExpression, sourceFile: SourceFile) {\r\n-        if (sourceFile.renamedDependencies && hasProperty(sourceFile.renamedDependencies, moduleName.text)) {\r\n-            return createLiteral(sourceFile.renamedDependencies[moduleName.text]);\r\n-        }\r\n-        return undefined;\r\n+        const rename = sourceFile.renamedDependencies && sourceFile.renamedDependencies.get(moduleName.text);\r\n+        return rename && createLiteral(rename);\r\n     }\r\n \r\n     /**\r"},{"sha":"ea33473fe40a63ff79e8a10297f609d1d957fc2c","filename":"src/compiler/parser.ts","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fparser.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fparser.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Fparser.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -491,7 +491,7 @@ namespace ts {\n         let currentToken: SyntaxKind;\r\n         let sourceText: string;\r\n         let nodeCount: number;\r\n-        let identifiers: Map<string>;\r\n+        let identifiers: Map<string, string>;\r\n         let identifierCount: number;\r\n \r\n         let parsingContext: ParsingContext;\r\n@@ -601,7 +601,7 @@ namespace ts {\n \r\n             parseDiagnostics = [];\r\n             parsingContext = 0;\r\n-            identifiers = createMap<string>();\r\n+            identifiers = createMap<string, string>();\r\n             identifierCount = 0;\r\n             nodeCount = 0;\r\n \r\n@@ -1104,7 +1104,7 @@ namespace ts {\n \r\n         function internIdentifier(text: string): string {\r\n             text = escapeIdentifier(text);\r\n-            return identifiers[text] || (identifiers[text] = text);\r\n+            return getOrUpdate(identifiers, text, text => text);\r\n         }\r\n \r\n         // An identifier that starts with two underscores has an extra underscore character prepended to it to avoid issues\r"},{"sha":"6cb73e4d058c758e10a3e9aae49c0e191f71566d","filename":"src/compiler/performance.ts","status":"modified","additions":14,"deletions":16,"changes":30,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fperformance.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fperformance.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Fperformance.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -16,9 +16,9 @@ namespace ts.performance {\n \r\n     let enabled = false;\r\n     let profilerStart = 0;\r\n-    let counts: Map<number>;\r\n-    let marks: Map<number>;\r\n-    let measures: Map<number>;\r\n+    let counts: Map<string, number>;\r\n+    let marks: Map<string, number>;\r\n+    let measures: Map<string, number>;\r\n \r\n     /**\r\n      * Marks a performance event.\r\n@@ -27,8 +27,8 @@ namespace ts.performance {\n      */\r\n     export function mark(markName: string) {\r\n         if (enabled) {\r\n-            marks[markName] = timestamp();\r\n-            counts[markName] = (counts[markName] || 0) + 1;\r\n+            marks.set(markName, timestamp());\r\n+            counts.set(markName, (counts.get(markName) || 0) + 1);\r\n             profilerEvent(markName);\r\n         }\r\n     }\r\n@@ -44,9 +44,9 @@ namespace ts.performance {\n      */\r\n     export function measure(measureName: string, startMarkName?: string, endMarkName?: string) {\r\n         if (enabled) {\r\n-            const end = endMarkName && marks[endMarkName] || timestamp();\r\n-            const start = startMarkName && marks[startMarkName] || profilerStart;\r\n-            measures[measureName] = (measures[measureName] || 0) + (end - start);\r\n+            const end = endMarkName && marks.get(endMarkName) || timestamp();\r\n+            const start = startMarkName && marks.get(startMarkName) || profilerStart;\r\n+            measures.set(measureName, (measures.get(measureName) || 0) + (end - start));\r\n         }\r\n     }\r\n \r\n@@ -56,7 +56,7 @@ namespace ts.performance {\n      * @param markName The name of the mark.\r\n      */\r\n     export function getCount(markName: string) {\r\n-        return counts && counts[markName] || 0;\r\n+        return counts && counts.get(markName) || 0;\r\n     }\r\n \r\n     /**\r\n@@ -65,7 +65,7 @@ namespace ts.performance {\n      * @param measureName The name of the measure whose durations should be accumulated.\r\n      */\r\n     export function getDuration(measureName: string) {\r\n-        return measures && measures[measureName] || 0;\r\n+        return measures && measures.get(measureName) || 0;\r\n     }\r\n \r\n     /**\r\n@@ -74,16 +74,14 @@ namespace ts.performance {\n      * @param cb The action to perform for each measure\r\n      */\r\n     export function forEachMeasure(cb: (measureName: string, duration: number) => void) {\r\n-        for (const key in measures) {\r\n-            cb(key, measures[key]);\r\n-        }\r\n+        measures.forEach((duration, measureName) => cb(measureName, duration));\r\n     }\r\n \r\n     /** Enables (and resets) performance measurements for the compiler. */\r\n     export function enable() {\r\n-        counts = createMap<number>();\r\n-        marks = createMap<number>();\r\n-        measures = createMap<number>();\r\n+        counts = createMap<string, number>();\r\n+        marks = createMap<string, number>();\r\n+        measures = createMap<string, number>();\r\n         enabled = true;\r\n         profilerStart = timestamp();\r\n     }\r"},{"sha":"8a2b4d86671bfd6d98677d3cae013adca6f888b7","filename":"src/compiler/program.ts","status":"modified","additions":34,"deletions":38,"changes":72,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fprogram.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fprogram.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Fprogram.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -82,7 +82,7 @@ namespace ts {\n     }\r\n \r\n     export function createCompilerHost(options: CompilerOptions, setParentNodes?: boolean): CompilerHost {\r\n-        const existingDirectories = createMap<boolean>();\r\n+        const existingDirectories = createSet();\r\n \r\n         function getCanonicalFileName(fileName: string): string {\r\n             // if underlying system can distinguish between two files whose names differs only in cases then file name already in canonical form.\r\n@@ -114,11 +114,11 @@ namespace ts {\n         }\r\n \r\n         function directoryExists(directoryPath: string): boolean {\r\n-            if (directoryPath in existingDirectories) {\r\n+            if (existingDirectories.has(directoryPath)) {\r\n                 return true;\r\n             }\r\n             if (sys.directoryExists(directoryPath)) {\r\n-                existingDirectories[directoryPath] = true;\r\n+                existingDirectories.add(directoryPath);\r\n                 return true;\r\n             }\r\n             return false;\r\n@@ -132,21 +132,21 @@ namespace ts {\n             }\r\n         }\r\n \r\n-        let outputFingerprints: Map<OutputFingerprint>;\r\n+        let outputFingerprints: Map<string, OutputFingerprint>;\r\n \r\n         function writeFileIfUpdated(fileName: string, data: string, writeByteOrderMark: boolean): void {\r\n             if (!outputFingerprints) {\r\n-                outputFingerprints = createMap<OutputFingerprint>();\r\n+                outputFingerprints = createMap<string, OutputFingerprint>();\r\n             }\r\n \r\n             const hash = sys.createHash(data);\r\n             const mtimeBefore = sys.getModifiedTime(fileName);\r\n \r\n-            if (mtimeBefore && fileName in outputFingerprints) {\r\n-                const fingerprint = outputFingerprints[fileName];\r\n+            if (mtimeBefore) {\r\n+                const fingerprint = outputFingerprints.get(fileName);\r\n \r\n                 // If output has not been changed, and the file has no external modification\r\n-                if (fingerprint.byteOrderMark === writeByteOrderMark &&\r\n+                if (fingerprint && fingerprint.byteOrderMark === writeByteOrderMark &&\r\n                     fingerprint.hash === hash &&\r\n                     fingerprint.mtime.getTime() === mtimeBefore.getTime()) {\r\n                     return;\r\n@@ -157,11 +157,11 @@ namespace ts {\n \r\n             const mtimeAfter = sys.getModifiedTime(fileName);\r\n \r\n-            outputFingerprints[fileName] = {\r\n+            outputFingerprints.set(fileName, {\r\n                 hash,\r\n                 byteOrderMark: writeByteOrderMark,\r\n                 mtime: mtimeAfter\r\n-            };\r\n+            });\r\n         }\r\n \r\n         function writeFile(fileName: string, data: string, writeByteOrderMark: boolean, onError?: (message: string) => void) {\r\n@@ -279,11 +279,11 @@ namespace ts {\n             return [];\r\n         }\r\n         const resolutions: T[] = [];\r\n-        const cache = createMap<T>();\r\n+        const cache = createMap<string, T>();\r\n         for (const name of names) {\r\n-            const result = name in cache\r\n-                ? cache[name]\r\n-                : cache[name] = loader(name, containingFile);\r\n+            const result = cache.has(name)\r\n+                ? cache.get(name)\r\n+                : setAndReturn(cache, name, loader(name, containingFile));\r\n             resolutions.push(result);\r\n         }\r\n         return resolutions;\r\n@@ -295,9 +295,9 @@ namespace ts {\n         let commonSourceDirectory: string;\r\n         let diagnosticsProducingTypeChecker: TypeChecker;\r\n         let noDiagnosticsTypeChecker: TypeChecker;\r\n-        let classifiableNames: Map<string>;\r\n+        let classifiableNames: Set<string>;\r\n \r\n-        let resolvedTypeReferenceDirectives = createMap<ResolvedTypeReferenceDirective>();\r\n+        let resolvedTypeReferenceDirectives = createMap<string, ResolvedTypeReferenceDirective>();\r\n         let fileProcessingDiagnostics = createDiagnosticCollection();\r\n \r\n         // The below settings are to track if a .js file should be add to the program if loaded via searching under node_modules.\r\n@@ -312,10 +312,10 @@ namespace ts {\n \r\n         // If a module has some of its imports skipped due to being at the depth limit under node_modules, then track\r\n         // this, as it may be imported at a shallower depth later, and then it will need its skipped imports processed.\r\n-        const modulesWithElidedImports = createMap<boolean>();\r\n+        const modulesWithElidedImports = createMap<string, boolean>();\r\n \r\n         // Track source files that are source files found by searching under node_modules, as these shouldn't be compiled.\r\n-        const sourceFilesFoundSearchingNodeModules = createMap<boolean>();\r\n+        const sourceFilesFoundSearchingNodeModules = createMap<string, boolean>();\r\n \r\n         performance.mark(\"beforeProgram\");\r\n \r\n@@ -448,15 +448,11 @@ namespace ts {\n             return commonSourceDirectory;\r\n         }\r\n \r\n-        function getClassifiableNames() {\r\n+        function getClassifiableNames(): Set<string> {\r\n             if (!classifiableNames) {\r\n                 // Initialize a checker so that all our files are bound.\r\n                 getTypeChecker();\r\n-                classifiableNames = createMap<string>();\r\n-\r\n-                for (const sourceFile of files) {\r\n-                    copyProperties(sourceFile.classifiableNames, classifiableNames);\r\n-                }\r\n+                classifiableNames = setAggregate(files, sourceFile => sourceFile.classifiableNames);\r\n             }\r\n \r\n             return classifiableNames;\r\n@@ -592,7 +588,7 @@ namespace ts {\n                 getSourceFile: program.getSourceFile,\r\n                 getSourceFileByPath: program.getSourceFileByPath,\r\n                 getSourceFiles: program.getSourceFiles,\r\n-                isSourceFileFromExternalLibrary: (file: SourceFile) => !!sourceFilesFoundSearchingNodeModules[file.path],\r\n+                isSourceFileFromExternalLibrary: (file: SourceFile) => !!sourceFilesFoundSearchingNodeModules.get(file.path),\r\n                 writeFile: writeFileCallback || (\r\n                     (fileName, data, writeByteOrderMark, onError, sourceFiles) => host.writeFile(fileName, data, writeByteOrderMark, onError, sourceFiles)),\r\n                 isEmitBlocked,\r\n@@ -1132,8 +1128,8 @@ namespace ts {\n \r\n         // Get source file from normalized fileName\r\n         function findSourceFile(fileName: string, path: Path, isDefaultLib: boolean, refFile?: SourceFile, refPos?: number, refEnd?: number): SourceFile {\r\n-            if (filesByName.contains(path)) {\r\n-                const file = filesByName.get(path);\r\n+            let file = filesByName.get(path);\r\n+            if (file !== undefined) {\r\n                 // try to check if we've already seen this file but with a different casing in path\r\n                 // NOTE: this only makes sense for case-insensitive file systems\r\n                 if (file && options.forceConsistentCasingInFileNames && getNormalizedAbsolutePath(file.fileName, currentDirectory) !== getNormalizedAbsolutePath(fileName, currentDirectory)) {\r\n@@ -1142,20 +1138,20 @@ namespace ts {\n \r\n                 // If the file was previously found via a node_modules search, but is now being processed as a root file,\r\n                 // then everything it sucks in may also be marked incorrectly, and needs to be checked again.\r\n-                if (file && sourceFilesFoundSearchingNodeModules[file.path] && currentNodeModulesDepth == 0) {\r\n-                    sourceFilesFoundSearchingNodeModules[file.path] = false;\r\n+                if (file && sourceFilesFoundSearchingNodeModules.get(file.path) && currentNodeModulesDepth == 0) {\r\n+                    sourceFilesFoundSearchingNodeModules.set(file.path, false);\r\n                     if (!options.noResolve) {\r\n                         processReferencedFiles(file, isDefaultLib);\r\n                         processTypeReferenceDirectives(file);\r\n                     }\r\n \r\n-                    modulesWithElidedImports[file.path] = false;\r\n+                    modulesWithElidedImports.set(file.path, false);\r\n                     processImportedModules(file);\r\n                 }\r\n                 // See if we need to reprocess the imports due to prior skipped imports\r\n-                else if (file && modulesWithElidedImports[file.path]) {\r\n+                else if (file && modulesWithElidedImports.get(file.path)) {\r\n                     if (currentNodeModulesDepth < maxNodeModuleJsDepth) {\r\n-                        modulesWithElidedImports[file.path] = false;\r\n+                        modulesWithElidedImports.set(file.path, false);\r\n                         processImportedModules(file);\r\n                     }\r\n                 }\r\n@@ -1164,7 +1160,7 @@ namespace ts {\n             }\r\n \r\n             // We haven't looked for this file, do so now and cache result\r\n-            const file = host.getSourceFile(fileName, options.target, hostErrorMessage => {\r\n+            file = host.getSourceFile(fileName, options.target, hostErrorMessage => {\r\n                 if (refFile !== undefined && refPos !== undefined && refEnd !== undefined) {\r\n                     fileProcessingDiagnostics.add(createFileDiagnostic(refFile, refPos, refEnd - refPos,\r\n                         Diagnostics.Cannot_read_file_0_Colon_1, fileName, hostErrorMessage));\r\n@@ -1176,7 +1172,7 @@ namespace ts {\n \r\n             filesByName.set(path, file);\r\n             if (file) {\r\n-                sourceFilesFoundSearchingNodeModules[path] = (currentNodeModulesDepth > 0);\r\n+                sourceFilesFoundSearchingNodeModules.set(path, currentNodeModulesDepth > 0);\r\n                 file.path = path;\r\n \r\n                 if (host.useCaseSensitiveFileNames()) {\r\n@@ -1237,7 +1233,7 @@ namespace ts {\n             refFile?: SourceFile, refPos?: number, refEnd?: number): void {\r\n \r\n             // If we already found this library as a primary reference - nothing to do\r\n-            const previousResolution = resolvedTypeReferenceDirectives[typeReferenceDirective];\r\n+            const previousResolution = resolvedTypeReferenceDirectives.get(typeReferenceDirective);\r\n             if (previousResolution && previousResolution.primary) {\r\n                 return;\r\n             }\r\n@@ -1274,7 +1270,7 @@ namespace ts {\n             }\r\n \r\n             if (saveResolution) {\r\n-                resolvedTypeReferenceDirectives[typeReferenceDirective] = resolvedTypeReferenceDirective;\r\n+                resolvedTypeReferenceDirectives.set(typeReferenceDirective, resolvedTypeReferenceDirective);\r\n             }\r\n         }\r\n \r\n@@ -1294,7 +1290,7 @@ namespace ts {\n         function processImportedModules(file: SourceFile) {\r\n             collectExternalModuleReferences(file);\r\n             if (file.imports.length || file.moduleAugmentations.length) {\r\n-                file.resolvedModules = createMap<ResolvedModuleFull>();\r\n+                file.resolvedModules = createMap<string, ResolvedModuleFull>();\r\n                 const moduleNames = map(concatenate(file.imports, file.moduleAugmentations), getTextOfLiteral);\r\n                 const resolutions = resolveModuleNamesWorker(moduleNames, getNormalizedAbsolutePath(file.fileName, currentDirectory));\r\n                 Debug.assert(resolutions.length === moduleNames.length);\r\n@@ -1325,7 +1321,7 @@ namespace ts {\n                     const shouldAddFile = resolvedFileName && !getResolutionDiagnostic(options, resolution) && !options.noResolve && i < file.imports.length && !elideImport;\r\n \r\n                     if (elideImport) {\r\n-                        modulesWithElidedImports[file.path] = true;\r\n+                        modulesWithElidedImports.set(file.path, true);\r\n                     }\r\n                     else if (shouldAddFile) {\r\n                         const path = toPath(resolvedFileName, currentDirectory, getCanonicalFileName);\r"},{"sha":"dec76d2b926b6d4a3c27998ee1de41615d70b032","filename":"src/compiler/scanner.ts","status":"modified","additions":11,"deletions":10,"changes":21,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fscanner.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fscanner.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Fscanner.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -56,7 +56,7 @@ namespace ts {\n         tryScan<T>(callback: () => T): T;\r\n     }\r\n \r\n-    const textToToken = createMap({\r\n+    const textToToken = mapOfMapLike({\r\n         \"abstract\": SyntaxKind.AbstractKeyword,\r\n         \"any\": SyntaxKind.AnyKeyword,\r\n         \"as\": SyntaxKind.AsKeyword,\r\n@@ -272,11 +272,11 @@ namespace ts {\n             lookupInUnicodeMap(code, unicodeES3IdentifierPart);\r\n     }\r\n \r\n-    function makeReverseMap(source: Map<number>): string[] {\r\n+    function makeReverseMap(source: Map<string, number>): string[] {\r\n         const result: string[] = [];\r\n-        for (const name in source) {\r\n-            result[source[name]] = name;\r\n-        }\r\n+        source.forEach((num, name) => {\r\n+            result[num] = name;\r\n+        });\r\n         return result;\r\n     }\r\n \r\n@@ -288,7 +288,7 @@ namespace ts {\n \r\n     /* @internal */\r\n     export function stringToToken(s: string): SyntaxKind {\r\n-        return textToToken[s];\r\n+        return textToToken.get(s);\r\n     }\r\n \r\n     /* @internal */\r\n@@ -362,8 +362,6 @@ namespace ts {\n         return computeLineAndCharacterOfPosition(getLineStarts(sourceFile), position);\r\n     }\r\n \r\n-    const hasOwnProperty = Object.prototype.hasOwnProperty;\r\n-\r\n     export function isWhiteSpace(ch: number): boolean {\r\n         return isWhiteSpaceSingleLine(ch) || isLineBreak(ch);\r\n     }\r\n@@ -1182,8 +1180,11 @@ namespace ts {\n             const len = tokenValue.length;\r\n             if (len >= 2 && len <= 11) {\r\n                 const ch = tokenValue.charCodeAt(0);\r\n-                if (ch >= CharacterCodes.a && ch <= CharacterCodes.z && hasOwnProperty.call(textToToken, tokenValue)) {\r\n-                    return token = textToToken[tokenValue];\r\n+                if (ch >= CharacterCodes.a && ch <= CharacterCodes.z) {\r\n+                    token = textToToken.get(tokenValue);\r\n+                    if (token !== undefined) {\r\n+                        return token;\r\n+                    }\r\n                 }\r\n             }\r\n             return token = SyntaxKind.Identifier;\r"},{"sha":"fcf85aa86a67651aa8fdadfa03d386da40d510c0","filename":"src/compiler/sourcemap.ts","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fsourcemap.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fsourcemap.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Fsourcemap.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -362,7 +362,7 @@ namespace ts {\n \r\n             const emitNode = node && node.emitNode;\r\n             const emitFlags = emitNode && emitNode.flags;\r\n-            const range = emitNode && emitNode.tokenSourceMapRanges && emitNode.tokenSourceMapRanges[token];\r\n+            const range = emitNode && emitNode.tokenSourceMapRanges && emitNode.tokenSourceMapRanges.get(token);\r\n \r\n             tokenPos = skipTrivia(currentSourceText, range ? range.pos : tokenPos);\r\n             if ((emitFlags & EmitFlags.NoTokenLeadingSourceMaps) === 0 && tokenPos >= 0) {\r"},{"sha":"5df1976f98e346c396756f9d90929d93b957c12a","filename":"src/compiler/sys.ts","status":"modified","additions":12,"deletions":9,"changes":21,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fsys.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fsys.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Fsys.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -237,25 +237,25 @@ namespace ts {\n             const useNonPollingWatchers = process.env[\"TSC_NONPOLLING_WATCHER\"];\r\n \r\n             function createWatchedFileSet() {\r\n-                const dirWatchers = createMap<DirectoryWatcher>();\r\n+                const dirWatchers = createMap<string, DirectoryWatcher>();\r\n                 // One file can have multiple watchers\r\n-                const fileWatcherCallbacks = createMap<FileWatcherCallback[]>();\r\n+                const fileWatcherCallbacks = createMap<string, FileWatcherCallback[]>();\r\n                 return { addFile, removeFile };\r\n \r\n                 function reduceDirWatcherRefCountForFile(fileName: string) {\r\n                     const dirName = getDirectoryPath(fileName);\r\n-                    const watcher = dirWatchers[dirName];\r\n+                    const watcher = dirWatchers.get(dirName);\r\n                     if (watcher) {\r\n                         watcher.referenceCount -= 1;\r\n                         if (watcher.referenceCount <= 0) {\r\n                             watcher.close();\r\n-                            delete dirWatchers[dirName];\r\n+                            dirWatchers.delete(dirName);\r\n                         }\r\n                     }\r\n                 }\r\n \r\n                 function addDirWatcher(dirPath: string): void {\r\n-                    let watcher = dirWatchers[dirPath];\r\n+                    let watcher = dirWatchers.get(dirPath);\r\n                     if (watcher) {\r\n                         watcher.referenceCount += 1;\r\n                         return;\r\n@@ -266,7 +266,7 @@ namespace ts {\n                         (eventName: string, relativeFileName: string) => fileEventHandler(eventName, relativeFileName, dirPath)\r\n                     );\r\n                     watcher.referenceCount = 1;\r\n-                    dirWatchers[dirPath] = watcher;\r\n+                    dirWatchers.set(dirPath, watcher);\r\n                     return;\r\n                 }\r\n \r\n@@ -296,9 +296,12 @@ namespace ts {\n                         ? undefined\r\n                         : ts.getNormalizedAbsolutePath(relativeFileName, baseDirPath);\r\n                     // Some applications save a working file via rename operations\r\n-                    if ((eventName === \"change\" || eventName === \"rename\") && fileWatcherCallbacks[fileName]) {\r\n-                        for (const fileCallback of fileWatcherCallbacks[fileName]) {\r\n-                            fileCallback(fileName);\r\n+                    if ((eventName === \"change\" || eventName === \"rename\")) {\r\n+                        const callbacks = fileWatcherCallbacks.get(fileName);\r\n+                        if (callbacks) {\r\n+                            for (const fileCallback of callbacks) {\r\n+                                fileCallback(fileName);\r\n+                           }\r\n                         }\r\n                     }\r\n                 }\r"},{"sha":"4534564a854a4deb3301246666947ea04260820f","filename":"src/compiler/transformer.ts","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftransformer.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftransformer.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ftransformer.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -12,14 +12,14 @@\n \r\n /* @internal */\r\n namespace ts {\r\n-    const moduleTransformerMap = createMap<Transformer>({\r\n-        [ModuleKind.ES2015]: transformES2015Module,\r\n-        [ModuleKind.System]: transformSystemModule,\r\n-        [ModuleKind.AMD]: transformModule,\r\n-        [ModuleKind.CommonJS]: transformModule,\r\n-        [ModuleKind.UMD]: transformModule,\r\n-        [ModuleKind.None]: transformModule,\r\n-    });\r\n+    const moduleTransformerMap = createMap<ModuleKind, Transformer>([\r\n+        [ModuleKind.ES2015, transformES2015Module],\r\n+        [ModuleKind.System, transformSystemModule],\r\n+        [ModuleKind.AMD, transformModule],\r\n+        [ModuleKind.CommonJS, transformModule],\r\n+        [ModuleKind.UMD, transformModule],\r\n+        [ModuleKind.None, transformModule],\r\n+    ]);\r\n \r\n     const enum SyntaxKindFeatureFlags {\r\n         Substitution = 1 << 0,\r\n@@ -129,7 +129,7 @@ namespace ts {\n             transformers.push(transformGenerators);\r\n         }\r\n \r\n-        transformers.push(moduleTransformerMap[moduleKind] || moduleTransformerMap[ModuleKind.None]);\r\n+        transformers.push(moduleTransformerMap.get(moduleKind) || moduleTransformerMap.get(ModuleKind.None));\r\n \r\n         // The ES5 transformer is last so that it can substitute expressions like `exports.default`\r\n         // for ES3.\r"},{"sha":"4e0b0749d3a9738660b733e54678301c2a833dd2","filename":"src/compiler/transformers/es2015.ts","status":"modified","additions":16,"deletions":17,"changes":33,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftransformers%2Fes2015.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftransformers%2Fes2015.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ftransformers%2Fes2015.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -70,15 +70,15 @@ namespace ts {\n          * set of labels that occurred inside the converted loop\r\n          * used to determine if labeled jump can be emitted as is or it should be dispatched to calling code\r\n          */\r\n-        labels?: Map<string>;\r\n+        labels?: Map<string, string>;\r\n         /*\r\n          * collection of labeled jumps that transfer control outside the converted loop.\r\n          * maps store association 'label -> labelMarker' where\r\n          * - label - value of label as it appear in code\r\n          * - label marker - return value that should be interpreted by calling code as 'jump to <label>'\r\n          */\r\n-        labeledNonLocalBreaks?: Map<string>;\r\n-        labeledNonLocalContinues?: Map<string>;\r\n+        labeledNonLocalBreaks?: Map<string, string>;\r\n+        labeledNonLocalContinues?: Map<string, string>;\r\n \r\n         /*\r\n          * set of non-labeled jumps that transfer control outside the converted loop\r\n@@ -279,7 +279,7 @@ namespace ts {\n             else if (node.transformFlags & TransformFlags.ContainsES2015 || (isInConstructorWithCapturedSuper && !isExpression(node))) {\r\n                 // we want to dive in this branch either if node has children with ES2015 specific syntax\r\n                 // or we are inside constructor that captures result of the super call so all returns without expression should be\r\n-                // rewritten. Note: we skip expressions since returns should never appear there \r\n+                // rewritten. Note: we skip expressions since returns should never appear there\r\n                 return visitEachChild(node, visitor, context);\r\n             }\r\n             else {\r\n@@ -543,7 +543,7 @@ namespace ts {\n                 //   - break/continue is non-labeled and located in non-converted loop/switch statement\r\n                 const jump = node.kind === SyntaxKind.BreakStatement ? Jump.Break : Jump.Continue;\r\n                 const canUseBreakOrContinue =\r\n-                    (node.label && convertedLoopState.labels && convertedLoopState.labels[node.label.text]) ||\r\n+                    (node.label && convertedLoopState.labels && convertedLoopState.labels.get(node.label.text)) ||\r\n                     (!node.label && (convertedLoopState.allowedNonLabeledJumps & jump));\r\n \r\n                 if (!canUseBreakOrContinue) {\r\n@@ -1880,9 +1880,9 @@ namespace ts {\n         function visitLabeledStatement(node: LabeledStatement): VisitResult<Statement> {\r\n             if (convertedLoopState) {\r\n                 if (!convertedLoopState.labels) {\r\n-                    convertedLoopState.labels = createMap<string>();\r\n+                    convertedLoopState.labels = createMap<string, string>();\r\n                 }\r\n-                convertedLoopState.labels[node.label.text] = node.label.text;\r\n+                convertedLoopState.labels.set(node.label.text, node.label.text);\r\n             }\r\n \r\n             let result: VisitResult<Statement>;\r\n@@ -1894,7 +1894,7 @@ namespace ts {\n             }\r\n \r\n             if (convertedLoopState) {\r\n-                convertedLoopState.labels[node.label.text] = undefined;\r\n+                convertedLoopState.labels.set(node.label.text, undefined);\r\n             }\r\n \r\n             return result;\r\n@@ -2497,29 +2497,28 @@ namespace ts {\n         function setLabeledJump(state: ConvertedLoopState, isBreak: boolean, labelText: string, labelMarker: string): void {\r\n             if (isBreak) {\r\n                 if (!state.labeledNonLocalBreaks) {\r\n-                    state.labeledNonLocalBreaks = createMap<string>();\r\n+                    state.labeledNonLocalBreaks = createMap<string, string>();\r\n                 }\r\n-                state.labeledNonLocalBreaks[labelText] = labelMarker;\r\n+                state.labeledNonLocalBreaks.set(labelText, labelMarker);\r\n             }\r\n             else {\r\n                 if (!state.labeledNonLocalContinues) {\r\n-                    state.labeledNonLocalContinues = createMap<string>();\r\n+                    state.labeledNonLocalContinues = createMap<string, string>();\r\n                 }\r\n-                state.labeledNonLocalContinues[labelText] = labelMarker;\r\n+                state.labeledNonLocalContinues.set(labelText, labelMarker);\r\n             }\r\n         }\r\n \r\n-        function processLabeledJumps(table: Map<string>, isBreak: boolean, loopResultName: Identifier, outerLoop: ConvertedLoopState, caseClauses: CaseClause[]): void {\r\n+        function processLabeledJumps(table: Map<string, string>, isBreak: boolean, loopResultName: Identifier, outerLoop: ConvertedLoopState, caseClauses: CaseClause[]): void {\r\n             if (!table) {\r\n                 return;\r\n             }\r\n-            for (const labelText in table) {\r\n-                const labelMarker = table[labelText];\r\n+            table.forEach((labelMarker, labelText) => {\r\n                 const statements: Statement[] = [];\r\n                 // if there are no outer converted loop or outer label in question is located inside outer converted loop\r\n                 // then emit labeled break\\continue\r\n                 // otherwise propagate pair 'label -> marker' to outer converted loop and emit 'return labelMarker' so outer loop can later decide what to do\r\n-                if (!outerLoop || (outerLoop.labels && outerLoop.labels[labelText])) {\r\n+                if (!outerLoop || (outerLoop.labels && outerLoop.labels.get(labelText))) {\r\n                     const label = createIdentifier(labelText);\r\n                     statements.push(isBreak ? createBreak(label) : createContinue(label));\r\n                 }\r\n@@ -2528,7 +2527,7 @@ namespace ts {\n                     statements.push(createReturn(loopResultName));\r\n                 }\r\n                 caseClauses.push(createCaseClause(createLiteral(labelMarker), statements));\r\n-            }\r\n+            });\r\n         }\r\n \r\n         function processLoopVariableDeclaration(decl: VariableDeclaration | BindingElement, loopParameters: ParameterDeclaration[], loopOutParameters: LoopOutParameter[]) {\r"},{"sha":"74bc4ef4f0a56db044c55d2ec4df0ce87229e7ce","filename":"src/compiler/transformers/generators.ts","status":"modified","additions":16,"deletions":16,"changes":32,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftransformers%2Fgenerators.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftransformers%2Fgenerators.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ftransformers%2Fgenerators.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -217,13 +217,13 @@ namespace ts {\n         Endfinally = 7,\r\n     }\r\n \r\n-    const instructionNames = createMap<string>({\r\n-        [Instruction.Return]: \"return\",\r\n-        [Instruction.Break]: \"break\",\r\n-        [Instruction.Yield]: \"yield\",\r\n-        [Instruction.YieldStar]: \"yield*\",\r\n-        [Instruction.Endfinally]: \"endfinally\",\r\n-    });\r\n+    const instructionNames = createMap<Instruction, string>([\r\n+        [Instruction.Return, \"return\"],\r\n+        [Instruction.Break, \"break\"],\r\n+        [Instruction.Yield, \"yield\"],\r\n+        [Instruction.YieldStar, \"yield*\"],\r\n+        [Instruction.Endfinally, \"endfinally\"],\r\n+    ]);\r\n \r\n     export function transformGenerators(context: TransformationContext) {\r\n         const {\r\n@@ -240,8 +240,8 @@ namespace ts {\n         context.onSubstituteNode = onSubstituteNode;\r\n \r\n         let currentSourceFile: SourceFile;\r\n-        let renamedCatchVariables: Map<boolean>;\r\n-        let renamedCatchVariableDeclarations: Map<Identifier>;\r\n+        let renamedCatchVariables: Set<string>;\r\n+        let renamedCatchVariableDeclarations: Map<number, Identifier>;\r\n \r\n         let inGeneratorFunctionBody: boolean;\r\n         let inStatementContainingYield: boolean;\r\n@@ -1908,12 +1908,12 @@ namespace ts {\n         }\r\n \r\n         function substituteExpressionIdentifier(node: Identifier) {\r\n-            if (renamedCatchVariables && hasProperty(renamedCatchVariables, node.text)) {\r\n+            if (renamedCatchVariables && renamedCatchVariables.has(node.text)) {\r\n                 const original = getOriginalNode(node);\r\n                 if (isIdentifier(original) && original.parent) {\r\n                     const declaration = resolver.getReferencedValueDeclaration(original);\r\n                     if (declaration) {\r\n-                        const name = getProperty(renamedCatchVariableDeclarations, String(getOriginalNodeId(declaration)));\r\n+                        const name = renamedCatchVariableDeclarations.get(getOriginalNodeId(declaration));\r\n                         if (name) {\r\n                             const clone = getMutableClone(name);\r\n                             setSourceMapRange(clone, node);\r\n@@ -2078,13 +2078,13 @@ namespace ts {\n             const name = declareLocal(text);\r\n \r\n             if (!renamedCatchVariables) {\r\n-                renamedCatchVariables = createMap<boolean>();\r\n-                renamedCatchVariableDeclarations = createMap<Identifier>();\r\n+                renamedCatchVariables = createSet();\r\n+                renamedCatchVariableDeclarations = createMap<number, Identifier>();\r\n                 context.enableSubstitution(SyntaxKind.Identifier);\r\n             }\r\n \r\n-            renamedCatchVariables[text] = true;\r\n-            renamedCatchVariableDeclarations[getOriginalNodeId(variable)] = name;\r\n+            renamedCatchVariables.add(text);\r\n+            renamedCatchVariableDeclarations.set(getOriginalNodeId(variable), name);\r\n \r\n             const exception = <ExceptionBlock>peekBlock();\r\n             Debug.assert(exception.state < ExceptionBlockState.Catch);\r\n@@ -2388,7 +2388,7 @@ namespace ts {\n          */\r\n         function createInstruction(instruction: Instruction): NumericLiteral {\r\n             const literal = createLiteral(instruction);\r\n-            literal.trailingComment = instructionNames[instruction];\r\n+            literal.trailingComment = instructionNames.get(instruction);\r\n             return literal;\r\n         }\r\n \r"},{"sha":"5464325eb5b1e6cd938ec9f10627a8aeb6d5a140","filename":"src/compiler/transformers/jsx.ts","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftransformers%2Fjsx.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftransformers%2Fjsx.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ftransformers%2Fjsx.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -3,7 +3,7 @@\n \r\n /*@internal*/\r\n namespace ts {\r\n-    const entities: Map<number> = createEntitiesMap();\r\n+    const entities: Map<string, number> = createEntitiesMap();\r\n \r\n     export function transformJsx(context: TransformationContext) {\r\n         const compilerOptions = context.getCompilerOptions();\r\n@@ -227,7 +227,7 @@ namespace ts {\n                     return String.fromCharCode(parseInt(hex, 16));\r\n                 }\r\n                 else {\r\n-                    const ch = entities[word];\r\n+                    const ch = entities.get(word);\r\n                     // If this is not a valid entity, then just use `match` (replace it with itself, i.e. don't replace)\r\n                     return ch ? String.fromCharCode(ch) : match;\r\n                 }\r\n@@ -275,8 +275,8 @@ namespace ts {\n         }\r\n     }\r\n \r\n-    function createEntitiesMap(): Map<number> {\r\n-        return createMap<number>({\r\n+    function createEntitiesMap(): Map<string, number> {\r\n+        return mapOfMapLike<number>({\r\n             \"quot\": 0x0022,\r\n             \"amp\": 0x0026,\r\n             \"apos\": 0x0027,\r"},{"sha":"11a2a3dccad967ea35b232d866c4621c14d891d7","filename":"src/compiler/transformers/module/module.ts","status":"modified","additions":29,"deletions":28,"changes":57,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftransformers%2Fmodule%2Fmodule.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftransformers%2Fmodule%2Fmodule.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ftransformers%2Fmodule%2Fmodule.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -10,12 +10,12 @@ namespace ts {\n             importAliasNames: ParameterDeclaration[];\r\n         }\r\n \r\n-        const transformModuleDelegates = createMap<(node: SourceFile) => SourceFile>({\r\n-            [ModuleKind.None]: transformCommonJSModule,\r\n-            [ModuleKind.CommonJS]: transformCommonJSModule,\r\n-            [ModuleKind.AMD]: transformAMDModule,\r\n-            [ModuleKind.UMD]: transformUMDModule,\r\n-        });\r\n+        const transformModuleDelegates = createMap<ModuleKind, (node: SourceFile) => SourceFile>([\r\n+            [ModuleKind.None, transformCommonJSModule],\r\n+            [ModuleKind.CommonJS, transformCommonJSModule],\r\n+            [ModuleKind.AMD, transformAMDModule],\r\n+            [ModuleKind.UMD, transformUMDModule],\r\n+        ]);\r\n \r\n         const {\r\n             startLexicalEnvironment,\r\n@@ -32,19 +32,20 @@ namespace ts {\n         const previousOnEmitNode = context.onEmitNode;\r\n         context.onSubstituteNode = onSubstituteNode;\r\n         context.onEmitNode = onEmitNode;\r\n+\r\n         context.enableSubstitution(SyntaxKind.Identifier); // Substitutes expression identifiers with imported/exported symbols.\r\n         context.enableSubstitution(SyntaxKind.BinaryExpression); // Substitutes assignments to exported symbols.\r\n         context.enableSubstitution(SyntaxKind.PrefixUnaryExpression); // Substitutes updates to exported symbols.\r\n         context.enableSubstitution(SyntaxKind.PostfixUnaryExpression); // Substitutes updates to exported symbols.\r\n         context.enableSubstitution(SyntaxKind.ShorthandPropertyAssignment); // Substitutes shorthand property assignments for imported/exported symbols.\r\n         context.enableEmitNotification(SyntaxKind.SourceFile); // Restore state when substituting nodes in a file.\r\n \r\n-        const moduleInfoMap = createMap<ExternalModuleInfo>(); // The ExternalModuleInfo for each file.\r\n-        const deferredExports = createMap<Statement[]>(); // Exports to defer until an EndOfDeclarationMarker is found.\r\n+        const moduleInfoMap = createMap<number, ExternalModuleInfo>(); // The ExternalModuleInfo for each file.\r\n+        const deferredExports = createMap<number, Statement[]>(); // Exports to defer until an EndOfDeclarationMarker is found.\r\n \r\n         let currentSourceFile: SourceFile; // The current file.\r\n         let currentModuleInfo: ExternalModuleInfo; // The ExternalModuleInfo for the current file.\r\n-        let noSubstitution: Map<boolean>; // Set of nodes for which substitution rules should be ignored.\r\n+        let noSubstitution: Map<number, boolean>; // Set of nodes for which substitution rules should be ignored.\r\n \r\n         return transformSourceFile;\r\n \r\n@@ -61,10 +62,10 @@ namespace ts {\n             }\r\n \r\n             currentSourceFile = node;\r\n-            currentModuleInfo = moduleInfoMap[getOriginalNodeId(node)] = collectExternalModuleInfo(node, resolver);\r\n+            currentModuleInfo = setAndReturn(moduleInfoMap, getOriginalNodeId(node), collectExternalModuleInfo(node, resolver));\r\n \r\n             // Perform the transformation.\r\n-            const transformModule = transformModuleDelegates[moduleKind] || transformModuleDelegates[ModuleKind.None];\r\n+            const transformModule = transformModuleDelegates.get(moduleKind) || transformModuleDelegates.get(ModuleKind.None);\r\n             const updated = transformModule(node);\r\n \r\n             currentSourceFile = undefined;\r\n@@ -444,7 +445,7 @@ namespace ts {\n             if (hasAssociatedEndOfDeclarationMarker(node)) {\r\n                 // Defer exports until we encounter an EndOfDeclarationMarker node\r\n                 const id = getOriginalNodeId(node);\r\n-                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);\r\n+                deferredExports.set(id, appendExportsOfImportDeclaration(deferredExports.get(id), node));\r\n             }\r\n             else {\r\n                 statements = appendExportsOfImportDeclaration(statements, node);\r\n@@ -523,7 +524,7 @@ namespace ts {\n             if (hasAssociatedEndOfDeclarationMarker(node)) {\r\n                 // Defer exports until we encounter an EndOfDeclarationMarker node\r\n                 const id = getOriginalNodeId(node);\r\n-                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);\r\n+                deferredExports.set(id, appendExportsOfImportEqualsDeclaration(deferredExports.get(id), node));\r\n             }\r\n             else {\r\n                 statements = appendExportsOfImportEqualsDeclaration(statements, node);\r\n@@ -610,7 +611,7 @@ namespace ts {\n             if (original && hasAssociatedEndOfDeclarationMarker(original)) {\r\n                 // Defer exports until we encounter an EndOfDeclarationMarker node\r\n                 const id = getOriginalNodeId(node);\r\n-                deferredExports[id] = appendExportStatement(deferredExports[id], createIdentifier(\"default\"), node.expression, /*location*/ node, /*allowComments*/ true);\r\n+                deferredExports.set(id, appendExportStatement(deferredExports.get(id), createIdentifier(\"default\"), node.expression, /*location*/ node, /*allowComments*/ true));\r\n             }\r\n             else {\r\n                 statements = appendExportStatement(statements, createIdentifier(\"default\"), node.expression, /*location*/ node, /*allowComments*/ true);\r\n@@ -651,7 +652,7 @@ namespace ts {\n             if (hasAssociatedEndOfDeclarationMarker(node)) {\r\n                 // Defer exports until we encounter an EndOfDeclarationMarker node\r\n                 const id = getOriginalNodeId(node);\r\n-                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\r\n+                deferredExports.set(id, appendExportsOfHoistedDeclaration(deferredExports.get(id), node));\r\n             }\r\n             else {\r\n                 statements = appendExportsOfHoistedDeclaration(statements, node);\r\n@@ -690,7 +691,7 @@ namespace ts {\n             if (hasAssociatedEndOfDeclarationMarker(node)) {\r\n                 // Defer exports until we encounter an EndOfDeclarationMarker node\r\n                 const id = getOriginalNodeId(node);\r\n-                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\r\n+                deferredExports.set(id, appendExportsOfHoistedDeclaration(deferredExports.get(id), node));\r\n             }\r\n             else {\r\n                 statements = appendExportsOfHoistedDeclaration(statements, node);\r\n@@ -741,7 +742,7 @@ namespace ts {\n             if (hasAssociatedEndOfDeclarationMarker(node)) {\r\n                 // Defer exports until we encounter an EndOfDeclarationMarker node\r\n                 const id = getOriginalNodeId(node);\r\n-                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node);\r\n+                deferredExports.set(id, appendExportsOfVariableStatement(deferredExports.get(id), node));\r\n             }\r\n             else {\r\n                 statements = appendExportsOfVariableStatement(statements, node);\r\n@@ -791,7 +792,7 @@ namespace ts {\n             // statement.\r\n             if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === SyntaxKind.VariableStatement) {\r\n                 const id = getOriginalNodeId(node);\r\n-                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], <VariableStatement>node.original);\r\n+                deferredExports.set(id, appendExportsOfVariableStatement(deferredExports.get(id), <VariableStatement>node.original));\r\n             }\r\n \r\n             return node;\r\n@@ -817,9 +818,9 @@ namespace ts {\n             // end of the transformed declaration. We use this marker to emit any deferred exports\r\n             // of the declaration.\r\n             const id = getOriginalNodeId(node);\r\n-            const statements = deferredExports[id];\r\n+            const statements = deferredExports.get(id);\r\n             if (statements) {\r\n-                delete deferredExports[id];\r\n+                deferredExports.delete(id);\r\n                 return append(statements, node);\r\n             }\r\n \r\n@@ -970,7 +971,7 @@ namespace ts {\n          */\r\n         function appendExportsOfDeclaration(statements: Statement[] | undefined, decl: Declaration): Statement[] | undefined {\r\n             const name = getDeclarationName(decl);\r\n-            const exportSpecifiers = currentModuleInfo.exportSpecifiers[name.text];\r\n+            const exportSpecifiers = currentModuleInfo.exportSpecifiers.get(name.text);\r\n             if (exportSpecifiers) {\r\n                 for (const exportSpecifier of exportSpecifiers) {\r\n                     statements = appendExportStatement(statements, exportSpecifier.name, name, /*location*/ exportSpecifier.name);\r\n@@ -994,7 +995,7 @@ namespace ts {\n         function appendExportStatement(statements: Statement[] | undefined, exportName: Identifier, expression: Expression, location?: TextRange, allowComments?: boolean): Statement[] | undefined {\r\n             if (exportName.text === \"default\") {\r\n                 const sourceFile = getOriginalNode(currentSourceFile, isSourceFile);\r\n-                if (sourceFile && !sourceFile.symbol.exports[\"___esModule\"]) {\r\n+                if (sourceFile && !sourceFile.symbol.exports.get(\"___esModule\")) {\r\n                     if (languageVersion === ScriptTarget.ES3) {\r\n                         statements = append(statements,\r\n                             createStatement(\r\n@@ -1099,8 +1100,8 @@ namespace ts {\n         function onEmitNode(emitContext: EmitContext, node: Node, emitCallback: (emitContext: EmitContext, node: Node) => void): void {\r\n             if (node.kind === SyntaxKind.SourceFile) {\r\n                 currentSourceFile = <SourceFile>node;\r\n-                currentModuleInfo = moduleInfoMap[getOriginalNodeId(currentSourceFile)];\r\n-                noSubstitution = createMap<boolean>();\r\n+                currentModuleInfo = moduleInfoMap.get(getOriginalNodeId(currentSourceFile));\r\n+                noSubstitution = createMap<number, boolean>();\r\n \r\n                 previousOnEmitNode(emitContext, node, emitCallback);\r\n \r\n@@ -1125,7 +1126,7 @@ namespace ts {\n          */\r\n         function onSubstituteNode(emitContext: EmitContext, node: Node) {\r\n             node = previousOnSubstituteNode(emitContext, node);\r\n-            if (node.id && noSubstitution[node.id]) {\r\n+            if (node.id && noSubstitution.get(node.id)) {\r\n                 return node;\r\n             }\r\n \r\n@@ -1243,7 +1244,7 @@ namespace ts {\n                     let expression: Expression = node;\r\n                     for (const exportName of exportedNames) {\r\n                         // Mark the node to prevent triggering this rule again.\r\n-                        noSubstitution[getNodeId(expression)] = true;\r\n+                        noSubstitution.set(getNodeId(expression), true);\r\n                         expression = createExportExpression(exportName, expression, /*location*/ node);\r\n                     }\r\n \r\n@@ -1285,7 +1286,7 @@ namespace ts {\n                         : node;\r\n                     for (const exportName of exportedNames) {\r\n                         // Mark the node to prevent triggering this rule again.\r\n-                        noSubstitution[getNodeId(expression)] = true;\r\n+                        noSubstitution.set(getNodeId(expression), true);\r\n                         expression = createExportExpression(exportName, expression);\r\n                     }\r\n \r\n@@ -1307,7 +1308,7 @@ namespace ts {\n                     || resolver.getReferencedValueDeclaration(name);\r\n                 if (valueDeclaration) {\r\n                     return currentModuleInfo\r\n-                        && currentModuleInfo.exportedBindings[getOriginalNodeId(valueDeclaration)];\r\n+                        && currentModuleInfo.exportedBindings.get(getOriginalNodeId(valueDeclaration));\r\n                 }\r\n             }\r\n         }\r"},{"sha":"f3db63287b23818e19031c0fee4e6b51bdbd8f7d","filename":"src/compiler/transformers/module/system.ts","status":"modified","additions":32,"deletions":31,"changes":63,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftransformers%2Fmodule%2Fsystem.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftransformers%2Fmodule%2Fsystem.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ftransformers%2Fmodule%2Fsystem.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -28,18 +28,18 @@ namespace ts {\n         context.enableSubstitution(SyntaxKind.PostfixUnaryExpression); // Substitutes updates to exported symbols.\r\n         context.enableEmitNotification(SyntaxKind.SourceFile); // Restore state when substituting nodes in a file.\r\n \r\n-        const moduleInfoMap = createMap<ExternalModuleInfo>(); // The ExternalModuleInfo for each file.\r\n-        const deferredExports = createMap<Statement[]>(); // Exports to defer until an EndOfDeclarationMarker is found.\r\n-        const exportFunctionsMap = createMap<Identifier>(); // The export function associated with a source file.\r\n-        const noSubstitutionMap = createMap<Map<boolean>>(); // Set of nodes for which substitution rules should be ignored for each file.\r\n+        const moduleInfoMap = createMap<number, ExternalModuleInfo>(); // The ExternalModuleInfo for each file.\r\n+        const deferredExports = createMap<number, Statement[]>(); // Exports to defer until an EndOfDeclarationMarker is found.\r\n+        const exportFunctionsMap = createMap<number, Identifier>(); // The export function associated with a source file.\r\n+        const noSubstitutionMap = createMap<number, Map<number, boolean>>(); // Set of nodes for which substitution rules should be ignored for each file.\r\n \r\n         let currentSourceFile: SourceFile; // The current file.\r\n         let moduleInfo: ExternalModuleInfo; // ExternalModuleInfo for the current file.\r\n         let exportFunction: Identifier; // The export function for the current file.\r\n         let contextObject: Identifier; // The context object for the current file.\r\n         let hoistedStatements: Statement[];\r\n         let enclosingBlockScopedContainer: Node;\r\n-        let noSubstitution: Map<boolean>; // Set of nodes for which substitution rules should be ignored.\r\n+        let noSubstitution: Map<number, boolean>; // Set of nodes for which substitution rules should be ignored.\r\n \r\n         return transformSourceFile;\r\n \r\n@@ -73,11 +73,11 @@ namespace ts {\n             // see comment to 'substitutePostfixUnaryExpression' for more details\r\n \r\n             // Collect information about the external module and dependency groups.\r\n-            moduleInfo = moduleInfoMap[id] = collectExternalModuleInfo(node, resolver);\r\n+            moduleInfo = setAndReturn(moduleInfoMap, id, collectExternalModuleInfo(node, resolver));\r\n \r\n             // Make sure that the name of the 'exports' function does not conflict with\r\n             // existing identifiers.\r\n-            exportFunction = exportFunctionsMap[id] = createUniqueName(\"exports\");\r\n+            exportFunction = setAndReturn(exportFunctionsMap, id, createUniqueName(\"exports\"));\r\n             contextObject = createUniqueName(\"context\");\r\n \r\n             // Add the body of the module.\r\n@@ -118,7 +118,7 @@ namespace ts {\n             setEmitFlags(updated, getEmitFlags(node) & ~EmitFlags.EmitEmitHelpers);\r\n \r\n             if (noSubstitution) {\r\n-                noSubstitutionMap[id] = noSubstitution;\r\n+                noSubstitutionMap.set(id, noSubstitution);\r\n                 noSubstitution = undefined;\r\n             }\r\n \r\n@@ -138,19 +138,19 @@ namespace ts {\n          * @param externalImports The imports for the file.\r\n          */\r\n         function collectDependencyGroups(externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[]) {\r\n-            const groupIndices = createMap<number>();\r\n+            const groupIndices = createMap<string, number>();\r\n             const dependencyGroups: DependencyGroup[] = [];\r\n             for (let i = 0; i < externalImports.length; i++) {\r\n                 const externalImport = externalImports[i];\r\n                 const externalModuleName = getExternalModuleNameLiteral(externalImport, currentSourceFile, host, resolver, compilerOptions);\r\n                 const text = externalModuleName.text;\r\n-                if (hasProperty(groupIndices, text)) {\r\n+                const groupIndex = groupIndices.get(text);\r\n+                if (groupIndex !== undefined) {\r\n                     // deduplicate/group entries in dependency list by the dependency name\r\n-                    const groupIndex = groupIndices[text];\r\n                     dependencyGroups[groupIndex].externalImports.push(externalImport);\r\n                 }\r\n                 else {\r\n-                    groupIndices[text] = dependencyGroups.length;\r\n+                    groupIndices.set(text, dependencyGroups.length);\r\n                     dependencyGroups.push({\r\n                         name: externalModuleName,\r\n                         externalImports: [externalImport]\r\n@@ -301,7 +301,8 @@ namespace ts {\n             // this set is used to filter names brought by star expors.\r\n \r\n             // local names set should only be added if we have anything exported\r\n-            if (!moduleInfo.exportedNames && isEmpty(moduleInfo.exportSpecifiers)) {\r\n+\r\n+            if (!moduleInfo.exportedNames && mapIsEmpty(moduleInfo.exportSpecifiers)) {\r\n                 // no exported declarations (export var ...) or export specifiers (export {x})\r\n                 // check if we have any non star export declarations.\r\n                 let hasExportDeclarationWithExportClause = false;\r\n@@ -598,7 +599,7 @@ namespace ts {\n             if (hasAssociatedEndOfDeclarationMarker(node)) {\r\n                 // Defer exports until we encounter an EndOfDeclarationMarker node\r\n                 const id = getOriginalNodeId(node);\r\n-                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);\r\n+                deferredExports.set(id, appendExportsOfImportDeclaration(deferredExports.get(id), node));\r\n             }\r\n             else {\r\n                 statements = appendExportsOfImportDeclaration(statements, node);\r\n@@ -621,7 +622,7 @@ namespace ts {\n             if (hasAssociatedEndOfDeclarationMarker(node)) {\r\n                 // Defer exports until we encounter an EndOfDeclarationMarker node\r\n                 const id = getOriginalNodeId(node);\r\n-                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);\r\n+                deferredExports.set(id, appendExportsOfImportEqualsDeclaration(deferredExports.get(id), node));\r\n             }\r\n             else {\r\n                 statements = appendExportsOfImportEqualsDeclaration(statements, node);\r\n@@ -646,7 +647,7 @@ namespace ts {\n             if (original && hasAssociatedEndOfDeclarationMarker(original)) {\r\n                 // Defer exports until we encounter an EndOfDeclarationMarker node\r\n                 const id = getOriginalNodeId(node);\r\n-                deferredExports[id] = appendExportStatement(deferredExports[id], createIdentifier(\"default\"), expression, /*allowComments*/ true);\r\n+                deferredExports.set(id, appendExportStatement(deferredExports.get(id), createIdentifier(\"default\"), expression, /*allowComments*/ true));\r\n             }\r\n             else {\r\n                 return createExportStatement(createIdentifier(\"default\"), expression, /*allowComments*/ true);\r\n@@ -678,7 +679,7 @@ namespace ts {\n             if (hasAssociatedEndOfDeclarationMarker(node)) {\r\n                 // Defer exports until we encounter an EndOfDeclarationMarker node\r\n                 const id = getOriginalNodeId(node);\r\n-                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\r\n+                deferredExports.set(id, appendExportsOfHoistedDeclaration(deferredExports.get(id), node));\r\n             }\r\n             else {\r\n                 hoistedStatements = appendExportsOfHoistedDeclaration(hoistedStatements, node);\r\n@@ -720,7 +721,7 @@ namespace ts {\n             if (hasAssociatedEndOfDeclarationMarker(node)) {\r\n                 // Defer exports until we encounter an EndOfDeclarationMarker node\r\n                 const id = getOriginalNodeId(node);\r\n-                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\r\n+                deferredExports.set(id, appendExportsOfHoistedDeclaration(deferredExports.get(id), node));\r\n             }\r\n             else {\r\n                 statements = appendExportsOfHoistedDeclaration(statements, node);\r\n@@ -760,7 +761,7 @@ namespace ts {\n             if (isMarkedDeclaration) {\r\n                 // Defer exports until we encounter an EndOfDeclarationMarker node\r\n                 const id = getOriginalNodeId(node);\r\n-                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node, isExportedDeclaration);\r\n+                deferredExports.set(id, appendExportsOfVariableStatement(deferredExports.get(id), node, isExportedDeclaration));\r\n             }\r\n             else {\r\n                 statements = appendExportsOfVariableStatement(statements, node, /*exportSelf*/ false);\r\n@@ -866,7 +867,7 @@ namespace ts {\n             if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === SyntaxKind.VariableStatement) {\r\n                 const id = getOriginalNodeId(node);\r\n                 const isExportedDeclaration = hasModifier(node.original, ModifierFlags.Export);\r\n-                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], <VariableStatement>node.original, isExportedDeclaration);\r\n+                deferredExports.set(id, appendExportsOfVariableStatement(deferredExports.get(id), <VariableStatement>node.original, isExportedDeclaration));\r\n             }\r\n \r\n             return node;\r\n@@ -892,9 +893,9 @@ namespace ts {\n             // end of the transformed declaration. We use this marker to emit any deferred exports\r\n             // of the declaration.\r\n             const id = getOriginalNodeId(node);\r\n-            const statements = deferredExports[id];\r\n+            const statements = deferredExports.get(id);\r\n             if (statements) {\r\n-                delete deferredExports[id];\r\n+                deferredExports.delete(id);\r\n                 return append(statements, node);\r\n             }\r\n \r\n@@ -1063,7 +1064,7 @@ namespace ts {\n             }\r\n \r\n             const name = getDeclarationName(decl);\r\n-            const exportSpecifiers = moduleInfo.exportSpecifiers[name.text];\r\n+            const exportSpecifiers = moduleInfo.exportSpecifiers.get(name.text);\r\n             if (exportSpecifiers) {\r\n                 for (const exportSpecifier of exportSpecifiers) {\r\n                     if (exportSpecifier.name.text !== excludeName) {\r\n@@ -1531,12 +1532,12 @@ namespace ts {\n             if (node.kind === SyntaxKind.SourceFile) {\r\n                 const id = getOriginalNodeId(node);\r\n                 currentSourceFile = <SourceFile>node;\r\n-                moduleInfo = moduleInfoMap[id];\r\n-                exportFunction = exportFunctionsMap[id];\r\n-                noSubstitution = noSubstitutionMap[id];\r\n+                moduleInfo = moduleInfoMap.get(id);\r\n+                exportFunction = exportFunctionsMap.get(id);\r\n+                noSubstitution = noSubstitutionMap.get(id);\r\n \r\n                 if (noSubstitution) {\r\n-                    delete noSubstitutionMap[id];\r\n+                    noSubstitutionMap.delete(id);\r\n                 }\r\n \r\n                 previousOnEmitNode(emitContext, node, emitCallback);\r\n@@ -1725,7 +1726,7 @@ namespace ts {\n                         exportedNames = append(exportedNames, getDeclarationName(valueDeclaration));\r\n                     }\r\n \r\n-                    exportedNames = addRange(exportedNames, moduleInfo && moduleInfo.exportedBindings[getOriginalNodeId(valueDeclaration)]);\r\n+                    exportedNames = addRange(exportedNames, moduleInfo && moduleInfo.exportedBindings.get(getOriginalNodeId(valueDeclaration)));\r\n                 }\r\n             }\r\n \r\n@@ -1738,8 +1739,8 @@ namespace ts {\n          * @param node The node which should not be substituted.\r\n          */\r\n         function preventSubstitution<T extends Node>(node: T): T {\r\n-            if (noSubstitution === undefined) noSubstitution = createMap<boolean>();\r\n-            noSubstitution[getNodeId(node)] = true;\r\n+            if (noSubstitution === undefined) noSubstitution = createMap<number, boolean>();\r\n+            noSubstitution.set(getNodeId(node), true);\r\n             return node;\r\n         }\r\n \r\n@@ -1749,7 +1750,7 @@ namespace ts {\n          * @param node The node to test.\r\n          */\r\n         function isSubstitutionPrevented(node: Node) {\r\n-            return noSubstitution && node.id && noSubstitution[node.id];\r\n+            return noSubstitution && node.id && noSubstitution.get(node.id);\r\n         }\r\n     }\r\n }\r"},{"sha":"3e9a9855f7e7afcc768b522db9bd4d56e677cf4c","filename":"src/compiler/transformers/ts.ts","status":"modified","additions":11,"deletions":13,"changes":24,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftransformers%2Fts.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftransformers%2Fts.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ftransformers%2Fts.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -47,7 +47,7 @@ namespace ts {\n         let currentNamespace: ModuleDeclaration;\r\n         let currentNamespaceContainerName: Identifier;\r\n         let currentScope: SourceFile | Block | ModuleBlock | CaseBlock;\r\n-        let currentScopeFirstDeclarationsOfName: Map<Node>;\r\n+        let currentScopeFirstDeclarationsOfName: Map<string, Node>;\r\n         let currentExternalHelpersModuleName: Identifier;\r\n \r\n         /**\r\n@@ -60,7 +60,7 @@ namespace ts {\n          * A map that keeps track of aliases created for classes with decorators to avoid issues\r\n          * with the double-binding behavior of classes.\r\n          */\r\n-        let classAliases: Map<Identifier>;\r\n+        let classAliases: Map<number, Identifier>;\r\n \r\n         /**\r\n          * Keeps track of whether  we are within any containing namespaces when performing\r\n@@ -783,7 +783,7 @@ namespace ts {\n                 if (resolver.getNodeCheckFlags(node) & NodeCheckFlags.ClassWithConstructorReference) {\r\n                     // record an alias as the class name is not in scope for statics.\r\n                     enableSubstitutionForClassAliases();\r\n-                    classAliases[getOriginalNodeId(node)] = getSynthesizedClone(temp);\r\n+                    classAliases.set(getOriginalNodeId(node), getSynthesizedClone(temp));\r\n                 }\r\n \r\n                 // To preserve the behavior of the old emitter, we explicitly indent\r\n@@ -1454,7 +1454,7 @@ namespace ts {\n                 return undefined;\r\n             }\r\n \r\n-            const classAlias = classAliases && classAliases[getOriginalNodeId(node)];\r\n+            const classAlias = classAliases && classAliases.get(getOriginalNodeId(node));\r\n             const localName = getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true);\r\n             const decorate = createDecorateHelper(currentExternalHelpersModuleName, decoratorExpressions, localName);\r\n             const expression = createAssignment(localName, classAlias ? createAssignment(classAlias, decorate) : decorate);\r\n@@ -2245,7 +2245,7 @@ namespace ts {\n             const savedCurrentScope = currentScope;\r\n             const savedCurrentScopeFirstDeclarationsOfName = currentScopeFirstDeclarationsOfName;\r\n             currentScope = body;\r\n-            currentScopeFirstDeclarationsOfName = createMap<Node>();\r\n+            currentScopeFirstDeclarationsOfName = createMap<string, Node>();\r\n             startLexicalEnvironment();\r\n \r\n             const statements = visitNodes(body.statements, visitor, isStatement, start);\r\n@@ -2630,12 +2630,10 @@ namespace ts {\n             const name = node.symbol && node.symbol.name;\r\n             if (name) {\r\n                 if (!currentScopeFirstDeclarationsOfName) {\r\n-                    currentScopeFirstDeclarationsOfName = createMap<Node>();\r\n+                    currentScopeFirstDeclarationsOfName = createMap<string, Node>();\r\n                 }\r\n \r\n-                if (!(name in currentScopeFirstDeclarationsOfName)) {\r\n-                    currentScopeFirstDeclarationsOfName[name] = node;\r\n-                }\r\n+                setIfNotSet(currentScopeFirstDeclarationsOfName, name, node);\r\n             }\r\n         }\r\n \r\n@@ -2647,7 +2645,7 @@ namespace ts {\n             if (currentScopeFirstDeclarationsOfName) {\r\n                 const name = node.symbol && node.symbol.name;\r\n                 if (name) {\r\n-                    return currentScopeFirstDeclarationsOfName[name] === node;\r\n+                    return currentScopeFirstDeclarationsOfName.get(name) === node;\r\n                 }\r\n             }\r\n \r\n@@ -3188,7 +3186,7 @@ namespace ts {\n             if (resolver.getNodeCheckFlags(node) & NodeCheckFlags.ClassWithConstructorReference) {\r\n                 enableSubstitutionForClassAliases();\r\n                 const classAlias = createUniqueName(node.name && !isGeneratedIdentifier(node.name) ? node.name.text : \"default\");\r\n-                classAliases[getOriginalNodeId(node)] = classAlias;\r\n+                classAliases.set(getOriginalNodeId(node), classAlias);\r\n                 hoistVariableDeclaration(classAlias);\r\n                 return classAlias;\r\n             }\r\n@@ -3220,7 +3218,7 @@ namespace ts {\n                 context.enableSubstitution(SyntaxKind.Identifier);\r\n \r\n                 // Keep track of class aliases.\r\n-                classAliases = createMap<Identifier>();\r\n+                classAliases = createMap<number, Identifier>();\r\n             }\r\n         }\r\n \r\n@@ -3333,7 +3331,7 @@ namespace ts {\n                     // constructor references in static property initializers.\r\n                     const declaration = resolver.getReferencedValueDeclaration(node);\r\n                     if (declaration) {\r\n-                        const classAlias = classAliases[declaration.id];\r\n+                        const classAlias = classAliases.get(declaration.id);\r\n                         if (classAlias) {\r\n                             const clone = getSynthesizedClone(classAlias);\r\n                             setSourceMapRange(clone, node);\r"},{"sha":"28b3b9f3068b9a07ede6d4dfc9e36d5d5798ec23","filename":"src/compiler/tsc.ts","status":"modified","additions":16,"deletions":18,"changes":34,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftsc.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftsc.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ftsc.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -93,7 +93,7 @@ namespace ts {\n             return false;\r\n         }\r\n         try {\r\n-            ts.localizedDiagnosticMessages = JSON.parse(fileContents);\r\n+            ts.localizedDiagnosticMessages = mapOfMapLike<string>(JSON.parse(fileContents));\r\n         }\r\n         catch (e) {\r\n             errors.push(createCompilerDiagnostic(Diagnostics.Corrupted_locale_file_0, filePath));\r\n@@ -127,11 +127,11 @@ namespace ts {\n     const gutterSeparator = \" \";\r\n     const resetEscapeSequence = \"\\u001b[0m\";\r\n     const ellipsis = \"...\";\r\n-    const categoryFormatMap = createMap<string>({\r\n-        [DiagnosticCategory.Warning]: yellowForegroundEscapeSequence,\r\n-        [DiagnosticCategory.Error]: redForegroundEscapeSequence,\r\n-        [DiagnosticCategory.Message]: blueForegroundEscapeSequence,\r\n-    });\r\n+    const categoryFormatMap = createMap<DiagnosticCategory, string>([\r\n+        [DiagnosticCategory.Warning, yellowForegroundEscapeSequence],\r\n+        [DiagnosticCategory.Error, redForegroundEscapeSequence],\r\n+        [DiagnosticCategory.Message, blueForegroundEscapeSequence],\r\n+    ]);\r\n \r\n     function formatAndReset(text: string, formatStyle: string) {\r\n         return formatStyle + text + resetEscapeSequence;\r\n@@ -199,7 +199,7 @@ namespace ts {\n             output += `${ relativeFileName }(${ firstLine + 1 },${ firstLineChar + 1 }): `;\r\n         }\r\n \r\n-        const categoryColor = categoryFormatMap[diagnostic.category];\r\n+        const categoryColor = categoryFormatMap.get(diagnostic.category);\r\n         const category = DiagnosticCategory[diagnostic.category].toLowerCase();\r\n         output += `${ formatAndReset(category, categoryColor) } TS${ diagnostic.code }: ${ flattenDiagnosticMessageText(diagnostic.messageText, sys.newLine) }`;\r\n         output += sys.newLine + sys.newLine;\r\n@@ -255,7 +255,7 @@ namespace ts {\n \r\n         // This map stores and reuses results of fileExists check that happen inside 'createProgram'\r\n         // This allows to save time in module resolution heavy scenarios when existence of the same file might be checked multiple times.\r\n-        let cachedExistingFiles: Map<boolean>;\r\n+        let cachedExistingFiles: Map<string, boolean>;\r\n         let hostFileExists: typeof compilerHost.fileExists;\r\n \r\n         if (commandLine.options.locale) {\r\n@@ -425,7 +425,7 @@ namespace ts {\n             }\r\n \r\n             // reset the cache of existing files\r\n-            cachedExistingFiles = createMap<boolean>();\r\n+            cachedExistingFiles = createMap<string, boolean>();\r\n \r\n             const compileResult = compile(rootFileNames, compilerOptions, compilerHost);\r\n \r\n@@ -438,9 +438,7 @@ namespace ts {\n         }\r\n \r\n         function cachedFileExists(fileName: string): boolean {\r\n-            return fileName in cachedExistingFiles\r\n-                ? cachedExistingFiles[fileName]\r\n-                : cachedExistingFiles[fileName] = hostFileExists(fileName);\r\n+            return getOrUpdate(cachedExistingFiles, fileName, hostFileExists);\r\n         }\r\n \r\n         function getSourceFile(fileName: string, languageVersion: ScriptTarget, onError?: (message: string) => void) {\r\n@@ -708,7 +706,7 @@ namespace ts {\n         const usageColumn: string[] = []; // Things like \"-d, --declaration\" go in here.\r\n         const descriptionColumn: string[] = [];\r\n \r\n-        const optionsDescriptionMap = createMap<string[]>();  // Map between option.description and list of option.type if it is a kind\r\n+        const optionsDescriptionMap = createMap<string, string[]>();  // Map between option.description and list of option.type if it is a kind\r\n \r\n         for (let i = 0; i < optsList.length; i++) {\r\n             const option = optsList[i];\r\n@@ -736,11 +734,11 @@ namespace ts {\n                 description = getDiagnosticText(option.description);\r\n                 const options: string[] = [];\r\n                 const element = (<CommandLineOptionOfListType>option).element;\r\n-                const typeMap = <Map<number | string>>element.type;\r\n-                for (const key in typeMap) {\r\n+                const typeMap = <Map<string, number | string>>element.type;\r\n+                forEachKeyInMap(typeMap, key => {\r\n                     options.push(`'${key}'`);\r\n-                }\r\n-                optionsDescriptionMap[description] = options;\r\n+                });\r\n+                optionsDescriptionMap.set(description, options);\r\n             }\r\n             else {\r\n                 description = getDiagnosticText(option.description);\r\n@@ -762,7 +760,7 @@ namespace ts {\n         for (let i = 0; i < usageColumn.length; i++) {\r\n             const usage = usageColumn[i];\r\n             const description = descriptionColumn[i];\r\n-            const kindsList = optionsDescriptionMap[description];\r\n+            const kindsList = optionsDescriptionMap.get(description);\r\n             output.push(usage + makePadding(marginLength - usage.length + 2) + description + sys.newLine);\r\n \r\n             if (kindsList) {\r"},{"sha":"d048ec2f891a6bc0cdccd376004f0e0f9ca422cc","filename":"src/compiler/tsconfig.json","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftsconfig.json","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftsconfig.json","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ftsconfig.json?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -15,6 +15,7 @@\n     },\r\n     \"files\": [\r\n         \"core.ts\",\r\n+        \"collections.ts\",\r\n         \"performance.ts\",\r\n         \"sys.ts\",\r\n         \"types.ts\",\r"},{"sha":"12f46751f64141fcec1fe80587f90e8b4bb763d4","filename":"src/compiler/types.ts","status":"modified","additions":54,"deletions":19,"changes":73,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftypes.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Ftypes.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Ftypes.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -1,11 +1,46 @@\n namespace ts {\r\n-\r\n+    /**\r\n+     * Type of objects whose values are all of the same type.\r\n+     * The `in` and `for-in` operators can *not* be safely used,\r\n+     * since `Object.prototype` may be modified by outside code.\r\n+    */\r\n     export interface MapLike<T> {\r\n         [index: string]: T;\r\n     }\r\n \r\n-    export interface Map<T> extends MapLike<T> {\r\n-        __mapBrand: any;\r\n+    /**\r\n+     * This contains just the parts of ES6's `Map` interface that we allow.\r\n+     * Map can only be instantiated using NumberMap and StringMap, which come with shims.\r\n+     *\r\n+     * Internet Explorer does not support iterator-returning methods, so those are not allowed here.\r\n+     * But map-using functions in collections.ts check for these features and use them where possible.\r\n+     */\r\n+    export interface Map<K, V> {\r\n+        clear(): void;\r\n+        delete(key: K): boolean;\r\n+        /**\r\n+         * Call `action` for each entry in the map.\r\n+         * Since we use a `for-in` loop for our shims, `key` may be a string.\r\n+         */\r\n+        forEach(action: (value: V, key: K | string) => void): void;\r\n+        get(key: K): V;\r\n+        /**\r\n+         * Whether the key is in the map.\r\n+         * Note: It is better to ask forgiveness than permission. Consider calling `get` and checking if the result is undefined.\r\n+         */\r\n+        has(key: K): boolean;\r\n+        set(key: K, value: V): void;\r\n+    }\r\n+\r\n+    /**\r\n+     * This contains just the parts of ES6's `Set` interface that we allow.\r\n+     */\r\n+    export interface Set<T> {\r\n+        add(value: T): void;\r\n+        clear(): void;\r\n+        delete(value: T): boolean;\r\n+        forEach(action: (value: T) => void): void;\r\n+        has(value: T): boolean;\r\n     }\r\n \r\n     // branded string type used to store absolute, normalized and canonicalized paths\r\n@@ -2044,7 +2079,7 @@ namespace ts {\n \r\n         // this map is used by transpiler to supply alternative names for dependencies (i.e. in case of bundling)\r\n         /* @internal */\r\n-        renamedDependencies?: Map<string>;\r\n+        renamedDependencies?: Map<string, string>;\r\n \r\n         /**\r\n          * lib.d.ts should have a reference comment like\r\n@@ -2064,7 +2099,7 @@ namespace ts {\n         // The first node that causes this file to be a CommonJS module\r\n         /* @internal */ commonJsModuleIndicator: Node;\r\n \r\n-        /* @internal */ identifiers: Map<string>;\r\n+        /* @internal */ identifiers: Map<string, string>;\r\n         /* @internal */ nodeCount: number;\r\n         /* @internal */ identifierCount: number;\r\n         /* @internal */ symbolCount: number;\r\n@@ -2079,12 +2114,12 @@ namespace ts {\n         // Stores a line map for the file.\r\n         // This field should never be used directly to obtain line map, use getLineMap function instead.\r\n         /* @internal */ lineMap: number[];\r\n-        /* @internal */ classifiableNames?: Map<string>;\r\n+        /* @internal */ classifiableNames?: Set<string>;\r\n         // Stores a mapping 'external module reference text' -> 'resolved file name' | undefined\r\n         // It is used to resolve module names in the checker.\r\n         // Content of this field should never be used directly - use getResolvedModuleFileName/setResolvedModuleFileName functions instead\r\n-        /* @internal */ resolvedModules: Map<ResolvedModuleFull>;\r\n-        /* @internal */ resolvedTypeReferenceDirectiveNames: Map<ResolvedTypeReferenceDirective>;\r\n+        /* @internal */ resolvedModules: Map<string, ResolvedModuleFull>;\r\n+        /* @internal */ resolvedTypeReferenceDirectiveNames: Map<string, ResolvedTypeReferenceDirective>;\r\n         /* @internal */ imports: LiteralExpression[];\r\n         /* @internal */ moduleAugmentations: LiteralExpression[];\r\n         /* @internal */ patternAmbientModules?: PatternAmbientModule[];\r\n@@ -2168,15 +2203,15 @@ namespace ts {\n         /* @internal */ getDiagnosticsProducingTypeChecker(): TypeChecker;\r\n         /* @internal */ dropDiagnosticsProducingTypeChecker(): void;\r\n \r\n-        /* @internal */ getClassifiableNames(): Map<string>;\r\n+        /* @internal */ getClassifiableNames(): Set<string>;\r\n \r\n         /* @internal */ getNodeCount(): number;\r\n         /* @internal */ getIdentifierCount(): number;\r\n         /* @internal */ getSymbolCount(): number;\r\n         /* @internal */ getTypeCount(): number;\r\n \r\n         /* @internal */ getFileProcessingDiagnostics(): DiagnosticCollection;\r\n-        /* @internal */ getResolvedTypeReferenceDirectives(): Map<ResolvedTypeReferenceDirective>;\r\n+        /* @internal */ getResolvedTypeReferenceDirectives(): Map<string, ResolvedTypeReferenceDirective>;\r\n         // For testing purposes only.\r\n         /* @internal */ structureIsReused?: boolean;\r\n     }\r\n@@ -2237,7 +2272,7 @@ namespace ts {\n \r\n         getSourceFiles(): SourceFile[];\r\n         getSourceFile(fileName: string): SourceFile;\r\n-        getResolvedTypeReferenceDirectives(): Map<ResolvedTypeReferenceDirective>;\r\n+        getResolvedTypeReferenceDirectives(): Map<string, ResolvedTypeReferenceDirective>;\r\n     }\r\n \r\n     export interface TypeChecker {\r\n@@ -2571,7 +2606,7 @@ namespace ts {\n         declaredType?: Type;                // Type of class, interface, enum, type alias, or type parameter\r\n         typeParameters?: TypeParameter[];   // Type parameters of type alias (undefined if non-generic)\r\n         inferredClassType?: Type;           // Type of an inferred ES5 class\r\n-        instantiations?: Map<Type>;         // Instantiations of generic type alias (undefined if non-generic)\r\n+        instantiations?: Map<string, Type>;         // Instantiations of generic type alias (undefined if non-generic)\r\n         mapper?: TypeMapper;                // Type mapper for instantiation alias\r\n         referenced?: boolean;               // True if alias symbol has been referenced as a value\r\n         containingType?: UnionOrIntersectionType; // Containing union or intersection type for synthetic property\r\n@@ -2588,7 +2623,7 @@ namespace ts {\n     /* @internal */\r\n     export interface TransientSymbol extends Symbol, SymbolLinks { }\r\n \r\n-    export type SymbolTable = Map<Symbol>;\r\n+    export type SymbolTable = Map<string, Symbol>;\r\n \r\n     /** Represents a \"prefix*suffix\" pattern. */\r\n     /* @internal */\r\n@@ -2730,7 +2765,7 @@ namespace ts {\n \r\n     // Enum types (TypeFlags.Enum)\r\n     export interface EnumType extends Type {\r\n-        memberTypes: Map<EnumLiteralType>;\r\n+        memberTypes: { [enumMemberValue: number]: EnumLiteralType };\r\n     }\r\n \r\n     // Enum types (TypeFlags.EnumLiteral)\r\n@@ -2792,7 +2827,7 @@ namespace ts {\n     // Generic class and interface types\r\n     export interface GenericType extends InterfaceType, TypeReference {\r\n         /* @internal */\r\n-        instantiations: Map<TypeReference>;   // Generic instantiation cache\r\n+        instantiations: Map<string, TypeReference>;   // Generic instantiation cache\r\n     }\r\n \r\n     export interface UnionOrIntersectionType extends Type {\r\n@@ -3080,7 +3115,7 @@ namespace ts {\n         fileNames: string[];                            // The file names that belong to the same project.\r\n         projectRootPath: string;                        // The path to the project root directory\r\n         safeListPath: string;                           // The path used to retrieve the safe list\r\n-        packageNameToTypingLocation: Map<string>;       // The map of package names to their cached typing locations\r\n+        packageNameToTypingLocation: MapLike<string>;   // The map of package names to their cached typing locations\r\n         typingOptions: TypingOptions;                   // Used to customize the typing inference process\r\n         compilerOptions: CompilerOptions;               // Used as a source for typing inference\r\n         unresolvedImports: ReadonlyArray<string>;       // List of unresolved module ids from imports\r\n@@ -3165,7 +3200,7 @@ namespace ts {\n     /* @internal */\r\n     export interface CommandLineOptionBase {\r\n         name: string;\r\n-        type: \"string\" | \"number\" | \"boolean\" | \"object\" | \"list\" | Map<number | string>;    // a value of a primitive type, or an object literal mapping named values to actual values\r\n+        type: \"string\" | \"number\" | \"boolean\" | \"object\" | \"list\" | Map<string, number | string>;    // a value of a primitive type, or an object literal mapping named values to actual values\r\n         isFilePath?: boolean;                                   // True if option value is a path or fileName\r\n         shortName?: string;                                     // A short mnemonic for convenience - for instance, 'h' can be used in place of 'help'\r\n         description?: DiagnosticMessage;                        // The message describing what the command line switch does\r\n@@ -3181,7 +3216,7 @@ namespace ts {\n \r\n     /* @internal */\r\n     export interface CommandLineOptionOfCustomType extends CommandLineOptionBase {\r\n-        type: Map<number | string>;  // an object literal mapping named values to actual values\r\n+        type: Map<string, number | string>;  // an object literal mapping named values to actual values\r\n     }\r\n \r\n     /* @internal */\r\n@@ -3508,7 +3543,7 @@ namespace ts {\n         flags?: EmitFlags;\r\n         commentRange?: TextRange;\r\n         sourceMapRange?: TextRange;\r\n-        tokenSourceMapRanges?: Map<TextRange>;\r\n+        tokenSourceMapRanges?: Map<SyntaxKind, TextRange>;\r\n         annotatedNodes?: Node[];                // Tracks Parse-tree nodes with EmitNodes for eventual cleanup.\r\n         constantValue?: number;\r\n     }\r"},{"sha":"bd77d5b2138f390e160c65cbd272384fcdde44a9","filename":"src/compiler/utilities.ts","status":"modified","additions":43,"deletions":43,"changes":86,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Futilities.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Futilities.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Futilities.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -84,27 +84,27 @@ namespace ts {\n     }\r\n \r\n     export function hasResolvedModule(sourceFile: SourceFile, moduleNameText: string): boolean {\r\n-        return !!(sourceFile && sourceFile.resolvedModules && sourceFile.resolvedModules[moduleNameText]);\r\n+        return !!(sourceFile && sourceFile.resolvedModules && sourceFile.resolvedModules.get(moduleNameText));\r\n     }\r\n \r\n     export function getResolvedModule(sourceFile: SourceFile, moduleNameText: string): ResolvedModuleFull {\r\n-        return hasResolvedModule(sourceFile, moduleNameText) ? sourceFile.resolvedModules[moduleNameText] : undefined;\r\n+        return hasResolvedModule(sourceFile, moduleNameText) ? sourceFile.resolvedModules.get(moduleNameText) : undefined;\r\n     }\r\n \r\n     export function setResolvedModule(sourceFile: SourceFile, moduleNameText: string, resolvedModule: ResolvedModuleFull): void {\r\n         if (!sourceFile.resolvedModules) {\r\n-            sourceFile.resolvedModules = createMap<ResolvedModuleFull>();\r\n+            sourceFile.resolvedModules = createMap<string, ResolvedModuleFull>();\r\n         }\r\n \r\n-        sourceFile.resolvedModules[moduleNameText] = resolvedModule;\r\n+        sourceFile.resolvedModules.set(moduleNameText, resolvedModule);\r\n     }\r\n \r\n     export function setResolvedTypeReferenceDirective(sourceFile: SourceFile, typeReferenceDirectiveName: string, resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective): void {\r\n         if (!sourceFile.resolvedTypeReferenceDirectiveNames) {\r\n-            sourceFile.resolvedTypeReferenceDirectiveNames = createMap<ResolvedTypeReferenceDirective>();\r\n+            sourceFile.resolvedTypeReferenceDirectiveNames = createMap<string, ResolvedTypeReferenceDirective>();\r\n         }\r\n \r\n-        sourceFile.resolvedTypeReferenceDirectiveNames[typeReferenceDirectiveName] = resolvedTypeReferenceDirective;\r\n+        sourceFile.resolvedTypeReferenceDirectiveNames.set(typeReferenceDirectiveName, resolvedTypeReferenceDirective);\r\n     }\r\n \r\n     /* @internal */\r\n@@ -120,13 +120,13 @@ namespace ts {\n     }\r\n \r\n     /* @internal */\r\n-    export function hasChangesInResolutions<T>(names: string[], newResolutions: T[], oldResolutions: Map<T>, comparer: (oldResolution: T, newResolution: T) => boolean): boolean {\r\n+    export function hasChangesInResolutions<T>(names: string[], newResolutions: T[], oldResolutions: Map<string, T>, comparer: (oldResolution: T, newResolution: T) => boolean): boolean {\r\n         if (names.length !== newResolutions.length) {\r\n             return false;\r\n         }\r\n         for (let i = 0; i < names.length; i++) {\r\n             const newResolution = newResolutions[i];\r\n-            const oldResolution = oldResolutions && oldResolutions[names[i]];\r\n+            const oldResolution = oldResolutions && oldResolutions.get(names[i]);\r\n             const changed =\r\n                 oldResolution\r\n                     ? !newResolution || !comparer(oldResolution, newResolution)\r\n@@ -2201,7 +2201,7 @@ namespace ts {\n \r\n     export function createDiagnosticCollection(): DiagnosticCollection {\r\n         let nonFileDiagnostics: Diagnostic[] = [];\r\n-        const fileDiagnostics = createMap<Diagnostic[]>();\r\n+        const fileDiagnostics = createMap<string, Diagnostic[]>();\r\n \r\n         let diagnosticsModified = false;\r\n         let modificationCount = 0;\r\n@@ -2219,22 +2219,23 @@ namespace ts {\n         }\r\n \r\n         function reattachFileDiagnostics(newFile: SourceFile): void {\r\n-            if (!hasProperty(fileDiagnostics, newFile.fileName)) {\r\n+            const diagnostics = fileDiagnostics.get(newFile.fileName);\r\n+            if (!diagnostics) {\r\n                 return;\r\n             }\r\n \r\n-            for (const diagnostic of fileDiagnostics[newFile.fileName]) {\r\n+            for (const diagnostic of diagnostics) {\r\n                 diagnostic.file = newFile;\r\n             }\r\n         }\r\n \r\n         function add(diagnostic: Diagnostic): void {\r\n             let diagnostics: Diagnostic[];\r\n             if (diagnostic.file) {\r\n-                diagnostics = fileDiagnostics[diagnostic.file.fileName];\r\n+                diagnostics = fileDiagnostics.get(diagnostic.file.fileName);\r\n                 if (!diagnostics) {\r\n                     diagnostics = [];\r\n-                    fileDiagnostics[diagnostic.file.fileName] = diagnostics;\r\n+                    fileDiagnostics.set(diagnostic.file.fileName, diagnostics);\r\n                 }\r\n             }\r\n             else {\r\n@@ -2254,7 +2255,7 @@ namespace ts {\n         function getDiagnostics(fileName?: string): Diagnostic[] {\r\n             sortAndDeduplicate();\r\n             if (fileName) {\r\n-                return fileDiagnostics[fileName] || [];\r\n+                return fileDiagnostics.get(fileName) || [];\r\n             }\r\n \r\n             const allDiagnostics: Diagnostic[] = [];\r\n@@ -2264,9 +2265,9 @@ namespace ts {\n \r\n             forEach(nonFileDiagnostics, pushDiagnostic);\r\n \r\n-            for (const key in fileDiagnostics) {\r\n-                forEach(fileDiagnostics[key], pushDiagnostic);\r\n-            }\r\n+            fileDiagnostics.forEach(diagnostics => {\r\n+                forEach(diagnostics, pushDiagnostic);\r\n+            });\r\n \r\n             return sortAndDeduplicateDiagnostics(allDiagnostics);\r\n         }\r\n@@ -2279,9 +2280,7 @@ namespace ts {\n             diagnosticsModified = false;\r\n             nonFileDiagnostics = sortAndDeduplicateDiagnostics(nonFileDiagnostics);\r\n \r\n-            for (const key in fileDiagnostics) {\r\n-                fileDiagnostics[key] = sortAndDeduplicateDiagnostics(fileDiagnostics[key]);\r\n-            }\r\n+            updateMapValues(fileDiagnostics, sortAndDeduplicateDiagnostics);\r\n         }\r\n     }\r\n \r\n@@ -2291,7 +2290,7 @@ namespace ts {\n     // the map below must be updated. Note that this regexp *does not* include the 'delete' character.\r\n     // There is no reason for this other than that JSON.stringify does not handle it either.\r\n     const escapedCharsRegExp = /[\\\\\\\"\\u0000-\\u001f\\t\\v\\f\\b\\r\\n\\u2028\\u2029\\u0085]/g;\r\n-    const escapedCharsMap = createMap({\r\n+    const escapedCharsMap = mapOfMapLike({\r\n         \"\\0\": \"\\\\0\",\r\n         \"\\t\": \"\\\\t\",\r\n         \"\\v\": \"\\\\v\",\r\n@@ -2318,7 +2317,7 @@ namespace ts {\n         return s;\r\n \r\n         function getReplacement(c: string) {\r\n-            return escapedCharsMap[c] || get16BitUnicodeEscapeSequence(c.charCodeAt(0));\r\n+            return escapedCharsMap.get(c) || get16BitUnicodeEscapeSequence(c.charCodeAt(0));\r\n         }\r\n     }\r\n \r\n@@ -3350,18 +3349,19 @@ namespace ts {\n         return false;\r\n     }\r\n \r\n-    const syntaxKindCache = createMap<string>();\r\n+    const syntaxKindCache = createMap<SyntaxKind, string>();\r\n \r\n     export function formatSyntaxKind(kind: SyntaxKind): string {\r\n         const syntaxKindEnum = (<any>ts).SyntaxKind;\r\n         if (syntaxKindEnum) {\r\n-            if (syntaxKindCache[kind]) {\r\n-                return syntaxKindCache[kind];\r\n+            const cached = syntaxKindCache.get(kind);\r\n+            if (cached !== undefined) {\r\n+                return cached;\r\n             }\r\n \r\n             for (const name in syntaxKindEnum) {\r\n                 if (syntaxKindEnum[name] === kind) {\r\n-                    return syntaxKindCache[kind] = kind.toString() + \" (\" + name + \")\";\r\n+                    return setAndReturn(syntaxKindCache, kind, `${kind}(${name})`);\r\n                 }\r\n             }\r\n         }\r\n@@ -3498,18 +3498,18 @@ namespace ts {\n \r\n     export interface ExternalModuleInfo {\r\n         externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[]; // imports of other external modules\r\n-        exportSpecifiers: Map<ExportSpecifier[]>; // export specifiers by name\r\n-        exportedBindings: Map<Identifier[]>; // exported names of local declarations\r\n+        exportSpecifiers: Map<string, ExportSpecifier[]>; // export specifiers by name\r\n+        exportedBindings: Map<number, Identifier[]>; // exported names of local declarations\r\n         exportedNames: Identifier[]; // all exported names local to module\r\n         exportEquals: ExportAssignment | undefined; // an export= declaration if one was present\r\n         hasExportStarsToExportValues: boolean; // whether this module contains export*\r\n     }\r\n \r\n     export function collectExternalModuleInfo(sourceFile: SourceFile, resolver: EmitResolver): ExternalModuleInfo {\r\n         const externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[] = [];\r\n-        const exportSpecifiers = createMap<ExportSpecifier[]>();\r\n-        const exportedBindings = createMap<Identifier[]>();\r\n-        const uniqueExports = createMap<Identifier>();\r\n+        const exportSpecifiers = createMap<string, ExportSpecifier[]>();\r\n+        const exportedBindings = createMap<number, Identifier[]>();\r\n+        const uniqueExports = createMap<string, Identifier>();\r\n         let hasExportDefault = false;\r\n         let exportEquals: ExportAssignment = undefined;\r\n         let hasExportStarsToExportValues = false;\r\n@@ -3546,7 +3546,7 @@ namespace ts {\n                     else {\r\n                         // export { x, y }\r\n                         for (const specifier of (<ExportDeclaration>node).exportClause.elements) {\r\n-                            if (!uniqueExports[specifier.name.text]) {\r\n+                            if (!uniqueExports.has(specifier.name.text)) {\r\n                                 const name = specifier.propertyName || specifier.name;\r\n                                 multiMapAdd(exportSpecifiers, name.text, specifier);\r\n \r\n@@ -3557,7 +3557,7 @@ namespace ts {\n                                     multiMapAdd(exportedBindings, getOriginalNodeId(decl), specifier.name);\r\n                                 }\r\n \r\n-                                uniqueExports[specifier.name.text] = specifier.name;\r\n+                                uniqueExports.set(specifier.name.text, specifier.name);\r\n                             }\r\n                         }\r\n                     }\r\n@@ -3590,9 +3590,9 @@ namespace ts {\n                         else {\r\n                             // export function x() { }\r\n                             const name = (<FunctionDeclaration>node).name;\r\n-                            if (!uniqueExports[name.text]) {\r\n+                            if (!uniqueExports.has(name.text)) {\r\n                                 multiMapAdd(exportedBindings, getOriginalNodeId(node), name);\r\n-                                uniqueExports[name.text] = name;\r\n+                                uniqueExports.set(name.text, name);\r\n                             }\r\n                         }\r\n                     }\r\n@@ -3610,9 +3610,9 @@ namespace ts {\n                         else {\r\n                             // export class x { }\r\n                             const name = (<ClassDeclaration>node).name;\r\n-                            if (!uniqueExports[name.text]) {\r\n+                            if (!uniqueExports.has(name.text)) {\r\n                                 multiMapAdd(exportedBindings, getOriginalNodeId(node), name);\r\n-                                uniqueExports[name.text] = name;\r\n+                                uniqueExports.set(name.text, name);\r\n                             }\r\n                         }\r\n                     }\r\n@@ -3621,14 +3621,14 @@ namespace ts {\n         }\r\n \r\n         let exportedNames: Identifier[];\r\n-        for (const key in uniqueExports) {\r\n-            exportedNames = ts.append(exportedNames, uniqueExports[key]);\r\n-        }\r\n+        uniqueExports.forEach(exported => {\r\n+            exportedNames = ts.append(exportedNames, exported);\r\n+        });\r\n \r\n         return { externalImports, exportSpecifiers, exportEquals, hasExportStarsToExportValues, exportedBindings, exportedNames };\r\n     }\r\n \r\n-    function collectExportedVariableInfo(decl: VariableDeclaration | BindingElement, uniqueExports: Map<Identifier>) {\r\n+    function collectExportedVariableInfo(decl: VariableDeclaration | BindingElement, uniqueExports: Map<string, Identifier>) {\r\n         if (isBindingPattern(decl.name)) {\r\n             for (const element of decl.name.elements) {\r\n                 if (!isOmittedExpression(element)) {\r\n@@ -3637,8 +3637,8 @@ namespace ts {\n             }\r\n         }\r\n         else if (!isGeneratedIdentifier(decl.name)) {\r\n-            if (!uniqueExports[decl.name.text]) {\r\n-                uniqueExports[decl.name.text] = decl.name;\r\n+            if (!uniqueExports.has(decl.name.text)) {\r\n+                uniqueExports.set(decl.name.text, decl.name);\r\n             }\r\n         }\r\n     }\r"},{"sha":"fb1c572f08241f4de5fcb4cbb3a003727daa7b3c","filename":"src/compiler/visitor.ts","status":"modified","additions":27,"deletions":27,"changes":54,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fvisitor.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fcompiler%2Fvisitor.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fcompiler%2Fvisitor.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -46,54 +46,54 @@ namespace ts {\n      *       supplant the existing `forEachChild` implementation if performance is not\r\n      *       significantly impacted.\r\n      */\r\n-    const nodeEdgeTraversalMap = createMap<NodeTraversalPath>({\r\n-        [SyntaxKind.QualifiedName]: [\r\n+    const nodeEdgeTraversalMap = createMap<SyntaxKind, NodeTraversalPath>([\r\n+        [SyntaxKind.QualifiedName, [\r\n             { name: \"left\", test: isEntityName },\r\n             { name: \"right\", test: isIdentifier }\r\n-        ],\r\n-        [SyntaxKind.Decorator]: [\r\n+        ]],\r\n+        [SyntaxKind.Decorator, [\r\n             { name: \"expression\", test: isLeftHandSideExpression }\r\n-        ],\r\n-        [SyntaxKind.TypeAssertionExpression]: [\r\n+        ]],\r\n+        [SyntaxKind.TypeAssertionExpression, [\r\n             { name: \"type\", test: isTypeNode },\r\n             { name: \"expression\", test: isUnaryExpression }\r\n-        ],\r\n-        [SyntaxKind.AsExpression]: [\r\n+        ]],\r\n+        [SyntaxKind.AsExpression, [\r\n             { name: \"expression\", test: isExpression },\r\n             { name: \"type\", test: isTypeNode }\r\n-        ],\r\n-        [SyntaxKind.NonNullExpression]: [\r\n+        ]],\r\n+        [SyntaxKind.NonNullExpression, [\r\n             { name: \"expression\", test: isLeftHandSideExpression }\r\n-        ],\r\n-        [SyntaxKind.EnumDeclaration]: [\r\n+        ]],\r\n+        [SyntaxKind.EnumDeclaration, [\r\n             { name: \"decorators\", test: isDecorator },\r\n             { name: \"modifiers\", test: isModifier },\r\n             { name: \"name\", test: isIdentifier },\r\n             { name: \"members\", test: isEnumMember }\r\n-        ],\r\n-        [SyntaxKind.ModuleDeclaration]: [\r\n+        ]],\r\n+        [SyntaxKind.ModuleDeclaration, [\r\n             { name: \"decorators\", test: isDecorator },\r\n             { name: \"modifiers\", test: isModifier },\r\n             { name: \"name\", test: isModuleName },\r\n             { name: \"body\", test: isModuleBody }\r\n-        ],\r\n-        [SyntaxKind.ModuleBlock]: [\r\n+        ]],\r\n+        [SyntaxKind.ModuleBlock, [\r\n             { name: \"statements\", test: isStatement }\r\n-        ],\r\n-        [SyntaxKind.ImportEqualsDeclaration]: [\r\n+        ]],\r\n+        [SyntaxKind.ImportEqualsDeclaration, [\r\n             { name: \"decorators\", test: isDecorator },\r\n             { name: \"modifiers\", test: isModifier },\r\n             { name: \"name\", test: isIdentifier },\r\n             { name: \"moduleReference\", test: isModuleReference }\r\n-        ],\r\n-        [SyntaxKind.ExternalModuleReference]: [\r\n+        ]],\r\n+        [SyntaxKind.ExternalModuleReference, [\r\n             { name: \"expression\", test: isExpression, optional: true }\r\n-        ],\r\n-        [SyntaxKind.EnumMember]: [\r\n+        ]],\r\n+        [SyntaxKind.EnumMember, [\r\n             { name: \"name\", test: isPropertyName },\r\n             { name: \"initializer\", test: isExpression, optional: true, parenthesize: parenthesizeExpressionForList }\r\n-        ]\r\n-    });\r\n+        ]]\r\n+    ]);\r\n \r\n     function reduceNode<T>(node: Node, f: (memo: T, node: Node) => T, initial: T) {\r\n         return node ? f(initial, node) : initial;\r\n@@ -520,7 +520,7 @@ namespace ts {\n                 break;\r\n \r\n             default:\r\n-                const edgeTraversalPath = nodeEdgeTraversalMap[kind];\r\n+                const edgeTraversalPath = nodeEdgeTraversalMap.get(kind);\r\n                 if (edgeTraversalPath) {\r\n                     for (const edge of edgeTraversalPath) {\r\n                         const value = (<MapLike<any>>node)[edge.name];\r\n@@ -1142,10 +1142,10 @@ namespace ts {\n \r\n             default:\r\n                 let updated: Node & MapLike<any>;\r\n-                const edgeTraversalPath = nodeEdgeTraversalMap[kind];\r\n+                const edgeTraversalPath = nodeEdgeTraversalMap.get(kind);\r\n                 if (edgeTraversalPath) {\r\n                     for (const edge of edgeTraversalPath) {\r\n-                        const value = <Node | NodeArray<Node>>(<Node & Map<any>>node)[edge.name];\r\n+                        const value = <Node | NodeArray<Node>>(<Node & MapLike<any>>node)[edge.name];\r\n                         if (value !== undefined) {\r\n                             const visited = isArray(value)\r\n                                 ? visitNodes(value, visitor, edge.test, 0, value.length, edge.parenthesize, node)\r"},{"sha":"88181d5edd27bf43ac6747da40ebffd343f1ca49","filename":"src/harness/fourslash.ts","status":"modified","additions":25,"deletions":22,"changes":47,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2Ffourslash.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2Ffourslash.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fharness%2Ffourslash.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -86,7 +86,7 @@ namespace FourSlash {\n \r\n     export import IndentStyle = ts.IndentStyle;\r\n \r\n-    const entityMap = ts.createMap({\r\n+    const entityMap = ts.mapOfMapLike({\r\n         \"&\": \"&amp;\",\r\n         \"\\\"\": \"&quot;\",\r\n         \"'\": \"&#39;\",\r\n@@ -96,7 +96,7 @@ namespace FourSlash {\n     });\r\n \r\n     export function escapeXmlAttributeValue(s: string) {\r\n-        return s.replace(/[&<>\"'\\/]/g, ch => entityMap[ch]);\r\n+        return s.replace(/[&<>\"'\\/]/g, ch => entityMap.get(ch));\r\n     }\r\n \r\n     // Name of testcase metadata including ts.CompilerOptions properties that will be used by globalOptions\r\n@@ -189,7 +189,7 @@ namespace FourSlash {\n \r\n         public formatCodeSettings: ts.FormatCodeSettings;\r\n \r\n-        private inputFiles = ts.createMap<string>();  // Map between inputFile's fileName and its content for easily looking up when resolving references\r\n+        private inputFiles = ts.createMap<string, string>();  // Map between inputFile's fileName and its content for easily looking up when resolving references\r\n \r\n         private static getDisplayPartsJson(displayParts: ts.SymbolDisplayPart[]) {\r\n             let result = \"\";\r\n@@ -222,7 +222,7 @@ namespace FourSlash {\n             }\r\n \r\n             function tryAdd(path: string) {\r\n-                const inputFile = inputFiles[path];\r\n+                const inputFile = inputFiles.get(path);\r\n                 if (inputFile && !Harness.isDefaultLibraryFile(path)) {\r\n                     languageServiceAdapterHost.addScript(path, inputFile, /*isRootFile*/ true);\r\n                     return true;\r\n@@ -256,7 +256,7 @@ namespace FourSlash {\n \r\n             ts.forEach(testData.files, file => {\r\n                 // Create map between fileName and its content for easily looking up when resolveReference flag is specified\r\n-                this.inputFiles[file.fileName] = file.content;\r\n+                this.inputFiles.set(file.fileName, file.content);\r\n \r\n                 if (ts.getBaseFileName(file.fileName).toLowerCase() === \"tsconfig.json\") {\r\n                     const configJson = ts.parseConfigFileTextToJson(file.fileName, file.content);\r\n@@ -322,11 +322,11 @@ namespace FourSlash {\n             }\r\n             else {\r\n                 // resolveReference file-option is not specified then do not resolve any files and include all inputFiles\r\n-                for (const fileName in this.inputFiles) {\r\n+                this.inputFiles.forEach((inputFile, fileName) => {\r\n                     if (!Harness.isDefaultLibraryFile(fileName)) {\r\n-                        this.languageServiceAdapterHost.addScript(fileName, this.inputFiles[fileName], /*isRootFile*/ true);\r\n+                        this.languageServiceAdapterHost.addScript(fileName, inputFile, /*isRootFile*/ true);\r\n                     }\r\n-                }\r\n+                });\r\n                 this.languageServiceAdapterHost.addScript(Harness.Compiler.defaultLibFileName,\r\n                     Harness.Compiler.getDefaultLibrarySourceFile().text, /*isRootFile*/ false);\r\n             }\r\n@@ -674,13 +674,11 @@ namespace FourSlash {\n \r\n         public noItemsWithSameNameButDifferentKind(): void {\r\n             const completions = this.getCompletionListAtCaret();\r\n-            const uniqueItems = ts.createMap<string>();\r\n+            const uniqueItems = ts.createMap<string, string>();\r\n             for (const item of completions.entries) {\r\n-                if (!(item.name in uniqueItems)) {\r\n-                    uniqueItems[item.name] = item.kind;\r\n-                }\r\n-                else {\r\n-                    assert.equal(item.kind, uniqueItems[item.name], `Items should have the same kind, got ${item.kind} and ${uniqueItems[item.name]}`);\r\n+                if (!ts.setIfNotSet(uniqueItems, item.name, item.kind)) {\r\n+                    const uniqueItem = uniqueItems.get(item.name);\r\n+                    assert.equal(item.kind, uniqueItem, `Items should have the same kind, got ${item.kind} and ${uniqueItem}`);\r\n                 }\r\n             }\r\n         }\r\n@@ -858,7 +856,7 @@ namespace FourSlash {\n         }\r\n \r\n         public verifyRangesWithSameTextReferenceEachOther() {\r\n-            ts.forEachProperty(this.rangesByText(), ranges => this.verifyRangesReferenceEachOther(ranges));\r\n+            this.rangesByTextMap().forEach(ranges => this.verifyRangesReferenceEachOther(ranges));\r\n         }\r\n \r\n         public verifyDisplayPartsOfReferencedSymbol(expected: ts.SymbolDisplayPart[]) {\r\n@@ -934,7 +932,8 @@ namespace FourSlash {\n         }\r\n \r\n         public verifyQuickInfos(namesAndTexts: { [name: string]: string | [string, string] }) {\r\n-            ts.forEachProperty(ts.createMap(namesAndTexts), (text, name) => {\r\n+            for (const name in namesAndTexts) {\r\n+                const text = namesAndTexts[name];\r\n                 if (text instanceof Array) {\r\n                     assert(text.length === 2);\r\n                     const [expectedText, expectedDocumentation] = text;\r\n@@ -943,7 +942,7 @@ namespace FourSlash {\n                 else {\r\n                     this.verifyQuickInfoAt(name, text);\r\n                 }\r\n-            });\r\n+            }\r\n         }\r\n \r\n         public verifyQuickInfoString(expectedText: string, expectedDocumentation?: string) {\r\n@@ -1777,15 +1776,19 @@ namespace FourSlash {\n             return this.testData.ranges;\r\n         }\r\n \r\n-        public rangesByText(): ts.Map<Range[]> {\r\n-            const result = ts.createMap<Range[]>();\r\n+        private rangesByTextMap(): ts.Map<string, Range[]> {\r\n+            const result = ts.createMap<string, Range[]>();\r\n             for (const range of this.getRanges()) {\r\n                 const text = this.rangeText(range);\r\n                 ts.multiMapAdd(result, text, range);\r\n             }\r\n             return result;\r\n         }\r\n \r\n+        public rangesByText(): ts.MapLike<Range[]> {\r\n+            return ts.mapLikeOfMap(this.rangesByTextMap());\r\n+        }\r\n+\r\n         private rangeText({fileName, start, end}: Range): string {\r\n             return this.getFileContent(fileName).slice(start, end);\r\n         }\r\n@@ -2066,7 +2069,7 @@ namespace FourSlash {\n \r\n         public verifyBraceCompletionAtPosition(negative: boolean, openingBrace: string) {\r\n \r\n-            const openBraceMap = ts.createMap<ts.CharacterCodes>({\r\n+            const openBraceMap = ts.mapOfMapLike<ts.CharacterCodes>({\r\n                 \"(\": ts.CharacterCodes.openParen,\r\n                 \"{\": ts.CharacterCodes.openBrace,\r\n                 \"[\": ts.CharacterCodes.openBracket,\r\n@@ -2076,7 +2079,7 @@ namespace FourSlash {\n                 \"<\": ts.CharacterCodes.lessThan\r\n             });\r\n \r\n-            const charCode = openBraceMap[openingBrace];\r\n+            const charCode = openBraceMap.get(openingBrace);\r\n \r\n             if (!charCode) {\r\n                 this.raiseError(`Invalid openingBrace '${openingBrace}' specified.`);\r\n@@ -2951,7 +2954,7 @@ namespace FourSlashInterface {\n             return this.state.getRanges();\r\n         }\r\n \r\n-        public rangesByText(): ts.Map<FourSlash.Range[]> {\r\n+        public rangesByText(): ts.MapLike<FourSlash.Range[]> {\r\n             return this.state.rangesByText();\r\n         }\r\n \r"},{"sha":"a029dfc38014d73849acd720c3cd040eec28b802","filename":"src/harness/harness.ts","status":"modified","additions":15,"deletions":15,"changes":30,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2Fharness.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2Fharness.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fharness%2Fharness.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -922,19 +922,19 @@ namespace Harness {\n         export const defaultLibFileName = \"lib.d.ts\";\r\n         export const es2015DefaultLibFileName = \"lib.es2015.d.ts\";\r\n \r\n-        const libFileNameSourceFileMap = ts.createMap<ts.SourceFile>({\r\n-            [defaultLibFileName]: createSourceFileAndAssertInvariants(defaultLibFileName, IO.readFile(libFolder + \"lib.es5.d.ts\"), /*languageVersion*/ ts.ScriptTarget.Latest)\r\n-        });\r\n+        const libFileNameSourceFileMap = ts.createMap<string, ts.SourceFile>([[\r\n+            defaultLibFileName,\r\n+            createSourceFileAndAssertInvariants(defaultLibFileName, IO.readFile(libFolder + \"lib.es5.d.ts\"), /*languageVersion*/ ts.ScriptTarget.Latest)\r\n+        ]]);\r\n \r\n         export function getDefaultLibrarySourceFile(fileName = defaultLibFileName): ts.SourceFile {\r\n             if (!isDefaultLibraryFile(fileName)) {\r\n                 return undefined;\r\n             }\r\n \r\n-            if (!libFileNameSourceFileMap[fileName]) {\r\n-                libFileNameSourceFileMap[fileName] = createSourceFileAndAssertInvariants(fileName, IO.readFile(libFolder + fileName), ts.ScriptTarget.Latest);\r\n-            }\r\n-            return libFileNameSourceFileMap[fileName];\r\n+            const sourceFile = libFileNameSourceFileMap.get(fileName);\r\n+            return sourceFile || ts.setAndReturn(libFileNameSourceFileMap, fileName,\r\n+                createSourceFileAndAssertInvariants(fileName, IO.readFile(libFolder + fileName), ts.ScriptTarget.Latest));\r\n         }\r\n \r\n         export function getDefaultLibFileName(options: ts.CompilerOptions): string {\r\n@@ -1086,16 +1086,16 @@ namespace Harness {\n             { name: \"symlink\", type: \"string\" }\r\n         ];\r\n \r\n-        let optionsIndex: ts.Map<ts.CommandLineOption>;\r\n+        let optionsIndex: ts.Map<string, ts.CommandLineOption>;\r\n         function getCommandLineOption(name: string): ts.CommandLineOption {\r\n             if (!optionsIndex) {\r\n-                optionsIndex = ts.createMap<ts.CommandLineOption>();\r\n+                optionsIndex = ts.createMap<string, ts.CommandLineOption>();\r\n                 const optionDeclarations = harnessOptionDeclarations.concat(ts.optionDeclarations);\r\n                 for (const option of optionDeclarations) {\r\n-                    optionsIndex[option.name.toLowerCase()] = option;\r\n+                    optionsIndex.set(option.name.toLowerCase(), option);\r\n                 }\r\n             }\r\n-            return optionsIndex[name.toLowerCase()];\r\n+            return optionsIndex.get(name.toLowerCase());\r\n         }\r\n \r\n         export function setCompilerOptionsFromHarnessSetting(settings: Harness.TestCaseParser.CompilerSettings, options: ts.CompilerOptions & HarnessOptions): void {\r\n@@ -1452,10 +1452,10 @@ namespace Harness {\n \r\n             const fullWalker = new TypeWriterWalker(program, /*fullTypeCheck*/ true);\r\n \r\n-            const fullResults = ts.createMap<TypeWriterResult[]>();\r\n+            const fullResults = ts.createMap<string, TypeWriterResult[]>();\r\n \r\n             for (const sourceFile of allFiles) {\r\n-                fullResults[sourceFile.unitName] = fullWalker.getTypeAndSymbols(sourceFile.unitName);\r\n+                fullResults.set(sourceFile.unitName, fullWalker.getTypeAndSymbols(sourceFile.unitName));\r\n             }\r\n \r\n             // Produce baselines.  The first gives the types for all expressions.\r\n@@ -1502,13 +1502,13 @@ namespace Harness {\n                 Harness.Baseline.runBaseline(outputFileName, () => fullBaseLine, opts);\r\n             }\r\n \r\n-            function generateBaseLine(typeWriterResults: ts.Map<TypeWriterResult[]>, isSymbolBaseline: boolean): string {\r\n+            function generateBaseLine(typeWriterResults: ts.Map<string, TypeWriterResult[]>, isSymbolBaseline: boolean): string {\r\n                 const typeLines: string[] = [];\r\n                 const typeMap: { [fileName: string]: { [lineNum: number]: string[]; } } = {};\r\n \r\n                 allFiles.forEach(file => {\r\n                     const codeLines = file.content.split(\"\\n\");\r\n-                    typeWriterResults[file.unitName].forEach(result => {\r\n+                    typeWriterResults.get(file.unitName).forEach(result => {\r\n                         if (isSymbolBaseline && !result.symbol) {\r\n                             return;\r\n                         }\r"},{"sha":"ee7bc43ac2aec3131189b324822e08e4db527015","filename":"src/harness/harnessLanguageService.ts","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2FharnessLanguageService.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2FharnessLanguageService.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fharness%2FharnessLanguageService.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -262,7 +262,7 @@ namespace Harness.LanguageService {\n                 this.getModuleResolutionsForFile = (fileName) => {\r\n                     const scriptInfo = this.getScriptInfo(fileName);\r\n                     const preprocessInfo = ts.preProcessFile(scriptInfo.content, /*readImportFiles*/ true);\r\n-                    const imports = ts.createMap<string>();\r\n+                    const imports: ts.MapLike<string> = {};\r\n                     for (const module of preprocessInfo.importedFiles) {\r\n                         const resolutionInfo = ts.resolveModuleName(module.fileName, fileName, compilerOptions, moduleResolutionHost);\r\n                         if (resolutionInfo.resolvedModule) {\r\n@@ -275,7 +275,7 @@ namespace Harness.LanguageService {\n                     const scriptInfo = this.getScriptInfo(fileName);\r\n                     if (scriptInfo) {\r\n                         const preprocessInfo = ts.preProcessFile(scriptInfo.content, /*readImportFiles*/ false);\r\n-                        const resolutions = ts.createMap<ts.ResolvedTypeReferenceDirective>();\r\n+                        const resolutions: ts.MapLike<ts.ResolvedTypeReferenceDirective> = {};\r\n                         const settings = this.nativeHost.getCompilationSettings();\r\n                         for (const typeReferenceDirective of preprocessInfo.typeReferenceDirectives) {\r\n                             const resolutionInfo = ts.resolveTypeReferenceDirective(typeReferenceDirective.fileName, fileName, settings, moduleResolutionHost);\r"},{"sha":"a4cd4d36b39da640f7b5870a3876592fcec4f489","filename":"src/harness/loggedIO.ts","status":"modified","additions":4,"deletions":6,"changes":10,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2FloggedIO.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2FloggedIO.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fharness%2FloggedIO.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -91,13 +91,11 @@ namespace Playback {\n     }\r\n \r\n     function memoize<T>(func: (s: string) => T): Memoized<T> {\r\n-        let lookup: { [s: string]: T } = {};\r\n-        const run: Memoized<T> = <Memoized<T>>((s: string) => {\r\n-            if (lookup.hasOwnProperty(s)) return lookup[s];\r\n-            return lookup[s] = func(s);\r\n-        });\r\n+        const lookup = ts.createMap<string, T>();\r\n+        const run: Memoized<T> = <Memoized<T>>((s: string) =>\r\n+            ts.getOrUpdateAndAllowUndefined(lookup, s, func));\r\n         run.reset = () => {\r\n-            lookup = undefined;\r\n+            lookup.clear();\r\n         };\r\n \r\n         return run;\r"},{"sha":"99c395f16996be9b9a381ea5260cdb365b8892bb","filename":"src/harness/projectsRunner.ts","status":"modified","additions":12,"deletions":9,"changes":21,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2FprojectsRunner.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2FprojectsRunner.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fharness%2FprojectsRunner.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -256,17 +256,20 @@ class ProjectRunner extends RunnerBase {\n                 // Set the values specified using json\r\n                 const optionNameMap = ts.arrayToMap(ts.optionDeclarations, option => option.name);\r\n                 for (const name in testCase) {\r\n-                    if (name !== \"mapRoot\" && name !== \"sourceRoot\" && name in optionNameMap) {\r\n-                        const option = optionNameMap[name];\r\n-                        const optType = option.type;\r\n-                        let value = <any>testCase[name];\r\n-                        if (typeof optType !== \"string\") {\r\n-                            const key = value.toLowerCase();\r\n-                            if (key in optType) {\r\n-                                value = optType[key];\r\n+                    if (name !== \"mapRoot\" && name !== \"sourceRoot\") {\r\n+                        const option = optionNameMap.get(name);\r\n+                        if (option !== undefined) {\r\n+                            const optType = option.type;\r\n+                            let value = <any>testCase[name];\r\n+                            if (typeof optType !== \"string\") {\r\n+                                const key = value.toLowerCase();\r\n+                                const translation = optType.get(key);\r\n+                                if (translation !== undefined) {\r\n+                                    value = translation;\r\n+                                }\r\n                             }\r\n+                            compilerOptions[option.name] = value;\r\n                         }\r\n-                        compilerOptions[option.name] = value;\r\n                     }\r\n                 }\r\n \r"},{"sha":"1bfff0bf6a920a2b5976a76caf57c36f86c66fa4","filename":"src/harness/unittests/cachingInServerLSHost.ts","status":"modified","additions":12,"deletions":11,"changes":23,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2Funittests%2FcachingInServerLSHost.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2Funittests%2FcachingInServerLSHost.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fharness%2Funittests%2FcachingInServerLSHost.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -6,24 +6,25 @@ namespace ts {\n         content: string;\r\n     }\r\n \r\n-    function createDefaultServerHost(fileMap: Map<File>): server.ServerHost {\r\n-        const existingDirectories = createMap<boolean>();\r\n-        for (const name in fileMap) {\r\n+    function createDefaultServerHost(fileMap: Map<string, File>): server.ServerHost {\r\n+        const existingDirectories = createSet();\r\n+        forEachKeyInMap(fileMap, name => {\r\n             let dir = getDirectoryPath(name);\r\n             let previous: string;\r\n             do {\r\n-                existingDirectories[dir] = true;\r\n+                existingDirectories.add(dir);\r\n                 previous = dir;\r\n                 dir = getDirectoryPath(dir);\r\n             } while (dir !== previous);\r\n-        }\r\n+        });\r\n         return {\r\n             args: <string[]>[],\r\n             newLine: \"\\r\\n\",\r\n             useCaseSensitiveFileNames: false,\r\n             write: noop,\r\n             readFile: (path: string): string => {\r\n-                return path in fileMap ? fileMap[path].content : undefined;\r\n+                const file = fileMap.get(path);\r\n+                return file !== undefined ? file.content : undefined;\r\n             },\r\n             writeFile: (_path: string, _data: string, _writeByteOrderMark?: boolean) => {\r\n                 return ts.notImplemented();\r\n@@ -32,10 +33,10 @@ namespace ts {\n                 return ts.notImplemented();\r\n             },\r\n             fileExists: (path: string): boolean => {\r\n-                return path in fileMap;\r\n+                return fileMap.has(path);\r\n             },\r\n             directoryExists: (path: string): boolean => {\r\n-                return existingDirectories[path] || false;\r\n+                return existingDirectories.has(path);\r\n             },\r\n             createDirectory: noop,\r\n             getExecutingFilePath: (): string => {\r\n@@ -98,7 +99,7 @@ namespace ts {\n                 content: `foo()`\r\n             };\r\n \r\n-            const serverHost = createDefaultServerHost(createMap({ [root.name]: root, [imported.name]: imported }));\r\n+            const serverHost = createDefaultServerHost(mapOfMapLike({ [root.name]: root, [imported.name]: imported }));\r\n             const { project, rootScriptInfo } = createProject(root.name, serverHost);\r\n \r\n             // ensure that imported file was found\r\n@@ -182,7 +183,7 @@ namespace ts {\n                 content: `export var y = 1`\r\n             };\r\n \r\n-            const fileMap = createMap({ [root.name]: root });\r\n+            const fileMap = mapOfMapLike({ [root.name]: root });\r\n             const serverHost = createDefaultServerHost(fileMap);\r\n             const originalFileExists = serverHost.fileExists;\r\n \r\n@@ -206,7 +207,7 @@ namespace ts {\n             assert.isTrue(typeof diags[0].messageText === \"string\" && ((<string>diags[0].messageText).indexOf(\"Cannot find module\") === 0), \"should be 'cannot find module' message\");\r\n \r\n             // assert that import will success once file appear on disk\r\n-            fileMap[imported.name] = imported;\r\n+            fileMap.set(imported.name, imported);\r\n             fileExistsCalledForBar = false;\r\n             rootScriptInfo.editContent(0, root.content.length, `import {y} from \"bar\"`);\r\n \r"},{"sha":"5f07e46cbcfcacc7f01c65c8917264e99292be45","filename":"src/harness/unittests/moduleResolution.ts","status":"modified","additions":34,"deletions":30,"changes":64,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2Funittests%2FmoduleResolution.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2Funittests%2FmoduleResolution.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fharness%2Funittests%2FmoduleResolution.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -32,11 +32,11 @@ namespace ts {\n         const map = arrayToMap(files, f => f.name);\r\n \r\n         if (hasDirectoryExists) {\r\n-            const directories = createMap<string>();\r\n+            const directories = createSet();\r\n             for (const f of files) {\r\n                 let name = getDirectoryPath(f.name);\r\n                 while (true) {\r\n-                    directories[name] = name;\r\n+                    directories.add(name);\r\n                     const baseName = getDirectoryPath(name);\r\n                     if (baseName === name) {\r\n                         break;\r\n@@ -46,20 +46,19 @@ namespace ts {\n             }\r\n             return {\r\n                 readFile,\r\n-                directoryExists: path => {\r\n-                    return path in directories;\r\n-                },\r\n+                directoryExists: path => directories.has(path),\r\n                 fileExists: path => {\r\n-                    assert.isTrue(getDirectoryPath(path) in directories, `'fileExists' '${path}' request in non-existing directory`);\r\n-                    return path in map;\r\n+                    assert.isTrue(directories.has(getDirectoryPath(path)), `'fileExists' '${path}' request in non-existing directory`);\r\n+                    return map.has(path);\r\n                 }\r\n             };\r\n         }\r\n         else {\r\n-            return { readFile, fileExists: path => path in map, };\r\n+            return { readFile, fileExists: path => map.has(path) };\r\n         }\r\n         function readFile(path: string): string {\r\n-            return path in map ? map[path].content : undefined;\r\n+            const file = map.get(path);\r\n+            return file !== undefined ? file.content : undefined;\r\n         }\r\n     }\r\n \r\n@@ -315,12 +314,13 @@ namespace ts {\n     });\r\n \r\n     describe(\"Module resolution - relative imports\", () => {\r\n-        function test(files: Map<string>, currentDirectory: string, rootFiles: string[], expectedFilesCount: number, relativeNamesToCheck: string[]) {\r\n+        function test(files: Map<string, string>, currentDirectory: string, rootFiles: string[], expectedFilesCount: number, relativeNamesToCheck: string[]) {\r\n             const options: CompilerOptions = { module: ModuleKind.CommonJS };\r\n             const host: CompilerHost = {\r\n                 getSourceFile: (fileName: string, languageVersion: ScriptTarget) => {\r\n                     const path = normalizePath(combinePaths(currentDirectory, fileName));\r\n-                    return path in files ? createSourceFile(fileName, files[path], languageVersion) : undefined;\r\n+                    const file = files.get(path);\r\n+                    return file !== undefined ? createSourceFile(fileName, file, languageVersion) : undefined;\r\n                 },\r\n                 getDefaultLibFileName: () => \"lib.d.ts\",\r\n                 writeFile: notImplemented,\r\n@@ -331,7 +331,7 @@ namespace ts {\n                 useCaseSensitiveFileNames: () => false,\r\n                 fileExists: fileName => {\r\n                     const path = normalizePath(combinePaths(currentDirectory, fileName));\r\n-                    return path in files;\r\n+                    return files.has(path);\r\n                 },\r\n                 readFile: notImplemented\r\n             };\r\n@@ -351,7 +351,7 @@ namespace ts {\n         }\r\n \r\n         it(\"should find all modules\", () => {\r\n-            const files = createMap({\r\n+            const files = mapOfMapLike({\r\n                 \"/a/b/c/first/shared.ts\": `\r\n class A {}\r\n export = A`,\r\n@@ -370,15 +370,15 @@ export = C;\n         });\r\n \r\n         it(\"should find modules in node_modules\", () => {\r\n-            const files = createMap({\r\n+            const files = mapOfMapLike({\r\n                 \"/parent/node_modules/mod/index.d.ts\": \"export var x\",\r\n                 \"/parent/app/myapp.ts\": `import {x} from \"mod\"`\r\n             });\r\n             test(files, \"/parent/app\", [\"myapp.ts\"], 2, []);\r\n         });\r\n \r\n         it(\"should find file referenced via absolute and relative names\", () => {\r\n-            const files = createMap({\r\n+            const files = mapOfMapLike({\r\n                 \"/a/b/c.ts\": `/// <reference path=\"b.ts\"/>`,\r\n                 \"/a/b/b.ts\": \"var x\"\r\n             });\r\n@@ -388,10 +388,10 @@ export = C;\n \r\n     describe(\"Files with different casing\", () => {\r\n         const library = createSourceFile(\"lib.d.ts\", \"\", ScriptTarget.ES5);\r\n-        function test(files: Map<string>, options: CompilerOptions, currentDirectory: string, useCaseSensitiveFileNames: boolean, rootFiles: string[], diagnosticCodes: number[]): void {\r\n+        function test(files: Map<string, string>, options: CompilerOptions, currentDirectory: string, useCaseSensitiveFileNames: boolean, rootFiles: string[], diagnosticCodes: number[]): void {\r\n             const getCanonicalFileName = createGetCanonicalFileName(useCaseSensitiveFileNames);\r\n             if (!useCaseSensitiveFileNames) {\r\n-                files = reduceProperties(files, (files, file, fileName) => (files[getCanonicalFileName(fileName)] = file, files), createMap<string>());\r\n+                files = transformKeys(files, getCanonicalFileName);\r\n             }\r\n \r\n             const host: CompilerHost = {\r\n@@ -400,7 +400,8 @@ export = C;\n                         return library;\r\n                     }\r\n                     const path = getCanonicalFileName(normalizePath(combinePaths(currentDirectory, fileName)));\r\n-                    return path in files ? createSourceFile(fileName, files[path], languageVersion) : undefined;\r\n+                    const file = files.get(path);\r\n+                    return file !== undefined ? createSourceFile(fileName, file, languageVersion) : undefined;\r\n                 },\r\n                 getDefaultLibFileName: () => \"lib.d.ts\",\r\n                 writeFile: notImplemented,\r\n@@ -411,7 +412,7 @@ export = C;\n                 useCaseSensitiveFileNames: () => useCaseSensitiveFileNames,\r\n                 fileExists: fileName => {\r\n                     const path = getCanonicalFileName(normalizePath(combinePaths(currentDirectory, fileName)));\r\n-                    return path in files;\r\n+                    return files.has(path);\r\n                 },\r\n                 readFile: notImplemented\r\n             };\r\n@@ -424,39 +425,39 @@ export = C;\n         }\r\n \r\n         it(\"should succeed when the same file is referenced using absolute and relative names\", () => {\r\n-            const files = createMap({\r\n+            const files = mapOfMapLike({\r\n                 \"/a/b/c.ts\": `/// <reference path=\"d.ts\"/>`,\r\n                 \"/a/b/d.ts\": \"var x\"\r\n             });\r\n             test(files, { module: ts.ModuleKind.AMD },  \"/a/b\", /*useCaseSensitiveFileNames*/ false, [\"c.ts\", \"/a/b/d.ts\"], []);\r\n         });\r\n \r\n         it(\"should fail when two files used in program differ only in casing (tripleslash references)\", () => {\r\n-            const files = createMap({\r\n+            const files = mapOfMapLike({\r\n                 \"/a/b/c.ts\": `/// <reference path=\"D.ts\"/>`,\r\n                 \"/a/b/d.ts\": \"var x\"\r\n             });\r\n             test(files, { module: ts.ModuleKind.AMD, forceConsistentCasingInFileNames: true },  \"/a/b\", /*useCaseSensitiveFileNames*/ false, [\"c.ts\", \"d.ts\"], [1149]);\r\n         });\r\n \r\n         it(\"should fail when two files used in program differ only in casing (imports)\", () => {\r\n-            const files = createMap({\r\n+            const files = mapOfMapLike({\r\n                 \"/a/b/c.ts\": `import {x} from \"D\"`,\r\n                 \"/a/b/d.ts\": \"export var x\"\r\n             });\r\n             test(files, { module: ts.ModuleKind.AMD, forceConsistentCasingInFileNames: true },  \"/a/b\", /*useCaseSensitiveFileNames*/ false, [\"c.ts\", \"d.ts\"], [1149]);\r\n         });\r\n \r\n         it(\"should fail when two files used in program differ only in casing (imports, relative module names)\", () => {\r\n-            const files = createMap({\r\n+            const files = mapOfMapLike({\r\n                 \"moduleA.ts\": `import {x} from \"./ModuleB\"`,\r\n                 \"moduleB.ts\": \"export var x\"\r\n             });\r\n             test(files, { module: ts.ModuleKind.CommonJS, forceConsistentCasingInFileNames: true },  \"\", /*useCaseSensitiveFileNames*/ false, [\"moduleA.ts\", \"moduleB.ts\"], [1149]);\r\n         });\r\n \r\n         it(\"should fail when two files exist on disk that differs only in casing\", () => {\r\n-            const files = createMap({\r\n+            const files = mapOfMapLike({\r\n                 \"/a/b/c.ts\": `import {x} from \"D\"`,\r\n                 \"/a/b/D.ts\": \"export var x\",\r\n                 \"/a/b/d.ts\": \"export var y\"\r\n@@ -465,7 +466,7 @@ export = C;\n         });\r\n \r\n         it(\"should fail when module name in 'require' calls has inconsistent casing\", () => {\r\n-            const files = createMap({\r\n+            const files = mapOfMapLike({\r\n                 \"moduleA.ts\": `import a = require(\"./ModuleC\")`,\r\n                 \"moduleB.ts\": `import a = require(\"./moduleC\")`,\r\n                 \"moduleC.ts\": \"export var x\"\r\n@@ -474,7 +475,7 @@ export = C;\n         });\r\n \r\n         it(\"should fail when module names in 'require' calls has inconsistent casing and current directory has uppercase chars\", () => {\r\n-            const files = createMap({\r\n+            const files = mapOfMapLike({\r\n                 \"/a/B/c/moduleA.ts\": `import a = require(\"./ModuleC\")`,\r\n                 \"/a/B/c/moduleB.ts\": `import a = require(\"./moduleC\")`,\r\n                 \"/a/B/c/moduleC.ts\": \"export var x\",\r\n@@ -486,7 +487,7 @@ import b = require(\"./moduleB\");\n             test(files, { module: ts.ModuleKind.CommonJS, forceConsistentCasingInFileNames: true },  \"/a/B/c\", /*useCaseSensitiveFileNames*/ false, [\"moduleD.ts\"], [1149]);\r\n         });\r\n         it(\"should not fail when module names in 'require' calls has consistent casing and current directory has uppercase chars\", () => {\r\n-            const files = createMap({\r\n+            const files = mapOfMapLike({\r\n                 \"/a/B/c/moduleA.ts\": `import a = require(\"./moduleC\")`,\r\n                 \"/a/B/c/moduleB.ts\": `import a = require(\"./moduleC\")`,\r\n                 \"/a/B/c/moduleC.ts\": \"export var x\",\r\n@@ -1044,16 +1045,19 @@ import b = require(\"./moduleB\");\n             const names = map(files, f => f.name);\r\n             const sourceFiles = arrayToMap(map(files, f => createSourceFile(f.name, f.content, ScriptTarget.ES2015)), f => f.fileName);\r\n             const compilerHost: CompilerHost = {\r\n-                fileExists : fileName => fileName in sourceFiles,\r\n-                getSourceFile: fileName => sourceFiles[fileName],\r\n+                fileExists : fileName => sourceFiles.has(fileName),\r\n+                getSourceFile: fileName => sourceFiles.get(fileName),\r\n                 getDefaultLibFileName: () => \"lib.d.ts\",\r\n                 writeFile: notImplemented,\r\n                 getCurrentDirectory: () => \"/\",\r\n                 getDirectories: () => [],\r\n                 getCanonicalFileName: f => f.toLowerCase(),\r\n                 getNewLine: () => \"\\r\\n\",\r\n                 useCaseSensitiveFileNames: () => false,\r\n-                readFile: fileName => fileName in sourceFiles ? sourceFiles[fileName].text : undefined\r\n+                readFile: fileName => {\r\n+                    const file = sourceFiles.get(fileName);\r\n+                    return file !== undefined ? file.text : undefined;\r\n+                }\r\n             };\r\n             const program1 = createProgram(names, {}, compilerHost);\r\n             const diagnostics1 = program1.getFileProcessingDiagnostics().getDiagnostics();\r"},{"sha":"6a34bbd193c87d98385ef297b9b384cf3ab722c2","filename":"src/harness/unittests/reuseProgramStructure.ts","status":"modified","additions":14,"deletions":13,"changes":27,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2Funittests%2FreuseProgramStructure.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2Funittests%2FreuseProgramStructure.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fharness%2Funittests%2FreuseProgramStructure.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -106,7 +106,7 @@ namespace ts {\n \r\n         return {\r\n             getSourceFile(fileName): SourceFile {\r\n-                return files[fileName];\r\n+                return files.get(fileName);\r\n             },\r\n             getDefaultLibFileName(): string {\r\n                 return \"lib.d.ts\";\r\n@@ -127,9 +127,10 @@ namespace ts {\n             getNewLine(): string {\r\n                 return sys ? sys.newLine : newLine;\r\n             },\r\n-            fileExists: fileName => fileName in files,\r\n+            fileExists: fileName => files.has(fileName),\r\n             readFile: fileName => {\r\n-                return fileName in files ? files[fileName].text : undefined;\r\n+                const file = files.get(fileName);\r\n+                return file !== undefined ? file.text : undefined;\r\n             }\r\n         };\r\n     }\r\n@@ -161,7 +162,7 @@ namespace ts {\n         return false;\r\n     }\r\n \r\n-    function checkCache<T>(caption: string, program: Program, fileName: string, expectedContent: Map<T>, getCache: (f: SourceFile) => Map<T>, entryChecker: (expected: T, original: T) => boolean): void {\r\n+    function checkCache<T>(caption: string, program: Program, fileName: string, expectedContent: Map<string, T>, getCache: (f: SourceFile) => Map<string, T>, entryChecker: (expected: T, original: T) => boolean): void {\r\n         const file = program.getSourceFile(fileName);\r\n         assert.isTrue(file !== undefined, `cannot find file ${fileName}`);\r\n         const cache = getCache(file);\r\n@@ -170,15 +171,15 @@ namespace ts {\n         }\r\n         else {\r\n             assert.isTrue(cache !== undefined, `expected ${caption} to be set`);\r\n-            assert.isTrue(equalOwnProperties(expectedContent, cache, entryChecker), `contents of ${caption} did not match the expected contents.`);\r\n+            assert.isTrue(mapsAreEqual(expectedContent, cache, entryChecker), `contents of ${caption} did not match the expected contents.`);\r\n         }\r\n     }\r\n \r\n-    function checkResolvedModulesCache(program: Program, fileName: string, expectedContent: Map<ResolvedModule>): void {\r\n+    function checkResolvedModulesCache(program: Program, fileName: string, expectedContent: Map<string, ResolvedModule>): void {\r\n         checkCache(\"resolved modules\", program, fileName, expectedContent, f => f.resolvedModules, checkResolvedModule);\r\n     }\r\n \r\n-    function checkResolvedTypeDirectivesCache(program: Program, fileName: string, expectedContent: Map<ResolvedTypeReferenceDirective>): void {\r\n+    function checkResolvedTypeDirectivesCache(program: Program, fileName: string, expectedContent: Map<string, ResolvedTypeReferenceDirective>): void {\r\n         checkCache(\"resolved type directives\", program, fileName, expectedContent, f => f.resolvedTypeReferenceDirectiveNames, checkResolvedTypeDirective);\r\n     }\r\n \r\n@@ -289,7 +290,7 @@ namespace ts {\n             const options: CompilerOptions = { target };\r\n \r\n             const program_1 = newProgram(files, [\"a.ts\"], options);\r\n-            checkResolvedModulesCache(program_1, \"a.ts\", createMap({ \"b\": createResolvedModule(\"b.ts\") }));\r\n+            checkResolvedModulesCache(program_1, \"a.ts\", mapOfMapLike({ \"b\": createResolvedModule(\"b.ts\") }));\r\n             checkResolvedModulesCache(program_1, \"b.ts\", undefined);\r\n \r\n             const program_2 = updateProgram(program_1, [\"a.ts\"], options, files => {\r\n@@ -298,7 +299,7 @@ namespace ts {\n             assert.isTrue(program_1.structureIsReused);\r\n \r\n             // content of resolution cache should not change\r\n-            checkResolvedModulesCache(program_1, \"a.ts\", createMap({ \"b\": createResolvedModule(\"b.ts\") }));\r\n+            checkResolvedModulesCache(program_1, \"a.ts\", mapOfMapLike({ \"b\": createResolvedModule(\"b.ts\") }));\r\n             checkResolvedModulesCache(program_1, \"b.ts\", undefined);\r\n \r\n             // imports has changed - program is not reused\r\n@@ -315,7 +316,7 @@ namespace ts {\n                 files[0].text = files[0].text.updateImportsAndExports(newImports);\r\n             });\r\n             assert.isTrue(!program_3.structureIsReused);\r\n-            checkResolvedModulesCache(program_4, \"a.ts\", createMap({ \"b\": createResolvedModule(\"b.ts\"), \"c\": undefined }));\r\n+            checkResolvedModulesCache(program_4, \"a.ts\", mapOfMapLike({ \"b\": createResolvedModule(\"b.ts\"), \"c\": undefined }));\r\n         });\r\n \r\n         it(\"resolved type directives cache follows type directives\", () => {\r\n@@ -326,7 +327,7 @@ namespace ts {\n             const options: CompilerOptions = { target, typeRoots: [\"/types\"] };\r\n \r\n             const program_1 = newProgram(files, [\"/a.ts\"], options);\r\n-            checkResolvedTypeDirectivesCache(program_1, \"/a.ts\", createMap({ \"typedefs\": { resolvedFileName: \"/types/typedefs/index.d.ts\", primary: true } }));\r\n+            checkResolvedTypeDirectivesCache(program_1, \"/a.ts\", mapOfMapLike({ \"typedefs\": { resolvedFileName: \"/types/typedefs/index.d.ts\", primary: true } }));\r\n             checkResolvedTypeDirectivesCache(program_1, \"/types/typedefs/index.d.ts\", undefined);\r\n \r\n             const program_2 = updateProgram(program_1, [\"/a.ts\"], options, files => {\r\n@@ -335,7 +336,7 @@ namespace ts {\n             assert.isTrue(program_1.structureIsReused);\r\n \r\n             // content of resolution cache should not change\r\n-            checkResolvedTypeDirectivesCache(program_1, \"/a.ts\", createMap({ \"typedefs\": { resolvedFileName: \"/types/typedefs/index.d.ts\", primary: true } }));\r\n+            checkResolvedTypeDirectivesCache(program_1, \"/a.ts\", mapOfMapLike({ \"typedefs\": { resolvedFileName: \"/types/typedefs/index.d.ts\", primary: true } }));\r\n             checkResolvedTypeDirectivesCache(program_1, \"/types/typedefs/index.d.ts\", undefined);\r\n \r\n             // type reference directives has changed - program is not reused\r\n@@ -353,7 +354,7 @@ namespace ts {\n                 files[0].text = files[0].text.updateReferences(newReferences);\r\n             });\r\n             assert.isTrue(!program_3.structureIsReused);\r\n-            checkResolvedTypeDirectivesCache(program_1, \"/a.ts\", createMap({ \"typedefs\": { resolvedFileName: \"/types/typedefs/index.d.ts\", primary: true } }));\r\n+            checkResolvedTypeDirectivesCache(program_1, \"/a.ts\", mapOfMapLike({ \"typedefs\": { resolvedFileName: \"/types/typedefs/index.d.ts\", primary: true } }));\r\n         });\r\n     });\r\n \r"},{"sha":"53f3ec3deb2870b49c272f32dc990388b7f7e07f","filename":"src/harness/unittests/session.ts","status":"modified","additions":10,"deletions":12,"changes":22,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2Funittests%2Fsession.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2Funittests%2Fsession.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fharness%2Funittests%2Fsession.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -159,9 +159,6 @@ namespace ts.server {\n             it(\"should not throw when commands are executed with invalid arguments\", () => {\r\n                 let i = 0;\r\n                 for (const name in CommandNames) {\r\n-                    if (!Object.prototype.hasOwnProperty.call(CommandNames, name)) {\r\n-                        continue;\r\n-                    }\r\n                     const req: protocol.Request = {\r\n                         command: name,\r\n                         seq: i,\r\n@@ -414,15 +411,15 @@ namespace ts.server {\n         class InProcClient {\r\n             private server: InProcSession;\r\n             private seq = 0;\r\n-            private callbacks = createMap<(resp: protocol.Response) => void>();\r\n-            private eventHandlers = createMap<(args: any) => void>();\r\n+            private callbacks = createMap<number, (resp: protocol.Response) => void>();\r\n+            private eventHandlers = createMap<string, (args: any) => void>();\r\n \r\n             handle(msg: protocol.Message): void {\r\n                 if (msg.type === \"response\") {\r\n                     const response = <protocol.Response>msg;\r\n-                    if (response.request_seq in this.callbacks) {\r\n-                        this.callbacks[response.request_seq](response);\r\n-                        delete this.callbacks[response.request_seq];\r\n+                    const callback = tryDelete(this.callbacks, response.request_seq);\r\n+                    if (callback !== undefined) {\r\n+                        callback(response);\r\n                     }\r\n                 }\r\n                 else if (msg.type === \"event\") {\r\n@@ -432,13 +429,14 @@ namespace ts.server {\n             }\r\n \r\n             emit(name: string, args: any): void {\r\n-                if (name in this.eventHandlers) {\r\n-                    this.eventHandlers[name](args);\r\n+                const handler = this.eventHandlers.get(name);\r\n+                if (handler !== undefined) {\r\n+                    handler(args);\r\n                 }\r\n             }\r\n \r\n             on(name: string, handler: (args: any) => void): void {\r\n-                this.eventHandlers[name] = handler;\r\n+                this.eventHandlers.set(name, handler);\r\n             }\r\n \r\n             connect(session: InProcSession): void {\r\n@@ -456,7 +454,7 @@ namespace ts.server {\n                     command,\r\n                     arguments: args\r\n                 });\r\n-                this.callbacks[this.seq] = callback;\r\n+                this.callbacks.set(this.seq, callback);\r\n             }\r\n         };\r\n \r"},{"sha":"8972da33bb1eb8746d62e46bb1f6cbe1f21c7210","filename":"src/harness/unittests/tsserverProjectSystem.ts","status":"modified","additions":14,"deletions":23,"changes":37,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2Funittests%2FtsserverProjectSystem.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2Funittests%2FtsserverProjectSystem.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fharness%2Funittests%2FtsserverProjectSystem.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -249,10 +249,10 @@ namespace ts.projectSystem {\n         return entry;\r\n     }\r\n \r\n-    export function checkMapKeys(caption: string, map: Map<any>, expectedKeys: string[]) {\r\n-        assert.equal(reduceProperties(map, count => count + 1, 0), expectedKeys.length, `${caption}: incorrect size of map`);\r\n+    export function checkMapKeys(caption: string, map: Map<string, any>, expectedKeys: string[]) {\r\n+        assert.equal(mapSize(map), expectedKeys.length, `${caption}: incorrect size of map`);\r\n         for (const name of expectedKeys) {\r\n-            assert.isTrue(name in map, `${caption} is expected to contain ${name}, actual keys: ${Object.keys(map)}`);\r\n+            assert.isTrue(map.has(name), `${caption} is expected to contain ${name}, actual keys: ${keysOfMap(map)}`);\r\n         }\r\n     }\r\n \r\n@@ -298,38 +298,28 @@ namespace ts.projectSystem {\n     }\r\n \r\n     export class Callbacks {\r\n-        private map: { [n: number]: TimeOutCallback } = {};\r\n+        private map = createMap<number, TimeOutCallback>();\r\n         private nextId = 1;\r\n \r\n         register(cb: (...args: any[]) => void, args: any[]) {\r\n             const timeoutId = this.nextId;\r\n             this.nextId++;\r\n-            this.map[timeoutId] = cb.bind(undefined, ...args);\r\n+            this.map.set(timeoutId, cb.bind(undefined, ...args));\r\n             return timeoutId;\r\n         }\r\n         unregister(id: any) {\r\n             if (typeof id === \"number\") {\r\n-                delete this.map[id];\r\n+                this.map.delete(id);\r\n             }\r\n         }\r\n \r\n         count() {\r\n-            let n = 0;\r\n-            for (const _ in this.map) {\r\n-                // TODO: GH#11734\r\n-                _;\r\n-                n++;\r\n-            }\r\n-            return n;\r\n+            return mapSize(this.map);\r\n         }\r\n \r\n         invoke() {\r\n-            for (const id in this.map) {\r\n-                if (hasProperty(this.map, id)) {\r\n-                    this.map[id]();\r\n-                }\r\n-            }\r\n-            this.map = {};\r\n+            this.map.forEach(callback => { callback(); });\r\n+            this.map.clear();\r\n         }\r\n     }\r\n \r\n@@ -345,8 +335,9 @@ namespace ts.projectSystem {\n         private timeoutCallbacks = new Callbacks();\r\n         private immediateCallbacks = new Callbacks();\r\n \r\n-        readonly watchedDirectories = createMap<{ cb: DirectoryWatcherCallback, recursive: boolean }[]>();\r\n-        readonly watchedFiles = createMap<FileWatcherCallback[]>();\r\n+        readonly watchedDirectories = createMap<string, { cb: DirectoryWatcherCallback, recursive: boolean }[]>();\r\n+        readonly watchedFiles = createMap<string, FileWatcherCallback[]>();\r\n+\r\n \r\n         private filesOrFolders: FileOrFolder[];\r\n \r\n@@ -441,7 +432,7 @@ namespace ts.projectSystem {\n \r\n         triggerDirectoryWatcherCallback(directoryName: string, fileName: string): void {\r\n             const path = this.toPath(directoryName);\r\n-            const callbacks = this.watchedDirectories[path];\r\n+            const callbacks = this.watchedDirectories.get(path);\r\n             if (callbacks) {\r\n                 for (const callback of callbacks) {\r\n                     callback.cb(fileName);\r\n@@ -451,7 +442,7 @@ namespace ts.projectSystem {\n \r\n         triggerFileWatcherCallback(fileName: string, removed?: boolean): void {\r\n             const path = this.toPath(fileName);\r\n-            const callbacks = this.watchedFiles[path];\r\n+            const callbacks = this.watchedFiles.get(path);\r\n             if (callbacks) {\r\n                 for (const callback of callbacks) {\r\n                     callback(path, removed);\r"},{"sha":"e101b932ef9f364100cda8b0dfcdb018de2ebd93","filename":"src/harness/unittests/typingsInstaller.ts","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2Funittests%2FtypingsInstaller.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fharness%2Funittests%2FtypingsInstaller.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fharness%2Funittests%2FtypingsInstaller.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -955,7 +955,7 @@ namespace ts.projectSystem {\n                 content: \"\"\r\n             };\r\n             const host = createServerHost([f]);\r\n-            const cache = createMap<string>();\r\n+            const cache = createMap<string, string>();\r\n             for (const name of JsTyping.nodeCoreModuleList) {\r\n                 const result = JsTyping.discoverTypings(host, [f.path], getDirectoryPath(<Path>f.path), /*safeListPath*/ undefined, cache, { enableAutoDiscovery: true }, [name, \"somename\"]);\r\n                 assert.deepEqual(result.newTypingNames.sort(), [\"node\", \"somename\"]);\r\n@@ -972,7 +972,7 @@ namespace ts.projectSystem {\n                 content: \"\"\r\n             };\r\n             const host = createServerHost([f, node]);\r\n-            const cache = createMap<string>({ \"node\": node.path });\r\n+            const cache = mapOfMapLike({ \"node\": node.path });\r\n             const result = JsTyping.discoverTypings(host, [f.path], getDirectoryPath(<Path>f.path), /*safeListPath*/ undefined, cache, { enableAutoDiscovery: true }, [\"fs\", \"bar\"]);\r\n             assert.deepEqual(result.cachedTypingPaths, [node.path]);\r\n             assert.deepEqual(result.newTypingNames, [\"bar\"]);\r"},{"sha":"59948f32df6f53516db386074b337b69b42d8940","filename":"src/server/builder.ts","status":"modified","additions":8,"deletions":7,"changes":15,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2Fbuilder.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2Fbuilder.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fserver%2Fbuilder.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -346,25 +346,26 @@ namespace ts.server {\n \r\n             // Use slice to clone the array to avoid manipulating in place\r\n             const queue = fileInfo.referencedBy.slice(0);\r\n-            const fileNameSet = createMap<ScriptInfo>();\r\n-            fileNameSet[scriptInfo.fileName] = scriptInfo;\r\n+            const fileNameSet = createMap<string, ScriptInfo>();\r\n+            fileNameSet.set(scriptInfo.fileName, scriptInfo);\r\n             while (queue.length > 0) {\r\n                 const processingFileInfo = queue.pop();\r\n                 if (processingFileInfo.updateShapeSignature() && processingFileInfo.referencedBy.length > 0) {\r\n                     for (const potentialFileInfo of processingFileInfo.referencedBy) {\r\n-                        if (!fileNameSet[potentialFileInfo.scriptInfo.fileName]) {\r\n+                        if (!fileNameSet.get(potentialFileInfo.scriptInfo.fileName)) {\r\n                             queue.push(potentialFileInfo);\r\n                         }\r\n                     }\r\n                 }\r\n-                fileNameSet[processingFileInfo.scriptInfo.fileName] = processingFileInfo.scriptInfo;\r\n+                fileNameSet.set(processingFileInfo.scriptInfo.fileName, processingFileInfo.scriptInfo);\r\n             }\r\n+\r\n             const result: string[] = [];\r\n-            for (const fileName in fileNameSet) {\r\n-                if (shouldEmitFile(fileNameSet[fileName])) {\r\n+            fileNameSet.forEach((scriptInfo, fileName) => {\r\n+                if (shouldEmitFile(scriptInfo)) {\r\n                     result.push(fileName);\r\n                 }\r\n-            }\r\n+            });\r\n             return result;\r\n         }\r\n     }\r"},{"sha":"f4912025527e5e7337b28c80219db54938bedc98","filename":"src/server/client.ts","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2Fclient.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2Fclient.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fserver%2Fclient.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -15,7 +15,7 @@ namespace ts.server {\n \r\n     export class SessionClient implements LanguageService {\r\n         private sequence: number = 0;\r\n-        private lineMaps: ts.Map<number[]> = ts.createMap<number[]>();\r\n+        private lineMaps = ts.createMap<string, number[]>();\r\n         private messages: string[] = [];\r\n         private lastRenameEntry: RenameEntry;\r\n \r\n@@ -31,10 +31,10 @@ namespace ts.server {\n         }\r\n \r\n         private getLineMap(fileName: string): number[] {\r\n-            let lineMap = this.lineMaps[fileName];\r\n+            let lineMap = this.lineMaps.get(fileName);\r\n             if (!lineMap) {\r\n                 const scriptSnapshot = this.host.getScriptSnapshot(fileName);\r\n-                lineMap = this.lineMaps[fileName] = ts.computeLineStarts(scriptSnapshot.getText(0, scriptSnapshot.getLength()));\r\n+                lineMap = setAndReturn(this.lineMaps, fileName, ts.computeLineStarts(scriptSnapshot.getText(0, scriptSnapshot.getLength())));\r\n             }\r\n             return lineMap;\r\n         }\r\n@@ -140,7 +140,7 @@ namespace ts.server {\n \r\n         changeFile(fileName: string, start: number, end: number, newText: string): void {\r\n             // clear the line map after an edit\r\n-            this.lineMaps[fileName] = undefined;\r\n+            this.lineMaps.set(fileName, undefined);\r\n \r\n             const lineOffset = this.positionToOneBasedLineOffset(fileName, start);\r\n             const endLineOffset = this.positionToOneBasedLineOffset(fileName, end);\r"},{"sha":"109a372f8312a797eab81572793e66e4f6a5a322","filename":"src/server/editorServices.ts","status":"modified","additions":72,"deletions":68,"changes":140,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2FeditorServices.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2FeditorServices.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fserver%2FeditorServices.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -17,44 +17,44 @@ namespace ts.server {\n         (event: ProjectServiceEvent): void;\r\n     }\r\n \r\n-    function prepareConvertersForEnumLikeCompilerOptions(commandLineOptions: CommandLineOption[]): Map<Map<number>> {\r\n-        const map: Map<Map<number>> = createMap<Map<number>>();\r\n+    function prepareConvertersForEnumLikeCompilerOptions(commandLineOptions: CommandLineOption[]): Map<string, Map<string, number>> {\r\n+        const map = createMap<string, Map<string, number>>();\r\n         for (const option of commandLineOptions) {\r\n             if (typeof option.type === \"object\") {\r\n-                const optionMap = <Map<number>>option.type;\r\n+                const optionMap = <Map<string, number>>option.type;\r\n                 // verify that map contains only numbers\r\n-                for (const id in optionMap) {\r\n-                    Debug.assert(typeof optionMap[id] === \"number\");\r\n-                }\r\n-                map[option.name] = optionMap;\r\n+                optionMap.forEach(value => {\r\n+                    Debug.assert(typeof value  === \"number\");\r\n+                });\r\n+                map.set(option.name, optionMap);\r\n             }\r\n         }\r\n         return map;\r\n     }\r\n \r\n     const compilerOptionConverters = prepareConvertersForEnumLikeCompilerOptions(optionDeclarations);\r\n-    const indentStyle = createMap({\r\n+    const indentStyle = mapOfMapLike({\r\n         \"none\": IndentStyle.None,\r\n         \"block\": IndentStyle.Block,\r\n         \"smart\": IndentStyle.Smart\r\n     });\r\n \r\n     export function convertFormatOptions(protocolOptions: protocol.FormatCodeSettings): FormatCodeSettings {\r\n         if (typeof protocolOptions.indentStyle === \"string\") {\r\n-            protocolOptions.indentStyle = indentStyle[protocolOptions.indentStyle.toLowerCase()];\r\n+            protocolOptions.indentStyle = indentStyle.get(protocolOptions.indentStyle.toLowerCase());\r\n             Debug.assert(protocolOptions.indentStyle !== undefined);\r\n         }\r\n         return <any>protocolOptions;\r\n     }\r\n \r\n     export function convertCompilerOptions(protocolOptions: protocol.ExternalProjectCompilerOptions): CompilerOptions & protocol.CompileOnSaveMixin {\r\n-        for (const id in compilerOptionConverters) {\r\n+        forEachKeyInMap(compilerOptionConverters, id => {\r\n             const propertyValue = protocolOptions[id];\r\n             if (typeof propertyValue === \"string\") {\r\n-                const mappedValues = compilerOptionConverters[id];\r\n-                protocolOptions[id] = mappedValues[propertyValue.toLowerCase()];\r\n+                const mappedValues = compilerOptionConverters.get(id);\r\n+                protocolOptions[id] = mappedValues.get(propertyValue.toLowerCase());\r\n             }\r\n-        }\r\n+        });\r\n         return <any>protocolOptions;\r\n     }\r\n \r\n@@ -159,37 +159,38 @@ namespace ts.server {\n         /**\r\n          * a path to directory watcher map that detects added tsconfig files\r\n          **/\r\n-        private readonly directoryWatchersForTsconfig: Map<FileWatcher> = createMap<FileWatcher>();\r\n+        private readonly directoryWatchersForTsconfig = createMap<string, FileWatcher>();\r\n         /**\r\n          * count of how many projects are using the directory watcher.\r\n          * If the number becomes 0 for a watcher, then we should close it.\r\n          **/\r\n-        private readonly directoryWatchersRefCount: Map<number> = createMap<number>();\r\n+        private readonly directoryWatchersRefCount = createMap<string, number>();\r\n \r\n         constructor(private readonly projectService: ProjectService) {\r\n         }\r\n \r\n         stopWatchingDirectory(directory: string) {\r\n             // if the ref count for this directory watcher drops to 0, it's time to close it\r\n-            this.directoryWatchersRefCount[directory]--;\r\n-            if (this.directoryWatchersRefCount[directory] === 0) {\r\n+            const refCount = this.directoryWatchersRefCount.get(directory) - 1;\r\n+            this.directoryWatchersRefCount.set(directory, refCount);\r\n+            if (refCount === 0) {\r\n                 this.projectService.logger.info(`Close directory watcher for: ${directory}`);\r\n-                this.directoryWatchersForTsconfig[directory].close();\r\n-                delete this.directoryWatchersForTsconfig[directory];\r\n+                this.directoryWatchersForTsconfig.get(directory).close();\r\n+                this.directoryWatchersForTsconfig.delete(directory);\r\n             }\r\n         }\r\n \r\n         startWatchingContainingDirectoriesForFile(fileName: string, project: InferredProject, callback: (fileName: string) => void) {\r\n             let currentPath = getDirectoryPath(fileName);\r\n             let parentPath = getDirectoryPath(currentPath);\r\n             while (currentPath != parentPath) {\r\n-                if (!this.directoryWatchersForTsconfig[currentPath]) {\r\n+                if (!this.directoryWatchersForTsconfig.get(currentPath)) {\r\n                     this.projectService.logger.info(`Add watcher for: ${currentPath}`);\r\n-                    this.directoryWatchersForTsconfig[currentPath] = this.projectService.host.watchDirectory(currentPath, callback);\r\n-                    this.directoryWatchersRefCount[currentPath] = 1;\r\n+                    this.directoryWatchersForTsconfig.set(currentPath, this.projectService.host.watchDirectory(currentPath, callback));\r\n+                    this.directoryWatchersRefCount.set(currentPath, 1);\r\n                 }\r\n                 else {\r\n-                    this.directoryWatchersRefCount[currentPath] += 1;\r\n+                    modifyValue(this.directoryWatchersRefCount, currentPath, count => count + 1);\r\n                 }\r\n                 project.directoriesWatchedForTsconfig.push(currentPath);\r\n                 currentPath = parentPath;\r\n@@ -211,7 +212,7 @@ namespace ts.server {\n         /**\r\n          * maps external project file name to list of config files that were the part of this project\r\n          */\r\n-        private readonly externalProjectToConfiguredProjectMap: Map<NormalizedPath[]> = createMap<NormalizedPath[]>();\r\n+        private readonly externalProjectToConfiguredProjectMap = createMap<string, NormalizedPath[]>();\r\n \r\n         /**\r\n          * external projects (configuration and list of root files is not controlled by tsserver)\r\n@@ -392,7 +393,7 @@ namespace ts.server {\n             }\r\n             else {\r\n                 if (info && (!info.isOpen)) {\r\n-                    // file has been changed which might affect the set of referenced files in projects that include \r\n+                    // file has been changed which might affect the set of referenced files in projects that include\r\n                     // this file and set of inferred projects\r\n                     info.reloadFromFile();\r\n                     this.updateProjectGraphs(info.containingProjects);\r\n@@ -411,7 +412,7 @@ namespace ts.server {\n                 this.filenameToScriptInfo.remove(info.path);\r\n                 this.lastDeletedFile = info;\r\n \r\n-                // capture list of projects since detachAllProjects will wipe out original list \r\n+                // capture list of projects since detachAllProjects will wipe out original list\r\n                 const containingProjects = info.containingProjects.slice();\r\n \r\n                 info.detachAllProjects();\r\n@@ -562,7 +563,7 @@ namespace ts.server {\n                 const inferredProject = this.createInferredProjectWithRootFileIfNecessary(info);\r\n                 if (!this.useSingleInferredProject) {\r\n                     // if useOneInferredProject is not set then try to fixup ownership of open files\r\n-                    // check 'defaultProject !== inferredProject' is necessary to handle cases \r\n+                    // check 'defaultProject !== inferredProject' is necessary to handle cases\r\n                     // when creation inferred project for some file has added other open files into this project (i.e. as referenced files)\r\n                     // we definitely don't want to delete the project that was just created\r\n                     for (const f of this.openFiles) {\r\n@@ -572,7 +573,7 @@ namespace ts.server {\n                         }\r\n                         const defaultProject = f.getDefaultProject();\r\n                         if (isRootFileInInferredProject(info) && defaultProject !== inferredProject && inferredProject.containsScriptInfo(f)) {\r\n-                            // open file used to be root in inferred project, \r\n+                            // open file used to be root in inferred project,\r\n                             // this inferred project is different from the one we've just created for current file\r\n                             // and new inferred project references this open file.\r\n                             // We should delete old inferred project and attach open file to the new one\r\n@@ -784,7 +785,7 @@ namespace ts.server {\n                 files: parsedCommandLine.fileNames,\r\n                 compilerOptions: parsedCommandLine.options,\r\n                 configHasFilesProperty: config[\"files\"] !== undefined,\r\n-                wildcardDirectories: createMap(parsedCommandLine.wildcardDirectories),\r\n+                wildcardDirectories: parsedCommandLine.wildcardDirectories,\r\n                 typingOptions: parsedCommandLine.typingOptions,\r\n                 compileOnSave: parsedCommandLine.compileOnSave\r\n             };\r\n@@ -843,7 +844,7 @@ namespace ts.server {\n                 this.documentRegistry,\r\n                 projectOptions.configHasFilesProperty,\r\n                 projectOptions.compilerOptions,\r\n-                projectOptions.wildcardDirectories,\r\n+                mapOfMapLike(projectOptions.wildcardDirectories),\r\n                 /*languageServiceEnabled*/ !sizeLimitExceeded,\r\n                 projectOptions.compileOnSave === undefined ? false : projectOptions.compileOnSave);\r\n \r\n@@ -901,7 +902,7 @@ namespace ts.server {\n         private updateNonInferredProject<T>(project: ExternalProject | ConfiguredProject, newUncheckedFiles: T[], propertyReader: FilePropertyReader<T>, newOptions: CompilerOptions, newTypingOptions: TypingOptions, compileOnSave: boolean, configFileErrors: Diagnostic[]) {\r\n             const oldRootScriptInfos = project.getRootScriptInfos();\r\n             const newRootScriptInfos: ScriptInfo[] = [];\r\n-            const newRootScriptInfoMap: NormalizedPathMap<ScriptInfo> = createNormalizedPathMap<ScriptInfo>();\r\n+            const newRootScriptInfoMap: Map<NormalizedPath, ScriptInfo> = createMap<string, ScriptInfo>();\r\n \r\n             let projectErrors: Diagnostic[];\r\n             let rootFilesChanged = false;\r\n@@ -929,7 +930,7 @@ namespace ts.server {\n                 let toAdd: ScriptInfo[];\r\n                 let toRemove: ScriptInfo[];\r\n                 for (const oldFile of oldRootScriptInfos) {\r\n-                    if (!newRootScriptInfoMap.contains(oldFile.fileName)) {\r\n+                    if (!newRootScriptInfoMap.has(oldFile.fileName)) {\r\n                         (toRemove || (toRemove = [])).push(oldFile);\r\n                     }\r\n                 }\r\n@@ -946,7 +947,7 @@ namespace ts.server {\n                 if (toAdd) {\r\n                     for (const f of toAdd) {\r\n                         if (f.isOpen && isRootFileInInferredProject(f)) {\r\n-                            // if file is already root in some inferred project \r\n+                            // if file is already root in some inferred project\r\n                             // - remove the file from that project and delete the project if necessary\r\n                             const inferredProject = f.containingProjects[0];\r\n                             inferredProject.removeFile(f);\r\n@@ -1095,7 +1096,7 @@ namespace ts.server {\n                     this.logger.info(`Host information ${args.hostInfo}`);\r\n                 }\r\n                 if (args.formatOptions) {\r\n-                    mergeMaps(this.hostConfiguration.formatCodeOptions, convertFormatOptions(args.formatOptions));\r\n+                    mergeMapLikes(this.hostConfiguration.formatCodeOptions, convertFormatOptions(args.formatOptions));\r\n                     this.logger.info(\"Format host information updated\");\r\n                 }\r\n             }\r\n@@ -1217,7 +1218,7 @@ namespace ts.server {\n                 for (const file of changedFiles) {\r\n                     const scriptInfo = this.getScriptInfo(file.fileName);\r\n                     Debug.assert(!!scriptInfo);\r\n-                    // apply changes in reverse order \r\n+                    // apply changes in reverse order\r\n                     for (let i = file.changes.length - 1; i >= 0; i--) {\r\n                         const change = file.changes[i];\r\n                         scriptInfo.editContent(change.span.start, change.span.start + change.span.length, change.newText);\r\n@@ -1254,15 +1255,15 @@ namespace ts.server {\n \r\n         closeExternalProject(uncheckedFileName: string, suppressRefresh = false): void {\r\n             const fileName = toNormalizedPath(uncheckedFileName);\r\n-            const configFiles = this.externalProjectToConfiguredProjectMap[fileName];\r\n+            const configFiles = this.externalProjectToConfiguredProjectMap.get(fileName);\r\n             if (configFiles) {\r\n                 let shouldRefreshInferredProjects = false;\r\n                 for (const configFile of configFiles) {\r\n                     if (this.closeConfiguredProject(configFile)) {\r\n                         shouldRefreshInferredProjects = true;\r\n                     }\r\n                 }\r\n-                delete this.externalProjectToConfiguredProjectMap[fileName];\r\n+                this.externalProjectToConfiguredProjectMap.delete(fileName);\r\n                 if (shouldRefreshInferredProjects && !suppressRefresh) {\r\n                     this.refreshInferredProjects();\r\n                 }\r\n@@ -1309,43 +1310,46 @@ namespace ts.server {\n                 // close existing project and later we'll open a set of configured projects for these files\r\n                 this.closeExternalProject(proj.projectFileName, /*suppressRefresh*/ true);\r\n             }\r\n-            else if (this.externalProjectToConfiguredProjectMap[proj.projectFileName]) {\r\n-                // this project used to include config files\r\n-                if (!tsConfigFiles) {\r\n-                    // config files were removed from the project - close existing external project which in turn will close configured projects\r\n-                    this.closeExternalProject(proj.projectFileName, /*suppressRefresh*/ true);\r\n-                }\r\n-                else {\r\n-                    // project previously had some config files - compare them with new set of files and close all configured projects that correspond to unused files\r\n-                    const oldConfigFiles = this.externalProjectToConfiguredProjectMap[proj.projectFileName];\r\n-                    let iNew = 0;\r\n-                    let iOld = 0;\r\n-                    while (iNew < tsConfigFiles.length && iOld < oldConfigFiles.length) {\r\n-                        const newConfig = tsConfigFiles[iNew];\r\n-                        const oldConfig = oldConfigFiles[iOld];\r\n-                        if (oldConfig < newConfig) {\r\n-                            this.closeConfiguredProject(oldConfig);\r\n-                            iOld++;\r\n-                        }\r\n-                        else if (oldConfig > newConfig) {\r\n-                            iNew++;\r\n+            else  {\r\n+                const oldConfigFiles = this.externalProjectToConfiguredProjectMap.get(proj.projectFileName);\r\n+                if (oldConfigFiles) {\r\n+                    // this project used to include config files\r\n+                    if (!tsConfigFiles) {\r\n+                        // config files were removed from the project - close existing external project which in turn will close configured projects\r\n+                        this.closeExternalProject(proj.projectFileName, /*suppressRefresh*/ true);\r\n+                    }\r\n+                    else {\r\n+                        // project previously had some config files - compare them with new set of files and close all configured projects that correspond to unused files\r\n+                        let iNew = 0;\r\n+                        let iOld = 0;\r\n+                        while (iNew < tsConfigFiles.length && iOld < oldConfigFiles.length) {\r\n+                            const newConfig = tsConfigFiles[iNew];\r\n+                            const oldConfig = oldConfigFiles[iOld];\r\n+                            if (oldConfig < newConfig) {\r\n+                                this.closeConfiguredProject(oldConfig);\r\n+                                iOld++;\r\n+                            }\r\n+                            else if (oldConfig > newConfig) {\r\n+                                iNew++;\r\n+                            }\r\n+                            else {\r\n+                                // record existing config files so avoid extra add-refs\r\n+                                (exisingConfigFiles || (exisingConfigFiles = [])).push(oldConfig);\r\n+                                iOld++;\r\n+                                iNew++;\r\n+                            }\r\n                         }\r\n-                        else {\r\n-                            // record existing config files so avoid extra add-refs\r\n-                            (exisingConfigFiles || (exisingConfigFiles = [])).push(oldConfig);\r\n-                            iOld++;\r\n-                            iNew++;\r\n+                        for (let i = iOld; i < oldConfigFiles.length; i++) {\r\n+                            // projects for all remaining old config files should be closed\r\n+                            this.closeConfiguredProject(oldConfigFiles[i]);\r\n                         }\r\n                     }\r\n-                    for (let i = iOld; i < oldConfigFiles.length; i++) {\r\n-                        // projects for all remaining old config files should be closed\r\n-                        this.closeConfiguredProject(oldConfigFiles[i]);\r\n-                    }\r\n                 }\r\n             }\r\n+\r\n             if (tsConfigFiles) {\r\n                 // store the list of tsconfig files that belong to the external project\r\n-                this.externalProjectToConfiguredProjectMap[proj.projectFileName] = tsConfigFiles;\r\n+                this.externalProjectToConfiguredProjectMap.set(proj.projectFileName, tsConfigFiles);\r\n                 for (const tsconfigFile of tsConfigFiles) {\r\n                     let project = this.findConfiguredProjectByProjectName(tsconfigFile);\r\n                     if (!project) {\r\n@@ -1361,7 +1365,7 @@ namespace ts.server {\n             }\r\n             else {\r\n                 // no config files - remove the item from the collection\r\n-                delete this.externalProjectToConfiguredProjectMap[proj.projectFileName];\r\n+                this.externalProjectToConfiguredProjectMap.delete(proj.projectFileName);\r\n                 this.createAndAddExternalProject(proj.projectFileName, rootFiles, proj.options, proj.typingOptions);\r\n             }\r\n             this.refreshInferredProjects();\r"},{"sha":"26da70c53899d518d3ba2728182ed6a6d8887ba1","filename":"src/server/lsHost.ts","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2FlsHost.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2FlsHost.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fserver%2FlsHost.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -5,8 +5,8 @@\n namespace ts.server {\r\n     export class LSHost implements ts.LanguageServiceHost, ModuleResolutionHost, ServerLanguageServiceHost {\r\n         private compilationSettings: ts.CompilerOptions;\r\n-        private readonly resolvedModuleNames= createFileMap<Map<ResolvedModuleWithFailedLookupLocations>>();\r\n-        private readonly resolvedTypeReferenceDirectives = createFileMap<Map<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>>();\r\n+        private readonly resolvedModuleNames = createFileMap<Map<string, ResolvedModuleWithFailedLookupLocations>>();\r\n+        private readonly resolvedTypeReferenceDirectives = createFileMap<Map<string, ResolvedTypeReferenceDirectiveWithFailedLookupLocations>>();\r\n         private readonly getCanonicalFileName: (fileName: string) => string;\r\n \r\n         private filesWithChangedSetOfUnresolvedImports: Path[];\r\n@@ -54,7 +54,7 @@ namespace ts.server {\n         private resolveNamesWithLocalCache<T extends { failedLookupLocations: string[] }, R>(\r\n             names: string[],\r\n             containingFile: string,\r\n-            cache: ts.FileMap<Map<T>>,\r\n+            cache: ts.FileMap<Map<string, T>>,\r\n             loader: (name: string, containingFile: string, options: CompilerOptions, host: ModuleResolutionHost) => T,\r\n             getResult: (s: T) => R,\r\n             getResultFileName: (result: R) => string | undefined,\r\n@@ -63,22 +63,22 @@ namespace ts.server {\n             const path = toPath(containingFile, this.host.getCurrentDirectory(), this.getCanonicalFileName);\r\n             const currentResolutionsInFile = cache.get(path);\r\n \r\n-            const newResolutions: Map<T> = createMap<T>();\r\n+            const newResolutions = createMap<string, T>();\r\n             const resolvedModules: R[] = [];\r\n             const compilerOptions = this.getCompilationSettings();\r\n             const lastDeletedFileName = this.project.projectService.lastDeletedFile && this.project.projectService.lastDeletedFile.fileName;\r\n \r\n             for (const name of names) {\r\n                 // check if this is a duplicate entry in the list\r\n-                let resolution = newResolutions[name];\r\n+                let resolution = newResolutions.get(name);\r\n                 if (!resolution) {\r\n-                    const existingResolution = currentResolutionsInFile && currentResolutionsInFile[name];\r\n+                    const existingResolution = currentResolutionsInFile && currentResolutionsInFile.get(name);\r\n                     if (moduleResolutionIsValid(existingResolution)) {\r\n                         // ok, it is safe to use existing name resolution results\r\n                         resolution = existingResolution;\r\n                     }\r\n                     else {\r\n-                        newResolutions[name] = resolution = loader(name, containingFile, compilerOptions, this);\r\n+                        newResolutions.set(name, resolution = loader(name, containingFile, compilerOptions, this));\r\n                     }\r\n                     if (logChanges && this.filesWithChangedSetOfUnresolvedImports && !resolutionIsEqualTo(existingResolution, resolution)) {\r\n                         this.filesWithChangedSetOfUnresolvedImports.push(path);\r"},{"sha":"92431c08543b4283200f51cce9c4202542bf5799","filename":"src/server/project.ts","status":"modified","additions":28,"deletions":31,"changes":59,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2Fproject.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2Fproject.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fserver%2Fproject.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -104,7 +104,7 @@ namespace ts.server {\n         /**\r\n          * Set of files that was returned from the last call to getChangesSinceVersion.\r\n          */\r\n-        private lastReportedFileNames: Map<string>;\r\n+        private lastReportedFileNames: Map<string, string>;\r\n         /**\r\n          * Last version that was reported.\r\n          */\r\n@@ -385,9 +385,9 @@ namespace ts.server {\n             }\r\n             let unresolvedImports: string[];\r\n             if (file.resolvedModules) {\r\n-                for (const name in file.resolvedModules) {\r\n+                file.resolvedModules.forEach((resolvedModule, name) => {\r\n                     // pick unresolved non-relative names\r\n-                    if (!file.resolvedModules[name] && !isExternalModuleNameRelative(name)) {\r\n+                    if (!resolvedModule && !isExternalModuleNameRelative(name)) {\r\n                         // for non-scoped names extract part up-to the first slash\r\n                         // for scoped names - extract up to the second slash\r\n                         let trimmed = name.trim();\r\n@@ -401,7 +401,7 @@ namespace ts.server {\n                         (unresolvedImports || (unresolvedImports = [])).push(trimmed);\r\n                         result.push(trimmed);\r\n                     }\r\n-                }\r\n+                });\r\n             }\r\n             this.cachedUnresolvedImportsPerFile.set(file.path, unresolvedImports || emptyArray);\r\n         }\r\n@@ -427,7 +427,7 @@ namespace ts.server {\n             }\r\n \r\n             // 1. no changes in structure, no changes in unresolved imports - do nothing\r\n-            // 2. no changes in structure, unresolved imports were changed - collect unresolved imports for all files \r\n+            // 2. no changes in structure, unresolved imports were changed - collect unresolved imports for all files\r\n             // (can reuse cached imports for files that were not changed)\r\n             // 3. new files were added/removed, but compilation settings stays the same - collect unresolved imports for all new/modified files\r\n             // (can reuse cached imports for files that were not changed)\r\n@@ -568,16 +568,16 @@ namespace ts.server {\n \r\n                 const added: string[] = [];\r\n                 const removed: string[] = [];\r\n-                for (const id in currentFiles) {\r\n-                    if (!hasProperty(lastReportedFileNames, id)) {\r\n+                forEachKeyInMap(currentFiles, id => {\r\n+                    if (!lastReportedFileNames.has(id)) {\r\n                         added.push(id);\r\n                     }\r\n-                }\r\n-                for (const id in lastReportedFileNames) {\r\n-                    if (!hasProperty(currentFiles, id)) {\r\n+                });\r\n+                forEachKeyInMap(lastReportedFileNames, id => {\r\n+                    if (!currentFiles.has(id)) {\r\n                         removed.push(id);\r\n                     }\r\n-                }\r\n+                });\r\n                 this.lastReportedFileNames = currentFiles;\r\n                 this.lastReportedVersion = this.projectStructureVersion;\r\n                 return { info, changes: { added, removed }, projectErrors: this.projectErrors };\r\n@@ -603,15 +603,15 @@ namespace ts.server {\n             // We need to use a set here since the code can contain the same import twice,\r\n             // but that will only be one dependency.\r\n             // To avoid invernal conversion, the key of the referencedFiles map must be of type Path\r\n-            const referencedFiles = createMap<boolean>();\r\n+            const referencedFiles = createSet();\r\n             if (sourceFile.imports && sourceFile.imports.length > 0) {\r\n                 const checker: TypeChecker = this.program.getTypeChecker();\r\n                 for (const importName of sourceFile.imports) {\r\n                     const symbol = checker.getSymbolAtLocation(importName);\r\n                     if (symbol && symbol.declarations && symbol.declarations[0]) {\r\n                         const declarationSourceFile = symbol.declarations[0].getSourceFile();\r\n                         if (declarationSourceFile) {\r\n-                            referencedFiles[declarationSourceFile.path] = true;\r\n+                            referencedFiles.add(declarationSourceFile.path);\r\n                         }\r\n                     }\r\n                 }\r\n@@ -623,26 +623,24 @@ namespace ts.server {\n             if (sourceFile.referencedFiles && sourceFile.referencedFiles.length > 0) {\r\n                 for (const referencedFile of sourceFile.referencedFiles) {\r\n                     const referencedPath = toPath(referencedFile.fileName, currentDirectory, getCanonicalFileName);\r\n-                    referencedFiles[referencedPath] = true;\r\n+                    referencedFiles.add(referencedPath);\r\n                 }\r\n             }\r\n \r\n             // Handle type reference directives\r\n             if (sourceFile.resolvedTypeReferenceDirectiveNames) {\r\n-                for (const typeName in sourceFile.resolvedTypeReferenceDirectiveNames) {\r\n-                    const resolvedTypeReferenceDirective = sourceFile.resolvedTypeReferenceDirectiveNames[typeName];\r\n+                sourceFile.resolvedTypeReferenceDirectiveNames.forEach(resolvedTypeReferenceDirective => {\r\n                     if (!resolvedTypeReferenceDirective) {\r\n-                        continue;\r\n+                        return;\r\n                     }\r\n \r\n                     const fileName = resolvedTypeReferenceDirective.resolvedFileName;\r\n                     const typeFilePath = toPath(fileName, currentDirectory, getCanonicalFileName);\r\n-                    referencedFiles[typeFilePath] = true;\r\n-                }\r\n+                    referencedFiles.add(typeFilePath);\r\n+                });\r\n             }\r\n \r\n-            const allFileNames = map(Object.keys(referencedFiles), key => <Path>key);\r\n-            return filter(allFileNames, file => this.projectService.host.fileExists(file));\r\n+            return filterSetToArray(referencedFiles, file => this.projectService.host.fileExists(file)) as Path[];\r\n         }\r\n \r\n         // remove a root file from project\r\n@@ -713,7 +711,7 @@ namespace ts.server {\n         private typingOptions: TypingOptions;\r\n         private projectFileWatcher: FileWatcher;\r\n         private directoryWatcher: FileWatcher;\r\n-        private directoriesWatchedForWildcards: Map<FileWatcher>;\r\n+        private directoriesWatchedForWildcards: Map<string, FileWatcher>;\r\n         private typeRootsWatchers: FileWatcher[];\r\n \r\n         /** Used for configured projects which may have multiple open roots */\r\n@@ -724,7 +722,7 @@ namespace ts.server {\n             documentRegistry: ts.DocumentRegistry,\r\n             hasExplicitListOfFiles: boolean,\r\n             compilerOptions: CompilerOptions,\r\n-            private wildcardDirectories: Map<WatchDirectoryFlags>,\r\n+            private wildcardDirectories: Map<string, WatchDirectoryFlags>,\r\n             languageServiceEnabled: boolean,\r\n             public compileOnSaveEnabled: boolean) {\r\n             super(ProjectKind.Configured, projectService, documentRegistry, hasExplicitListOfFiles, languageServiceEnabled, compilerOptions, compileOnSaveEnabled);\r\n@@ -779,18 +777,19 @@ namespace ts.server {\n                 return;\r\n             }\r\n             const configDirectoryPath = getDirectoryPath(this.configFileName);\r\n-            this.directoriesWatchedForWildcards = reduceProperties(this.wildcardDirectories, (watchers, flag, directory) => {\r\n+\r\n+            this.directoriesWatchedForWildcards = createMap<string, FileWatcher>();\r\n+            this.wildcardDirectories.forEach((flag, directory) => {\r\n                 if (comparePaths(configDirectoryPath, directory, \".\", !this.projectService.host.useCaseSensitiveFileNames) !== Comparison.EqualTo) {\r\n                     const recursive = (flag & WatchDirectoryFlags.Recursive) !== 0;\r\n                     this.projectService.logger.info(`Add ${recursive ? \"recursive \" : \"\"}watcher for: ${directory}`);\r\n-                    watchers[directory] = this.projectService.host.watchDirectory(\r\n+                    this.directoriesWatchedForWildcards.set(directory, this.projectService.host.watchDirectory(\r\n                         directory,\r\n                         path => callback(this, path),\r\n                         recursive\r\n-                    );\r\n+                    ));\r\n                 }\r\n-                return watchers;\r\n-            }, <Map<FileWatcher>>{});\r\n+            });\r\n         }\r\n \r\n         stopWatchingDirectory() {\r\n@@ -814,9 +813,7 @@ namespace ts.server {\n                 this.typeRootsWatchers = undefined;\r\n             }\r\n \r\n-            for (const id in this.directoriesWatchedForWildcards) {\r\n-                this.directoriesWatchedForWildcards[id].close();\r\n-            }\r\n+            this.directoriesWatchedForWildcards.forEach(watcher => { watcher.close(); });\r\n             this.directoriesWatchedForWildcards = undefined;\r\n \r\n             this.stopWatchingDirectory();\r"},{"sha":"fa9eac0e8e3996196858368d3fac6603e33c0dc8","filename":"src/server/scriptInfo.ts","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2FscriptInfo.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2FscriptInfo.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fserver%2FscriptInfo.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -95,7 +95,7 @@ namespace ts.server {\n                 if (!this.formatCodeSettings) {\r\n                     this.formatCodeSettings = getDefaultFormatCodeSettings(this.host);\r\n                 }\r\n-                mergeMaps(this.formatCodeSettings, formatSettings);\r\n+                mergeMapLikes(this.formatCodeSettings, formatSettings);\r\n             }\r\n         }\r\n \r"},{"sha":"4c9990f22843bf705a47a34bcffccc64debdc56b","filename":"src/server/session.ts","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2Fsession.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2Fsession.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fserver%2Fsession.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -1351,7 +1351,7 @@ namespace ts.server {\n             return { response, responseRequired: true };\r\n         }\r\n \r\n-        private handlers = createMap<(request: protocol.Request) => { response?: any, responseRequired?: boolean }>({\r\n+        private handlers = mapOfMapLike<(request: protocol.Request) => { response?: any, responseRequired?: boolean }>({\r\n             [CommandNames.OpenExternalProject]: (request: protocol.OpenExternalProjectRequest) => {\r\n                 this.projectService.openExternalProject(request.arguments);\r\n                 // TODO: report errors\r\n@@ -1597,14 +1597,14 @@ namespace ts.server {\n         });\r\n \r\n         public addProtocolHandler(command: string, handler: (request: protocol.Request) => { response?: any, responseRequired: boolean }) {\r\n-            if (command in this.handlers) {\r\n+            if (this.handlers.has(command)) {\r\n                 throw new Error(`Protocol handler already exists for command \"${command}\"`);\r\n             }\r\n-            this.handlers[command] = handler;\r\n+            this.handlers.set(command, handler);\r\n         }\r\n \r\n         public executeCommand(request: protocol.Request): { response?: any, responseRequired?: boolean } {\r\n-            const handler = this.handlers[request.command];\r\n+            const handler = this.handlers.get(request.command);\r\n             if (handler) {\r\n                 return handler(request);\r\n             }\r"},{"sha":"b5b3bf2328c237f3e7c0e47e1c8b300077e9b916","filename":"src/server/tsconfig.library.json","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2Ftsconfig.library.json","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2Ftsconfig.library.json","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fserver%2Ftsconfig.library.json?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -18,7 +18,7 @@\n         \"utilities.ts\",\r\n         \"scriptVersionCache.ts\",\r\n         \"scriptInfo.ts\",\r\n-        \"lshost.ts\",\r\n+        \"lsHost.ts\",\r\n         \"typingsCache.ts\",\r\n         \"project.ts\",\r\n         \"editorServices.ts\",\r"},{"sha":"399a0788c474447b28748d558635b8afeaf747e9","filename":"src/server/typingsCache.ts","status":"modified","additions":15,"deletions":14,"changes":29,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2FtypingsCache.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2FtypingsCache.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fserver%2FtypingsCache.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -31,21 +31,22 @@ namespace ts.server {\n         if ((arr1 || emptyArray).length === 0 && (arr2 || emptyArray).length === 0) {\r\n             return true;\r\n         }\r\n-        const set: Map<boolean> = createMap<boolean>();\r\n+        const set = createMap<string, boolean>();\r\n         let unique = 0;\r\n \r\n         for (const v of arr1) {\r\n-            if (set[v] !== true) {\r\n-                set[v] = true;\r\n+            if (set.get(v) !== true) {\r\n+                set.set(v, true);\r\n                 unique++;\r\n             }\r\n         }\r\n         for (const v of arr2) {\r\n-            if (!hasProperty(set, v)) {\r\n+            const isSet = set.get(v);\r\n+            if (isSet === undefined) {\r\n                 return false;\r\n             }\r\n-            if (set[v] === true) {\r\n-                set[v] = false;\r\n+            if (isSet === true) {\r\n+                set.set(v, false);\r\n                 unique--;\r\n             }\r\n         }\r\n@@ -71,7 +72,7 @@ namespace ts.server {\n     }\r\n \r\n     export class TypingsCache {\r\n-        private readonly perProjectCache: Map<TypingsCacheEntry> = createMap<TypingsCacheEntry>();\r\n+        private readonly perProjectCache = createMap<string, TypingsCacheEntry>();\r\n \r\n         constructor(private readonly installer: ITypingsInstaller) {\r\n         }\r\n@@ -83,7 +84,7 @@ namespace ts.server {\n                 return <any>emptyArray;\r\n             }\r\n \r\n-            const entry = this.perProjectCache[project.getProjectName()];\r\n+            const entry = this.perProjectCache.get(project.getProjectName());\r\n             const result: SortedReadonlyArray<string> = entry ? entry.typings : <any>emptyArray;\r\n             if (forceRefresh ||\r\n                 !entry ||\r\n@@ -92,35 +93,35 @@ namespace ts.server {\n                 unresolvedImportsChanged(unresolvedImports, entry.unresolvedImports)) {\r\n                 // Note: entry is now poisoned since it does not really contain typings for a given combination of compiler options\\typings options.\r\n                 // instead it acts as a placeholder to prevent issuing multiple requests\r\n-                this.perProjectCache[project.getProjectName()] = {\r\n+                this.perProjectCache.set(project.getProjectName(), {\r\n                     compilerOptions: project.getCompilerOptions(),\r\n                     typingOptions,\r\n                     typings: result,\r\n                     unresolvedImports,\r\n                     poisoned: true\r\n-                };\r\n+                });\r\n                 // something has been changed, issue a request to update typings\r\n                 this.installer.enqueueInstallTypingsRequest(project, typingOptions, unresolvedImports);\r\n             }\r\n             return result;\r\n         }\r\n \r\n         updateTypingsForProject(projectName: string, compilerOptions: CompilerOptions, typingOptions: TypingOptions, unresolvedImports: SortedReadonlyArray<string>, newTypings: string[]) {\r\n-            this.perProjectCache[projectName] = {\r\n+            this.perProjectCache.set(projectName, {\r\n                 compilerOptions,\r\n                 typingOptions,\r\n                 typings: toSortedReadonlyArray(newTypings),\r\n                 unresolvedImports,\r\n                 poisoned: false\r\n-            };\r\n+            });\r\n         }\r\n \r\n         deleteTypingsForProject(projectName: string) {\r\n-            delete this.perProjectCache[projectName];\r\n+            this.perProjectCache.delete(projectName);\r\n         }\r\n \r\n         onProjectClosed(project: Project) {\r\n-            delete this.perProjectCache[project.getProjectName()];\r\n+            this.perProjectCache.delete(project.getProjectName());\r\n             this.installer.onProjectClosed(project);\r\n         }\r\n     }\r"},{"sha":"18c16b0d90ca5691bd48f9bc29d6e899e320b8e7","filename":"src/server/typingsInstaller/typingsInstaller.ts","status":"modified","additions":19,"deletions":19,"changes":38,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2FtypingsInstaller%2FtypingsInstaller.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2FtypingsInstaller%2FtypingsInstaller.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fserver%2FtypingsInstaller%2FtypingsInstaller.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -78,10 +78,10 @@ namespace ts.server.typingsInstaller {\n     };\r\n \r\n     export abstract class TypingsInstaller {\r\n-        private readonly packageNameToTypingLocation: Map<string> = createMap<string>();\r\n-        private readonly missingTypingsSet: Map<true> = createMap<true>();\r\n-        private readonly knownCachesSet: Map<true> = createMap<true>();\r\n-        private readonly projectWatchers: Map<FileWatcher[]> = createMap<FileWatcher[]>();\r\n+        private readonly packageNameToTypingLocation = createMap<string, string>();\r\n+        private readonly missingTypingsSet = createSet();\r\n+        private readonly knownCachesSet = createSet();\r\n+        private readonly projectWatchers = createMap<string, FileWatcher[]>();\r\n         readonly pendingRunRequests: PendingRequest[] = [];\r\n \r\n         private installRunCount = 1;\r\n@@ -111,7 +111,7 @@ namespace ts.server.typingsInstaller {\n             if (this.log.isEnabled()) {\r\n                 this.log.writeLine(`Closing file watchers for project '${projectName}'`);\r\n             }\r\n-            const watchers = this.projectWatchers[projectName];\r\n+            const watchers = this.projectWatchers.get(projectName);\r\n             if (!watchers) {\r\n                 if (this.log.isEnabled()) {\r\n                     this.log.writeLine(`No watchers are registered for project '${projectName}'`);\r\n@@ -122,7 +122,7 @@ namespace ts.server.typingsInstaller {\n                 w.close();\r\n             }\r\n \r\n-            delete this.projectWatchers[projectName];\r\n+            this.projectWatchers.delete(projectName);\r\n \r\n             if (this.log.isEnabled()) {\r\n                 this.log.writeLine(`Closing file watchers for project '${projectName}' - done.`);\r\n@@ -176,7 +176,7 @@ namespace ts.server.typingsInstaller {\n             if (this.log.isEnabled()) {\r\n                 this.log.writeLine(`Processing cache location '${cacheLocation}'`);\r\n             }\r\n-            if (this.knownCachesSet[cacheLocation]) {\r\n+            if (this.knownCachesSet.has(cacheLocation)) {\r\n                 if (this.log.isEnabled()) {\r\n                     this.log.writeLine(`Cache location was already processed...`);\r\n                 }\r\n@@ -202,7 +202,7 @@ namespace ts.server.typingsInstaller {\n                         if (!typingFile) {\r\n                             continue;\r\n                         }\r\n-                        const existingTypingFile = this.packageNameToTypingLocation[packageName];\r\n+                        const existingTypingFile = this.packageNameToTypingLocation.get(packageName);\r\n                         if (existingTypingFile === typingFile) {\r\n                             continue;\r\n                         }\r\n@@ -214,14 +214,14 @@ namespace ts.server.typingsInstaller {\n                         if (this.log.isEnabled()) {\r\n                             this.log.writeLine(`Adding entry into typings cache: '${packageName}' => '${typingFile}'`);\r\n                         }\r\n-                        this.packageNameToTypingLocation[packageName] = typingFile;\r\n+                        this.packageNameToTypingLocation.set(packageName, typingFile);\r\n                     }\r\n                 }\r\n             }\r\n             if (this.log.isEnabled()) {\r\n                 this.log.writeLine(`Finished processing cache location '${cacheLocation}'`);\r\n             }\r\n-            this.knownCachesSet[cacheLocation] = true;\r\n+            this.knownCachesSet.add(cacheLocation);\r\n         }\r\n \r\n         private filterTypings(typingsToInstall: string[]) {\r\n@@ -230,7 +230,7 @@ namespace ts.server.typingsInstaller {\n             }\r\n             const result: string[] = [];\r\n             for (const typing of typingsToInstall) {\r\n-                if (this.missingTypingsSet[typing]) {\r\n+                if (this.missingTypingsSet.has(typing)) {\r\n                     continue;\r\n                 }\r\n                 const validationResult = validatePackageName(typing);\r\n@@ -239,7 +239,7 @@ namespace ts.server.typingsInstaller {\n                 }\r\n                 else {\r\n                     // add typing name to missing set so we won't process it again\r\n-                    this.missingTypingsSet[typing] = true;\r\n+                    this.missingTypingsSet.add(typing);\r\n                     if (this.log.isEnabled()) {\r\n                         switch (validationResult) {\r\n                             case PackageNameValidationResult.EmptyName:\r\n@@ -296,32 +296,32 @@ namespace ts.server.typingsInstaller {\n                 if (this.log.isEnabled()) {\r\n                     this.log.writeLine(`Requested to install typings ${JSON.stringify(typingsToInstall)}, installed typings ${JSON.stringify(installedTypings)}`);\r\n                 }\r\n-                const installedPackages: Map<true> = createMap<true>();\r\n+                const installedPackages = createSet();\r\n                 const installedTypingFiles: string[] = [];\r\n                 for (const t of installedTypings) {\r\n                     const packageName = getBaseFileName(t);\r\n                     if (!packageName) {\r\n                         continue;\r\n                     }\r\n-                    installedPackages[packageName] = true;\r\n+                    installedPackages.add(packageName);\r\n                     const typingFile = typingToFileName(cachePath, packageName, this.installTypingHost);\r\n                     if (!typingFile) {\r\n                         continue;\r\n                     }\r\n-                    if (!this.packageNameToTypingLocation[packageName]) {\r\n-                        this.packageNameToTypingLocation[packageName] = typingFile;\r\n+                    if (!this.packageNameToTypingLocation.get(packageName)) {\r\n+                        this.packageNameToTypingLocation.set(packageName, typingFile);\r\n                     }\r\n                     installedTypingFiles.push(typingFile);\r\n                 }\r\n                 if (this.log.isEnabled()) {\r\n                     this.log.writeLine(`Installed typing files ${JSON.stringify(installedTypingFiles)}`);\r\n                 }\r\n                 for (const toInstall of typingsToInstall) {\r\n-                    if (!installedPackages[toInstall]) {\r\n+                    if (!installedPackages.has(toInstall)) {\r\n                         if (this.log.isEnabled()) {\r\n                             this.log.writeLine(`New missing typing package '${toInstall}'`);\r\n                         }\r\n-                        this.missingTypingsSet[toInstall] = true;\r\n+                        this.missingTypingsSet.add(toInstall);\r\n                     }\r\n                 }\r\n \r\n@@ -395,7 +395,7 @@ namespace ts.server.typingsInstaller {\n                 });\r\n                 watchers.push(w);\r\n             }\r\n-            this.projectWatchers[projectName] = watchers;\r\n+            this.projectWatchers.set(projectName, watchers);\r\n         }\r\n \r\n         private createSetTypings(request: DiscoverTypings, typings: string[]): SetTypings {\r"},{"sha":"8cf2fbfe24218eb03ad8d59688420a8f6f28d6cd","filename":"src/server/utilities.ts","status":"modified","additions":8,"deletions":33,"changes":41,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2Futilities.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fserver%2Futilities.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fserver%2Futilities.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -91,7 +91,7 @@ namespace ts.server {\n         };\r\n     }\r\n \r\n-    export function mergeMaps(target: MapLike<any>, source: MapLike <any>): void {\r\n+    export function mergeMapLikes(target: MapLike<any>, source: MapLike <any>): void {\r\n         for (const key in source) {\r\n             if (hasProperty(source, key)) {\r\n                 target[key] = source[key];\r\n@@ -132,32 +132,6 @@ namespace ts.server {\n         return <NormalizedPath>fileName;\r\n     }\r\n \r\n-    export interface NormalizedPathMap<T> {\r\n-        get(path: NormalizedPath): T;\r\n-        set(path: NormalizedPath, value: T): void;\r\n-        contains(path: NormalizedPath): boolean;\r\n-        remove(path: NormalizedPath): void;\r\n-    }\r\n-\r\n-    export function createNormalizedPathMap<T>(): NormalizedPathMap<T> {\r\n-/* tslint:disable:no-null-keyword */\r\n-        const map: Map<T> = Object.create(null);\r\n-/* tslint:enable:no-null-keyword */\r\n-        return {\r\n-            get(path) {\r\n-                return map[path];\r\n-            },\r\n-            set(path, value) {\r\n-                map[path] = value;\r\n-            },\r\n-            contains(path) {\r\n-                return hasProperty(map, path);\r\n-            },\r\n-            remove(path) {\r\n-                delete map[path];\r\n-            }\r\n-        };\r\n-    }\r\n     function throwLanguageServiceIsDisabledError(): never {\r\n         throw new Error(\"LanguageService is disabled\");\r\n     }\r\n@@ -230,7 +204,7 @@ namespace ts.server {\n          * these fields can be present in the project file\r\n          **/\r\n         files?: string[];\r\n-        wildcardDirectories?: Map<WatchDirectoryFlags>;\r\n+        wildcardDirectories?: MapLike<WatchDirectoryFlags>;\r\n         compilerOptions?: CompilerOptions;\r\n         typingOptions?: TypingOptions;\r\n         compileOnSave?: boolean;\r\n@@ -251,21 +225,22 @@ namespace ts.server {\n     }\r\n \r\n     export class ThrottledOperations {\r\n-        private pendingTimeouts: Map<any> = createMap<any>();\r\n+        private pendingTimeouts = createMap<string, any>();\r\n         constructor(private readonly host: ServerHost) {\r\n         }\r\n \r\n         public schedule(operationId: string, delay: number, cb: () => void) {\r\n-            if (hasProperty(this.pendingTimeouts, operationId)) {\r\n+            const pendingTimeout = this.pendingTimeouts.get(operationId);\r\n+            if (pendingTimeout !== undefined) {\r\n                 // another operation was already scheduled for this id - cancel it\r\n-                this.host.clearTimeout(this.pendingTimeouts[operationId]);\r\n+                this.host.clearTimeout(pendingTimeout);\r\n             }\r\n             // schedule new operation, pass arguments\r\n-            this.pendingTimeouts[operationId] = this.host.setTimeout(ThrottledOperations.run, delay, this, operationId, cb);\r\n+            this.pendingTimeouts.set(operationId, this.host.setTimeout(ThrottledOperations.run, delay, this, operationId, cb));\r\n         }\r\n \r\n         private static run(self: ThrottledOperations, operationId: string, cb: () => void) {\r\n-            delete self.pendingTimeouts[operationId];\r\n+            self.pendingTimeouts.delete(operationId);\r\n             cb();\r\n         }\r\n     }\r"},{"sha":"553d184eb95603b0b293df300bfbb285e2abf89d","filename":"src/services/classifier.ts","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2Fclassifier.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2Fclassifier.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fservices%2Fclassifier.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -462,7 +462,7 @@ namespace ts {\n     }\r\n \r\n     /* @internal */\r\n-    export function getSemanticClassifications(typeChecker: TypeChecker, cancellationToken: CancellationToken, sourceFile: SourceFile, classifiableNames: Map<string>, span: TextSpan): ClassifiedSpan[] {\r\n+    export function getSemanticClassifications(typeChecker: TypeChecker, cancellationToken: CancellationToken, sourceFile: SourceFile, classifiableNames: Set<string>, span: TextSpan): ClassifiedSpan[] {\r\n         return convertClassifications(getEncodedSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span));\r\n     }\r\n \r\n@@ -487,7 +487,7 @@ namespace ts {\n     }\r\n \r\n     /* @internal */\r\n-    export function getEncodedSemanticClassifications(typeChecker: TypeChecker, cancellationToken: CancellationToken, sourceFile: SourceFile, classifiableNames: Map<string>, span: TextSpan): Classifications {\r\n+    export function getEncodedSemanticClassifications(typeChecker: TypeChecker, cancellationToken: CancellationToken, sourceFile: SourceFile, classifiableNames: Set<string>, span: TextSpan): Classifications {\r\n         const result: number[] = [];\r\n         processNode(sourceFile);\r\n \r\n@@ -557,7 +557,7 @@ namespace ts {\n                     // Only bother calling into the typechecker if this is an identifier that\r\n                     // could possibly resolve to a type name.  This makes classification run\r\n                     // in a third of the time it would normally take.\r\n-                    if (classifiableNames[identifier.text]) {\r\n+                    if (classifiableNames.has(identifier.text)) {\r\n                         const symbol = typeChecker.getSymbolAtLocation(node);\r\n                         if (symbol) {\r\n                             const type = classifySymbol(symbol, getMeaningFromLocation(node));\r"},{"sha":"6b27b11e4369fa031f9b815b2ec6a8c535a62268","filename":"src/services/codefixes/codeFixProvider.ts","status":"modified","additions":8,"deletions":9,"changes":17,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2Fcodefixes%2FcodeFixProvider.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2Fcodefixes%2FcodeFixProvider.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fservices%2Fcodefixes%2FcodeFixProvider.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -14,25 +14,24 @@ namespace ts {\n     }\r\n \r\n     export namespace codefix {\r\n-        const codeFixes = createMap<CodeFix[]>();\r\n+        const codeFixes = createMap<number, CodeFix[]>();\r\n \r\n         export function registerCodeFix(action: CodeFix) {\r\n             forEach(action.errorCodes, error => {\r\n-                let fixes = codeFixes[error];\r\n-                if (!fixes) {\r\n-                    fixes = [];\r\n-                    codeFixes[error] = fixes;\r\n-                }\r\n-                fixes.push(action);\r\n+                multiMapAdd(codeFixes, error, action);\r\n             });\r\n         }\r\n \r\n         export function getSupportedErrorCodes() {\r\n-            return Object.keys(codeFixes);\r\n+            const supportedErrorCodes: string[] = [];\r\n+            codeFixes.forEach((_, key) => {\r\n+                supportedErrorCodes.push(key.toString());\r\n+            });\r\n+            return supportedErrorCodes;\r\n         }\r\n \r\n         export function getFixes(context: CodeFixContext): CodeAction[] {\r\n-            const fixes = codeFixes[context.errorCode];\r\n+            const fixes = codeFixes.get(context.errorCode);\r\n             let allActions: CodeAction[] = [];\r\n \r\n             forEach(fixes, f => {\r"},{"sha":"5005343ca9273580187172bfa97c5604af82d7fe","filename":"src/services/completions.ts","status":"modified","additions":27,"deletions":28,"changes":55,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2Fcompletions.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2Fcompletions.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fservices%2Fcompletions.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -60,18 +60,17 @@ namespace ts.Completions {\n \r\n         return { isGlobalCompletion, isMemberCompletion, isNewIdentifierLocation: isNewIdentifierLocation, entries };\r\n \r\n-        function getJavaScriptCompletionEntries(sourceFile: SourceFile, position: number, uniqueNames: Map<string>): CompletionEntry[] {\r\n+        function getJavaScriptCompletionEntries(sourceFile: SourceFile, position: number, uniqueNames: Set<string>): CompletionEntry[] {\r\n             const entries: CompletionEntry[] = [];\r\n \r\n-            const nameTable = getNameTable(sourceFile);\r\n-            for (const name in nameTable) {\r\n+            getNameTable(sourceFile).forEach((nameTablePosition, name) => {\r\n                 // Skip identifiers produced only from the current location\r\n-                if (nameTable[name] === position) {\r\n-                    continue;\r\n+                if (nameTablePosition === position) {\r\n+                    return;\r\n                 }\r\n \r\n-                if (!uniqueNames[name]) {\r\n-                    uniqueNames[name] = name;\r\n+                if (!uniqueNames.has(name)) {\r\n+                    uniqueNames.add(name);\r\n                     const displayName = getCompletionEntryDisplayName(unescapeIdentifier(name), compilerOptions.target, /*performCharacterChecks*/ true);\r\n                     if (displayName) {\r\n                         const entry = {\r\n@@ -83,7 +82,7 @@ namespace ts.Completions {\n                         entries.push(entry);\r\n                     }\r\n                 }\r\n-            }\r\n+            });\r\n \r\n             return entries;\r\n         }\r\n@@ -114,17 +113,17 @@ namespace ts.Completions {\n \r\n         }\r\n \r\n-        function getCompletionEntriesFromSymbols(symbols: Symbol[], entries: CompletionEntry[], location: Node, performCharacterChecks: boolean): Map<string> {\r\n+        function getCompletionEntriesFromSymbols(symbols: Symbol[], entries: CompletionEntry[], location: Node, performCharacterChecks: boolean): Set<string> {\r\n             const start = timestamp();\r\n-            const uniqueNames = createMap<string>();\r\n+            const uniqueNames = createSet();\r\n             if (symbols) {\r\n                 for (const symbol of symbols) {\r\n                     const entry = createCompletionEntry(symbol, location, performCharacterChecks);\r\n                     if (entry) {\r\n                         const id = escapeIdentifier(entry.name);\r\n-                        if (!uniqueNames[id]) {\r\n+                        if (!uniqueNames.has(id)) {\r\n                             entries.push(entry);\r\n-                            uniqueNames[id] = id;\r\n+                            uniqueNames.add(id);\r\n                         }\r\n                     }\r\n                 }\r\n@@ -364,7 +363,7 @@ namespace ts.Completions {\n                      *\r\n                      * both foo.ts and foo.tsx become foo\r\n                      */\r\n-                    const foundFiles = createMap<boolean>();\r\n+                    const foundFiles = createSet();\r\n                     for (let filePath of files) {\r\n                         filePath = normalizePath(filePath);\r\n                         if (exclude && comparePaths(filePath, exclude, scriptPath, ignoreCase) === Comparison.EqualTo) {\r\n@@ -373,14 +372,14 @@ namespace ts.Completions {\n \r\n                         const foundFileName = includeExtensions ? getBaseFileName(filePath) : removeFileExtension(getBaseFileName(filePath));\r\n \r\n-                        if (!foundFiles[foundFileName]) {\r\n-                            foundFiles[foundFileName] = true;\r\n+                        if (!foundFiles.has(foundFileName)) {\r\n+                            foundFiles.add(foundFileName);\r\n                         }\r\n                     }\r\n \r\n-                    for (const foundFile in foundFiles) {\r\n+                    foundFiles.forEach(foundFile => {\r\n                         result.push(createCompletionEntryForModule(foundFile, ScriptElementKind.scriptElement, span));\r\n-                    }\r\n+                    });\r\n                 }\r\n \r\n                 // If possible, get folder completion as well\r\n@@ -418,7 +417,7 @@ namespace ts.Completions {\n \r\n                 if (paths) {\r\n                     for (const path in paths) {\r\n-                        if (paths.hasOwnProperty(path)) {\r\n+                        if (hasProperty(paths, path)) {\r\n                             if (path === \"*\") {\r\n                                 if (paths[path]) {\r\n                                     for (const pattern of paths[path]) {\r\n@@ -1554,7 +1553,7 @@ namespace ts.Completions {\n          *          do not occur at the current position and have not otherwise been typed.\r\n          */\r\n         function filterNamedImportOrExportCompletionItems(exportsOfModule: Symbol[], namedImportsOrExports: ImportOrExportSpecifier[]): Symbol[] {\r\n-            const existingImportsOrExports = createMap<boolean>();\r\n+            const existingImportsOrExports = createSet();\r\n \r\n             for (const element of namedImportsOrExports) {\r\n                 // If this is the current item we are editing right now, do not filter it out\r\n@@ -1563,14 +1562,14 @@ namespace ts.Completions {\n                 }\r\n \r\n                 const name = element.propertyName || element.name;\r\n-                existingImportsOrExports[name.text] = true;\r\n+                existingImportsOrExports.add(name.text);\r\n             }\r\n \r\n-            if (!someProperties(existingImportsOrExports)) {\r\n+            if (setIsEmpty(existingImportsOrExports)) {\r\n                 return filter(exportsOfModule, e => e.name !== \"default\");\r\n             }\r\n \r\n-            return filter(exportsOfModule, e => e.name !== \"default\" && !existingImportsOrExports[e.name]);\r\n+            return filter(exportsOfModule, e => e.name !== \"default\" && !existingImportsOrExports.has(e.name));\r\n         }\r\n \r\n         /**\r\n@@ -1584,7 +1583,7 @@ namespace ts.Completions {\n                 return contextualMemberSymbols;\r\n             }\r\n \r\n-            const existingMemberNames = createMap<boolean>();\r\n+            const existingMemberNames = createSet();\r\n             for (const m of existingMembers) {\r\n                 // Ignore omitted expressions for missing members\r\n                 if (m.kind !== SyntaxKind.PropertyAssignment &&\r\n@@ -1616,10 +1615,10 @@ namespace ts.Completions {\n                     existingName = (<Identifier>m.name).text;\r\n                 }\r\n \r\n-                existingMemberNames[existingName] = true;\r\n+                existingMemberNames.add(existingName);\r\n             }\r\n \r\n-            return filter(contextualMemberSymbols, m => !existingMemberNames[m.name]);\r\n+            return filter(contextualMemberSymbols, m => !existingMemberNames.has(m.name));\r\n         }\r\n \r\n         /**\r\n@@ -1629,19 +1628,19 @@ namespace ts.Completions {\n          *          do not occur at the current position and have not otherwise been typed.\r\n          */\r\n         function filterJsxAttributes(symbols: Symbol[], attributes: NodeArray<JsxAttribute | JsxSpreadAttribute>): Symbol[] {\r\n-            const seenNames = createMap<boolean>();\r\n+            const seenNames = createSet();\r\n             for (const attr of attributes) {\r\n                 // If this is the current item we are editing right now, do not filter it out\r\n                 if (attr.getStart() <= position && position <= attr.getEnd()) {\r\n                     continue;\r\n                 }\r\n \r\n                 if (attr.kind === SyntaxKind.JsxAttribute) {\r\n-                    seenNames[(<JsxAttribute>attr).name.text] = true;\r\n+                    seenNames.add((<JsxAttribute>attr).name.text);\r\n                 }\r\n             }\r\n \r\n-            return filter(symbols, a => !seenNames[a.name]);\r\n+            return filter(symbols, a => !seenNames.has(a.name));\r\n         }\r\n     }\r\n \r"},{"sha":"791ad48d9d682024ec37be86f22992bb3af234e1","filename":"src/services/documentHighlights.ts","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2FdocumentHighlights.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2FdocumentHighlights.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fservices%2FdocumentHighlights.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -39,16 +39,16 @@ namespace ts.DocumentHighlights {\n                     return undefined;\r\n                 }\r\n \r\n-                const fileNameToDocumentHighlights = createMap<DocumentHighlights>();\r\n+                const fileNameToDocumentHighlights = createMap<string, DocumentHighlights>();\r\n                 const result: DocumentHighlights[] = [];\r\n                 for (const referencedSymbol of referencedSymbols) {\r\n                     for (const referenceEntry of referencedSymbol.references) {\r\n                         const fileName = referenceEntry.fileName;\r\n-                        let documentHighlights = fileNameToDocumentHighlights[fileName];\r\n+                        let documentHighlights = fileNameToDocumentHighlights.get(fileName);\r\n                         if (!documentHighlights) {\r\n                             documentHighlights = { fileName, highlightSpans: [] };\r\n \r\n-                            fileNameToDocumentHighlights[fileName] = documentHighlights;\r\n+                            fileNameToDocumentHighlights.set(fileName, documentHighlights);\r\n                             result.push(documentHighlights);\r\n                         }\r\n \r"},{"sha":"5c5a7797d2d093cdc248c37193b6ffcdf04a6a63","filename":"src/services/documentRegistry.ts","status":"modified","additions":22,"deletions":17,"changes":39,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2FdocumentRegistry.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2FdocumentRegistry.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fservices%2FdocumentRegistry.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -105,38 +105,43 @@ namespace ts {\n     export function createDocumentRegistry(useCaseSensitiveFileNames?: boolean, currentDirectory = \"\"): DocumentRegistry {\r\n         // Maps from compiler setting target (ES3, ES5, etc.) to all the cached documents we have\r\n         // for those settings.\r\n-        const buckets = createMap<FileMap<DocumentRegistryEntry>>();\r\n+        const buckets = createMap<string, FileMap<DocumentRegistryEntry>>();\r\n         const getCanonicalFileName = createGetCanonicalFileName(!!useCaseSensitiveFileNames);\r\n \r\n         function getKeyForCompilationSettings(settings: CompilerOptions): DocumentRegistryBucketKey {\r\n             return <DocumentRegistryBucketKey>`_${settings.target}|${settings.module}|${settings.noResolve}|${settings.jsx}|${settings.allowJs}|${settings.baseUrl}|${JSON.stringify(settings.typeRoots)}|${JSON.stringify(settings.rootDirs)}|${JSON.stringify(settings.paths)}`;\r\n         }\r\n \r\n         function getBucketForCompilationSettings(key: DocumentRegistryBucketKey, createIfMissing: boolean): FileMap<DocumentRegistryEntry> {\r\n-            let bucket = buckets[key];\r\n+            let bucket = buckets.get(key);\r\n             if (!bucket && createIfMissing) {\r\n-                buckets[key] = bucket = createFileMap<DocumentRegistryEntry>();\r\n+                buckets.set(key, bucket = createFileMap<DocumentRegistryEntry>());\r\n             }\r\n             return bucket;\r\n         }\r\n \r\n         function reportStats() {\r\n-            const bucketInfoArray = Object.keys(buckets).filter(name => name && name.charAt(0) === \"_\").map(name => {\r\n-                const entries = buckets[name];\r\n-                const sourceFiles: { name: string; refCount: number; references: string[]; }[] = [];\r\n-                entries.forEachValue((key, entry) => {\r\n-                    sourceFiles.push({\r\n-                        name: key,\r\n-                        refCount: entry.languageServiceRefCount,\r\n-                        references: entry.owners.slice(0)\r\n+            type Info = {\r\n+                bucket: string;\r\n+                sourceFiles: { name: string, refCount: number, references: string[] }[]\r\n+            };\r\n+\r\n+            const bucketInfoArray: Info[] = [];\r\n+            buckets.forEach((entries, name) => {\r\n+                if (name && name.charAt(0) === \"_\") {\r\n+                    const sourceFiles: { name: string; refCount: number; references: string[]; }[] = [];\r\n+                    entries.forEachValue((key, entry) => {\r\n+                        sourceFiles.push({\r\n+                            name: key,\r\n+                            refCount: entry.languageServiceRefCount,\r\n+                            references: entry.owners\r\n+                        });\r\n                     });\r\n-                });\r\n-                sourceFiles.sort((x, y) => y.refCount - x.refCount);\r\n-                return {\r\n-                    bucket: name,\r\n-                    sourceFiles\r\n-                };\r\n+                    sourceFiles.sort((x, y) => y.refCount - x.refCount);\r\n+                    bucketInfoArray.push({ bucket: name, sourceFiles });\r\n+                }\r\n             });\r\n+\r\n             return JSON.stringify(bucketInfoArray, undefined, 2);\r\n         }\r\n \r"},{"sha":"fa86aba26aaa4e0e73a35e1688f247f6caef0787","filename":"src/services/findAllReferences.ts","status":"modified","additions":16,"deletions":15,"changes":31,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2FfindAllReferences.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2FfindAllReferences.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fservices%2FfindAllReferences.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -96,7 +96,7 @@ namespace ts.FindAllReferences {\n \r\n                 const nameTable = getNameTable(sourceFile);\r\n \r\n-                if (nameTable[internedName] !== undefined) {\r\n+                if (nameTable.get(internedName) !== undefined) {\r\n                     result = result || [];\r\n                     getReferencesInNode(sourceFile, symbol, declaredName, node, searchMeaning, findInStrings, findInComments, result, symbolToIndex);\r\n                 }\r\n@@ -378,7 +378,7 @@ namespace ts.FindAllReferences {\n             const possiblePositions = getPossibleSymbolReferencePositions(sourceFile, searchText, start, container.getEnd());\r\n \r\n             const parents = getParentSymbolsOfPropertyAccess();\r\n-            const inheritsFromCache: Map<boolean> = createMap<boolean>();\r\n+            const inheritsFromCache = createMap<string, boolean>();\r\n \r\n             if (possiblePositions.length) {\r\n                 // Build the set of symbols to search for, initially it has only the current symbol\r\n@@ -501,14 +501,14 @@ namespace ts.FindAllReferences {\n             function findOwnConstructorCalls(classSymbol: Symbol): Node[] {\r\n                 const result: Node[] = [];\r\n \r\n-                for (const decl of classSymbol.members[\"__constructor\"].declarations) {\r\n+                for (const decl of classSymbol.members.get(\"__constructor\").declarations) {\r\n                     Debug.assert(decl.kind === SyntaxKind.Constructor);\r\n                     const ctrKeyword = decl.getChildAt(0);\r\n                     Debug.assert(ctrKeyword.kind === SyntaxKind.ConstructorKeyword);\r\n                     result.push(ctrKeyword);\r\n                 }\r\n \r\n-                forEachProperty(classSymbol.exports, member => {\r\n+                classSymbol.exports.forEach(member => {\r\n                     const decl = member.valueDeclaration;\r\n                     if (decl && decl.kind === SyntaxKind.MethodDeclaration) {\r\n                         const body = (<MethodDeclaration>decl).body;\r\n@@ -528,7 +528,7 @@ namespace ts.FindAllReferences {\n             /** Find references to `super` in the constructor of an extending class.  */\r\n             function superConstructorAccesses(cls: ClassLikeDeclaration): Node[] {\r\n                 const symbol = cls.symbol;\r\n-                const ctr = symbol.members[\"__constructor\"];\r\n+                const ctr = symbol.members.get(\"__constructor\");\r\n                 if (!ctr) {\r\n                     return [];\r\n                 }\r\n@@ -705,7 +705,7 @@ namespace ts.FindAllReferences {\n          * @param parent        Another class or interface Symbol\r\n          * @param cachedResults A map of symbol id pairs (i.e. \"child,parent\") to booleans indicating previous results\r\n          */\r\n-        function explicitlyInheritsFrom(child: Symbol, parent: Symbol, cachedResults: Map<boolean>): boolean {\r\n+        function explicitlyInheritsFrom(child: Symbol, parent: Symbol, cachedResults: Map<string, boolean>): boolean {\r\n             const parentIsInterface = parent.getFlags() & SymbolFlags.Interface;\r\n             return searchHierarchy(child);\r\n \r\n@@ -715,12 +715,13 @@ namespace ts.FindAllReferences {\n                 }\r\n \r\n                 const key = getSymbolId(symbol) + \",\" + getSymbolId(parent);\r\n-                if (key in cachedResults) {\r\n-                    return cachedResults[key];\r\n+                const cachedResult = cachedResults.get(key);\r\n+                if (cachedResult !== undefined) {\r\n+                    return cachedResult;\r\n                 }\r\n \r\n                 // Set the key so that we don't infinitely recurse\r\n-                cachedResults[key] = false;\r\n+                cachedResults.set(key, false);\r\n \r\n                 const inherits = forEach(symbol.getDeclarations(), declaration => {\r\n                     if (isClassLike(declaration)) {\r\n@@ -744,7 +745,7 @@ namespace ts.FindAllReferences {\n                     return false;\r\n                 });\r\n \r\n-                cachedResults[key] = inherits;\r\n+                cachedResults.set(key, inherits);\r\n                 return inherits;\r\n             }\r\n \r\n@@ -1046,7 +1047,7 @@ namespace ts.FindAllReferences {\n \r\n                 // Add symbol of properties/methods of the same name in base classes and implemented interfaces definitions\r\n                 if (!implementations && rootSymbol.parent && rootSymbol.parent.flags & (SymbolFlags.Class | SymbolFlags.Interface)) {\r\n-                    getPropertySymbolsFromBaseTypes(rootSymbol.parent, rootSymbol.getName(), result, /*previousIterationSymbolsCache*/ createMap<Symbol>());\r\n+                    getPropertySymbolsFromBaseTypes(rootSymbol.parent, rootSymbol.getName(), result, /*previousIterationSymbolsCache*/ createMap<string, Symbol>());\r\n                 }\r\n             });\r\n \r\n@@ -1078,7 +1079,7 @@ namespace ts.FindAllReferences {\n             // the function will add any found symbol of the property-name, then its sub-routine will call\r\n             // getPropertySymbolsFromBaseTypes again to walk up any base types to prevent revisiting already\r\n             // visited symbol, interface \"C\", the sub-routine will pass the current symbol as previousIterationSymbol.\r\n-            if (symbol.name in previousIterationSymbolsCache) {\r\n+            if (previousIterationSymbolsCache.has(symbol.name)) {\r\n                 return;\r\n             }\r\n \r\n@@ -1105,14 +1106,14 @@ namespace ts.FindAllReferences {\n                         }\r\n \r\n                         // Visit the typeReference as well to see if it directly or indirectly use that property\r\n-                        previousIterationSymbolsCache[symbol.name] = symbol;\r\n+                        previousIterationSymbolsCache.set(symbol.name, symbol);\r\n                         getPropertySymbolsFromBaseTypes(type.symbol, propertyName, result, previousIterationSymbolsCache);\r\n                     }\r\n                 }\r\n             }\r\n         }\r\n \r\n-        function getRelatedSymbol(searchSymbols: Symbol[], referenceSymbol: Symbol, referenceLocation: Node, searchLocationIsConstructor: boolean, parents: Symbol[] | undefined, cache: Map<boolean>): Symbol {\r\n+        function getRelatedSymbol(searchSymbols: Symbol[], referenceSymbol: Symbol, referenceLocation: Node, searchLocationIsConstructor: boolean, parents: Symbol[] | undefined, cache: Map<string, boolean>): Symbol {\r\n             if (contains(searchSymbols, referenceSymbol)) {\r\n                 // If we are searching for constructor uses, they must be 'new' expressions.\r\n                 return (!searchLocationIsConstructor || isNewExpressionTarget(referenceLocation)) && referenceSymbol;\r\n@@ -1176,7 +1177,7 @@ namespace ts.FindAllReferences {\n                     }\r\n \r\n                     const result: Symbol[] = [];\r\n-                    getPropertySymbolsFromBaseTypes(rootSymbol.parent, rootSymbol.getName(), result, /*previousIterationSymbolsCache*/ createMap<Symbol>());\r\n+                    getPropertySymbolsFromBaseTypes(rootSymbol.parent, rootSymbol.getName(), result, /*previousIterationSymbolsCache*/ createMap<string, Symbol>());\r\n                     return forEach(result, s => searchSymbols.indexOf(s) >= 0 ? s : undefined);\r\n                 }\r\n \r"},{"sha":"215289159c2891b932053daaea7aa9683f944cec","filename":"src/services/formatting/rules.ts","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2Fformatting%2Frules.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2Fformatting%2Frules.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fservices%2Fformatting%2Frules.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -4,7 +4,7 @@\n namespace ts.formatting {\r\n     export class Rules {\r\n         public getRuleName(rule: Rule) {\r\n-            const o: ts.Map<any> = <any>this;\r\n+            const o: ts.MapLike<any> = <any>this;\r\n             for (const name in o) {\r\n                 if (o[name] === rule) {\r\n                     return name;\r"},{"sha":"d6ade7aed6bd9841a51767563cbf0931d88dd56d","filename":"src/services/goToDefinition.ts","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2FgoToDefinition.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2FgoToDefinition.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fservices%2FgoToDefinition.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -14,7 +14,7 @@ namespace ts.GoToDefinition {\n         // Type reference directives\r\n         const typeReferenceDirective = findReferenceInPosition(sourceFile.typeReferenceDirectives, position);\r\n         if (typeReferenceDirective) {\r\n-            const referenceFile = program.getResolvedTypeReferenceDirectives()[typeReferenceDirective.fileName];\r\n+            const referenceFile = program.getResolvedTypeReferenceDirectives().get(typeReferenceDirective.fileName);\r\n             if (referenceFile && referenceFile.resolvedFileName) {\r\n                 return [getDefinitionInfoForFileReference(typeReferenceDirective.fileName, referenceFile.resolvedFileName)];\r\n             }\r"},{"sha":"a4841a17752b0d5c85d4d2bd7f6434cf3aaa4d7a","filename":"src/services/jsTyping.ts","status":"modified","additions":26,"deletions":25,"changes":51,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2FjsTyping.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2FjsTyping.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fservices%2FjsTyping.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -17,19 +17,19 @@ namespace ts.JsTyping {\n \r\n     interface PackageJson {\r\n         _requiredBy?: string[];\r\n-        dependencies?: Map<string>;\r\n-        devDependencies?: Map<string>;\r\n+        dependencies?: MapLike<string>;\r\n+        devDependencies?: MapLike<string>;\r\n         name?: string;\r\n-        optionalDependencies?: Map<string>;\r\n-        peerDependencies?: Map<string>;\r\n+        optionalDependencies?: MapLike<string>;\r\n+        peerDependencies?: MapLike<string>;\r\n         typings?: string;\r\n     };\r\n \r\n     // A map of loose file names to library names\r\n     // that we are confident require typings\r\n-    let safeList: Map<string>;\r\n+    let safeList: Map<string, string>;\r\n \r\n-    const EmptySafeList: Map<string> = createMap<string>();\r\n+    const EmptySafeList = createMap<string, string>();\r\n \r\n     /* @internal */\r\n     export const nodeCoreModuleList: ReadonlyArray<string> = [\r\n@@ -56,13 +56,13 @@ namespace ts.JsTyping {\n         fileNames: string[],\r\n         projectRootPath: Path,\r\n         safeListPath: Path,\r\n-        packageNameToTypingLocation: Map<string>,\r\n+        packageNameToTypingLocation: Map<string, string>,\r\n         typingOptions: TypingOptions,\r\n         unresolvedImports: ReadonlyArray<string>):\r\n         { cachedTypingPaths: string[], newTypingNames: string[], filesToWatch: string[] } {\r\n \r\n         // A typing name to typing file path mapping\r\n-        const inferredTypings = createMap<string>();\r\n+        const inferredTypings = createMap<string, string | undefined>();\r\n \r\n         if (!typingOptions || !typingOptions.enableAutoDiscovery) {\r\n             return { cachedTypingPaths: [], newTypingNames: [], filesToWatch: [] };\r\n@@ -76,7 +76,7 @@ namespace ts.JsTyping {\n \r\n         if (!safeList) {\r\n             const result = readConfigFile(safeListPath, (path: string) => host.readFile(path));\r\n-            safeList = result.config ? createMap<string>(result.config) : EmptySafeList;\r\n+            safeList = result.config ? mapOfMapLike<string>(result.config) : EmptySafeList;\r\n         }\r\n \r\n         const filesToWatch: string[] = [];\r\n@@ -107,34 +107,35 @@ namespace ts.JsTyping {\n         // add typings for unresolved imports\r\n         if (unresolvedImports) {\r\n             for (const moduleId of unresolvedImports) {\r\n-                const typingName = moduleId in nodeCoreModules ? \"node\" : moduleId;\r\n-                if (!(typingName in inferredTypings)) {\r\n-                    inferredTypings[typingName] = undefined;\r\n+                const typingName = nodeCoreModules.has(moduleId) ? \"node\" : moduleId;\r\n+                if (!inferredTypings.has(typingName)) {\r\n+                    inferredTypings.set(typingName, undefined);\r\n                 }\r\n             }\r\n         }\r\n         // Add the cached typing locations for inferred typings that are already installed\r\n-        for (const name in packageNameToTypingLocation) {\r\n-            if (name in inferredTypings && !inferredTypings[name]) {\r\n-                inferredTypings[name] = packageNameToTypingLocation[name];\r\n+        packageNameToTypingLocation.forEach((typingLocation, name) => {\r\n+            if (inferredTypings.has(name) && inferredTypings.get(name) === undefined) {\r\n+                inferredTypings.set(name, typingLocation);\r\n             }\r\n-        }\r\n+        });\r\n \r\n         // Remove typings that the user has added to the exclude list\r\n         for (const excludeTypingName of exclude) {\r\n-            delete inferredTypings[excludeTypingName];\r\n+            inferredTypings.delete(excludeTypingName);\r\n         }\r\n \r\n         const newTypingNames: string[] = [];\r\n         const cachedTypingPaths: string[] = [];\r\n-        for (const typing in inferredTypings) {\r\n-            if (inferredTypings[typing] !== undefined) {\r\n-                cachedTypingPaths.push(inferredTypings[typing]);\r\n+\r\n+        inferredTypings.forEach((inferredTyping, typing) => {\r\n+            if (inferredTyping !== undefined) {\r\n+                cachedTypingPaths.push(inferredTyping);\r\n             }\r\n             else {\r\n                 newTypingNames.push(typing);\r\n             }\r\n-        }\r\n+        });\r\n         return { cachedTypingPaths, newTypingNames, filesToWatch };\r\n \r\n         /**\r\n@@ -146,8 +147,8 @@ namespace ts.JsTyping {\n             }\r\n \r\n             for (const typing of typingNames) {\r\n-                if (!(typing in inferredTypings)) {\r\n-                    inferredTypings[typing] = undefined;\r\n+                if (!inferredTypings.has(typing)) {\r\n+                    inferredTypings.set(typing, undefined);\r\n                 }\r\n             }\r\n         }\r\n@@ -189,7 +190,7 @@ namespace ts.JsTyping {\n             const cleanedTypingNames = map(inferredTypingNames, f => f.replace(/((?:\\.|-)min(?=\\.|$))|((?:-|\\.)\\d+)/g, \"\"));\r\n \r\n             if (safeList !== EmptySafeList) {\r\n-                mergeTypings(filter(cleanedTypingNames, f => f in safeList));\r\n+                mergeTypings(filter(cleanedTypingNames, f => safeList.has(f)));\r\n             }\r\n \r\n             const hasJsxFile = forEach(fileNames, f => ensureScriptKind(f, getScriptKindFromFileName(f)) === ScriptKind.JSX);\r\n@@ -236,7 +237,7 @@ namespace ts.JsTyping {\n                 }\r\n                 if (packageJson.typings) {\r\n                     const absolutePath = getNormalizedAbsolutePath(packageJson.typings, getDirectoryPath(normalizedFileName));\r\n-                    inferredTypings[packageJson.name] = absolutePath;\r\n+                    inferredTypings.set(packageJson.name, absolutePath);\r\n                 }\r\n                 else {\r\n                     typingNames.push(packageJson.name);\r"},{"sha":"dbe32d84baf18325d58a50c5284141d43ae41cf2","filename":"src/services/navigateTo.ts","status":"modified","additions":9,"deletions":10,"changes":19,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2FnavigateTo.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2FnavigateTo.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fservices%2FnavigateTo.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -7,23 +7,22 @@ namespace ts.NavigateTo {\n         let rawItems: RawNavigateToItem[] = [];\r\n \r\n         // Search the declarations in all files and output matched NavigateToItem into array of NavigateToItem[]\r\n-        forEach(sourceFiles, sourceFile => {\r\n+        for (const sourceFile of sourceFiles) {\r\n             cancellationToken.throwIfCancellationRequested();\r\n \r\n             if (excludeDtsFiles && fileExtensionIs(sourceFile.fileName, \".d.ts\")) {\r\n-                return;\r\n+                continue;\r\n             }\r\n \r\n-            const nameToDeclarations = sourceFile.getNamedDeclarations();\r\n-            for (const name in nameToDeclarations) {\r\n-                const declarations = nameToDeclarations[name];\r\n+            // Use `someInMap` to break out early.\r\n+            someInMap(sourceFile.getNamedDeclarations(), (declarations, name) => {\r\n                 if (declarations) {\r\n                     // First do a quick check to see if the name of the declaration matches the\r\n                     // last portion of the (possibly) dotted name they're searching for.\r\n                     let matches = patternMatcher.getMatchesForLastSegmentOfPattern(name);\r\n \r\n                     if (!matches) {\r\n-                        continue;\r\n+                        return false;\r\n                     }\r\n \r\n                     for (const declaration of declarations) {\r\n@@ -32,13 +31,13 @@ namespace ts.NavigateTo {\n                         if (patternMatcher.patternContainsDots) {\r\n                             const containers = getContainers(declaration);\r\n                             if (!containers) {\r\n-                                return undefined;\r\n+                                return true; // Go to the next source file.\r\n                             }\r\n \r\n                             matches = patternMatcher.getMatches(containers, name);\r\n \r\n                             if (!matches) {\r\n-                                continue;\r\n+                                return false;\r\n                             }\r\n                         }\r\n \r\n@@ -47,8 +46,8 @@ namespace ts.NavigateTo {\n                         rawItems.push({ name, fileName, matchKind, isCaseSensitive: allMatchesAreCaseSensitive(matches), declaration });\r\n                     }\r\n                 }\r\n-            }\r\n-        });\r\n+            });\r\n+        }\r\n \r\n         // Remove imports when the imported declaration is already in the list and has the same name.\r\n         rawItems = filter(rawItems, item => {\r"},{"sha":"00472f46c74bb31bd0021dcdeca8c582ff1a84f4","filename":"src/services/navigationBar.ts","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2FnavigationBar.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2FnavigationBar.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fservices%2FnavigationBar.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -239,7 +239,7 @@ namespace ts.NavigationBar {\n \r\n     /** Merge declarations of the same kind. */\r\n     function mergeChildren(children: NavigationBarNode[]): void {\r\n-        const nameToItems = createMap<NavigationBarNode | NavigationBarNode[]>();\r\n+        const nameToItems = createMap<string, NavigationBarNode | NavigationBarNode[]>();\r\n         filterMutate(children, child => {\r\n             const decl = <Declaration>child.node;\r\n             const name = decl.name && nodeText(decl.name);\r\n@@ -248,9 +248,9 @@ namespace ts.NavigationBar {\n                 return true;\r\n             }\r\n \r\n-            const itemsWithSameName = nameToItems[name];\r\n+            const itemsWithSameName = nameToItems.get(name);\r\n             if (!itemsWithSameName) {\r\n-                nameToItems[name] = child;\r\n+                nameToItems.set(name, child);\r\n                 return true;\r\n             }\r\n \r\n@@ -268,7 +268,7 @@ namespace ts.NavigationBar {\n                 if (tryMerge(itemWithSameName, child)) {\r\n                     return false;\r\n                 }\r\n-                nameToItems[name] = [itemWithSameName, child];\r\n+                nameToItems.set(name, [itemWithSameName, child]);\r\n                 return true;\r\n             }\r\n \r\n@@ -626,15 +626,15 @@ namespace ts.NavigationBar {\n \r\n     /**\r\n      * Matches all whitespace characters in a string. Eg:\r\n-     * \r\n+     *\r\n      * \"app.\r\n-     * \r\n+     *\r\n      * onactivated\"\r\n-     * \r\n+     *\r\n      * matches because of the newline, whereas\r\n-     * \r\n+     *\r\n      * \"app.onactivated\"\r\n-     * \r\n+     *\r\n      * does not match.\r\n      */\r\n     const whiteSpaceRegex = /\\s+/g;\r"},{"sha":"cf107d8984bf37097a08765e441b4674d01706ed","filename":"src/services/patternMatcher.ts","status":"modified","additions":2,"deletions":6,"changes":8,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2FpatternMatcher.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2FpatternMatcher.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fservices%2FpatternMatcher.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -113,7 +113,7 @@ namespace ts {\n         // we see the name of a module that is used everywhere, or the name of an overload).  As\r\n         // such, we cache the information we compute about the candidate for the life of this\r\n         // pattern matcher so we don't have to compute it multiple times.\r\n-        const stringToWordSpans = createMap<TextSpan[]>();\r\n+        const stringToWordSpans = createMap<string, TextSpan[]>();\r\n \r\n         pattern = pattern.trim();\r\n \r\n@@ -188,11 +188,7 @@ namespace ts {\n         }\r\n \r\n         function getWordSpans(word: string): TextSpan[] {\r\n-            if (!(word in stringToWordSpans)) {\r\n-                stringToWordSpans[word] = breakIntoWordSpans(word);\r\n-            }\r\n-\r\n-            return stringToWordSpans[word];\r\n+            return getOrUpdate(stringToWordSpans, word, breakIntoWordSpans);\r\n         }\r\n \r\n         function matchTextChunk(candidate: string, chunk: TextChunk, punctuationStripped: boolean): PatternMatch {\r"},{"sha":"ac77391cc1211535decf6dbc9d154eb7bf2274eb","filename":"src/services/services.ts","status":"modified","additions":14,"deletions":14,"changes":28,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2Fservices.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2Fservices.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fservices%2Fservices.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -465,13 +465,13 @@ namespace ts {\n         public scriptKind: ScriptKind;\r\n         public languageVersion: ScriptTarget;\r\n         public languageVariant: LanguageVariant;\r\n-        public identifiers: Map<string>;\r\n-        public nameTable: Map<number>;\r\n-        public resolvedModules: Map<ResolvedModuleFull>;\r\n-        public resolvedTypeReferenceDirectiveNames: Map<ResolvedTypeReferenceDirective>;\r\n+        public identifiers: Map<string, string>;\r\n+        public nameTable: Map<string, number>;\r\n+        public resolvedModules: Map<string, ResolvedModuleFull>;\r\n+        public resolvedTypeReferenceDirectiveNames: Map<string, ResolvedTypeReferenceDirective>;\r\n         public imports: LiteralExpression[];\r\n         public moduleAugmentations: LiteralExpression[];\r\n-        private namedDeclarations: Map<Declaration[]>;\r\n+        private namedDeclarations: Map<string, Declaration[]>;\r\n \r\n         constructor(kind: SyntaxKind, pos: number, end: number) {\r\n             super(kind, pos, end);\r\n@@ -493,16 +493,16 @@ namespace ts {\n             return ts.getPositionOfLineAndCharacter(this, line, character);\r\n         }\r\n \r\n-        public getNamedDeclarations(): Map<Declaration[]> {\r\n+        public getNamedDeclarations(): Map<string, Declaration[]> {\r\n             if (!this.namedDeclarations) {\r\n                 this.namedDeclarations = this.computeNamedDeclarations();\r\n             }\r\n \r\n             return this.namedDeclarations;\r\n         }\r\n \r\n-        private computeNamedDeclarations(): Map<Declaration[]> {\r\n-            const result = createMap<Declaration[]>();\r\n+        private computeNamedDeclarations(): Map<string, Declaration[]> {\r\n+            const result = createMap<string, Declaration[]>();\r\n \r\n             forEachChild(this, visit);\r\n \r\n@@ -516,7 +516,7 @@ namespace ts {\n             }\r\n \r\n             function getDeclarations(name: string) {\r\n-                return result[name] || (result[name] = []);\r\n+                return getOrUpdate(result, name, () => []);\r\n             }\r\n \r\n             function getDeclarationName(declaration: Declaration) {\r\n@@ -967,7 +967,7 @@ namespace ts {\n         const currentDirectory = host.getCurrentDirectory();\r\n         // Check if the localized messages json is set, otherwise query the host for it\r\n         if (!localizedDiagnosticMessages && host.getLocalizedDiagnosticMessages) {\r\n-            localizedDiagnosticMessages = host.getLocalizedDiagnosticMessages();\r\n+            localizedDiagnosticMessages = mapOfMapLike<string>(host.getLocalizedDiagnosticMessages());\r\n         }\r\n \r\n         function log(message: string) {\r\n@@ -1922,7 +1922,7 @@ namespace ts {\n     }\r\n \r\n     /* @internal */\r\n-    export function getNameTable(sourceFile: SourceFile): Map<number> {\r\n+    export function getNameTable(sourceFile: SourceFile): Map<string, number> {\r\n         if (!sourceFile.nameTable) {\r\n             initializeNameTable(sourceFile);\r\n         }\r\n@@ -1931,15 +1931,15 @@ namespace ts {\n     }\r\n \r\n     function initializeNameTable(sourceFile: SourceFile): void {\r\n-        const nameTable = createMap<number>();\r\n+        const nameTable = createMap<string, number>();\r\n \r\n         walk(sourceFile);\r\n         sourceFile.nameTable = nameTable;\r\n \r\n         function walk(node: Node) {\r\n             switch (node.kind) {\r\n                 case SyntaxKind.Identifier:\r\n-                    nameTable[(<Identifier>node).text] = nameTable[(<Identifier>node).text] === undefined ? node.pos : -1;\r\n+                    nameTable.set((<Identifier>node).text, nameTable.get((<Identifier>node).text) === undefined ? node.pos : -1);\r\n                     break;\r\n                 case SyntaxKind.StringLiteral:\r\n                 case SyntaxKind.NumericLiteral:\r\n@@ -1952,7 +1952,7 @@ namespace ts {\n                         isArgumentOfElementAccessExpression(node) ||\r\n                         isLiteralComputedPropertyDeclarationName(node)) {\r\n \r\n-                        nameTable[(<LiteralExpression>node).text] = nameTable[(<LiteralExpression>node).text] === undefined ? node.pos : -1;\r\n+                        nameTable.set((<LiteralExpression>node).text, nameTable.get((<LiteralExpression>node).text) === undefined ? node.pos : -1);\r\n                     }\r\n                     break;\r\n                 default:\r"},{"sha":"8e9155d3eede201e99157f91b9b87348f4b60fc9","filename":"src/services/shims.ts","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2Fshims.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2Fshims.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fservices%2Fshims.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -1167,7 +1167,7 @@ namespace ts {\n                     info.fileNames,\r\n                     toPath(info.projectRootPath, info.projectRootPath, getCanonicalFileName),\r\n                     toPath(info.safeListPath, info.safeListPath, getCanonicalFileName),\r\n-                    info.packageNameToTypingLocation,\r\n+                    mapOfMapLike(info.packageNameToTypingLocation),\r\n                     info.typingOptions,\r\n                     info.unresolvedImports);\r\n             });\r"},{"sha":"3562169ac7af6e7064be1d590d64e2d3d4fe4645","filename":"src/services/signatureHelp.ts","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2FsignatureHelp.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2FsignatureHelp.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fservices%2FsignatureHelp.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -237,7 +237,7 @@ namespace ts.SignatureHelp {\n         const typeChecker = program.getTypeChecker();\r\n         for (const sourceFile of program.getSourceFiles()) {\r\n             const nameToDeclarations = sourceFile.getNamedDeclarations();\r\n-            const declarations = nameToDeclarations[name.text];\r\n+            const declarations = nameToDeclarations.get(name.text);\r\n \r\n             if (declarations) {\r\n                 for (const declaration of declarations) {\r"},{"sha":"c327186613fb68689f92a5d076c9c4a38d986ceb","filename":"src/services/transpile.ts","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2Ftranspile.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2Ftranspile.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fservices%2Ftranspile.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -63,7 +63,7 @@ namespace ts {\n         }\r\n \r\n         if (transpileOptions.renamedDependencies) {\r\n-            sourceFile.renamedDependencies = createMap(transpileOptions.renamedDependencies);\r\n+            sourceFile.renamedDependencies = mapOfMapLike(transpileOptions.renamedDependencies);\r\n         }\r\n \r\n         const newLine = getNewLineCharacter(options);\r\n@@ -126,7 +126,7 @@ namespace ts {\n     function fixupCompilerOptions(options: CompilerOptions, diagnostics: Diagnostic[]): CompilerOptions {\r\n         // Lazily create this value to fix module loading errors.\r\n         commandLineOptionsStringToEnum = commandLineOptionsStringToEnum || <CommandLineOptionOfCustomType[]>filter(optionDeclarations, o =>\r\n-            typeof o.type === \"object\" && !forEachProperty(o.type, v => typeof v !== \"number\"));\r\n+            typeof o.type === \"object\" && !someValueInMap(o.type, v => typeof v !== \"number\"));\r\n \r\n         options = clone(options);\r\n \r\n@@ -142,7 +142,7 @@ namespace ts {\n                 options[opt.name] = parseCustomTypeOption(opt, value, diagnostics);\r\n             }\r\n             else {\r\n-                if (!forEachProperty(opt.type, v => v === value)) {\r\n+                if (!someValueInMap(opt.type, v => v === value)) {\r\n                     // Supplied value isn't a valid enum value.\r\n                     diagnostics.push(createCompilerDiagnosticForInvalidCustomType(opt));\r\n                 }\r"},{"sha":"9989aebaec6c8460ff4384e8b611ddbd78ee2192","filename":"src/services/types.ts","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2Ftypes.ts","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/src%2Fservices%2Ftypes.ts","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/src%2Fservices%2Ftypes.ts?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -48,9 +48,9 @@ namespace ts {\n     export interface SourceFile {\r\n         /* @internal */ version: string;\r\n         /* @internal */ scriptSnapshot: IScriptSnapshot;\r\n-        /* @internal */ nameTable: Map<number>;\r\n+        /* @internal */ nameTable: Map<string, number>;\r\n \r\n-        /* @internal */ getNamedDeclarations(): Map<Declaration[]>;\r\n+        /* @internal */ getNamedDeclarations(): Map<string, Declaration[]>;\r\n \r\n         getLineAndCharacterOfPosition(pos: number): LineAndCharacter;\r\n         getLineStarts(): number[];\r"},{"sha":"d33b87381c8593ac088315defef3bd050086bae1","filename":"tslint.json","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/microsoft/TypeScript/blob/bcc0807198ca89a80878e50bb9fd9258c6970d07/tslint.json","raw_url":"https://github.com/microsoft/TypeScript/raw/bcc0807198ca89a80878e50bb9fd9258c6970d07/tslint.json","contents_url":"https://api.github.com/repos/microsoft/TypeScript/contents/tslint.json?ref=bcc0807198ca89a80878e50bb9fd9258c6970d07","patch":"@@ -47,6 +47,7 @@\n         \"prefer-const\": true,\r\n         \"no-increment-decrement\": true,\r\n         \"object-literal-surrounding-space\": true,\r\n-        \"no-type-assertion-whitespace\": true\r\n+        \"no-type-assertion-whitespace\": true,\r\n+        \"no-in-operator\": true\r\n   }\r\n }\r"}]}]