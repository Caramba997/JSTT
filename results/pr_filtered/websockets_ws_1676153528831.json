[{"url":"https://api.github.com/repos/websockets/ws/issues/811","repository_url":"https://api.github.com/repos/websockets/ws","labels_url":"https://api.github.com/repos/websockets/ws/issues/811/labels{/name}","comments_url":"https://api.github.com/repos/websockets/ws/issues/811/comments","events_url":"https://api.github.com/repos/websockets/ws/issues/811/events","html_url":"https://github.com/websockets/ws/pull/811","id":172251779,"node_id":"MDExOlB1bGxSZXF1ZXN0ODIwNjgwNDU=","number":811,"title":"increased performance of frameAndSend","user":{"login":"JoshuaWise","id":8255757,"node_id":"MDQ6VXNlcjgyNTU3NTc=","avatar_url":"https://avatars.githubusercontent.com/u/8255757?v=4","gravatar_id":"","url":"https://api.github.com/users/JoshuaWise","html_url":"https://github.com/JoshuaWise","followers_url":"https://api.github.com/users/JoshuaWise/followers","following_url":"https://api.github.com/users/JoshuaWise/following{/other_user}","gists_url":"https://api.github.com/users/JoshuaWise/gists{/gist_id}","starred_url":"https://api.github.com/users/JoshuaWise/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JoshuaWise/subscriptions","organizations_url":"https://api.github.com/users/JoshuaWise/orgs","repos_url":"https://api.github.com/users/JoshuaWise/repos","events_url":"https://api.github.com/users/JoshuaWise/events{/privacy}","received_events_url":"https://api.github.com/users/JoshuaWise/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2016-08-20T03:57:10Z","updated_at":"2021-04-07T16:07:00Z","closed_at":"2016-09-15T10:38:44Z","author_association":"MEMBER","active_lock_reason":null,"draft":false,"pull_request":{"url":"https://api.github.com/repos/websockets/ws/pulls/811","html_url":"https://github.com/websockets/ws/pull/811","diff_url":"https://github.com/websockets/ws/pull/811.diff","patch_url":"https://github.com/websockets/ws/pull/811.patch","merged_at":"2016-09-15T10:38:44Z"},"body":"The V8 engine optimizes code on a per-function basis. But it can't optimize functions that have a `try {} catch {}` block in them. Because of this, `frameAndSend()` was not getting optimized. And I don't know about you, but I'd say that's a pretty important function for optimization.\n\nTo fix this, I moved the `try {} catch {}` block into a separate function.\n\nAlso, when converting from ArrayBuffers/TypedArrays to Buffers, the data was being copied in memory, which has a speed of _O(n)_. With this pull request, converting between the two will no longer copy the memory, which is much faster; _O(1)_.\n\nAlso, I renamed the function `getArrayBuffer` to `getBufferFromNative` to better describe what it actually does.\n","reactions":{"url":"https://api.github.com/repos/websockets/ws/issues/811/reactions","total_count":3,"+1":3,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/websockets/ws/issues/811/timeline","performed_via_github_app":null,"state_reason":null,"score":1,"files":[{"sha":"0fc1d4f634718e6f14db3fa5e9c0eef80b82e287","filename":"bench/sender.benchmark.js","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/websockets/ws/blob/becd825443537d2410c915dd55f47c02798aa213/bench%2Fsender.benchmark.js","raw_url":"https://github.com/websockets/ws/raw/becd825443537d2410c915dd55f47c02798aa213/bench%2Fsender.benchmark.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/bench%2Fsender.benchmark.js?ref=becd825443537d2410c915dd55f47c02798aa213","patch":"@@ -20,6 +20,7 @@ require('./util');\n  * Setup sender.\n  */\n \n+var sender;\n suite.on('start', function () {\n   sender = new Sender();\n   sender._socket = { write: function() {} };\n@@ -34,7 +35,7 @@ suite.on('cycle', function () {\n  * Benchmarks\n  */\n \n-framePacket = new Buffer(200*1024);\n+var framePacket = new Buffer(200*1024);\n framePacket.fill(99);\n suite.add('frameAndSend, unmasked (200 kB)', function () {\n   sender.frameAndSend(0x2, framePacket, true, false);"},{"sha":"adce2c0c09d9d79b7d2b43875fe0e9dc8211767e","filename":"bench/util.js","status":"modified","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/websockets/ws/blob/becd825443537d2410c915dd55f47c02798aa213/bench%2Futil.js","raw_url":"https://github.com/websockets/ws/raw/becd825443537d2410c915dd55f47c02798aa213/bench%2Futil.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/bench%2Futil.js?ref=becd825443537d2410c915dd55f47c02798aa213","patch":"@@ -10,7 +10,7 @@\n  * Returns a Buffer from a \"ff 00 ff\"-type hex string.\n  */\n \n-getBufferFromHexString = function(byteStr) {\n+global.getBufferFromHexString = function(byteStr) {\n   var bytes = byteStr.split(' ');\n   var buf = new Buffer(bytes.length);\n   for (var i = 0; i < bytes.length; ++i) {\n@@ -23,7 +23,7 @@ getBufferFromHexString = function(byteStr) {\n  * Returns a hex string from a Buffer.\n  */\n \n-getHexStringFromBuffer = function(data) {\n+global.getHexStringFromBuffer = function(data) {\n   var s = '';\n   for (var i = 0; i < data.length; ++i) {\n     s += padl(data[i].toString(16), 2, '0') + ' ';\n@@ -35,7 +35,7 @@ getHexStringFromBuffer = function(data) {\n  * Splits a buffer in two parts.\n  */\n \n-splitBuffer = function(buffer) {\n+global.splitBuffer = function(buffer) {\n   var b1 = new Buffer(Math.ceil(buffer.length / 2));\n   buffer.copy(b1, 0, 0, b1.length);\n   var b2 = new Buffer(Math.floor(buffer.length / 2));\n@@ -47,7 +47,7 @@ splitBuffer = function(buffer) {\n  * Performs hybi07+ type masking on a hex string or buffer.\n  */\n \n-mask = function(buf, maskString) {\n+global.mask = function(buf, maskString) {\n   if (typeof buf == 'string') buf = new Buffer(buf);\n   var mask = getBufferFromHexString(maskString || '34 83 a8 68');\n   for (var i = 0; i < buf.length; ++i) {\n@@ -60,7 +60,7 @@ mask = function(buf, maskString) {\n  * Returns a hex string representing the length of a message\n  */\n \n-getHybiLengthAsHexString = function(len, masked) {\n+global.getHybiLengthAsHexString = function(len, masked) {\n   if (len < 126) {\n     var buf = new Buffer(1);\n     buf[0] = (masked ? 0x80 : 0) | len;\n@@ -82,7 +82,7 @@ getHybiLengthAsHexString = function(len, masked) {\n  * Unpacks a Buffer into a number.\n  */\n \n-unpack = function(buffer) {\n+global.unpack = function(buffer) {\n   var n = 0;\n   for (var i = 0; i < buffer.length; ++i) {\n     n = (i == 0) ? buffer[i] : (n * 256) + buffer[i];\n@@ -94,14 +94,14 @@ unpack = function(buffer) {\n  * Returns a hex string, representing a specific byte count 'length', from a number.\n  */\n \n-pack = function(length, number) {\n+global.pack = function(length, number) {\n   return padl(number.toString(16), length, '0').replace(/([0-9a-f][0-9a-f])/gi, '$1 ').trim();\n }\n \n /**\n  * Left pads the string 's' to a total length of 'n' with char 'c'.\n  */\n \n-padl = function(s, n, c) {\n+global.padl = function(s, n, c) {\n   return new Array(1 + n - s.length).join(c) + s;\n }"},{"sha":"f5bbc101cee722d8c5ebfd6c47b05c8d844a11cf","filename":"lib/Sender.js","status":"modified","additions":28,"deletions":57,"changes":85,"blob_url":"https://github.com/websockets/ws/blob/becd825443537d2410c915dd55f47c02798aa213/lib%2FSender.js","raw_url":"https://github.com/websockets/ws/raw/becd825443537d2410c915dd55f47c02798aa213/lib%2FSender.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/lib%2FSender.js?ref=becd825443537d2410c915dd55f47c02798aa213","patch":"@@ -127,24 +127,17 @@ class Sender extends EventEmitter {\n     var canModifyData = false;\n \n     if (!data) {\n-\n-      try {\n-        var buff = [opcode | (finalFragment ? 0x80 : 0), 0 | (maskData ? 0x80 : 0)]\n-          .concat(maskData ? [0, 0, 0, 0] : []);\n-        this._socket.write(new Buffer(buff), 'binary', cb);\n-      }\n-      catch (e) {\n-        if (typeof cb == 'function') cb(e);\n-        else this.emit('error', e);\n-      }\n+      var buff = [opcode | (finalFragment ? 0x80 : 0), 0 | (maskData ? 0x80 : 0)]\n+        .concat(maskData ? [0, 0, 0, 0] : []);\n+      sendFramedData.call(this, new Buffer(buff), null, cb);\n       return;\n     }\n \n     if (!Buffer.isBuffer(data)) {\n-      canModifyData = true;\n-      if (data && (typeof data.byteLength !== 'undefined' || typeof data.buffer !== 'undefined')) {\n-        data = getArrayBuffer(data);\n+      if (data && (data.buffer || data) instanceof ArrayBuffer) {\n+        data = getBufferFromNative(data);\n       } else {\n+        canModifyData = true;\n         //\n         // If people want to send a number, this would allocate the number in\n         // bytes as memory size instead of storing the number as buffer value. So\n@@ -194,49 +187,17 @@ class Sender extends EventEmitter {\n       outputBuffer[dataOffset - 1] = mask[3];\n       if (mergeBuffers) {\n         bufferUtil.mask(data, mask, outputBuffer, dataOffset, dataLength);\n-        try {\n-          this._socket.write(outputBuffer, 'binary', cb);\n-        }\n-        catch (e) {\n-          if (typeof cb == 'function') cb(e);\n-          else this.emit('error', e);\n-        }\n-      }\n-      else {\n+      } else {\n         bufferUtil.mask(data, mask, data, 0, dataLength);\n-        try {\n-          this._socket.write(outputBuffer, 'binary');\n-          this._socket.write(data, 'binary', cb);\n-        }\n-        catch (e) {\n-          if (typeof cb == 'function') cb(e);\n-          else this.emit('error', e);\n-        }\n       }\n     }\n     else {\n       outputBuffer[1] = secondByte;\n       if (mergeBuffers) {\n         data.copy(outputBuffer, dataOffset);\n-        try {\n-          this._socket.write(outputBuffer, 'binary', cb);\n-        }\n-        catch (e) {\n-          if (typeof cb == 'function') cb(e);\n-          else this.emit('error', e);\n-        }\n-      }\n-      else {\n-        try {\n-          this._socket.write(outputBuffer, 'binary');\n-          this._socket.write(data, 'binary', cb);\n-        }\n-        catch (e) {\n-          if (typeof cb == 'function') cb(e);\n-          else this.emit('error', e);\n-        }\n       }\n     }\n+    sendFramedData.call(this, outputBuffer, mergeBuffers ? null : data, cb);\n   }\n \n   /**\n@@ -268,7 +229,7 @@ class Sender extends EventEmitter {\n   applyExtensions(data, fin, compress, callback) {\n     if (compress && data) {\n       if ((data.buffer || data) instanceof ArrayBuffer) {\n-        data = getArrayBuffer(data);\n+        data = getBufferFromNative(data);\n       }\n       this.extensions[PerMessageDeflate.extensionName].compress(data, fin, callback);\n     } else {\n@@ -279,16 +240,11 @@ class Sender extends EventEmitter {\n \n module.exports = Sender;\n \n-function getArrayBuffer(data) {\n+function getBufferFromNative(data) {\n   // data is either an ArrayBuffer or ArrayBufferView.\n-  var array = new Uint8Array(data.buffer || data),\n-    l = data.byteLength || data.length,\n-    o = data.byteOffset || 0,\n-    buffer = new Buffer(l);\n-  for (var i = 0; i < l; ++i) {\n-    buffer[i] = array[o + i];\n-  }\n-  return buffer;\n+  return !data.buffer\n+    ? new Buffer(data)\n+    : new Buffer(data.buffer).slice(data.byteOffset, data.byteOffset + data.byteLength)\n }\n \n function getRandomMask() {\n@@ -299,3 +255,18 @@ function getRandomMask() {\n     ~~(Math.random() * 255)\n   ]);\n }\n+\n+function sendFramedData(outputBuffer, data, cb) {\n+  try {\n+    if (data) {\n+      this._socket.write(outputBuffer, 'binary');\n+      this._socket.write(data, 'binary', cb);\n+    } else {\n+      this._socket.write(outputBuffer, 'binary', cb);\n+    }\n+  }\n+  catch (e) {\n+    if (typeof cb == 'function') cb(e);\n+    else this.emit('error', e);\n+  }\n+}"}]},{"url":"https://api.github.com/repos/websockets/ws/issues/1600","repository_url":"https://api.github.com/repos/websockets/ws","labels_url":"https://api.github.com/repos/websockets/ws/issues/1600/labels{/name}","comments_url":"https://api.github.com/repos/websockets/ws/issues/1600/comments","events_url":"https://api.github.com/repos/websockets/ws/issues/1600/events","html_url":"https://github.com/websockets/ws/pull/1600","id":461590919,"node_id":"MDExOlB1bGxSZXF1ZXN0MjkyNDg0NDQz","number":1600,"title":"Ensure that concat() never returns uninitialized data","user":{"login":"ChALkeR","id":291301,"node_id":"MDQ6VXNlcjI5MTMwMQ==","avatar_url":"https://avatars.githubusercontent.com/u/291301?v=4","gravatar_id":"","url":"https://api.github.com/users/ChALkeR","html_url":"https://github.com/ChALkeR","followers_url":"https://api.github.com/users/ChALkeR/followers","following_url":"https://api.github.com/users/ChALkeR/following{/other_user}","gists_url":"https://api.github.com/users/ChALkeR/gists{/gist_id}","starred_url":"https://api.github.com/users/ChALkeR/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ChALkeR/subscriptions","organizations_url":"https://api.github.com/users/ChALkeR/orgs","repos_url":"https://api.github.com/users/ChALkeR/repos","events_url":"https://api.github.com/users/ChALkeR/events{/privacy}","received_events_url":"https://api.github.com/users/ChALkeR/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2019-06-27T15:16:48Z","updated_at":"2019-09-15T07:14:54Z","closed_at":"2019-09-15T07:14:54Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"draft":false,"pull_request":{"url":"https://api.github.com/repos/websockets/ws/pulls/1600","html_url":"https://github.com/websockets/ws/pull/1600","diff_url":"https://github.com/websockets/ws/pull/1600.diff","patch_url":"https://github.com/websockets/ws/pull/1600.patch","merged_at":"2019-09-15T07:14:54Z"},"body":"_There are no known to me occurrences of returning uninitialized data, I am adding this as a safeguard._\r\n\r\n---\r\n\r\nThis is just a safeguard that ensures that for cases if totalLength is by some mistake gets miscalculated, no uninitialized memory would be leaked.\r\n\r\nThis should not introduce any performance impact as in a normal case (which should be all the cases) this is just a single comparison.","reactions":{"url":"https://api.github.com/repos/websockets/ws/issues/1600/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/websockets/ws/issues/1600/timeline","performed_via_github_app":null,"state_reason":null,"score":1,"files":[{"sha":"3648638b027afde6bf2ed8fc78d975f398c42491","filename":"lib/buffer-util.js","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/websockets/ws/blob/af8234059cef9e9d3a30e47fa84e748bb015b3fb/lib%2Fbuffer-util.js","raw_url":"https://github.com/websockets/ws/raw/af8234059cef9e9d3a30e47fa84e748bb015b3fb/lib%2Fbuffer-util.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/lib%2Fbuffer-util.js?ref=af8234059cef9e9d3a30e47fa84e748bb015b3fb","patch":"@@ -23,6 +23,8 @@ function concat(list, totalLength) {\n     offset += buf.length;\n   }\n \n+  if (offset < totalLength) return target.slice(0, offset);\n+\n   return target;\n }\n "},{"sha":"a6b84c94b1785de0ce4a6932c6bcf442eb2f97d1","filename":"test/buffer-util.test.js","status":"added","additions":15,"deletions":0,"changes":15,"blob_url":"https://github.com/websockets/ws/blob/af8234059cef9e9d3a30e47fa84e748bb015b3fb/test%2Fbuffer-util.test.js","raw_url":"https://github.com/websockets/ws/raw/af8234059cef9e9d3a30e47fa84e748bb015b3fb/test%2Fbuffer-util.test.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/test%2Fbuffer-util.test.js?ref=af8234059cef9e9d3a30e47fa84e748bb015b3fb","patch":"@@ -0,0 +1,15 @@\n+'use strict';\n+\n+const assert = require('assert');\n+\n+const { concat } = require('../lib/buffer-util');\n+\n+describe('bufferUtil', () => {\n+  describe('concat', () => {\n+    it('never returns uninitialized data', () => {\n+      const buf = concat([Buffer.from([1, 2]), Buffer.from([3, 4])], 6);\n+\n+      assert.ok(buf.equals(Buffer.from([1, 2, 3, 4])));\n+    });\n+  });\n+});"}]},{"url":"https://api.github.com/repos/websockets/ws/issues/1302","repository_url":"https://api.github.com/repos/websockets/ws","labels_url":"https://api.github.com/repos/websockets/ws/issues/1302/labels{/name}","comments_url":"https://api.github.com/repos/websockets/ws/issues/1302/comments","events_url":"https://api.github.com/repos/websockets/ws/issues/1302/events","html_url":"https://github.com/websockets/ws/pull/1302","id":297349865,"node_id":"MDExOlB1bGxSZXF1ZXN0MTY5Mjk5NzQ1","number":1302,"title":"Make `Receiver` inherit from `stream.Writable`","user":{"login":"lpinca","id":1443911,"node_id":"MDQ6VXNlcjE0NDM5MTE=","avatar_url":"https://avatars.githubusercontent.com/u/1443911?v=4","gravatar_id":"","url":"https://api.github.com/users/lpinca","html_url":"https://github.com/lpinca","followers_url":"https://api.github.com/users/lpinca/followers","following_url":"https://api.github.com/users/lpinca/following{/other_user}","gists_url":"https://api.github.com/users/lpinca/gists{/gist_id}","starred_url":"https://api.github.com/users/lpinca/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/lpinca/subscriptions","organizations_url":"https://api.github.com/users/lpinca/orgs","repos_url":"https://api.github.com/users/lpinca/repos","events_url":"https://api.github.com/users/lpinca/events{/privacy}","received_events_url":"https://api.github.com/users/lpinca/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":7,"created_at":"2018-02-15T07:20:23Z","updated_at":"2018-03-01T11:26:24Z","closed_at":"2018-03-01T11:26:19Z","author_association":"MEMBER","active_lock_reason":null,"draft":false,"pull_request":{"url":"https://api.github.com/repos/websockets/ws/pulls/1302","html_url":"https://github.com/websockets/ws/pull/1302","diff_url":"https://github.com/websockets/ws/pull/1302.diff","patch_url":"https://github.com/websockets/ws/pull/1302.patch","merged_at":"2018-03-01T11:26:19Z"},"body":"This makes `Receiver` inherit from `stream.Writable`.\r\n\r\nThe main reason for this change is to have back-pressure properly handled when permessage-deflate is enabled.\r\n\r\nThere are no significant performance differences but memory usage is a lot higher. 100k connections use ~400 MB on master and ~600 MB with this patch.\r\n\r\nI'm opening this PR to discuss whether or not this makes sense.","reactions":{"url":"https://api.github.com/repos/websockets/ws/issues/1302/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/websockets/ws/issues/1302/timeline","performed_via_github_app":null,"state_reason":null,"score":1,"files":[{"sha":"e21953a5a41ff1455a9548c87033b2a23881c6b1","filename":".travis.yml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/websockets/ws/blob/908c358bd801dcc60583924058a5d565ec5ecf0b/.travis.yml","raw_url":"https://github.com/websockets/ws/raw/908c358bd801dcc60583924058a5d565ec5ecf0b/.travis.yml","contents_url":"https://api.github.com/repos/websockets/ws/contents/.travis.yml?ref=908c358bd801dcc60583924058a5d565ec5ecf0b","patch":"@@ -5,6 +5,6 @@ node_js:\n   - \"8\"\n   - \"6\"\n   - \"4\"\n-  - \"4.2.0\"\n+  - \"4.2.2\"\n after_success:\n   - \"npm install coveralls@3 && nyc report --reporter=text-lcov | coveralls\""},{"sha":"394bc1e89b2bffe51f95b194eec0637679b911da","filename":"appveyor.yml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/websockets/ws/blob/908c358bd801dcc60583924058a5d565ec5ecf0b/appveyor.yml","raw_url":"https://github.com/websockets/ws/raw/908c358bd801dcc60583924058a5d565ec5ecf0b/appveyor.yml","contents_url":"https://api.github.com/repos/websockets/ws/contents/appveyor.yml?ref=908c358bd801dcc60583924058a5d565ec5ecf0b","patch":"@@ -4,7 +4,7 @@ environment:\n     - nodejs_version: \"8\"\n     - nodejs_version: \"6\"\n     - nodejs_version: \"4\"\n-    - nodejs_version: \"4.2.0\"\n+    - nodejs_version: \"4.2.2\"\n platform:\n   - x86\n   - x64"},{"sha":"f505ed5e28b710b959301b6776fdb734eee495a2","filename":"doc/ws.md","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/websockets/ws/blob/908c358bd801dcc60583924058a5d565ec5ecf0b/doc%2Fws.md","raw_url":"https://github.com/websockets/ws/raw/908c358bd801dcc60583924058a5d565ec5ecf0b/doc%2Fws.md","contents_url":"https://api.github.com/repos/websockets/ws/contents/doc%2Fws.md?ref=908c358bd801dcc60583924058a5d565ec5ecf0b","patch":"@@ -244,8 +244,7 @@ human-readable string explaining why the connection has been closed.\n \n - `error` {Error}\n \n-Emitted when an error occurs. Errors from the underlying `net.Socket` are\n-forwarded here.\n+Emitted when an error occurs.\n \n ### Event: 'message'\n "},{"sha":"613a6766cff2686c1e7eaa18ec94dee22c94acad","filename":"lib/constants.js","status":"modified","additions":8,"deletions":4,"changes":12,"blob_url":"https://github.com/websockets/ws/blob/908c358bd801dcc60583924058a5d565ec5ecf0b/lib%2Fconstants.js","raw_url":"https://github.com/websockets/ws/raw/908c358bd801dcc60583924058a5d565ec5ecf0b/lib%2Fconstants.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/lib%2Fconstants.js?ref=908c358bd801dcc60583924058a5d565ec5ecf0b","patch":"@@ -4,7 +4,11 @@ const safeBuffer = require('safe-buffer');\n \n const Buffer = safeBuffer.Buffer;\n \n-exports.BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\n-exports.GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';\n-exports.EMPTY_BUFFER = Buffer.alloc(0);\n-exports.NOOP = () => {};\n+module.exports = {\n+  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],\n+  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n+  kStatusCode: Symbol('status-code'),\n+  kWebSocket: Symbol('websocket'),\n+  EMPTY_BUFFER: Buffer.alloc(0),\n+  NOOP: () => {}\n+};"},{"sha":"05832f28fb56320f598d3556230881b3baafba14","filename":"lib/permessage-deflate.js","status":"modified","additions":9,"deletions":11,"changes":20,"blob_url":"https://github.com/websockets/ws/blob/908c358bd801dcc60583924058a5d565ec5ecf0b/lib%2Fpermessage-deflate.js","raw_url":"https://github.com/websockets/ws/raw/908c358bd801dcc60583924058a5d565ec5ecf0b/lib%2Fpermessage-deflate.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/lib%2Fpermessage-deflate.js?ref=908c358bd801dcc60583924058a5d565ec5ecf0b","patch":"@@ -5,19 +5,20 @@ const Limiter = require('async-limiter');\n const zlib = require('zlib');\n \n const bufferUtil = require('./buffer-util');\n+const constants = require('./constants');\n \n const Buffer = safeBuffer.Buffer;\n \n const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\n const EMPTY_BLOCK = Buffer.from([0x00]);\n \n+const kPerMessageDeflate = Symbol('permessage-deflate');\n const kWriteInProgress = Symbol('write-in-progress');\n const kPendingClose = Symbol('pending-close');\n const kTotalLength = Symbol('total-length');\n const kCallback = Symbol('callback');\n const kBuffers = Symbol('buffers');\n const kError = Symbol('error');\n-const kOwner = Symbol('owner');\n \n //\n // We limit zlib concurrency, which prevents severe memory fragmentation\n@@ -346,15 +347,11 @@ class PerMessageDeflate {\n         : this.params[key];\n \n       this._inflate = zlib.createInflateRaw(\n-        Object.assign(\n-          {},\n-          this._options.zlibInflateOptions,\n-          { windowBits }\n-        )\n+        Object.assign({}, this._options.zlibInflateOptions, { windowBits })\n       );\n+      this._inflate[kPerMessageDeflate] = this;\n       this._inflate[kTotalLength] = 0;\n       this._inflate[kBuffers] = [];\n-      this._inflate[kOwner] = this;\n       this._inflate.on('error', inflateOnError);\n       this._inflate.on('data', inflateOnData);\n     }\n@@ -492,15 +489,15 @@ function inflateOnData (chunk) {\n   this[kTotalLength] += chunk.length;\n \n   if (\n-    this[kOwner]._maxPayload < 1 ||\n-    this[kTotalLength] <= this[kOwner]._maxPayload\n+    this[kPerMessageDeflate]._maxPayload < 1 ||\n+    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n   ) {\n     this[kBuffers].push(chunk);\n     return;\n   }\n \n   this[kError] = new RangeError('Max payload size exceeded');\n-  this[kError].closeCode = 1009;\n+  this[kError][constants.kStatusCode] = 1009;\n   this.removeListener('data', inflateOnData);\n   this.reset();\n }\n@@ -516,6 +513,7 @@ function inflateOnError (err) {\n   // There is no need to call `Zlib#close()` as the handle is automatically\n   // closed when an error is emitted.\n   //\n-  this[kOwner]._inflate = null;\n+  this[kPerMessageDeflate]._inflate = null;\n+  err[constants.kStatusCode] = 1007;\n   this[kCallback](err);\n }"},{"sha":"a66cc10eeefcd0414e52f9dc080eec8b0092bfaf","filename":"lib/receiver.js","status":"modified","additions":172,"deletions":245,"changes":417,"blob_url":"https://github.com/websockets/ws/blob/908c358bd801dcc60583924058a5d565ec5ecf0b/lib%2Freceiver.js","raw_url":"https://github.com/websockets/ws/raw/908c358bd801dcc60583924058a5d565ec5ecf0b/lib%2Freceiver.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/lib%2Freceiver.js?ref=908c358bd801dcc60583924058a5d565ec5ecf0b","patch":"@@ -1,6 +1,7 @@\n 'use strict';\n \n const safeBuffer = require('safe-buffer');\n+const stream = require('stream');\n \n const PerMessageDeflate = require('./permessage-deflate');\n const bufferUtil = require('./buffer-util');\n@@ -18,8 +19,10 @@ const INFLATING = 5;\n \n /**\n  * HyBi Receiver implementation.\n+ *\n+ * @extends stream.Writable\n  */\n-class Receiver {\n+class Receiver extends stream.Writable {\n   /**\n    * Creates a Receiver instance.\n    *\n@@ -28,7 +31,10 @@ class Receiver {\n    * @param {String} binaryType The type for binary data\n    */\n   constructor (extensions, maxPayload, binaryType) {\n+    super();\n+\n     this._binaryType = binaryType || constants.BINARY_TYPES[0];\n+    this[constants.kWebSocket] = undefined;\n     this._extensions = extensions || {};\n     this._maxPayload = maxPayload | 0;\n \n@@ -37,46 +43,43 @@ class Receiver {\n \n     this._compressed = false;\n     this._payloadLength = 0;\n+    this._mask = undefined;\n     this._fragmented = 0;\n     this._masked = false;\n     this._fin = false;\n-    this._mask = null;\n     this._opcode = 0;\n \n     this._totalPayloadLength = 0;\n     this._messageLength = 0;\n     this._fragments = [];\n \n-    this._cleanupCallback = null;\n-    this._isCleaningUp = false;\n-    this._hadError = false;\n+    this._state = GET_INFO;\n     this._loop = false;\n+  }\n \n-    this.add = this.add.bind(this);\n-    this.onmessage = null;\n-    this.onclose = null;\n-    this.onerror = null;\n-    this.onping = null;\n-    this.onpong = null;\n+  /**\n+   * Implements `Writable.prototype._write()`.\n+   *\n+   * @param {Buffer} chunk The chunk of data to write\n+   * @param {String} encoding The character encoding of `chunk`\n+   * @param {Function} cb Callback\n+   */\n+  _write (chunk, encoding, cb) {\n+    if (this._opcode === 0x08) return cb();\n \n-    this._state = GET_INFO;\n+    this._bufferedBytes += chunk.length;\n+    this._buffers.push(chunk);\n+    this.startLoop(cb);\n   }\n \n   /**\n-   * Consumes `n` bytes from the buffered data, calls `cleanup` if necessary.\n+   * Consumes `n` bytes from the buffered data.\n    *\n    * @param {Number} n The number of bytes to consume\n-   * @return {(Buffer|null)} The consumed bytes or `null` if `n` bytes are not\n-   *     available\n+   * @return {Buffer} The consumed bytes\n    * @private\n    */\n   consume (n) {\n-    if (this._bufferedBytes < n) {\n-      this._loop = false;\n-      if (this._isCleaningUp) this.cleanup(this._cleanupCallback);\n-      return null;\n-    }\n-\n     this._bufferedBytes -= n;\n \n     if (n === this._buffers[0].length) return this._buffers.shift();\n@@ -105,74 +108,66 @@ class Receiver {\n     return dst;\n   }\n \n-  /**\n-   * Adds new data to the parser.\n-   *\n-   * @param {Buffer} chunk A chunk of data\n-   * @public\n-   */\n-  add (chunk) {\n-    this._bufferedBytes += chunk.length;\n-    this._buffers.push(chunk);\n-    this.startLoop();\n-  }\n-\n   /**\n    * Starts the parsing loop.\n    *\n+   * @param {Function} cb Callback\n    * @private\n    */\n-  startLoop () {\n+  startLoop (cb) {\n+    var err;\n     this._loop = true;\n \n     do {\n       switch (this._state) {\n         case GET_INFO:\n-          this.getInfo();\n+          err = this.getInfo();\n           break;\n         case GET_PAYLOAD_LENGTH_16:\n-          this.getPayloadLength16();\n+          err = this.getPayloadLength16();\n           break;\n         case GET_PAYLOAD_LENGTH_64:\n-          this.getPayloadLength64();\n+          err = this.getPayloadLength64();\n           break;\n         case GET_MASK:\n           this.getMask();\n           break;\n         case GET_DATA:\n-          this.getData();\n+          err = this.getData(cb);\n           break;\n         default: // `INFLATING`\n           this._loop = false;\n+          return;\n       }\n     } while (this._loop);\n+\n+    cb(err);\n   }\n \n   /**\n    * Reads the first two bytes of a frame.\n    *\n+   * @return {(RangeError|undefined)} A possible error\n    * @private\n    */\n   getInfo () {\n+    if (this._bufferedBytes < 2) {\n+      this._loop = false;\n+      return;\n+    }\n+\n     const buf = this.consume(2);\n-    if (buf === null) return;\n \n     if ((buf[0] & 0x30) !== 0x00) {\n-      this.error(\n-        new RangeError('Invalid WebSocket frame: RSV2 and RSV3 must be clear'),\n-        1002\n-      );\n-      return;\n+      this._loop = false;\n+      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);\n     }\n \n     const compressed = (buf[0] & 0x40) === 0x40;\n \n     if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n-      this.error(\n-        new RangeError('Invalid WebSocket frame: RSV1 must be clear'),\n-        1002\n-      );\n-      return;\n+      this._loop = false;\n+      return error(RangeError, 'RSV1 must be clear', true, 1002);\n     }\n \n     this._fin = (buf[0] & 0x80) === 0x80;\n@@ -181,130 +176,118 @@ class Receiver {\n \n     if (this._opcode === 0x00) {\n       if (compressed) {\n-        this.error(\n-          new RangeError('Invalid WebSocket frame: RSV1 must be clear'),\n-          1002\n-        );\n-        return;\n+        this._loop = false;\n+        return error(RangeError, 'RSV1 must be clear', true, 1002);\n       }\n \n       if (!this._fragmented) {\n-        this.error(\n-          new RangeError('Invalid WebSocket frame: invalid opcode 0'),\n-          1002\n-        );\n-        return;\n-      } else {\n-        this._opcode = this._fragmented;\n+        this._loop = false;\n+        return error(RangeError, 'invalid opcode 0', true, 1002);\n       }\n+\n+      this._opcode = this._fragmented;\n     } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n       if (this._fragmented) {\n-        this.error(\n-          new RangeError(\n-            `Invalid WebSocket frame: invalid opcode ${this._opcode}`\n-          ),\n-          1002\n-        );\n-        return;\n+        this._loop = false;\n+        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\n       }\n \n       this._compressed = compressed;\n     } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n       if (!this._fin) {\n-        this.error(\n-          new RangeError('Invalid WebSocket frame: FIN must be set'),\n-          1002\n-        );\n-        return;\n+        this._loop = false;\n+        return error(RangeError, 'FIN must be set', true, 1002);\n       }\n \n       if (compressed) {\n-        this.error(\n-          new RangeError('Invalid WebSocket frame: RSV1 must be clear'),\n-          1002\n-        );\n-        return;\n+        this._loop = false;\n+        return error(RangeError, 'RSV1 must be clear', true, 1002);\n       }\n \n       if (this._payloadLength > 0x7d) {\n-        this.error(\n-          new RangeError(\n-            `Invalid WebSocket frame: invalid payload length ` +\n-              `${this._payloadLength}`\n-          ),\n+        this._loop = false;\n+        return error(\n+          RangeError,\n+          `invalid payload length ${this._payloadLength}`,\n+          true,\n           1002\n         );\n-        return;\n       }\n     } else {\n-      this.error(\n-        new RangeError(\n-          `Invalid WebSocket frame: invalid opcode ${this._opcode}`\n-        ),\n-        1002\n-      );\n-      return;\n+      this._loop = false;\n+      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\n     }\n \n     if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n-\n     this._masked = (buf[1] & 0x80) === 0x80;\n \n     if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n     else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n-    else this.haveLength();\n+    else return this.haveLength();\n   }\n \n   /**\n    * Gets extended payload length (7+16).\n    *\n+   * @return {(RangeError|undefined)} A possible error\n    * @private\n    */\n   getPayloadLength16 () {\n-    const buf = this.consume(2);\n-    if (buf === null) return;\n+    if (this._bufferedBytes < 2) {\n+      this._loop = false;\n+      return;\n+    }\n \n-    this._payloadLength = buf.readUInt16BE(0, true);\n-    this.haveLength();\n+    this._payloadLength = this.consume(2).readUInt16BE(0, true);\n+    return this.haveLength();\n   }\n \n   /**\n    * Gets extended payload length (7+64).\n    *\n+   * @return {(RangeError|undefined)} A possible error\n    * @private\n    */\n   getPayloadLength64 () {\n-    const buf = this.consume(8);\n-    if (buf === null) return;\n+    if (this._bufferedBytes < 8) {\n+      this._loop = false;\n+      return;\n+    }\n \n+    const buf = this.consume(8);\n     const num = buf.readUInt32BE(0, true);\n \n     //\n     // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n     // if payload length is greater than this number.\n     //\n     if (num > Math.pow(2, 53 - 32) - 1) {\n-      this.error(\n-        new RangeError(\n-          'Unsupported WebSocket frame: payload length > 2^53 - 1'\n-        ),\n+      this._loop = false;\n+      return error(\n+        RangeError,\n+        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n+        false,\n         1009\n       );\n-      return;\n     }\n \n     this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4, true);\n-    this.haveLength();\n+    return this.haveLength();\n   }\n \n   /**\n    * Payload length has been read.\n    *\n+   * @return {(RangeError|undefined)} A possible error\n    * @private\n    */\n   haveLength () {\n-    if (this._opcode < 0x08 && this.maxPayloadExceeded(this._payloadLength)) {\n-      return;\n+    if (this._payloadLength && this._opcode < 0x08) {\n+      this._totalPayloadLength += this._payloadLength;\n+      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n+        this._loop = false;\n+        return error(RangeError, 'Max payload size exceeded', false, 1009);\n+      }\n     }\n \n     if (this._masked) this._state = GET_MASK;\n@@ -317,60 +300,88 @@ class Receiver {\n    * @private\n    */\n   getMask () {\n-    this._mask = this.consume(4);\n-    if (this._mask === null) return;\n+    if (this._bufferedBytes < 4) {\n+      this._loop = false;\n+      return;\n+    }\n \n+    this._mask = this.consume(4);\n     this._state = GET_DATA;\n   }\n \n   /**\n    * Reads data bytes.\n    *\n+   * @param {Function} cb Callback\n+   * @return {(Error|RangeError|undefined)} A possible error\n    * @private\n    */\n-  getData () {\n+  getData (cb) {\n     var data = constants.EMPTY_BUFFER;\n \n     if (this._payloadLength) {\n-      data = this.consume(this._payloadLength);\n-      if (data === null) return;\n+      if (this._bufferedBytes < this._payloadLength) {\n+        this._loop = false;\n+        return;\n+      }\n \n+      data = this.consume(this._payloadLength);\n       if (this._masked) bufferUtil.unmask(data, this._mask);\n     }\n \n-    if (this._opcode > 0x07) {\n-      this.controlMessage(data);\n-    } else if (this._compressed) {\n+    if (this._opcode > 0x07) return this.controlMessage(data);\n+\n+    if (this._compressed) {\n       this._state = INFLATING;\n-      this.decompress(data);\n-    } else if (this.pushFragment(data)) {\n-      this.dataMessage();\n+      this.decompress(data, cb);\n+      return;\n+    }\n+\n+    if (data.length) {\n+      //\n+      // This message is not compressed so its lenght is the sum of the payload\n+      // length of all fragments.\n+      //\n+      this._messageLength = this._totalPayloadLength;\n+      this._fragments.push(data);\n     }\n+\n+    return this.dataMessage();\n   }\n \n   /**\n    * Decompresses data.\n    *\n    * @param {Buffer} data Compressed data\n+   * @param {Function} cb Callback\n    * @private\n    */\n-  decompress (data) {\n+  decompress (data, cb) {\n     const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n \n     perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n-      if (err) {\n-        this.error(err, err.closeCode === 1009 ? 1009 : 1007);\n-        return;\n+      if (err) return cb(err);\n+\n+      if (buf.length) {\n+        this._messageLength += buf.length;\n+        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n+          return cb(error(RangeError, 'Max payload size exceeded', false, 1009));\n+        }\n+\n+        this._fragments.push(buf);\n       }\n \n-      if (this.pushFragment(buf)) this.dataMessage();\n-      this.startLoop();\n+      const er = this.dataMessage();\n+      if (er) return cb(er);\n+\n+      this.startLoop(cb);\n     });\n   }\n \n   /**\n    * Handles a data message.\n    *\n+   * @return {(Error|undefined)} A possible error\n    * @private\n    */\n   dataMessage () {\n@@ -394,19 +405,16 @@ class Receiver {\n           data = fragments;\n         }\n \n-        this.onmessage(data);\n+        this.emit('message', data);\n       } else {\n         const buf = toBuffer(fragments, messageLength);\n \n         if (!validation.isValidUTF8(buf)) {\n-          this.error(\n-            new Error('Invalid WebSocket frame: invalid UTF-8 sequence'),\n-            1007\n-          );\n-          return;\n+          this._loop = false;\n+          return error(Error, 'invalid UTF-8 sequence', true, 1007);\n         }\n \n-        this.onmessage(buf.toString());\n+        this.emit('message', buf.toString());\n       }\n     }\n \n@@ -417,149 +425,68 @@ class Receiver {\n    * Handles a control message.\n    *\n    * @param {Buffer} data Data to handle\n+   * @return {(Error|RangeError|undefined)} A possible error\n    * @private\n    */\n   controlMessage (data) {\n     if (this._opcode === 0x08) {\n+      this._loop = false;\n+\n       if (data.length === 0) {\n-        this._loop = false;\n-        this.onclose(1005, '');\n-        this.cleanup(this._cleanupCallback);\n+        this.emit('close', 1005, '');\n+        this.end();\n       } else if (data.length === 1) {\n-        this.error(\n-          new RangeError('Invalid WebSocket frame: invalid payload length 1'),\n-          1002\n-        );\n+        return error(RangeError, 'invalid payload length 1', true, 1002);\n       } else {\n         const code = data.readUInt16BE(0, true);\n \n         if (!validation.isValidStatusCode(code)) {\n-          this.error(\n-            new RangeError(\n-              `Invalid WebSocket frame: invalid status code ${code}`\n-            ),\n-            1002\n-          );\n-          return;\n+          return error(RangeError, `invalid status code ${code}`, true, 1002);\n         }\n \n         const buf = data.slice(2);\n \n         if (!validation.isValidUTF8(buf)) {\n-          this.error(\n-            new Error('Invalid WebSocket frame: invalid UTF-8 sequence'),\n-            1007\n-          );\n-          return;\n+          return error(Error, 'invalid UTF-8 sequence', true, 1007);\n         }\n \n-        this._loop = false;\n-        this.onclose(code, buf.toString());\n-        this.cleanup(this._cleanupCallback);\n+        this.emit('close', code, buf.toString());\n+        this.end();\n       }\n \n       return;\n     }\n \n-    if (this._opcode === 0x09) this.onping(data);\n-    else this.onpong(data);\n+    if (this._opcode === 0x09) this.emit('ping', data);\n+    else this.emit('pong', data);\n \n     this._state = GET_INFO;\n   }\n-\n-  /**\n-   * Handles an error.\n-   *\n-   * @param {Error} err The error\n-   * @param {Number} code Close code\n-   * @private\n-   */\n-  error (err, code) {\n-    this._hadError = true;\n-    this._loop = false;\n-    this.onerror(err, code);\n-    this.cleanup(this._cleanupCallback);\n-  }\n-\n-  /**\n-   * Checks payload size, disconnects socket when it exceeds `maxPayload`.\n-   *\n-   * @param {Number} length Payload length\n-   * @private\n-   */\n-  maxPayloadExceeded (length) {\n-    if (length === 0 || this._maxPayload < 1) return false;\n-\n-    const fullLength = this._totalPayloadLength + length;\n-\n-    if (fullLength <= this._maxPayload) {\n-      this._totalPayloadLength = fullLength;\n-      return false;\n-    }\n-\n-    this.error(new RangeError('Max payload size exceeded'), 1009);\n-    return true;\n-  }\n-\n-  /**\n-   * Appends a fragment in the fragments array after checking that the sum of\n-   * fragment lengths does not exceed `maxPayload`.\n-   *\n-   * @param {Buffer} fragment The fragment to add\n-   * @return {Boolean} `true` if `maxPayload` is not exceeded, else `false`\n-   * @private\n-   */\n-  pushFragment (fragment) {\n-    if (fragment.length === 0) return true;\n-\n-    const totalLength = this._messageLength + fragment.length;\n-\n-    if (this._maxPayload < 1 || totalLength <= this._maxPayload) {\n-      this._messageLength = totalLength;\n-      this._fragments.push(fragment);\n-      return true;\n-    }\n-\n-    this.error(new RangeError('Max payload size exceeded'), 1009);\n-    return false;\n-  }\n-\n-  /**\n-   * Releases resources used by the receiver.\n-   *\n-   * @param {Function} cb Callback\n-   * @public\n-   */\n-  cleanup (cb) {\n-    if (this._extensions === null) {\n-      if (cb) cb();\n-      return;\n-    }\n-\n-    if (!this._hadError && (this._loop || this._state === INFLATING)) {\n-      this._cleanupCallback = cb;\n-      this._isCleaningUp = true;\n-      return;\n-    }\n-\n-    this._extensions = null;\n-    this._fragments = null;\n-    this._buffers = null;\n-    this._mask = null;\n-\n-    this._cleanupCallback = null;\n-    this.onmessage = null;\n-    this.onclose = null;\n-    this.onerror = null;\n-    this.onping = null;\n-    this.onpong = null;\n-\n-    if (cb) cb();\n-  }\n }\n \n module.exports = Receiver;\n \n+/**\n+ * Builds an error object.\n+ *\n+ * @param {(Error|RangeError)} ErrorCtor The error constructor\n+ * @param {String} message The error message\n+ * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n+ *     `message`\n+ * @param {Number} statusCode The status code\n+ * @return {(Error|RangeError)} The error\n+ * @private\n+ */\n+function error (ErrorCtor, message, prefix, statusCode) {\n+  const err = new ErrorCtor(\n+    prefix ? `Invalid WebSocket frame: ${message}` : message\n+  );\n+\n+  Error.captureStackTrace(err, error);\n+  err[constants.kStatusCode] = statusCode;\n+  return err;\n+}\n+\n /**\n  * Makes a buffer from a list of fragments.\n  *"},{"sha":"f3b460e308531dcfb8f08a96bd8258ada3235823","filename":"lib/websocket.js","status":"modified","additions":268,"deletions":129,"changes":397,"blob_url":"https://github.com/websockets/ws/blob/908c358bd801dcc60583924058a5d565ec5ecf0b/lib%2Fwebsocket.js","raw_url":"https://github.com/websockets/ws/raw/908c358bd801dcc60583924058a5d565ec5ecf0b/lib%2Fwebsocket.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/lib%2Fwebsocket.js?ref=908c358bd801dcc60583924058a5d565ec5ecf0b","patch":"@@ -14,6 +14,7 @@ const Receiver = require('./receiver');\n const Sender = require('./sender');\n \n const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\n+const kWebSocket = constants.kWebSocket;\n const protocolVersions = [8, 13];\n const closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly.\n \n@@ -37,19 +38,16 @@ class WebSocket extends EventEmitter {\n     this.protocol = '';\n \n     this._binaryType = constants.BINARY_TYPES[0];\n-    this._finalize = this.finalize.bind(this);\n     this._closeFrameReceived = false;\n     this._closeFrameSent = false;\n     this._closeMessage = '';\n     this._closeTimer = null;\n-    this._finalized = false;\n     this._closeCode = 1006;\n     this._extensions = {};\n     this._isServer = true;\n     this._receiver = null;\n     this._sender = null;\n     this._socket = null;\n-    this._error = null;\n \n     if (address !== null) {\n       if (!protocols) {\n@@ -119,126 +117,75 @@ class WebSocket extends EventEmitter {\n    * @private\n    */\n   setSocket (socket, head, maxPayload) {\n-    socket.setTimeout(0);\n-    socket.setNoDelay();\n-\n-    socket.on('close', this._finalize);\n-    socket.on('error', this._finalize);\n-    socket.on('end', this._finalize);\n+    const receiver = new Receiver(\n+      this._extensions,\n+      maxPayload,\n+      this._binaryType\n+    );\n \n-    this._receiver = new Receiver(this._extensions, maxPayload, this.binaryType);\n     this._sender = new Sender(socket, this._extensions);\n+    this._receiver = receiver;\n     this._socket = socket;\n \n-    if (head.length > 0) socket.unshift(head);\n-\n-    socket.on('data', this._receiver.add);\n-\n-    this._receiver.onmessage = (data) => this.emit('message', data);\n-    this._receiver.onping = (data) => {\n-      this.pong(data, !this._isServer, constants.NOOP);\n-      this.emit('ping', data);\n-    };\n-    this._receiver.onpong = (data) => this.emit('pong', data);\n-    this._receiver.onclose = (code, reason) => {\n-      //\n-      // Discard any additional data that is received on the socket.\n-      //\n-      this._socket.removeListener('data', this._receiver.add);\n+    receiver[kWebSocket] = this;\n+    socket[kWebSocket] = this;\n \n-      this._closeFrameReceived = true;\n-      this._closeMessage = reason;\n-      this._closeCode = code;\n+    receiver.on('close', receiverOnClose);\n+    receiver.on('drain', receiverOnDrain);\n+    receiver.on('error', receiverOnError);\n+    receiver.on('message', receiverOnMessage);\n+    receiver.on('ping', receiverOnPing);\n+    receiver.on('pong', receiverOnPong);\n \n-      if (code === 1005) this.close();\n-      else this.close(code, reason);\n-    };\n-    this._receiver.onerror = (error, code) => {\n-      if (this._error) return;\n+    socket.setTimeout(0);\n+    socket.setNoDelay();\n \n-      this._closeCode = code;\n+    if (head.length > 0) socket.unshift(head);\n \n-      if (!this._finalized) this.finalize(error);\n-      else this.emit('error', error);\n-    };\n+    socket.on('close', socketOnClose);\n+    socket.on('data', socketOnData);\n+    socket.on('end', socketOnEnd);\n+    socket.on('error', socketOnError);\n \n     this.readyState = WebSocket.OPEN;\n     this.emit('open');\n   }\n \n   /**\n-   * Clean up internal resources and emit the `'close'` event.\n+   * Emit the `'close'` event.\n    *\n-   * @param {(Boolean|Error)} error Indicates whether or not an error occurred\n    * @private\n    */\n-  finalize (error) {\n-    if (this._finalized) return;\n-\n-    this.readyState = WebSocket.CLOSING;\n-    this._finalized = true;\n+  emitClose () {\n+    this.readyState = WebSocket.CLOSED;\n \n     if (!this._socket) {\n-      //\n-      // `error` is always an `Error` instance in this case.\n-      //\n-      this.emit('error', error);\n-      this.readyState = WebSocket.CLOSED;\n       this.emit('close', this._closeCode, this._closeMessage);\n       return;\n     }\n \n-    clearTimeout(this._closeTimer);\n-\n-    this._socket.removeListener('data', this._receiver.add);\n-    this._socket.removeListener('close', this._finalize);\n-    this._socket.removeListener('error', this._finalize);\n-    this._socket.removeListener('end', this._finalize);\n-    this._socket.on('error', constants.NOOP);\n-\n-    if (error) {\n-      if (error !== true) this._error = error;\n-      this._socket.destroy();\n-    } else {\n-      this._socket.end();\n+    if (this._extensions[PerMessageDeflate.extensionName]) {\n+      this._extensions[PerMessageDeflate.extensionName].cleanup();\n     }\n \n-    this._receiver.cleanup(() => {\n-      const err = this._error;\n-\n-      if (err) {\n-        this._error = null;\n-        this.emit('error', err);\n-      }\n-\n-      this.readyState = WebSocket.CLOSED;\n-\n-      if (this._extensions[PerMessageDeflate.extensionName]) {\n-        this._extensions[PerMessageDeflate.extensionName].cleanup();\n-      }\n-\n-      this.emit('close', this._closeCode, this._closeMessage);\n-    });\n+    this._receiver.removeAllListeners();\n+    this.emit('close', this._closeCode, this._closeMessage);\n   }\n \n   /**\n    * Start a closing handshake.\n    *\n-   *            +----------+     +-----------+   +----------+\n-   *     + - - -|ws.close()|---->|close frame|-->|ws.close()|- - - -\n-   *            +----------+     +-----------+   +----------+       |\n-   *     |      +----------+     +-----------+         |\n-   *            |ws.close()|<----|close frame|<--------+            |\n-   *            +----------+     +-----------+         |\n-   *  CLOSING         |              +---+             |         CLOSING\n-   *                  |          +---|fin|<------------+\n-   *     |            |          |   +---+                          |\n-   *                  |          |   +---+      +-------------+\n-   *     |            +----------+-->|fin|----->|ws.finalize()| - - +\n-   *                             |   +---+      +-------------+\n-   *     |     +-------------+   |\n-   *      - - -|ws.finalize()|<--+\n-   *           +-------------+\n+   *          +----------+   +-----------+   +----------+\n+   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n+   *    |     +----------+   +-----------+   +----------+     |\n+   *          +----------+   +-----------+         |\n+   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n+   *          +----------+   +-----------+   |\n+   *    |           |                        |   +---+        |\n+   *                +------------------------+-->|fin| - - - -\n+   *    |         +---+                      |   +---+\n+   *     - - - - -|fin|<---------------------+\n+   *              +---+\n    *\n    * @param {Number} code Status code explaining why the connection is closing\n    * @param {String} data A string explaining why the connection is closing\n@@ -247,11 +194,8 @@ class WebSocket extends EventEmitter {\n   close (code, data) {\n     if (this.readyState === WebSocket.CLOSED) return;\n     if (this.readyState === WebSocket.CONNECTING) {\n-      this._req.abort();\n-      this.finalize(\n-        new Error('WebSocket was closed before the connection was established')\n-      );\n-      return;\n+      const msg = 'WebSocket was closed before the connection was established';\n+      return abortHandshake(this, this._req, msg);\n     }\n \n     if (this.readyState === WebSocket.CLOSING) {\n@@ -269,14 +213,17 @@ class WebSocket extends EventEmitter {\n \n       this._closeFrameSent = true;\n \n-      if (!this._finalized) {\n+      if (this._socket.writable) {\n         if (this._closeFrameReceived) this._socket.end();\n \n         //\n-        // Ensure that the connection is cleaned up even when the closing\n-        // handshake fails.\n+        // Ensure that the connection is closed even if the closing handshake\n+        // fails.\n         //\n-        this._closeTimer = setTimeout(this._finalize, closeTimeout, true);\n+        this._closeTimer = setTimeout(\n+          this._socket.destroy.bind(this._socket),\n+          closeTimeout\n+        );\n       }\n     });\n   }\n@@ -397,14 +344,14 @@ class WebSocket extends EventEmitter {\n   terminate () {\n     if (this.readyState === WebSocket.CLOSED) return;\n     if (this.readyState === WebSocket.CONNECTING) {\n-      this._req.abort();\n-      this.finalize(\n-        new Error('WebSocket was closed before the connection was established')\n-      );\n-      return;\n+      const msg = 'WebSocket was closed before the connection was established';\n+      return abortHandshake(this, this._req, msg);\n     }\n \n-    this.finalize(true);\n+    if (this._socket) {\n+      this.readyState = WebSocket.CLOSING;\n+      this._socket.destroy();\n+    }\n   }\n }\n \n@@ -619,30 +566,31 @@ function initAsClient (address, protocols, options) {\n \n   if (agent) requestOptions.agent = agent;\n \n-  this._req = httpObj.get(requestOptions);\n+  var req = this._req = httpObj.get(requestOptions);\n \n   if (options.handshakeTimeout) {\n-    this._req.setTimeout(options.handshakeTimeout, () => {\n-      this._req.abort();\n-      this.finalize(new Error('Opening handshake has timed out'));\n-    });\n+    req.setTimeout(\n+      options.handshakeTimeout,\n+      abortHandshake.bind(null, this, req, 'Opening handshake has timed out')\n+    );\n   }\n \n-  this._req.on('error', (error) => {\n+  req.on('error', (err) => {\n     if (this._req.aborted) return;\n \n-    this._req = null;\n-    this.finalize(error);\n+    req = this._req = null;\n+    this.readyState = WebSocket.CLOSING;\n+    this.emit('error', err);\n+    this.emitClose();\n   });\n \n-  this._req.on('response', (res) => {\n-    if (!this.emit('unexpected-response', this._req, res)) {\n-      this._req.abort();\n-      this.finalize(new Error(`Unexpected server response: ${res.statusCode}`));\n-    }\n+  req.on('response', (res) => {\n+    if (this.emit('unexpected-response', req, res)) return;\n+\n+    abortHandshake(this, req, `Unexpected server response: ${res.statusCode}`);\n   });\n \n-  this._req.on('upgrade', (res, socket, head) => {\n+  req.on('upgrade', (res, socket, head) => {\n     this.emit('upgrade', res);\n \n     //\n@@ -651,15 +599,15 @@ function initAsClient (address, protocols, options) {\n     //\n     if (this.readyState !== WebSocket.CONNECTING) return;\n \n-    this._req = null;\n+    req = this._req = null;\n \n     const digest = crypto.createHash('sha1')\n       .update(key + constants.GUID, 'binary')\n       .digest('base64');\n \n     if (res.headers['sec-websocket-accept'] !== digest) {\n-      socket.destroy();\n-      return this.finalize(new Error('Invalid Sec-WebSocket-Accept header'));\n+      abortHandshake(this, socket, 'Invalid Sec-WebSocket-Accept header');\n+      return;\n     }\n \n     const serverProt = res.headers['sec-websocket-protocol'];\n@@ -675,8 +623,8 @@ function initAsClient (address, protocols, options) {\n     }\n \n     if (protError) {\n-      socket.destroy();\n-      return this.finalize(new Error(protError));\n+      abortHandshake(this, socket, protError);\n+      return;\n     }\n \n     if (serverProt) this.protocol = serverProt;\n@@ -694,12 +642,203 @@ function initAsClient (address, protocols, options) {\n           this._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n         }\n       } catch (err) {\n-        socket.destroy();\n-        this.finalize(new Error('Invalid Sec-WebSocket-Extensions header'));\n+        abortHandshake(this, socket, 'Invalid Sec-WebSocket-Extensions header');\n         return;\n       }\n     }\n \n     this.setSocket(socket, head, 0);\n   });\n }\n+\n+/**\n+ * Abort the handshake and emit an error.\n+ *\n+ * @param {WebSocket} websocket The WebSocket instance\n+ * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the\n+ *     socket to destroy\n+ * @param {String} message The error message\n+ * @private\n+ */\n+function abortHandshake (websocket, stream, message) {\n+  websocket.readyState = WebSocket.CLOSING;\n+\n+  const err = new Error(message);\n+  Error.captureStackTrace(err, abortHandshake);\n+\n+  if (stream.setHeader) {\n+    stream.abort();\n+    stream.once('abort', websocket.emitClose.bind(websocket));\n+    websocket.emit('error', err);\n+  } else {\n+    stream.destroy(err);\n+    stream.once('error', websocket.emit.bind(websocket, 'error'));\n+    stream.once('close', websocket.emitClose.bind(websocket));\n+  }\n+}\n+\n+/**\n+ * The listener of the `Receiver` `'close'` event.\n+ *\n+ * @param {Number} code The status code\n+ * @param {String} reason The reason for closing\n+ * @private\n+ */\n+function receiverOnClose (code, reason) {\n+  const websocket = this[kWebSocket];\n+\n+  websocket._socket.removeListener('data', socketOnData);\n+  websocket._socket.resume();\n+\n+  websocket._closeFrameReceived = true;\n+  websocket._closeMessage = reason;\n+  websocket._closeCode = code;\n+\n+  if (code === 1005) websocket.close();\n+  else websocket.close(code, reason);\n+}\n+\n+/**\n+ * The listener of the `Receiver` `'drain'` event.\n+ *\n+ * @private\n+ */\n+function receiverOnDrain () {\n+  this[kWebSocket]._socket.resume();\n+}\n+\n+/**\n+ * The listener of the `Receiver` `'error'` event.\n+ *\n+ * @param {(RangeError|Error)} err The emitted error\n+ * @private\n+ */\n+function receiverOnError (err) {\n+  const websocket = this[kWebSocket];\n+\n+  websocket.readyState = WebSocket.CLOSING;\n+  websocket._closeCode = err[constants.kStatusCode];\n+  websocket.emit('error', err);\n+  websocket._socket.destroy();\n+}\n+\n+/**\n+ * The listener of the `Receiver` `'finish'` event.\n+ *\n+ * @private\n+ */\n+function receiverOnFinish () {\n+  this[kWebSocket].emitClose();\n+}\n+\n+/**\n+ * The listener of the `Receiver` `'message'` event.\n+ *\n+ * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message\n+ * @private\n+ */\n+function receiverOnMessage (data) {\n+  this[kWebSocket].emit('message', data);\n+}\n+\n+/**\n+ * The listener of the `Receiver` `'ping'` event.\n+ *\n+ * @param {Buffer} data The data included in the ping frame\n+ * @private\n+ */\n+function receiverOnPing (data) {\n+  const websocket = this[kWebSocket];\n+\n+  websocket.pong(data, !websocket._isServer, constants.NOOP);\n+  websocket.emit('ping', data);\n+}\n+\n+/**\n+ * The listener of the `Receiver` `'pong'` event.\n+ *\n+ * @param {Buffer} data The data included in the pong frame\n+ * @private\n+ */\n+function receiverOnPong (data) {\n+  this[kWebSocket].emit('pong', data);\n+}\n+\n+/**\n+ * The listener of the `net.Socket` `'close'` event.\n+ *\n+ * @private\n+ */\n+function socketOnClose () {\n+  const websocket = this[kWebSocket];\n+\n+  this.removeListener('close', socketOnClose);\n+  this.removeListener('data', socketOnData);\n+  this.removeListener('end', socketOnEnd);\n+  this[kWebSocket] = undefined;\n+\n+  websocket.readyState = WebSocket.CLOSING;\n+\n+  //\n+  // The close frame might not have been received or the `'end'` event emitted,\n+  // for example, if the socket was destroyed due to an error. Ensure that the\n+  // `receiver` stream is closed after writing any remaining buffered data to\n+  // it.\n+  //\n+  websocket._socket.read();\n+  websocket._receiver.end();\n+\n+  clearTimeout(websocket._closeTimer);\n+\n+  if (\n+    websocket._receiver._writableState.finished ||\n+    websocket._receiver._writableState.errorEmitted\n+  ) {\n+    websocket.emitClose();\n+  } else {\n+    websocket._receiver.on('error', receiverOnFinish);\n+    websocket._receiver.on('finish', receiverOnFinish);\n+  }\n+}\n+\n+/**\n+ * The listener of the `net.Socket` `'data'` event.\n+ *\n+ * @param {Buffer} chunk A chunk of data\n+ * @private\n+ */\n+function socketOnData (chunk) {\n+  if (!this[kWebSocket]._receiver.write(chunk)) {\n+    this.pause();\n+  }\n+}\n+\n+/**\n+ * The listener of the `net.Socket` `'end'` event.\n+ *\n+ * @private\n+ */\n+function socketOnEnd () {\n+  const websocket = this[kWebSocket];\n+\n+  websocket.readyState = WebSocket.CLOSING;\n+  websocket._receiver.end();\n+  this.end();\n+}\n+\n+/**\n+ * The listener of the `net.Socket` `'error'` event.\n+ *\n+ * @private\n+ */\n+function socketOnError () {\n+  const websocket = this[kWebSocket];\n+\n+  this.removeListener('error', socketOnError);\n+  this.on('error', constants.NOOP);\n+\n+  if (websocket) {\n+    websocket.readyState = WebSocket.CLOSING;\n+    this.destroy();\n+  }\n+}"},{"sha":"f235719ead639fa058fd974645856777a78c2c6c","filename":"test/receiver.test.js","status":"modified","additions":303,"deletions":426,"changes":729,"blob_url":"https://github.com/websockets/ws/blob/908c358bd801dcc60583924058a5d565ec5ecf0b/test%2Freceiver.test.js","raw_url":"https://github.com/websockets/ws/raw/908c358bd801dcc60583924058a5d565ec5ecf0b/test%2Freceiver.test.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/test%2Freceiver.test.js?ref=908c358bd801dcc60583924058a5d565ec5ecf0b","patch":"@@ -5,48 +5,52 @@ const assert = require('assert');\n const crypto = require('crypto');\n \n const PerMessageDeflate = require('../lib/permessage-deflate');\n+const constants = require('../lib/constants');\n const Receiver = require('../lib/receiver');\n const Sender = require('../lib/sender');\n \n+const kStatusCode = constants.kStatusCode;\n const Buffer = safeBuffer.Buffer;\n \n describe('Receiver', function () {\n-  it('can parse unmasked text message', function (done) {\n-    const p = new Receiver();\n+  it('parses an unmasked text message', function (done) {\n+    const receiver = new Receiver();\n \n-    p.onmessage = function (data) {\n+    receiver.on('message', (data) => {\n       assert.strictEqual(data, 'Hello');\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from('810548656c6c6f', 'hex'));\n+    receiver.write(Buffer.from('810548656c6c6f', 'hex'));\n   });\n \n-  it('can parse close message', function (done) {\n-    const p = new Receiver();\n+  it('parses a close message', function (done) {\n+    const receiver = new Receiver();\n \n-    p.onclose = function (code, data) {\n+    receiver.on('close', (code, data) => {\n       assert.strictEqual(code, 1005);\n       assert.strictEqual(data, '');\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from('8800', 'hex'));\n+    receiver.write(Buffer.from('8800', 'hex'));\n   });\n \n-  it('can parse masked text message', function (done) {\n-    const p = new Receiver();\n+  it('parses a masked text message', function (done) {\n+    const receiver = new Receiver();\n \n-    p.onmessage = function (data) {\n+    receiver.on('message', (data) => {\n       assert.strictEqual(data, '5:::{\"name\":\"echo\"}');\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from('81933483a86801b992524fa1c60959e68a5216e6cb005ba1d5', 'hex'));\n+    receiver.write(\n+      Buffer.from('81933483a86801b992524fa1c60959e68a5216e6cb005ba1d5', 'hex')\n+    );\n   });\n \n-  it('can parse a masked text message longer than 125 B', function (done) {\n-    const p = new Receiver();\n+  it('parses a masked text message longer than 125 B', function (done) {\n+    const receiver = new Receiver();\n     const msg = 'A'.repeat(200);\n \n     const list = Sender.frame(Buffer.from(msg), {\n@@ -59,17 +63,17 @@ describe('Receiver', function () {\n \n     const frame = Buffer.concat(list);\n \n-    p.onmessage = function (data) {\n+    receiver.on('message', (data) => {\n       assert.strictEqual(data, msg);\n       done();\n-    };\n+    });\n \n-    p.add(frame.slice(0, 2));\n-    setImmediate(() => p.add(frame.slice(2)));\n+    receiver.write(frame.slice(0, 2));\n+    setImmediate(() => receiver.write(frame.slice(2)));\n   });\n \n-  it('can parse a really long masked text message', function (done) {\n-    const p = new Receiver();\n+  it('parses a really long masked text message', function (done) {\n+    const receiver = new Receiver();\n     const msg = 'A'.repeat(64 * 1024);\n \n     const list = Sender.frame(Buffer.from(msg), {\n@@ -82,16 +86,16 @@ describe('Receiver', function () {\n \n     const frame = Buffer.concat(list);\n \n-    p.onmessage = function (data) {\n+    receiver.on('message', (data) => {\n       assert.strictEqual(data, msg);\n       done();\n-    };\n+    });\n \n-    p.add(frame);\n+    receiver.write(frame);\n   });\n \n-  it('can parse a fragmented masked text message of 300 B', function (done) {\n-    const p = new Receiver();\n+  it('parses a 300 B fragmented masked text message', function (done) {\n+    const receiver = new Receiver();\n     const msg = 'A'.repeat(300);\n \n     const fragment1 = msg.substr(0, 150);\n@@ -108,17 +112,17 @@ describe('Receiver', function () {\n       Object.assign({ fin: true, opcode: 0x00 }, options)\n     ));\n \n-    p.onmessage = function (data) {\n+    receiver.on('message', (data) => {\n       assert.strictEqual(data, msg);\n       done();\n-    };\n+    });\n \n-    p.add(frame1);\n-    p.add(frame2);\n+    receiver.write(frame1);\n+    receiver.write(frame2);\n   });\n \n-  it('can parse a ping message', function (done) {\n-    const p = new Receiver();\n+  it('parses a ping message', function (done) {\n+    const receiver = new Receiver();\n     const msg = 'Hello';\n \n     const list = Sender.frame(Buffer.from(msg), {\n@@ -131,27 +135,27 @@ describe('Receiver', function () {\n \n     const frame = Buffer.concat(list);\n \n-    p.onping = function (data) {\n+    receiver.on('ping', (data) => {\n       assert.strictEqual(data.toString(), msg);\n       done();\n-    };\n+    });\n \n-    p.add(frame);\n+    receiver.write(frame);\n   });\n \n-  it('can parse a ping with no data', function (done) {\n-    const p = new Receiver();\n+  it('parses a ping message with no data', function (done) {\n+    const receiver = new Receiver();\n \n-    p.onping = function (data) {\n+    receiver.on('ping', (data) => {\n       assert.ok(data.equals(Buffer.alloc(0)));\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from('8900', 'hex'));\n+    receiver.write(Buffer.from('8900', 'hex'));\n   });\n \n-  it('can parse a fragmented masked text message of 300 B with a ping in the middle (1/2)', function (done) {\n-    const p = new Receiver();\n+  it('parses a 300 B fragmented masked text message with a ping in the middle (1/2)', function (done) {\n+    const receiver = new Receiver();\n     const msg = 'A'.repeat(300);\n     const pingMessage = 'Hello';\n \n@@ -175,23 +179,23 @@ describe('Receiver', function () {\n \n     let gotPing = false;\n \n-    p.onmessage = function (data) {\n+    receiver.on('message', (data) => {\n       assert.strictEqual(data, msg);\n       assert.ok(gotPing);\n       done();\n-    };\n-    p.onping = function (data) {\n+    });\n+    receiver.on('ping', (data) => {\n       gotPing = true;\n       assert.strictEqual(data.toString(), pingMessage);\n-    };\n+    });\n \n-    p.add(frame1);\n-    p.add(frame2);\n-    p.add(frame3);\n+    receiver.write(frame1);\n+    receiver.write(frame2);\n+    receiver.write(frame3);\n   });\n \n-  it('can parse a fragmented masked text message of 300 B with a ping in the middle (2/2)', function (done) {\n-    const p = new Receiver();\n+  it('parses a 300 B fragmented masked text message with a ping in the middle (2/2)', function (done) {\n+    const receiver = new Receiver();\n     const msg = 'A'.repeat(300);\n     const pingMessage = 'Hello';\n \n@@ -225,23 +229,23 @@ describe('Receiver', function () {\n \n     let gotPing = false;\n \n-    p.onmessage = function (data) {\n+    receiver.on('message', (data) => {\n       assert.strictEqual(data, msg);\n       assert.ok(gotPing);\n       done();\n-    };\n-    p.onping = function (data) {\n+    });\n+    receiver.on('ping', (data) => {\n       gotPing = true;\n       assert.strictEqual(data.toString(), pingMessage);\n-    };\n+    });\n \n     for (let i = 0; i < chunks.length; ++i) {\n-      p.add(chunks[i]);\n+      receiver.write(chunks[i]);\n     }\n   });\n \n-  it('can parse a 100 B long masked binary message', function (done) {\n-    const p = new Receiver();\n+  it('parses a 100 B masked binary message', function (done) {\n+    const receiver = new Receiver();\n     const msg = crypto.randomBytes(100);\n \n     const list = Sender.frame(msg, {\n@@ -254,16 +258,16 @@ describe('Receiver', function () {\n \n     const frame = Buffer.concat(list);\n \n-    p.onmessage = function (data) {\n+    receiver.on('message', (data) => {\n       assert.ok(data.equals(msg));\n       done();\n-    };\n+    });\n \n-    p.add(frame);\n+    receiver.write(frame);\n   });\n \n-  it('can parse a 256 B long masked binary message', function (done) {\n-    const p = new Receiver();\n+  it('parses a 256 B masked binary message', function (done) {\n+    const receiver = new Receiver();\n     const msg = crypto.randomBytes(256);\n \n     const list = Sender.frame(msg, {\n@@ -276,16 +280,16 @@ describe('Receiver', function () {\n \n     const frame = Buffer.concat(list);\n \n-    p.onmessage = function (data) {\n+    receiver.on('message', (data) => {\n       assert.ok(data.equals(msg));\n       done();\n-    };\n+    });\n \n-    p.add(frame);\n+    receiver.write(frame);\n   });\n \n-  it('can parse a 200 KiB long masked binary message', function (done) {\n-    const p = new Receiver();\n+  it('parses a 200 KiB masked binary message', function (done) {\n+    const receiver = new Receiver();\n     const msg = crypto.randomBytes(200 * 1024);\n \n     const list = Sender.frame(msg, {\n@@ -298,16 +302,16 @@ describe('Receiver', function () {\n \n     const frame = Buffer.concat(list);\n \n-    p.onmessage = function (data) {\n+    receiver.on('message', (data) => {\n       assert.ok(data.equals(msg));\n       done();\n-    };\n+    });\n \n-    p.add(frame);\n+    receiver.write(frame);\n   });\n \n-  it('can parse a 200 KiB long unmasked binary message', function (done) {\n-    const p = new Receiver();\n+  it('parses a 200 KiB unmasked binary message', function (done) {\n+    const receiver = new Receiver();\n     const msg = crypto.randomBytes(200 * 1024);\n \n     const list = Sender.frame(msg, {\n@@ -320,399 +324,421 @@ describe('Receiver', function () {\n \n     const frame = Buffer.concat(list);\n \n-    p.onmessage = function (data) {\n+    receiver.on('message', (data) => {\n       assert.ok(data.equals(msg));\n       done();\n-    };\n+    });\n \n-    p.add(frame);\n+    receiver.write(frame);\n   });\n \n-  it('can parse compressed message', function (done) {\n+  it('parses a compressed message', function (done) {\n     const perMessageDeflate = new PerMessageDeflate();\n     perMessageDeflate.accept([{}]);\n \n-    const p = new Receiver({ 'permessage-deflate': perMessageDeflate });\n+    const receiver = new Receiver({ 'permessage-deflate': perMessageDeflate });\n     const buf = Buffer.from('Hello');\n \n-    p.onmessage = function (data) {\n+    receiver.on('message', (data) => {\n       assert.strictEqual(data, 'Hello');\n       done();\n-    };\n+    });\n \n-    perMessageDeflate.compress(buf, true, function (err, compressed) {\n+    perMessageDeflate.compress(buf, true, (err, data) => {\n       if (err) return done(err);\n \n-      p.add(Buffer.from([0xc1, compressed.length]));\n-      p.add(compressed);\n+      receiver.write(Buffer.from([0xc1, data.length]));\n+      receiver.write(data);\n     });\n   });\n \n-  it('can parse compressed fragments', function (done) {\n+  it('parses a compressed and fragmented message', function (done) {\n     const perMessageDeflate = new PerMessageDeflate();\n     perMessageDeflate.accept([{}]);\n \n-    const p = new Receiver({ 'permessage-deflate': perMessageDeflate });\n+    const receiver = new Receiver({ 'permessage-deflate': perMessageDeflate });\n     const buf1 = Buffer.from('foo');\n     const buf2 = Buffer.from('bar');\n \n-    p.onmessage = function (data) {\n+    receiver.on('message', (data) => {\n       assert.strictEqual(data, 'foobar');\n       done();\n-    };\n+    });\n \n-    perMessageDeflate.compress(buf1, false, function (err, compressed1) {\n+    perMessageDeflate.compress(buf1, false, function (err, fragment1) {\n       if (err) return done(err);\n \n-      p.add(Buffer.from([0x41, compressed1.length]));\n-      p.add(compressed1);\n+      receiver.write(Buffer.from([0x41, fragment1.length]));\n+      receiver.write(fragment1);\n \n-      perMessageDeflate.compress(buf2, true, function (err, compressed2) {\n+      perMessageDeflate.compress(buf2, true, function (err, fragment2) {\n         if (err) return done(err);\n \n-        p.add(Buffer.from([0x80, compressed2.length]));\n-        p.add(compressed2);\n+        receiver.write(Buffer.from([0x80, fragment2.length]));\n+        receiver.write(fragment2);\n       });\n     });\n   });\n \n-  it('can parse a buffer with thousands of frames', function (done) {\n+  it('parses a buffer with thousands of frames', function (done) {\n     const buf = Buffer.allocUnsafe(40000);\n \n     for (let i = 0; i < buf.length; i += 2) {\n       buf[i] = 0x81;\n       buf[i + 1] = 0x00;\n     }\n \n-    const p = new Receiver();\n+    const receiver = new Receiver();\n     let counter = 0;\n \n-    p.onmessage = function (data) {\n+    receiver.on('message', (data) => {\n       assert.strictEqual(data, '');\n       if (++counter === 20000) done();\n-    };\n+    });\n \n-    p.add(buf);\n+    receiver.write(buf);\n   });\n \n-  it('resets `totalPayloadLength` only on final frame (unfragmented)', function () {\n-    const p = new Receiver({}, 10);\n-    let message;\n+  it('resets `totalPayloadLength` only on final frame (unfragmented)', function (done) {\n+    const receiver = new Receiver({}, 10);\n \n-    p.onmessage = function (msg) {\n-      message = msg;\n-    };\n+    receiver.on('message', (data) => {\n+      assert.strictEqual(receiver._totalPayloadLength, 0);\n+      assert.strictEqual(data, 'Hello');\n+      done();\n+    });\n \n-    assert.strictEqual(p._totalPayloadLength, 0);\n-    p.add(Buffer.from('810548656c6c6f', 'hex'));\n-    assert.strictEqual(p._totalPayloadLength, 0);\n-    assert.strictEqual(message, 'Hello');\n+    assert.strictEqual(receiver._totalPayloadLength, 0);\n+    receiver.write(Buffer.from('810548656c6c6f', 'hex'));\n   });\n \n-  it('resets `totalPayloadLength` only on final frame (fragmented)', function () {\n-    const p = new Receiver({}, 10);\n-    let message;\n+  it('resets `totalPayloadLength` only on final frame (fragmented)', function (done) {\n+    const receiver = new Receiver({}, 10);\n \n-    p.onmessage = function (msg) {\n-      message = msg;\n-    };\n+    receiver.on('message', (data) => {\n+      assert.strictEqual(receiver._totalPayloadLength, 0);\n+      assert.strictEqual(data, 'Hello');\n+      done();\n+    });\n \n-    assert.strictEqual(p._totalPayloadLength, 0);\n-    p.add(Buffer.from('01024865', 'hex'));\n-    assert.strictEqual(p._totalPayloadLength, 2);\n-    p.add(Buffer.from('80036c6c6f', 'hex'));\n-    assert.strictEqual(p._totalPayloadLength, 0);\n-    assert.strictEqual(message, 'Hello');\n+    assert.strictEqual(receiver._totalPayloadLength, 0);\n+    receiver.write(Buffer.from('01024865', 'hex'));\n+    assert.strictEqual(receiver._totalPayloadLength, 2);\n+    receiver.write(Buffer.from('80036c6c6f', 'hex'));\n   });\n \n-  it('resets `totalPayloadLength` only on final frame (fragmented + ping)', function () {\n-    const p = new Receiver({}, 10);\n-    const data = [];\n+  it('resets `totalPayloadLength` only on final frame (fragmented + ping)', function (done) {\n+    const receiver = new Receiver({}, 10);\n+    let data;\n \n-    p.onmessage = p.onping = function (buf) {\n-      data.push(buf.toString());\n-    };\n+    receiver.on('ping', (buf) => {\n+      assert.strictEqual(receiver._totalPayloadLength, 2);\n+      data = buf.toString();\n+    });\n+    receiver.on('message', (buf) => {\n+      assert.strictEqual(receiver._totalPayloadLength, 0);\n+      assert.strictEqual(data, '');\n+      assert.strictEqual(buf.toString(), 'Hello');\n+      done();\n+    });\n+\n+    assert.strictEqual(receiver._totalPayloadLength, 0);\n+    receiver.write(Buffer.from('02024865', 'hex'));\n+    receiver.write(Buffer.from('8900', 'hex'));\n+    receiver.write(Buffer.from('80036c6c6f', 'hex'));\n+  });\n+\n+  it('ignores any data after a close frame', function (done) {\n+    const perMessageDeflate = new PerMessageDeflate();\n+    perMessageDeflate.accept([{}]);\n+\n+    const receiver = new Receiver({ 'permessage-deflate': perMessageDeflate });\n+    const results = [];\n+    const push = results.push.bind(results);\n \n-    assert.strictEqual(p._totalPayloadLength, 0);\n-    p.add(Buffer.from('02024865', 'hex'));\n-    assert.strictEqual(p._totalPayloadLength, 2);\n-    p.add(Buffer.from('8900', 'hex'));\n-    assert.strictEqual(p._totalPayloadLength, 2);\n-    p.add(Buffer.from('80036c6c6f', 'hex'));\n-    assert.strictEqual(p._totalPayloadLength, 0);\n-    assert.deepStrictEqual(data, ['', 'Hello']);\n+    receiver.on('close', push).on('message', push);\n+    receiver.on('finish', () => {\n+      assert.deepStrictEqual(results, ['', 1005, '']);\n+      done();\n+    });\n+\n+    receiver.write(Buffer.from([0xc1, 0x01, 0x00]));\n+    receiver.write(Buffer.from([0x88, 0x00]));\n+    receiver.write(Buffer.from([0x81, 0x00]));\n   });\n \n-  it('raises an error when RSV1 is on and permessage-deflate is disabled', function (done) {\n-    const p = new Receiver();\n+  it('emits an error if RSV1 is on and permessage-deflate is disabled', function (done) {\n+    const receiver = new Receiver();\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof RangeError);\n       assert.strictEqual(\n         err.message,\n         'Invalid WebSocket frame: RSV1 must be clear'\n       );\n-      assert.strictEqual(code, 1002);\n+      assert.strictEqual(err[kStatusCode], 1002);\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from([0xc2, 0x80, 0x00, 0x00, 0x00, 0x00]));\n+    receiver.write(Buffer.from([0xc2, 0x80, 0x00, 0x00, 0x00, 0x00]));\n   });\n \n-  it('raises an error when RSV1 is on and opcode is 0', function (done) {\n+  it('emits an error if RSV1 is on and opcode is 0', function (done) {\n     const perMessageDeflate = new PerMessageDeflate();\n     perMessageDeflate.accept([{}]);\n \n-    const p = new Receiver({ 'permessage-deflate': perMessageDeflate });\n+    const receiver = new Receiver({ 'permessage-deflate': perMessageDeflate });\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof RangeError);\n       assert.strictEqual(\n         err.message,\n         'Invalid WebSocket frame: RSV1 must be clear'\n       );\n-      assert.strictEqual(code, 1002);\n+      assert.strictEqual(err[kStatusCode], 1002);\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from([0x40, 0x00]));\n+    receiver.write(Buffer.from([0x40, 0x00]));\n   });\n \n-  it('raises an error when RSV2 is on', function (done) {\n-    const p = new Receiver();\n+  it('emits an error if RSV2 is on', function (done) {\n+    const receiver = new Receiver();\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof RangeError);\n       assert.strictEqual(\n         err.message,\n         'Invalid WebSocket frame: RSV2 and RSV3 must be clear'\n       );\n-      assert.strictEqual(code, 1002);\n+      assert.strictEqual(err[kStatusCode], 1002);\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from([0xa2, 0x00]));\n+    receiver.write(Buffer.from([0xa2, 0x00]));\n   });\n \n-  it('raises an error when RSV3 is on', function (done) {\n-    const p = new Receiver();\n+  it('emits an error if RSV3 is on', function (done) {\n+    const receiver = new Receiver();\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof RangeError);\n       assert.strictEqual(\n         err.message,\n         'Invalid WebSocket frame: RSV2 and RSV3 must be clear'\n       );\n-      assert.strictEqual(code, 1002);\n+      assert.strictEqual(err[kStatusCode], 1002);\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from([0x92, 0x00]));\n+    receiver.write(Buffer.from([0x92, 0x00]));\n   });\n \n-  it('raises an error if the first frame in a fragmented message has opcode 0', function (done) {\n-    const p = new Receiver();\n+  it('emits an error if the first frame in a fragmented message has opcode 0', function (done) {\n+    const receiver = new Receiver();\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof RangeError);\n       assert.strictEqual(\n         err.message,\n         'Invalid WebSocket frame: invalid opcode 0'\n       );\n-      assert.strictEqual(code, 1002);\n+      assert.strictEqual(err[kStatusCode], 1002);\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from([0x00, 0x00]));\n+    receiver.write(Buffer.from([0x00, 0x00]));\n   });\n \n-  it('raises an error if a frame has opcode 1 in the middle of a fragmented message', function (done) {\n-    const p = new Receiver();\n+  it('emits an error if a frame has opcode 1 in the middle of a fragmented message', function (done) {\n+    const receiver = new Receiver();\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof RangeError);\n       assert.strictEqual(\n         err.message,\n         'Invalid WebSocket frame: invalid opcode 1'\n       );\n-      assert.strictEqual(code, 1002);\n+      assert.strictEqual(err[kStatusCode], 1002);\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from([0x01, 0x00]));\n-    p.add(Buffer.from([0x01, 0x00]));\n+    receiver.write(Buffer.from([0x01, 0x00]));\n+    receiver.write(Buffer.from([0x01, 0x00]));\n   });\n \n-  it('raises an error if a frame has opcode 2 in the middle of a fragmented message', function (done) {\n-    const p = new Receiver();\n+  it('emits an error if a frame has opcode 2 in the middle of a fragmented message', function (done) {\n+    const receiver = new Receiver();\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof RangeError);\n       assert.strictEqual(\n         err.message,\n         'Invalid WebSocket frame: invalid opcode 2'\n       );\n-      assert.strictEqual(code, 1002);\n+      assert.strictEqual(err[kStatusCode], 1002);\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from([0x01, 0x00]));\n-    p.add(Buffer.from([0x02, 0x00]));\n+    receiver.write(Buffer.from([0x01, 0x00]));\n+    receiver.write(Buffer.from([0x02, 0x00]));\n   });\n \n-  it('raises an error when a control frame has the FIN bit off', function (done) {\n-    const p = new Receiver();\n+  it('emits an error if a control frame has the FIN bit off', function (done) {\n+    const receiver = new Receiver();\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof RangeError);\n       assert.strictEqual(\n         err.message,\n         'Invalid WebSocket frame: FIN must be set'\n       );\n-      assert.strictEqual(code, 1002);\n+      assert.strictEqual(err[kStatusCode], 1002);\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from([0x09, 0x00]));\n+    receiver.write(Buffer.from([0x09, 0x00]));\n   });\n \n-  it('raises an error when a control frame has the RSV1 bit on', function (done) {\n+  it('emits an error if a control frame has the RSV1 bit on', function (done) {\n     const perMessageDeflate = new PerMessageDeflate();\n     perMessageDeflate.accept([{}]);\n \n-    const p = new Receiver({ 'permessage-deflate': perMessageDeflate });\n+    const receiver = new Receiver({ 'permessage-deflate': perMessageDeflate });\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof RangeError);\n       assert.strictEqual(\n         err.message,\n         'Invalid WebSocket frame: RSV1 must be clear'\n       );\n-      assert.strictEqual(code, 1002);\n+      assert.strictEqual(err[kStatusCode], 1002);\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from([0xc9, 0x00]));\n+    receiver.write(Buffer.from([0xc9, 0x00]));\n   });\n \n-  it('raises an error when a control frame has the FIN bit off', function (done) {\n-    const p = new Receiver();\n+  it('emits an error if a control frame has the FIN bit off', function (done) {\n+    const receiver = new Receiver();\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof RangeError);\n       assert.strictEqual(\n         err.message,\n         'Invalid WebSocket frame: FIN must be set'\n       );\n-      assert.strictEqual(code, 1002);\n+      assert.strictEqual(err[kStatusCode], 1002);\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from([0x09, 0x00]));\n+    receiver.write(Buffer.from([0x09, 0x00]));\n   });\n \n-  it('raises an error when a control frame has a payload bigger than 125 B', function (done) {\n-    const p = new Receiver();\n+  it('emits an error if a control frame has a payload bigger than 125 B', function (done) {\n+    const receiver = new Receiver();\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof RangeError);\n       assert.strictEqual(\n         err.message,\n         'Invalid WebSocket frame: invalid payload length 126'\n       );\n-      assert.strictEqual(code, 1002);\n+      assert.strictEqual(err[kStatusCode], 1002);\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from([0x89, 0x7e]));\n+    receiver.write(Buffer.from([0x89, 0x7e]));\n   });\n \n-  it('raises an error when a data frame has a payload bigger than 2^53 - 1 B', function (done) {\n-    const p = new Receiver();\n+  it('emits an error if a data frame has a payload bigger than 2^53 - 1 B', function (done) {\n+    const receiver = new Receiver();\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof RangeError);\n       assert.strictEqual(\n         err.message,\n         'Unsupported WebSocket frame: payload length > 2^53 - 1'\n       );\n-      assert.strictEqual(code, 1009);\n+      assert.strictEqual(err[kStatusCode], 1009);\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from([0x82, 0x7f]));\n-    setImmediate(() => p.add(Buffer.from([\n+    receiver.write(Buffer.from([0x82, 0x7f]));\n+    setImmediate(() => receiver.write(Buffer.from([\n       0x00, 0x20, 0x00, 0x00,\n       0x00, 0x00, 0x00, 0x00\n     ])));\n   });\n \n-  it('raises an error if a text frame contains invalid UTF-8 data', function (done) {\n-    const p = new Receiver();\n+  it('emits an error if a text frame contains invalid UTF-8 data', function (done) {\n+    const receiver = new Receiver();\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof Error);\n       assert.strictEqual(\n         err.message,\n         'Invalid WebSocket frame: invalid UTF-8 sequence'\n       );\n-      assert.strictEqual(code, 1007);\n+      assert.strictEqual(err[kStatusCode], 1007);\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from([0x81, 0x04, 0xce, 0xba, 0xe1, 0xbd]));\n+    receiver.write(Buffer.from([0x81, 0x04, 0xce, 0xba, 0xe1, 0xbd]));\n   });\n \n-  it('raises an error if a close frame has a payload of 1 B', function (done) {\n-    const p = new Receiver();\n+  it('emits an error if a close frame has a payload of 1 B', function (done) {\n+    const receiver = new Receiver();\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof RangeError);\n       assert.strictEqual(\n         err.message,\n         'Invalid WebSocket frame: invalid payload length 1'\n       );\n-      assert.strictEqual(code, 1002);\n+      assert.strictEqual(err[kStatusCode], 1002);\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from([0x88, 0x01, 0x00]));\n+    receiver.write(Buffer.from([0x88, 0x01, 0x00]));\n   });\n \n-  it('raises an error if a close frame contains an invalid close code', function (done) {\n-    const p = new Receiver();\n+  it('emits an error if a close frame contains an invalid close code', function (done) {\n+    const receiver = new Receiver();\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof RangeError);\n       assert.strictEqual(\n         err.message,\n         'Invalid WebSocket frame: invalid status code 0'\n       );\n-      assert.strictEqual(code, 1002);\n+      assert.strictEqual(err[kStatusCode], 1002);\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from([0x88, 0x02, 0x00, 0x00]));\n+    receiver.write(Buffer.from([0x88, 0x02, 0x00, 0x00]));\n   });\n \n-  it('raises an error if a close frame contains invalid UTF-8 data', function (done) {\n-    const p = new Receiver();\n+  it('emits an error if a close frame contains invalid UTF-8 data', function (done) {\n+    const receiver = new Receiver();\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof Error);\n       assert.strictEqual(\n         err.message,\n         'Invalid WebSocket frame: invalid UTF-8 sequence'\n       );\n-      assert.strictEqual(code, 1007);\n+      assert.strictEqual(err[kStatusCode], 1007);\n       done();\n-    };\n+    });\n \n-    p.add(Buffer.from([0x88, 0x06, 0x03, 0xef, 0xce, 0xba, 0xe1, 0xbd]));\n+    receiver.write(\n+      Buffer.from([0x88, 0x06, 0x03, 0xef, 0xce, 0xba, 0xe1, 0xbd])\n+    );\n   });\n \n-  it('raises an error on a 200 KiB long masked binary message when `maxPayload` is 20 KiB', function (done) {\n-    const p = new Receiver({}, 20 * 1024);\n+  it('emits an error if a frame payload length is bigger than `maxPayload`', function (done) {\n+    const receiver = new Receiver({}, 20 * 1024);\n     const msg = crypto.randomBytes(200 * 1024);\n \n     const list = Sender.frame(msg, {\n@@ -725,234 +751,85 @@ describe('Receiver', function () {\n \n     const frame = Buffer.concat(list);\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof RangeError);\n       assert.strictEqual(err.message, 'Max payload size exceeded');\n-      assert.strictEqual(code, 1009);\n+      assert.strictEqual(err[kStatusCode], 1009);\n       done();\n-    };\n-\n-    p.add(frame);\n-  });\n-\n-  it('raises an error on a 200 KiB long unmasked binary message when `maxPayload` is 20 KiB', function (done) {\n-    const p = new Receiver({}, 20 * 1024);\n-    const msg = crypto.randomBytes(200 * 1024);\n-\n-    const list = Sender.frame(msg, {\n-      fin: true,\n-      rsv1: false,\n-      opcode: 0x02,\n-      mask: false,\n-      readOnly: true\n     });\n \n-    const frame = Buffer.concat(list);\n-\n-    p.onerror = function (err, code) {\n-      assert.ok(err instanceof RangeError);\n-      assert.strictEqual(err.message, 'Max payload size exceeded');\n-      assert.strictEqual(code, 1009);\n-      done();\n-    };\n-\n-    p.add(frame);\n+    receiver.write(frame);\n   });\n \n-  it('raises an error on a compressed message that exceeds `maxPayload`', function (done) {\n+  it('emits an error if the message length exceeds `maxPayload`', function (done) {\n     const perMessageDeflate = new PerMessageDeflate({}, false, 25);\n     perMessageDeflate.accept([{}]);\n \n-    const p = new Receiver({ 'permessage-deflate': perMessageDeflate }, 25);\n+    const receiver = new Receiver({\n+      'permessage-deflate': perMessageDeflate\n+    }, 25);\n     const buf = Buffer.from('A'.repeat(50));\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof RangeError);\n       assert.strictEqual(err.message, 'Max payload size exceeded');\n-      assert.strictEqual(code, 1009);\n+      assert.strictEqual(err[kStatusCode], 1009);\n       done();\n-    };\n+    });\n \n     perMessageDeflate.compress(buf, true, function (err, data) {\n       if (err) return done(err);\n \n-      p.add(Buffer.from([0xc1, data.length]));\n-      p.add(data);\n+      receiver.write(Buffer.from([0xc1, data.length]));\n+      receiver.write(data);\n     });\n   });\n \n-  it('raises an error if the sum of fragment lengths exceeds `maxPayload`', function (done) {\n+  it('emits an error if the sum of fragment lengths exceeds `maxPayload`', function (done) {\n     const perMessageDeflate = new PerMessageDeflate({}, false, 25);\n     perMessageDeflate.accept([{}]);\n \n-    const p = new Receiver({ 'permessage-deflate': perMessageDeflate }, 25);\n+    const receiver = new Receiver({\n+      'permessage-deflate': perMessageDeflate\n+    }, 25);\n     const buf = Buffer.from('A'.repeat(15));\n \n-    p.onerror = function (err, code) {\n+    receiver.on('error', (err) => {\n       assert.ok(err instanceof RangeError);\n       assert.strictEqual(err.message, 'Max payload size exceeded');\n-      assert.strictEqual(code, 1009);\n+      assert.strictEqual(err[kStatusCode], 1009);\n       done();\n-    };\n+    });\n \n     perMessageDeflate.compress(buf, false, function (err, fragment1) {\n       if (err) return done(err);\n \n-      p.add(Buffer.from([0x41, fragment1.length]));\n-      p.add(fragment1);\n+      receiver.write(Buffer.from([0x41, fragment1.length]));\n+      receiver.write(fragment1);\n \n       perMessageDeflate.compress(buf, true, function (err, fragment2) {\n         if (err) return done(err);\n \n-        p.add(Buffer.from([0x80, fragment2.length]));\n-        p.add(fragment2);\n-      });\n-    });\n-  });\n-\n-  it('consumes all data before calling `cleanup` callback (1/4)', function (done) {\n-    const perMessageDeflate = new PerMessageDeflate();\n-    perMessageDeflate.accept([{}]);\n-\n-    const p = new Receiver({ 'permessage-deflate': perMessageDeflate });\n-    const buf = Buffer.from('Hello');\n-    const results = [];\n-\n-    p.onmessage = (message) => results.push(message);\n-\n-    perMessageDeflate.compress(buf, true, (err, data) => {\n-      if (err) return done(err);\n-\n-      const frame = Buffer.concat([Buffer.from([0xc1, data.length]), data]);\n-\n-      p.add(frame);\n-      p.add(frame);\n-\n-      assert.strictEqual(p._state, 5);\n-      assert.strictEqual(p._bufferedBytes, frame.length);\n-\n-      p.cleanup(() => {\n-        assert.deepStrictEqual(results, ['Hello', 'Hello']);\n-        assert.strictEqual(p.onmessage, null);\n-        done();\n-      });\n-    });\n-  });\n-\n-  it('consumes all data before calling `cleanup` callback (2/4)', function (done) {\n-    const perMessageDeflate = new PerMessageDeflate();\n-    perMessageDeflate.accept([{}]);\n-\n-    const p = new Receiver({ 'permessage-deflate': perMessageDeflate });\n-    const buf = Buffer.from('Hello');\n-    const results = [];\n-\n-    p.onclose = (code, reason) => results.push(code, reason);\n-    p.onmessage = (message) => results.push(message);\n-\n-    perMessageDeflate.compress(buf, true, (err, data) => {\n-      if (err) return done(err);\n-\n-      const textFrame = Buffer.concat([Buffer.from([0xc1, data.length]), data]);\n-      const closeFrame = Buffer.from([0x88, 0x00]);\n-\n-      p.add(textFrame);\n-      p.add(textFrame);\n-      p.add(closeFrame);\n-\n-      assert.strictEqual(p._state, 5);\n-      assert.strictEqual(p._bufferedBytes, textFrame.length + closeFrame.length);\n-\n-      p.cleanup(() => {\n-        assert.deepStrictEqual(results, ['Hello', 'Hello', 1005, '']);\n-        assert.strictEqual(p.onmessage, null);\n-        done();\n-      });\n-    });\n-  });\n-\n-  it('consumes all data before calling `cleanup` callback (3/4)', function (done) {\n-    const perMessageDeflate = new PerMessageDeflate();\n-    perMessageDeflate.accept([{}]);\n-\n-    const p = new Receiver({ 'permessage-deflate': perMessageDeflate });\n-    const buf = Buffer.from('Hello');\n-    const results = [];\n-\n-    p.onerror = (err, code) => results.push(err.message, code);\n-    p.onmessage = (message) => results.push(message);\n-\n-    perMessageDeflate.compress(buf, true, (err, data) => {\n-      if (err) return done(err);\n-\n-      const textFrame = Buffer.concat([Buffer.from([0xc1, data.length]), data]);\n-      const invalidFrame = Buffer.from([0xa0, 0x00]);\n-\n-      p.add(textFrame);\n-      p.add(textFrame);\n-      p.add(invalidFrame);\n-\n-      assert.strictEqual(p._state, 5);\n-      assert.strictEqual(p._bufferedBytes, textFrame.length + invalidFrame.length);\n-\n-      p.cleanup(() => {\n-        assert.deepStrictEqual(results, [\n-          'Hello',\n-          'Hello',\n-          'Invalid WebSocket frame: RSV2 and RSV3 must be clear',\n-          1002\n-        ]);\n-        assert.strictEqual(p.onmessage, null);\n-        done();\n+        receiver.write(Buffer.from([0x80, fragment2.length]));\n+        receiver.write(fragment2);\n       });\n     });\n   });\n \n-  it('consumes all data before calling `cleanup` callback (4/4)', function (done) {\n-    const perMessageDeflate = new PerMessageDeflate();\n-    perMessageDeflate.accept([{}]);\n-\n-    const p = new Receiver({ 'permessage-deflate': perMessageDeflate });\n-    const buf = Buffer.from('Hello');\n-    const results = [];\n-\n-    p.onmessage = (message) => results.push(message);\n-\n-    perMessageDeflate.compress(buf, true, (err, data) => {\n-      if (err) return done(err);\n-\n-      const textFrame = Buffer.concat([Buffer.from([0xc1, data.length]), data]);\n-      const incompleteFrame = Buffer.from([0x82, 0x0a, 0x00, 0x00]);\n-\n-      p.add(textFrame);\n-      p.add(incompleteFrame);\n-\n-      assert.strictEqual(p._state, 5);\n-      assert.strictEqual(p._bufferedBytes, incompleteFrame.length);\n-\n-      p.cleanup(() => {\n-        assert.deepStrictEqual(results, ['Hello']);\n-        assert.strictEqual(p.onmessage, null);\n-        done();\n-      });\n-    });\n-  });\n-\n-  it('can emit nodebuffer of fragmented binary message', function (done) {\n-    const p = new Receiver();\n+  it(\"honors the 'nodebuffer' binary type\", function (done) {\n+    const receiver = new Receiver();\n     const frags = [\n       crypto.randomBytes(7321),\n       crypto.randomBytes(137),\n       crypto.randomBytes(285787),\n       crypto.randomBytes(3)\n     ];\n \n-    p.binaryType = 'nodebuffer';\n-    p.onmessage = (data) => {\n+    receiver.on('message', (data) => {\n       assert.ok(Buffer.isBuffer(data));\n       assert.ok(data.equals(Buffer.concat(frags)));\n       done();\n-    };\n+    });\n \n     frags.forEach((frag, i) => {\n       Sender.frame(frag, {\n@@ -961,24 +838,24 @@ describe('Receiver', function () {\n         readOnly: true,\n         mask: false,\n         rsv1: false\n-      }).forEach((buf) => p.add(buf));\n+      }).forEach((buf) => receiver.write(buf));\n     });\n   });\n \n-  it('can emit arraybuffer of fragmented binary message', function (done) {\n-    const p = new Receiver();\n+  it(\"honors the 'arraybuffer' binary type\", function (done) {\n+    const receiver = new Receiver();\n     const frags = [\n       crypto.randomBytes(19221),\n       crypto.randomBytes(954),\n       crypto.randomBytes(623987)\n     ];\n \n-    p._binaryType = 'arraybuffer';\n-    p.onmessage = (data) => {\n+    receiver._binaryType = 'arraybuffer';\n+    receiver.on('message', (data) => {\n       assert.ok(data instanceof ArrayBuffer);\n       assert.ok(Buffer.from(data).equals(Buffer.concat(frags)));\n       done();\n-    };\n+    });\n \n     frags.forEach((frag, i) => {\n       Sender.frame(frag, {\n@@ -987,12 +864,12 @@ describe('Receiver', function () {\n         readOnly: true,\n         mask: false,\n         rsv1: false\n-      }).forEach((buf) => p.add(buf));\n+      }).forEach((buf) => receiver.write(buf));\n     });\n   });\n \n-  it('can emit fragments of fragmented binary message', function (done) {\n-    const p = new Receiver();\n+  it(\"honors the 'fragments' binary type\", function (done) {\n+    const receiver = new Receiver();\n     const frags = [\n       crypto.randomBytes(17),\n       crypto.randomBytes(419872),\n@@ -1001,11 +878,11 @@ describe('Receiver', function () {\n       crypto.randomBytes(1)\n     ];\n \n-    p._binaryType = 'fragments';\n-    p.onmessage = (data) => {\n+    receiver._binaryType = 'fragments';\n+    receiver.on('message', (data) => {\n       assert.deepStrictEqual(data, frags);\n       done();\n-    };\n+    });\n \n     frags.forEach((frag, i) => {\n       Sender.frame(frag, {\n@@ -1014,7 +891,7 @@ describe('Receiver', function () {\n         readOnly: true,\n         mask: false,\n         rsv1: false\n-      }).forEach((buf) => p.add(buf));\n+      }).forEach((buf) => receiver.write(buf));\n     });\n   });\n });"},{"sha":"66e59acd59ab739d5ed9b59709bc6ae5c33e97af","filename":"test/websocket.test.js","status":"modified","additions":22,"deletions":31,"changes":53,"blob_url":"https://github.com/websockets/ws/blob/908c358bd801dcc60583924058a5d565ec5ecf0b/test%2Fwebsocket.test.js","raw_url":"https://github.com/websockets/ws/raw/908c358bd801dcc60583924058a5d565ec5ecf0b/test%2Fwebsocket.test.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/test%2Fwebsocket.test.js?ref=908c358bd801dcc60583924058a5d565ec5ecf0b","patch":"@@ -8,7 +8,6 @@ const crypto = require('crypto');\n const https = require('https');\n const http = require('http');\n const dns = require('dns');\n-const net = require('net');\n const fs = require('fs');\n const os = require('os');\n \n@@ -393,6 +392,28 @@ describe('WebSocket', function () {\n       });\n     });\n \n+    it('does not re-emit `net.Socket` errors', function (done) {\n+      const wss = new WebSocket.Server({ port: 0 }, () => {\n+        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n+\n+        ws.on('open', () => {\n+          ws._socket.on('error', (err) => {\n+            assert.ok(err instanceof Error);\n+            assert.ok(err.message.startsWith('write E'));\n+            ws.on('close', (code, message) => {\n+              assert.strictEqual(message, '');\n+              assert.strictEqual(code, 1006);\n+              wss.close(done);\n+            });\n+          });\n+\n+          for (const client of wss.clients) client.terminate();\n+          ws.send('foo');\n+          ws.send('bar');\n+        });\n+      });\n+    });\n+\n     it(\"emits an 'upgrade' event\", function (done) {\n       const wss = new WebSocket.Server({ port: 0 }, () => {\n         const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n@@ -1160,36 +1181,6 @@ describe('WebSocket', function () {\n       });\n     });\n \n-    it('emits an error if the close frame can not be sent', function (done) {\n-      const wss = new WebSocket.Server({ port: 0 }, () => {\n-        const socket = net.createConnection(wss.address().port, () => {\n-          socket.write(\n-            'GET / HTTP/1.1\\r\\n' +\n-            'Host: localhost\\r\\n' +\n-            'Upgrade: websocket\\r\\n' +\n-            'Connection: Upgrade\\r\\n' +\n-            'Sec-WebSocket-Key: qqFVFwaCnSMXiqfezY/AZQ==\\r\\n' +\n-            'Sec-WebSocket-Version: 13\\r\\n' +\n-            '\\r\\n'\n-          );\n-          socket.destroy();\n-        });\n-\n-        wss.on('connection', (ws) => {\n-          ws.on('error', (err) => {\n-            assert.ok(err instanceof Error);\n-            assert.ok(err.message.startsWith('write E'));\n-            ws.on('close', (code, message) => {\n-              assert.strictEqual(message, '');\n-              assert.strictEqual(code, 1006);\n-              wss.close(done);\n-            });\n-          });\n-          ws.close();\n-        });\n-      });\n-    });\n-\n     it('sends the close status code only when necessary', function (done) {\n       let sent;\n       const wss = new WebSocket.Server({ port: 0 }, () => {"}]},{"url":"https://api.github.com/repos/websockets/ws/issues/1105","repository_url":"https://api.github.com/repos/websockets/ws","labels_url":"https://api.github.com/repos/websockets/ws/issues/1105/labels{/name}","comments_url":"https://api.github.com/repos/websockets/ws/issues/1105/comments","events_url":"https://api.github.com/repos/websockets/ws/issues/1105/events","html_url":"https://github.com/websockets/ws/pull/1105","id":228462738,"node_id":"MDExOlB1bGxSZXF1ZXN0MTIwNDQyNTY4","number":1105,"title":"Prefix all private properties","user":{"login":"lpinca","id":1443911,"node_id":"MDQ6VXNlcjE0NDM5MTE=","avatar_url":"https://avatars.githubusercontent.com/u/1443911?v=4","gravatar_id":"","url":"https://api.github.com/users/lpinca","html_url":"https://github.com/lpinca","followers_url":"https://api.github.com/users/lpinca/followers","following_url":"https://api.github.com/users/lpinca/following{/other_user}","gists_url":"https://api.github.com/users/lpinca/gists{/gist_id}","starred_url":"https://api.github.com/users/lpinca/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/lpinca/subscriptions","organizations_url":"https://api.github.com/users/lpinca/orgs","repos_url":"https://api.github.com/users/lpinca/repos","events_url":"https://api.github.com/users/lpinca/events{/privacy}","received_events_url":"https://api.github.com/users/lpinca/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2017-05-13T09:53:47Z","updated_at":"2017-05-14T04:56:31Z","closed_at":"2017-05-14T04:56:25Z","author_association":"MEMBER","active_lock_reason":null,"draft":false,"pull_request":{"url":"https://api.github.com/repos/websockets/ws/pulls/1105","html_url":"https://github.com/websockets/ws/pull/1105","diff_url":"https://github.com/websockets/ws/pull/1105.diff","patch_url":"https://github.com/websockets/ws/pull/1105.patch","merged_at":"2017-05-14T04:56:25Z"},"body":"This patch prefixes all private properties with `_` in order to improve consistency in our codebase.\r\n\r\nI wanted to use symbols for private properties but it makes testing and debugging harder. We are also still supporting Node.js 4 and symbols have a significant performance impact there.","reactions":{"url":"https://api.github.com/repos/websockets/ws/issues/1105/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/websockets/ws/issues/1105/timeline","performed_via_github_app":null,"state_reason":null,"score":1,"files":[{"sha":"17bbf75ed2a09cfe2cfc72d935371fd872f0ff80","filename":"lib/PerMessageDeflate.js","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/websockets/ws/blob/d66e199017e0a1200c7e5a79b9b847063b55c13b/lib%2FPerMessageDeflate.js","raw_url":"https://github.com/websockets/ws/raw/d66e199017e0a1200c7e5a79b9b847063b55c13b/lib%2FPerMessageDeflate.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/lib%2FPerMessageDeflate.js?ref=d66e199017e0a1200c7e5a79b9b847063b55c13b","patch":"@@ -18,13 +18,16 @@ const DEFAULT_MEM_LEVEL = 8;\n  */\n class PerMessageDeflate {\n   constructor (options, isServer, maxPayload) {\n+    this._maxPayload = maxPayload | 0;\n     this._options = options || {};\n+    this._threshold = this._options.threshold !== undefined\n+      ? this._options.threshold\n+      : 1024;\n     this._isServer = !!isServer;\n-    this._inflate = null;\n     this._deflate = null;\n+    this._inflate = null;\n+\n     this.params = null;\n-    this._maxPayload = maxPayload || 0;\n-    this.threshold = this._options.threshold === undefined ? 1024 : this._options.threshold;\n   }\n \n   static get extensionName () {"},{"sha":"91196706c1937ae3f9e990c6aca3875f7d09d1d7","filename":"lib/Receiver.js","status":"modified","additions":117,"deletions":117,"changes":234,"blob_url":"https://github.com/websockets/ws/blob/d66e199017e0a1200c7e5a79b9b847063b55c13b/lib%2FReceiver.js","raw_url":"https://github.com/websockets/ws/raw/d66e199017e0a1200c7e5a79b9b847063b55c13b/lib%2FReceiver.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/lib%2FReceiver.js?ref=d66e199017e0a1200c7e5a79b9b847063b55c13b","patch":"@@ -35,37 +35,37 @@ class Receiver {\n    * @param {String} binaryType The type for binary data\n    */\n   constructor (extensions, maxPayload, binaryType) {\n-    this.binaryType = binaryType || constants.BINARY_TYPES[0];\n-    this.extensions = extensions || {};\n-    this.maxPayload = maxPayload | 0;\n-\n-    this.bufferedBytes = 0;\n-    this.buffers = [];\n-\n-    this.compressed = false;\n-    this.payloadLength = 0;\n-    this.fragmented = 0;\n-    this.masked = false;\n-    this.fin = false;\n-    this.mask = null;\n-    this.opcode = 0;\n-\n-    this.totalPayloadLength = 0;\n-    this.messageLength = 0;\n-    this.fragments = [];\n-\n-    this.cleanupCallback = null;\n-    this.hadError = false;\n-    this.dead = false;\n-    this.loop = false;\n+    this._binaryType = binaryType || constants.BINARY_TYPES[0];\n+    this._extensions = extensions || {};\n+    this._maxPayload = maxPayload | 0;\n+\n+    this._bufferedBytes = 0;\n+    this._buffers = [];\n+\n+    this._compressed = false;\n+    this._payloadLength = 0;\n+    this._fragmented = 0;\n+    this._masked = false;\n+    this._fin = false;\n+    this._mask = null;\n+    this._opcode = 0;\n+\n+    this._totalPayloadLength = 0;\n+    this._messageLength = 0;\n+    this._fragments = [];\n+\n+    this._cleanupCallback = null;\n+    this._hadError = false;\n+    this._dead = false;\n+    this._loop = false;\n \n     this.onmessage = null;\n     this.onclose = null;\n     this.onerror = null;\n     this.onping = null;\n     this.onpong = null;\n \n-    this.state = GET_INFO;\n+    this._state = GET_INFO;\n   }\n \n   /**\n@@ -80,28 +80,28 @@ class Receiver {\n     var dst;\n     var l;\n \n-    this.bufferedBytes -= bytes;\n+    this._bufferedBytes -= bytes;\n \n-    if (bytes === this.buffers[0].length) return this.buffers.shift();\n+    if (bytes === this._buffers[0].length) return this._buffers.shift();\n \n-    if (bytes < this.buffers[0].length) {\n-      dst = this.buffers[0].slice(0, bytes);\n-      this.buffers[0] = this.buffers[0].slice(bytes);\n+    if (bytes < this._buffers[0].length) {\n+      dst = this._buffers[0].slice(0, bytes);\n+      this._buffers[0] = this._buffers[0].slice(bytes);\n       return dst;\n     }\n \n     dst = Buffer.allocUnsafe(bytes);\n \n     while (bytes > 0) {\n-      l = this.buffers[0].length;\n+      l = this._buffers[0].length;\n \n       if (bytes >= l) {\n-        this.buffers[0].copy(dst, offset);\n+        this._buffers[0].copy(dst, offset);\n         offset += l;\n-        this.buffers.shift();\n+        this._buffers.shift();\n       } else {\n-        this.buffers[0].copy(dst, offset, 0, bytes);\n-        this.buffers[0] = this.buffers[0].slice(bytes);\n+        this._buffers[0].copy(dst, offset, 0, bytes);\n+        this._buffers[0] = this._buffers[0].slice(bytes);\n       }\n \n       bytes -= l;\n@@ -119,10 +119,10 @@ class Receiver {\n    * @private\n    */\n   hasBufferedBytes (n) {\n-    if (this.bufferedBytes >= n) return true;\n+    if (this._bufferedBytes >= n) return true;\n \n-    this.loop = false;\n-    if (this.dead) this.cleanup(this.cleanupCallback);\n+    this._loop = false;\n+    if (this._dead) this.cleanup(this._cleanupCallback);\n     return false;\n   }\n \n@@ -132,10 +132,10 @@ class Receiver {\n    * @public\n    */\n   add (data) {\n-    if (this.dead) return;\n+    if (this._dead) return;\n \n-    this.bufferedBytes += data.length;\n-    this.buffers.push(data);\n+    this._bufferedBytes += data.length;\n+    this._buffers.push(data);\n     this.startLoop();\n   }\n \n@@ -145,10 +145,10 @@ class Receiver {\n    * @private\n    */\n   startLoop () {\n-    this.loop = true;\n+    this._loop = true;\n \n-    while (this.loop) {\n-      switch (this.state) {\n+    while (this._loop) {\n+      switch (this._state) {\n         case GET_INFO:\n           this.getInfo();\n           break;\n@@ -165,7 +165,7 @@ class Receiver {\n           this.getData();\n           break;\n         default: // `INFLATING`\n-          this.loop = false;\n+          this._loop = false;\n       }\n     }\n   }\n@@ -187,36 +187,36 @@ class Receiver {\n \n     const compressed = (buf[0] & 0x40) === 0x40;\n \n-    if (compressed && !this.extensions[PerMessageDeflate.extensionName]) {\n+    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n       this.error(new Error('RSV1 must be clear'), 1002);\n       return;\n     }\n \n-    this.fin = (buf[0] & 0x80) === 0x80;\n-    this.opcode = buf[0] & 0x0f;\n-    this.payloadLength = buf[1] & 0x7f;\n+    this._fin = (buf[0] & 0x80) === 0x80;\n+    this._opcode = buf[0] & 0x0f;\n+    this._payloadLength = buf[1] & 0x7f;\n \n-    if (this.opcode === 0x00) {\n+    if (this._opcode === 0x00) {\n       if (compressed) {\n         this.error(new Error('RSV1 must be clear'), 1002);\n         return;\n       }\n \n-      if (!this.fragmented) {\n-        this.error(new Error(`invalid opcode: ${this.opcode}`), 1002);\n+      if (!this._fragmented) {\n+        this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n         return;\n       } else {\n-        this.opcode = this.fragmented;\n+        this._opcode = this._fragmented;\n       }\n-    } else if (this.opcode === 0x01 || this.opcode === 0x02) {\n-      if (this.fragmented) {\n-        this.error(new Error(`invalid opcode: ${this.opcode}`), 1002);\n+    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n+      if (this._fragmented) {\n+        this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n         return;\n       }\n \n-      this.compressed = compressed;\n-    } else if (this.opcode > 0x07 && this.opcode < 0x0b) {\n-      if (!this.fin) {\n+      this._compressed = compressed;\n+    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n+      if (!this._fin) {\n         this.error(new Error('FIN must be set'), 1002);\n         return;\n       }\n@@ -226,21 +226,21 @@ class Receiver {\n         return;\n       }\n \n-      if (this.payloadLength > 0x7d) {\n+      if (this._payloadLength > 0x7d) {\n         this.error(new Error('invalid payload length'), 1002);\n         return;\n       }\n     } else {\n-      this.error(new Error(`invalid opcode: ${this.opcode}`), 1002);\n+      this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n       return;\n     }\n \n-    if (!this.fin && !this.fragmented) this.fragmented = this.opcode;\n+    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n \n-    this.masked = (buf[1] & 0x80) === 0x80;\n+    this._masked = (buf[1] & 0x80) === 0x80;\n \n-    if (this.payloadLength === 126) this.state = GET_PAYLOAD_LENGTH_16;\n-    else if (this.payloadLength === 127) this.state = GET_PAYLOAD_LENGTH_64;\n+    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n+    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n     else this.haveLength();\n   }\n \n@@ -252,7 +252,7 @@ class Receiver {\n   getPayloadLength16 () {\n     if (!this.hasBufferedBytes(2)) return;\n \n-    this.payloadLength = this.readBuffer(2).readUInt16BE(0, true);\n+    this._payloadLength = this.readBuffer(2).readUInt16BE(0, true);\n     this.haveLength();\n   }\n \n@@ -276,7 +276,7 @@ class Receiver {\n       return;\n     }\n \n-    this.payloadLength = (num * Math.pow(2, 32)) + buf.readUInt32BE(4, true);\n+    this._payloadLength = (num * Math.pow(2, 32)) + buf.readUInt32BE(4, true);\n     this.haveLength();\n   }\n \n@@ -286,12 +286,12 @@ class Receiver {\n    * @private\n    */\n   haveLength () {\n-    if (this.opcode < 0x08 && this.maxPayloadExceeded(this.payloadLength)) {\n+    if (this._opcode < 0x08 && this.maxPayloadExceeded(this._payloadLength)) {\n       return;\n     }\n \n-    if (this.masked) this.state = GET_MASK;\n-    else this.state = GET_DATA;\n+    if (this._masked) this._state = GET_MASK;\n+    else this._state = GET_DATA;\n   }\n \n   /**\n@@ -302,8 +302,8 @@ class Receiver {\n   getMask () {\n     if (!this.hasBufferedBytes(4)) return;\n \n-    this.mask = this.readBuffer(4);\n-    this.state = GET_DATA;\n+    this._mask = this.readBuffer(4);\n+    this._state = GET_DATA;\n   }\n \n   /**\n@@ -314,17 +314,17 @@ class Receiver {\n   getData () {\n     var data = constants.EMPTY_BUFFER;\n \n-    if (this.payloadLength) {\n-      if (!this.hasBufferedBytes(this.payloadLength)) return;\n+    if (this._payloadLength) {\n+      if (!this.hasBufferedBytes(this._payloadLength)) return;\n \n-      data = this.readBuffer(this.payloadLength);\n-      if (this.masked) bufferUtil.unmask(data, this.mask);\n+      data = this.readBuffer(this._payloadLength);\n+      if (this._masked) bufferUtil.unmask(data, this._mask);\n     }\n \n-    if (this.opcode > 0x07) {\n+    if (this._opcode > 0x07) {\n       this.controlMessage(data);\n-    } else if (this.compressed) {\n-      this.state = INFLATING;\n+    } else if (this._compressed) {\n+      this._state = INFLATING;\n       this.decompress(data);\n     } else if (this.pushFragment(data)) {\n       this.dataMessage();\n@@ -338,9 +338,9 @@ class Receiver {\n    * @private\n    */\n   decompress (data) {\n-    const extension = this.extensions[PerMessageDeflate.extensionName];\n+    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n \n-    extension.decompress(data, this.fin, (err, buf) => {\n+    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n       if (err) {\n         this.error(err, err.closeCode === 1009 ? 1009 : 1007);\n         return;\n@@ -357,21 +357,21 @@ class Receiver {\n    * @private\n    */\n   dataMessage () {\n-    if (this.fin) {\n-      const messageLength = this.messageLength;\n-      const fragments = this.fragments;\n+    if (this._fin) {\n+      const messageLength = this._messageLength;\n+      const fragments = this._fragments;\n \n-      this.totalPayloadLength = 0;\n-      this.messageLength = 0;\n-      this.fragmented = 0;\n-      this.fragments = [];\n+      this._totalPayloadLength = 0;\n+      this._messageLength = 0;\n+      this._fragmented = 0;\n+      this._fragments = [];\n \n-      if (this.opcode === 2) {\n+      if (this._opcode === 2) {\n         var data;\n \n-        if (this.binaryType === 'nodebuffer') {\n+        if (this._binaryType === 'nodebuffer') {\n           data = toBuffer(fragments, messageLength);\n-        } else if (this.binaryType === 'arraybuffer') {\n+        } else if (this._binaryType === 'arraybuffer') {\n           data = toArrayBuffer(toBuffer(fragments, messageLength));\n         } else {\n           data = fragments;\n@@ -390,7 +390,7 @@ class Receiver {\n       }\n     }\n \n-    this.state = GET_INFO;\n+    this._state = GET_INFO;\n   }\n \n   /**\n@@ -400,11 +400,11 @@ class Receiver {\n    * @private\n    */\n   controlMessage (data) {\n-    if (this.opcode === 0x08) {\n+    if (this._opcode === 0x08) {\n       if (data.length === 0) {\n         this.onclose(1000, '');\n-        this.loop = false;\n-        this.cleanup(this.cleanupCallback);\n+        this._loop = false;\n+        this.cleanup(this._cleanupCallback);\n       } else if (data.length === 1) {\n         this.error(new Error('invalid payload length'), 1002);\n       } else {\n@@ -423,17 +423,17 @@ class Receiver {\n         }\n \n         this.onclose(code, buf.toString());\n-        this.loop = false;\n-        this.cleanup(this.cleanupCallback);\n+        this._loop = false;\n+        this.cleanup(this._cleanupCallback);\n       }\n \n       return;\n     }\n \n-    if (this.opcode === 0x09) this.onping(data);\n+    if (this._opcode === 0x09) this.onping(data);\n     else this.onpong(data);\n \n-    this.state = GET_INFO;\n+    this._state = GET_INFO;\n   }\n \n   /**\n@@ -445,9 +445,9 @@ class Receiver {\n    */\n   error (err, code) {\n     this.onerror(err, code);\n-    this.hadError = true;\n-    this.loop = false;\n-    this.cleanup(this.cleanupCallback);\n+    this._hadError = true;\n+    this._loop = false;\n+    this.cleanup(this._cleanupCallback);\n   }\n \n   /**\n@@ -457,12 +457,12 @@ class Receiver {\n    * @private\n    */\n   maxPayloadExceeded (length) {\n-    if (length === 0 || this.maxPayload < 1) return false;\n+    if (length === 0 || this._maxPayload < 1) return false;\n \n-    const fullLength = this.totalPayloadLength + length;\n+    const fullLength = this._totalPayloadLength + length;\n \n-    if (fullLength <= this.maxPayload) {\n-      this.totalPayloadLength = fullLength;\n+    if (fullLength <= this._maxPayload) {\n+      this._totalPayloadLength = fullLength;\n       return false;\n     }\n \n@@ -481,11 +481,11 @@ class Receiver {\n   pushFragment (fragment) {\n     if (fragment.length === 0) return true;\n \n-    const totalLength = this.messageLength + fragment.length;\n+    const totalLength = this._messageLength + fragment.length;\n \n-    if (this.maxPayload < 1 || totalLength <= this.maxPayload) {\n-      this.messageLength = totalLength;\n-      this.fragments.push(fragment);\n+    if (this._maxPayload < 1 || totalLength <= this._maxPayload) {\n+      this._messageLength = totalLength;\n+      this._fragments.push(fragment);\n       return true;\n     }\n \n@@ -500,17 +500,17 @@ class Receiver {\n    * @public\n    */\n   cleanup (cb) {\n-    this.dead = true;\n+    this._dead = true;\n \n-    if (!this.hadError && (this.loop || this.state === INFLATING)) {\n-      this.cleanupCallback = cb;\n+    if (!this._hadError && (this._loop || this._state === INFLATING)) {\n+      this._cleanupCallback = cb;\n     } else {\n-      this.extensions = null;\n-      this.fragments = null;\n-      this.buffers = null;\n-      this.mask = null;\n+      this._extensions = null;\n+      this._fragments = null;\n+      this._buffers = null;\n+      this._mask = null;\n \n-      this.cleanupCallback = null;\n+      this._cleanupCallback = null;\n       this.onmessage = null;\n       this.onclose = null;\n       this.onerror = null;"},{"sha":"d3502fe1695a006d132c8caabec2cc6a1b32f69f","filename":"lib/Sender.js","status":"modified","additions":31,"deletions":27,"changes":58,"blob_url":"https://github.com/websockets/ws/blob/d66e199017e0a1200c7e5a79b9b847063b55c13b/lib%2FSender.js","raw_url":"https://github.com/websockets/ws/raw/d66e199017e0a1200c7e5a79b9b847063b55c13b/lib%2FSender.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/lib%2FSender.js?ref=d66e199017e0a1200c7e5a79b9b847063b55c13b","patch":"@@ -26,15 +26,15 @@ class Sender {\n    * @param {Object} extensions An object containing the negotiated extensions\n    */\n   constructor (socket, extensions) {\n-    this.perMessageDeflate = (extensions || {})[PerMessageDeflate.extensionName];\n+    this._extensions = extensions || {};\n     this._socket = socket;\n \n-    this.firstFragment = true;\n-    this.compress = false;\n+    this._firstFragment = true;\n+    this._compress = false;\n \n-    this.bufferedBytes = 0;\n-    this.deflating = false;\n-    this.queue = [];\n+    this._bufferedBytes = 0;\n+    this._deflating = false;\n+    this._queue = [];\n \n     this.onerror = null;\n   }\n@@ -123,7 +123,7 @@ class Sender {\n     buf.writeUInt16BE(code || 1000, 0, true);\n     if (buf.length > 2) buf.write(data, 2);\n \n-    if (this.deflating) {\n+    if (this._deflating) {\n       this.enqueue([this.doClose, buf, mask, cb]);\n     } else {\n       this.doClose(buf, mask, cb);\n@@ -169,7 +169,7 @@ class Sender {\n       }\n     }\n \n-    if (this.deflating) {\n+    if (this._deflating) {\n       this.enqueue([this.doPing, data, mask, readOnly]);\n     } else {\n       this.doPing(data, mask, readOnly);\n@@ -215,7 +215,7 @@ class Sender {\n       }\n     }\n \n-    if (this.deflating) {\n+    if (this._deflating) {\n       this.enqueue([this.doPong, data, mask, readOnly]);\n     } else {\n       this.doPong(data, mask, readOnly);\n@@ -268,20 +268,22 @@ class Sender {\n       }\n     }\n \n-    if (this.firstFragment) {\n-      this.firstFragment = false;\n-      if (rsv1 && this.perMessageDeflate) {\n-        rsv1 = data.length >= this.perMessageDeflate.threshold;\n+    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n+\n+    if (this._firstFragment) {\n+      this._firstFragment = false;\n+      if (rsv1 && perMessageDeflate) {\n+        rsv1 = data.length >= perMessageDeflate._threshold;\n       }\n-      this.compress = rsv1;\n+      this._compress = rsv1;\n     } else {\n       rsv1 = false;\n       opcode = 0;\n     }\n \n-    if (options.fin) this.firstFragment = true;\n+    if (options.fin) this._firstFragment = true;\n \n-    if (this.perMessageDeflate) {\n+    if (perMessageDeflate) {\n       const opts = {\n         fin: options.fin,\n         rsv1,\n@@ -290,10 +292,10 @@ class Sender {\n         readOnly\n       };\n \n-      if (this.deflating) {\n-        this.enqueue([this.dispatch, data, this.compress, opts, cb]);\n+      if (this._deflating) {\n+        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n       } else {\n-        this.dispatch(data, this.compress, opts, cb);\n+        this.dispatch(data, this._compress, opts, cb);\n       }\n     } else {\n       this.sendFrame(Sender.frame(data, {\n@@ -326,8 +328,10 @@ class Sender {\n       return;\n     }\n \n-    this.deflating = true;\n-    this.perMessageDeflate.compress(data, options.fin, (err, buf) => {\n+    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n+\n+    this._deflating = true;\n+    perMessageDeflate.compress(data, options.fin, (err, buf) => {\n       if (err) {\n         if (cb) cb(err);\n         else this.onerror(err);\n@@ -336,7 +340,7 @@ class Sender {\n \n       options.readOnly = false;\n       this.sendFrame(Sender.frame(buf, options), cb);\n-      this.deflating = false;\n+      this._deflating = false;\n       this.dequeue();\n     });\n   }\n@@ -347,10 +351,10 @@ class Sender {\n    * @private\n    */\n   dequeue () {\n-    while (!this.deflating && this.queue.length) {\n-      const params = this.queue.shift();\n+    while (!this._deflating && this._queue.length) {\n+      const params = this._queue.shift();\n \n-      this.bufferedBytes -= params[1].length;\n+      this._bufferedBytes -= params[1].length;\n       params[0].apply(this, params.slice(1));\n     }\n   }\n@@ -362,8 +366,8 @@ class Sender {\n    * @private\n    */\n   enqueue (params) {\n-    this.bufferedBytes += params[1].length;\n-    this.queue.push(params);\n+    this._bufferedBytes += params[1].length;\n+    this._queue.push(params);\n   }\n \n   /**"},{"sha":"29180ea0f4d15d670a58fe2e13748b9390de375c","filename":"lib/WebSocket.js","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/websockets/ws/blob/d66e199017e0a1200c7e5a79b9b847063b55c13b/lib%2FWebSocket.js","raw_url":"https://github.com/websockets/ws/raw/d66e199017e0a1200c7e5a79b9b847063b55c13b/lib%2FWebSocket.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/lib%2FWebSocket.js?ref=d66e199017e0a1200c7e5a79b9b847063b55c13b","patch":"@@ -83,7 +83,7 @@ class WebSocket extends EventEmitter {\n     var amount = 0;\n \n     if (this._socket) {\n-      amount = this._socket.bufferSize + this._sender.bufferedBytes;\n+      amount = this._socket.bufferSize + this._sender._bufferedBytes;\n     }\n     return amount;\n   }\n@@ -106,7 +106,7 @@ class WebSocket extends EventEmitter {\n     //\n     // Allow to change `binaryType` on the fly.\n     //\n-    if (this._receiver) this._receiver.binaryType = type;\n+    if (this._receiver) this._receiver._binaryType = type;\n   }\n \n   /**\n@@ -120,7 +120,7 @@ class WebSocket extends EventEmitter {\n     socket.setTimeout(0);\n     socket.setNoDelay();\n \n-    this._receiver = new Receiver(this.extensions, this.maxPayload, this.binaryType);\n+    this._receiver = new Receiver(this.extensions, this._maxPayload, this.binaryType);\n     this._sender = new Sender(socket, this.extensions);\n     this._ultron = new Ultron(socket);\n     this._socket = socket;\n@@ -457,8 +457,8 @@ module.exports = WebSocket;\n  */\n function initAsServerClient (socket, head, options) {\n   this.protocolVersion = options.protocolVersion;\n+  this._maxPayload = options.maxPayload;\n   this.extensions = options.extensions;\n-  this.maxPayload = options.maxPayload;\n   this.protocol = options.protocol;\n \n   this._isServer = true;"},{"sha":"3735f990b5fabf16230f8d11097202e78c080e38","filename":"lib/WebSocketServer.js","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/websockets/ws/blob/d66e199017e0a1200c7e5a79b9b847063b55c13b/lib%2FWebSocketServer.js","raw_url":"https://github.com/websockets/ws/raw/d66e199017e0a1200c7e5a79b9b847063b55c13b/lib%2FWebSocketServer.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/lib%2FWebSocketServer.js?ref=d66e199017e0a1200c7e5a79b9b847063b55c13b","patch":"@@ -92,7 +92,6 @@ class WebSocketServer extends EventEmitter {\n \n     if (options.clientTracking) this.clients = new Set();\n     this.options = options;\n-    this.path = options.path;\n   }\n \n   /**"},{"sha":"ffd579e006d41d2244153cbd8a906933f985408a","filename":"test/Receiver.test.js","status":"modified","additions":19,"deletions":19,"changes":38,"blob_url":"https://github.com/websockets/ws/blob/d66e199017e0a1200c7e5a79b9b847063b55c13b/test%2FReceiver.test.js","raw_url":"https://github.com/websockets/ws/raw/d66e199017e0a1200c7e5a79b9b847063b55c13b/test%2FReceiver.test.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/test%2FReceiver.test.js?ref=d66e199017e0a1200c7e5a79b9b847063b55c13b","patch":"@@ -338,9 +338,9 @@ describe('Receiver', function () {\n       message = msg;\n     };\n \n-    assert.strictEqual(p.totalPayloadLength, 0);\n+    assert.strictEqual(p._totalPayloadLength, 0);\n     p.add(Buffer.from('810548656c6c6f', 'hex'));\n-    assert.strictEqual(p.totalPayloadLength, 0);\n+    assert.strictEqual(p._totalPayloadLength, 0);\n     assert.strictEqual(message, 'Hello');\n   });\n \n@@ -352,11 +352,11 @@ describe('Receiver', function () {\n       message = msg;\n     };\n \n-    assert.strictEqual(p.totalPayloadLength, 0);\n+    assert.strictEqual(p._totalPayloadLength, 0);\n     p.add(Buffer.from('01024865', 'hex'));\n-    assert.strictEqual(p.totalPayloadLength, 2);\n+    assert.strictEqual(p._totalPayloadLength, 2);\n     p.add(Buffer.from('80036c6c6f', 'hex'));\n-    assert.strictEqual(p.totalPayloadLength, 0);\n+    assert.strictEqual(p._totalPayloadLength, 0);\n     assert.strictEqual(message, 'Hello');\n   });\n \n@@ -368,13 +368,13 @@ describe('Receiver', function () {\n       data.push(buf.toString());\n     };\n \n-    assert.strictEqual(p.totalPayloadLength, 0);\n+    assert.strictEqual(p._totalPayloadLength, 0);\n     p.add(Buffer.from('02024865', 'hex'));\n-    assert.strictEqual(p.totalPayloadLength, 2);\n+    assert.strictEqual(p._totalPayloadLength, 2);\n     p.add(Buffer.from('8900', 'hex'));\n-    assert.strictEqual(p.totalPayloadLength, 2);\n+    assert.strictEqual(p._totalPayloadLength, 2);\n     p.add(Buffer.from('80036c6c6f', 'hex'));\n-    assert.strictEqual(p.totalPayloadLength, 0);\n+    assert.strictEqual(p._totalPayloadLength, 0);\n     assert.deepStrictEqual(data, ['', 'Hello']);\n   });\n \n@@ -722,8 +722,8 @@ describe('Receiver', function () {\n       p.add(frame);\n       p.add(frame);\n \n-      assert.strictEqual(p.state, 5);\n-      assert.strictEqual(p.bufferedBytes, frame.length);\n+      assert.strictEqual(p._state, 5);\n+      assert.strictEqual(p._bufferedBytes, frame.length);\n \n       p.cleanup(() => {\n         assert.deepStrictEqual(results, ['Hello', 'Hello']);\n@@ -754,8 +754,8 @@ describe('Receiver', function () {\n       p.add(textFrame);\n       p.add(closeFrame);\n \n-      assert.strictEqual(p.state, 5);\n-      assert.strictEqual(p.bufferedBytes, textFrame.length + closeFrame.length);\n+      assert.strictEqual(p._state, 5);\n+      assert.strictEqual(p._bufferedBytes, textFrame.length + closeFrame.length);\n \n       p.cleanup(() => {\n         assert.deepStrictEqual(results, ['Hello', 'Hello', 1000, '']);\n@@ -786,8 +786,8 @@ describe('Receiver', function () {\n       p.add(textFrame);\n       p.add(invalidFrame);\n \n-      assert.strictEqual(p.state, 5);\n-      assert.strictEqual(p.bufferedBytes, textFrame.length + invalidFrame.length);\n+      assert.strictEqual(p._state, 5);\n+      assert.strictEqual(p._bufferedBytes, textFrame.length + invalidFrame.length);\n \n       p.cleanup(() => {\n         assert.deepStrictEqual(results, [\n@@ -821,8 +821,8 @@ describe('Receiver', function () {\n       p.add(textFrame);\n       p.add(incompleteFrame);\n \n-      assert.strictEqual(p.state, 5);\n-      assert.strictEqual(p.bufferedBytes, incompleteFrame.length);\n+      assert.strictEqual(p._state, 5);\n+      assert.strictEqual(p._bufferedBytes, incompleteFrame.length);\n \n       p.cleanup(() => {\n         assert.deepStrictEqual(results, ['Hello']);\n@@ -867,7 +867,7 @@ describe('Receiver', function () {\n       crypto.randomBytes(623987)\n     ];\n \n-    p.binaryType = 'arraybuffer';\n+    p._binaryType = 'arraybuffer';\n     p.onmessage = (data) => {\n       assert.ok(data instanceof ArrayBuffer);\n       assert.ok(Buffer.from(data).equals(Buffer.concat(frags)));\n@@ -895,7 +895,7 @@ describe('Receiver', function () {\n       crypto.randomBytes(1)\n     ];\n \n-    p.binaryType = 'fragments';\n+    p._binaryType = 'fragments';\n     p.onmessage = (data) => {\n       assert.deepStrictEqual(data, frags);\n       done();"},{"sha":"a2916e25fb2c251f4be015d23ca27f9b0ce3cb7a","filename":"test/WebSocketServer.test.js","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/websockets/ws/blob/d66e199017e0a1200c7e5a79b9b847063b55c13b/test%2FWebSocketServer.test.js","raw_url":"https://github.com/websockets/ws/raw/d66e199017e0a1200c7e5a79b9b847063b55c13b/test%2FWebSocketServer.test.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/test%2FWebSocketServer.test.js?ref=d66e199017e0a1200c7e5a79b9b847063b55c13b","patch":"@@ -256,14 +256,14 @@ describe('WebSocketServer', function () {\n   });\n \n   describe('#maxpayload', function () {\n-    it('maxpayload is passed on to clients,', function (done) {\n+    it('maxpayload is passed on to clients', function (done) {\n       const maxPayload = 20480;\n       const wss = new WebSocketServer({ port: ++port, maxPayload }, () => {\n         const ws = new WebSocket(`ws://localhost:${port}`);\n       });\n \n       wss.on('connection', (client) => {\n-        assert.strictEqual(client.maxPayload, maxPayload);\n+        assert.strictEqual(client._maxPayload, maxPayload);\n         wss.close(done);\n       });\n     });\n@@ -275,7 +275,7 @@ describe('WebSocketServer', function () {\n       });\n \n       wss.on('connection', (client) => {\n-        assert.strictEqual(client._receiver.maxPayload, maxPayload);\n+        assert.strictEqual(client._receiver._maxPayload, maxPayload);\n         wss.close(done);\n       });\n     });\n@@ -289,7 +289,7 @@ describe('WebSocketServer', function () {\n \n       wss.on('connection', (client) => {\n         assert.strictEqual(\n-          client._receiver.extensions[PerMessageDeflate.extensionName]._maxPayload,\n+          client._receiver._extensions[PerMessageDeflate.extensionName]._maxPayload,\n           maxPayload\n         );\n         wss.close(done);"}]},{"url":"https://api.github.com/repos/websockets/ws/issues/997","repository_url":"https://api.github.com/repos/websockets/ws","labels_url":"https://api.github.com/repos/websockets/ws/issues/997/labels{/name}","comments_url":"https://api.github.com/repos/websockets/ws/issues/997/comments","events_url":"https://api.github.com/repos/websockets/ws/issues/997/events","html_url":"https://github.com/websockets/ws/pull/997","id":206970649,"node_id":"MDExOlB1bGxSZXF1ZXN0MTA1NzQ4NzM4","number":997,"title":"Write to the socket as soon as possible","user":{"login":"lpinca","id":1443911,"node_id":"MDQ6VXNlcjE0NDM5MTE=","avatar_url":"https://avatars.githubusercontent.com/u/1443911?v=4","gravatar_id":"","url":"https://api.github.com/users/lpinca","html_url":"https://github.com/lpinca","followers_url":"https://api.github.com/users/lpinca/followers","following_url":"https://api.github.com/users/lpinca/following{/other_user}","gists_url":"https://api.github.com/users/lpinca/gists{/gist_id}","starred_url":"https://api.github.com/users/lpinca/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/lpinca/subscriptions","organizations_url":"https://api.github.com/users/lpinca/orgs","repos_url":"https://api.github.com/users/lpinca/repos","events_url":"https://api.github.com/users/lpinca/events{/privacy}","received_events_url":"https://api.github.com/users/lpinca/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2017-02-11T09:52:25Z","updated_at":"2017-02-16T13:33:33Z","closed_at":"2017-02-16T13:33:24Z","author_association":"MEMBER","active_lock_reason":null,"draft":false,"pull_request":{"url":"https://api.github.com/repos/websockets/ws/pulls/997","html_url":"https://github.com/websockets/ws/pull/997","diff_url":"https://github.com/websockets/ws/pull/997.diff","patch_url":"https://github.com/websockets/ws/pull/997.patch","merged_at":"2017-02-16T13:33:24Z"},"body":"When permessage-deflate is enabled the outbound throughput performance is throttled by `process.nextTick()`. If the are `n` messages in the queue, it will take `n` ticks before all messages are dispatched even when compression is skipped.\r\n\r\nThis patch prevents `process.nextTick()` from being used by slightly changing the handling logic of the queued messages.","reactions":{"url":"https://api.github.com/repos/websockets/ws/issues/997/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/websockets/ws/issues/997/timeline","performed_via_github_app":null,"state_reason":null,"score":1,"files":[{"sha":"92a26525f902c90c72f98bad05d5f6463220b805","filename":"lib/PerMessageDeflate.js","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/websockets/ws/blob/8823a349a7b5ef82bd37025e3f4b902225f5b044/lib%2FPerMessageDeflate.js","raw_url":"https://github.com/websockets/ws/raw/8823a349a7b5ef82bd37025e3f4b902225f5b044/lib%2FPerMessageDeflate.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/lib%2FPerMessageDeflate.js?ref=8823a349a7b5ef82bd37025e3f4b902225f5b044","patch":"@@ -288,7 +288,8 @@ class PerMessageDeflate {\n \n   compress (data, fin, callback) {\n     if (!data || data.length === 0) {\n-      return callback(null, EMPTY_BLOCK);\n+      process.nextTick(callback, null, EMPTY_BLOCK);\n+      return;\n     }\n \n     var endpoint = this._isServer ? 'server' : 'client';"},{"sha":"ee520cddac4c3aa49540f923865484a63d170ba0","filename":"lib/Sender.js","status":"modified","additions":21,"deletions":36,"changes":57,"blob_url":"https://github.com/websockets/ws/blob/8823a349a7b5ef82bd37025e3f4b902225f5b044/lib%2FSender.js","raw_url":"https://github.com/websockets/ws/raw/8823a349a7b5ef82bd37025e3f4b902225f5b044/lib%2FSender.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/lib%2FSender.js?ref=8823a349a7b5ef82bd37025e3f4b902225f5b044","patch":"@@ -29,8 +29,8 @@ class Sender {\n     this.firstFragment = true;\n     this.compress = false;\n \n-    this.processing = false;\n     this.bufferedBytes = 0;\n+    this.deflating = false;\n     this.queue = [];\n \n     this.onerror = null;\n@@ -55,7 +55,7 @@ class Sender {\n     buf.writeUInt16BE(code || 1000, 0, true);\n     if (buf.length > 2) buf.write(data, 2);\n \n-    if (this.perMessageDeflate) {\n+    if (this.deflating) {\n       this.enqueue([this.doClose, buf, mask, cb]);\n     } else {\n       this.doClose(buf, mask, cb);\n@@ -78,8 +78,6 @@ class Sender {\n       fin: true,\n       mask\n     }, cb);\n-\n-    if (this.perMessageDeflate) this.continue();\n   }\n \n   /**\n@@ -103,7 +101,7 @@ class Sender {\n       }\n     }\n \n-    if (this.perMessageDeflate) {\n+    if (this.deflating) {\n       this.enqueue([this.doPing, data, mask, readOnly]);\n     } else {\n       this.doPing(data, mask, readOnly);\n@@ -126,8 +124,6 @@ class Sender {\n       readOnly,\n       mask\n     });\n-\n-    if (this.perMessageDeflate) this.continue();\n   }\n \n   /**\n@@ -151,7 +147,7 @@ class Sender {\n       }\n     }\n \n-    if (this.perMessageDeflate) {\n+    if (this.deflating) {\n       this.enqueue([this.doPong, data, mask, readOnly]);\n     } else {\n       this.doPong(data, mask, readOnly);\n@@ -174,8 +170,6 @@ class Sender {\n       readOnly,\n       mask\n     });\n-\n-    if (this.perMessageDeflate) this.continue();\n   }\n \n   /**\n@@ -220,14 +214,20 @@ class Sender {\n     if (options.fin) this.firstFragment = true;\n \n     if (this.perMessageDeflate) {\n-      this.enqueue([this.dispatch, data, {\n+      const opts = {\n         compress: this.compress,\n         mask: options.mask,\n         fin: options.fin,\n         readOnly,\n         opcode,\n         rsv1\n-      }, cb]);\n+      };\n+\n+      if (this.deflating) {\n+        this.enqueue([this.dispatch, data, opts, cb]);\n+      } else {\n+        this.dispatch(data, opts, cb);\n+      }\n     } else {\n       this.frameAndSend(data, {\n         mask: options.mask,\n@@ -256,10 +256,10 @@ class Sender {\n   dispatch (data, options, cb) {\n     if (!options.compress) {\n       this.frameAndSend(data, options, cb);\n-      this.continue();\n       return;\n     }\n \n+    this.deflating = true;\n     this.perMessageDeflate.compress(data, options.fin, (err, buf) => {\n       if (err) {\n         if (cb) cb(err);\n@@ -269,7 +269,8 @@ class Sender {\n \n       options.readOnly = false;\n       this.frameAndSend(buf, options, cb);\n-      this.continue();\n+      this.deflating = false;\n+      this.dequeue();\n     });\n   }\n \n@@ -349,32 +350,17 @@ class Sender {\n   }\n \n   /**\n-   * Executes a queued send operation.\n+   * Executes queued send operations.\n    *\n    * @private\n    */\n   dequeue () {\n-    if (this.processing) return;\n-\n-    const params = this.queue.shift();\n-    if (!params) return;\n+    while (!this.deflating && this.queue.length) {\n+      const params = this.queue.shift();\n \n-    if (params[1]) this.bufferedBytes -= params[1].length;\n-    this.processing = true;\n-\n-    params[0].apply(this, params.slice(1));\n-  }\n-\n-  /**\n-   * Signals the completion of a send operation.\n-   *\n-   * @private\n-   */\n-  continue () {\n-    process.nextTick(() => {\n-      this.processing = false;\n-      this.dequeue();\n-    });\n+      if (params[1]) this.bufferedBytes -= params[1].length;\n+      params[0].apply(this, params.slice(1));\n+    }\n   }\n \n   /**\n@@ -386,7 +372,6 @@ class Sender {\n   enqueue (params) {\n     if (params[1]) this.bufferedBytes += params[1].length;\n     this.queue.push(params);\n-    this.dequeue();\n   }\n }\n "},{"sha":"f7ea03d90475dc7ccadcd1ae568d156331c8ad5e","filename":"test/WebSocket.test.js","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/websockets/ws/blob/8823a349a7b5ef82bd37025e3f4b902225f5b044/test%2FWebSocket.test.js","raw_url":"https://github.com/websockets/ws/raw/8823a349a7b5ef82bd37025e3f4b902225f5b044/test%2FWebSocket.test.js","contents_url":"https://api.github.com/repos/websockets/ws/contents/test%2FWebSocket.test.js?ref=8823a349a7b5ef82bd37025e3f4b902225f5b044","patch":"@@ -143,7 +143,9 @@ describe('WebSocket', function () {\n \n       it('takes into account the data in the sender queue', function (done) {\n         const wss = new WebSocketServer({ port: ++port }, () => {\n-          const ws = new WebSocket(`ws://localhost:${port}`);\n+          const ws = new WebSocket(`ws://localhost:${port}`, {\n+            perMessageDeflate: { threshold: 0 }\n+          });\n \n           ws.on('open', () => {\n             ws.send('foo');"}]}]